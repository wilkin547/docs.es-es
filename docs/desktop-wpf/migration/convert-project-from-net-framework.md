---
title: Migración de aplicaciones WPF a .NET Core 3.0
description: Aprenda a migrar una aplicación de Windows Presentation Foundation (WPF) a .NET Core 3.0.
author: mjrousos
ms.date: 09/12/2019
ms.author: mikerou
ms.openlocfilehash: f52005e7c8a6312b8c4e09a950f1f635af1894e4
ms.sourcegitcommit: cdf5084648bf5e77970cbfeaa23f1cab3e6e234e
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 02/01/2020
ms.locfileid: "81432597"
---
# <a name="migrating-wpf-apps-to-net-core"></a><span data-ttu-id="68874-103">Migración de aplicaciones WPF a .NET Core</span><span class="sxs-lookup"><span data-stu-id="68874-103">Migrating WPF apps to .NET Core</span></span>

<span data-ttu-id="68874-104">En este artículo se describen los pasos necesarios para migrar una aplicación de Windows Presentation Foundation (WPF) de .NET Framework a .NET Core 3.0.</span><span class="sxs-lookup"><span data-stu-id="68874-104">This article covers the steps necessary to migrate a Windows Presentation Foundation (WPF) app from .NET Framework to .NET Core 3.0.</span></span> <span data-ttu-id="68874-105">Si no tiene una aplicación WPF a mano a puerto, pero le gustaría probar el proceso, puede usar la aplicación de ejemplo **Bean Trader** disponible en [GitHub](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader).</span><span class="sxs-lookup"><span data-stu-id="68874-105">If you don't have a WPF app on hand to port, but would like to try out the process, you can use the **Bean Trader** sample app available on [GitHub](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader).</span></span> <span data-ttu-id="68874-106">La aplicación original (dirigida a .NET Framework 4.7.2) está disponible en la carpeta NetFx-BeanTraderClient.</span><span class="sxs-lookup"><span data-stu-id="68874-106">The original app (targeting .NET Framework 4.7.2) is available in the NetFx\BeanTraderClient folder.</span></span> <span data-ttu-id="68874-107">Primero explicaremos los pasos necesarios para portar aplicaciones en general, y luego le explicaremos los cambios específicos que se aplican a la muestra **de Bean Trader.**</span><span class="sxs-lookup"><span data-stu-id="68874-107">First we'll explain the steps necessary to port apps in general, and then we'll walk through the specific changes that apply to the **Bean Trader** sample.</span></span>

[!INCLUDE [desktop guide under construction](../../../includes/desktop-guide-preview-note.md)]

<span data-ttu-id="68874-108">Para migrar a .NET Core, primero debe:</span><span class="sxs-lookup"><span data-stu-id="68874-108">To migrate to .NET Core, you must first:</span></span>

01. <span data-ttu-id="68874-109">Comprender y actualizar las dependencias de NuGet:</span><span class="sxs-lookup"><span data-stu-id="68874-109">Understand and update NuGet dependencies:</span></span>

    01. <span data-ttu-id="68874-110">Actualice las dependencias de `<PackageReference>` NuGet para usar el formato.</span><span class="sxs-lookup"><span data-stu-id="68874-110">Upgrade NuGet dependencies to use the `<PackageReference>` format.</span></span>
    01. <span data-ttu-id="68874-111">Revise las dependencias de NuGet de nivel superior para la compatibilidad con .NET Core o .NET Standard.</span><span class="sxs-lookup"><span data-stu-id="68874-111">Review top-level NuGet dependencies for .NET Core or .NET Standard compatibility.</span></span>
    01. <span data-ttu-id="68874-112">Actualice los paquetes NuGet a versiones más recientes.</span><span class="sxs-lookup"><span data-stu-id="68874-112">Upgrade NuGet packages to newer versions.</span></span>
    01. <span data-ttu-id="68874-113">Use el Analizador de portabilidad de [.NET](../../standard/analyzers/portability-analyzer.md) para comprender las dependencias de .NET.</span><span class="sxs-lookup"><span data-stu-id="68874-113">Use the [.NET Portability Analyzer](../../standard/analyzers/portability-analyzer.md) to understand .NET dependencies.</span></span>

01. <span data-ttu-id="68874-114">Migre el archivo de proyecto al nuevo formato de estilo SDK:</span><span class="sxs-lookup"><span data-stu-id="68874-114">Migrate the project file to the new SDK-style format:</span></span>

    01. <span data-ttu-id="68874-115">Elija si desea tener como destino .NET Core y .NET Framework, o solo .NET Core.</span><span class="sxs-lookup"><span data-stu-id="68874-115">Choose whether to target both .NET Core and .NET Framework, or only .NET Core.</span></span>
    01. <span data-ttu-id="68874-116">Copie las propiedades y los elementos relevantes del archivo de proyecto en el nuevo archivo de proyecto.</span><span class="sxs-lookup"><span data-stu-id="68874-116">Copy relevant project file properties and items to the new project file.</span></span>

01. <span data-ttu-id="68874-117">Solucionar problemas de compilación:</span><span class="sxs-lookup"><span data-stu-id="68874-117">Fix build issues:</span></span>

    01. <span data-ttu-id="68874-118">Agregue una referencia al paquete [Microsoft.Windows.Compatibility.](https://www.nuget.org/packages/Microsoft.Windows.Compatibility/)</span><span class="sxs-lookup"><span data-stu-id="68874-118">Add a reference to the [Microsoft.Windows.Compatibility](https://www.nuget.org/packages/Microsoft.Windows.Compatibility/) package.</span></span>
    01. <span data-ttu-id="68874-119">Busque y corrija las diferencias a nivel de API.</span><span class="sxs-lookup"><span data-stu-id="68874-119">Find and fix API-level differences.</span></span>
    01. <span data-ttu-id="68874-120">Quite las secciones *app.config* que no sean `appSettings` o `connectionStrings`.</span><span class="sxs-lookup"><span data-stu-id="68874-120">Remove *app.config* sections other than `appSettings` or `connectionStrings`.</span></span>
    01. <span data-ttu-id="68874-121">Regenere el código generado, si es necesario.</span><span class="sxs-lookup"><span data-stu-id="68874-121">Regenerate generated code, if necessary.</span></span>

01. <span data-ttu-id="68874-122">Pruebas en tiempo de ejecución:</span><span class="sxs-lookup"><span data-stu-id="68874-122">Runtime testing:</span></span>

    01. <span data-ttu-id="68874-123">Confirme que la aplicación porteada funciona según lo esperado.</span><span class="sxs-lookup"><span data-stu-id="68874-123">Confirm the ported app works as expected.</span></span>
    01. <span data-ttu-id="68874-124">Tenga cuidado <xref:System.NotSupportedException> con las excepciones.</span><span class="sxs-lookup"><span data-stu-id="68874-124">Beware of <xref:System.NotSupportedException> exceptions.</span></span>

## <a name="about-the-sample"></a><span data-ttu-id="68874-125">Sobre el ejemplo</span><span class="sxs-lookup"><span data-stu-id="68874-125">About the sample</span></span>

<span data-ttu-id="68874-126">Este artículo hace referencia a la aplicación de [ejemplo Bean Trader](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader) porque usa una variedad de dependencias similares a las que pueden tener las aplicaciones WPF del mundo real.</span><span class="sxs-lookup"><span data-stu-id="68874-126">This article references the [Bean Trader sample app](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader) because it uses a variety of dependencies similar to those that real-world WPF apps might have.</span></span> <span data-ttu-id="68874-127">La aplicación no es grande, pero está destinada a ser un paso adelante de 'Hello World' en términos de complejidad.</span><span class="sxs-lookup"><span data-stu-id="68874-127">The app isn't large, but is meant to be a step up from 'Hello World' in terms of complexity.</span></span> <span data-ttu-id="68874-128">La aplicación muestra algunos problemas que los usuarios pueden encontrar al migrar aplicaciones reales.</span><span class="sxs-lookup"><span data-stu-id="68874-128">The app demonstrates some issues users may encounter while porting real apps.</span></span> <span data-ttu-id="68874-129">La aplicación se comunica con un servicio WCF, por lo que para que se ejecute correctamente, también tendrá que ejecutar el proyecto BeanTraderServer (disponible en el mismo repositorio GitHub) y asegurarse de que la configuración de BeanTraderClient apunta al punto de conexión correcto.</span><span class="sxs-lookup"><span data-stu-id="68874-129">The app communicates with a WCF service, so for it to run properly, you'll also need to run the BeanTraderServer project (available in the same GitHub repository) and make sure the BeanTraderClient configuration points to the correct endpoint.</span></span> <span data-ttu-id="68874-130">(De forma predeterminada, el ejemplo supone que el *http://localhost:8090*servidor se está ejecutando en el mismo equipo en , que será true si inicia BeanTraderServer localmente.)</span><span class="sxs-lookup"><span data-stu-id="68874-130">(By default, the sample assumes the server is running on the same machine at *http://localhost:8090*, which will be true if you launch BeanTraderServer locally.)</span></span>

<span data-ttu-id="68874-131">Tenga en cuenta que esta aplicación de ejemplo está diseñada para demostrar soluciones y desafíos de portabilidad de .NET Core.</span><span class="sxs-lookup"><span data-stu-id="68874-131">Keep in mind that this sample app is meant to demonstrate .NET Core porting challenges and solutions.</span></span> <span data-ttu-id="68874-132">No está diseñado para demostrar las prácticas recomendadas de WPFWPF.</span><span class="sxs-lookup"><span data-stu-id="68874-132">It's not meant to demonstrate WPF best practices.</span></span> <span data-ttu-id="68874-133">De hecho, deliberadamente incluye algunos anti-patrones para asegurarse de que se encuentra con al menos un par de desafíos interesantes durante la portabilidad.</span><span class="sxs-lookup"><span data-stu-id="68874-133">In fact, it deliberately includes some anti-patterns to make sure you come across at least a couple of interesting challenges while porting.</span></span>

## <a name="getting-ready"></a><span data-ttu-id="68874-134">Preparación</span><span class="sxs-lookup"><span data-stu-id="68874-134">Getting ready</span></span>

<span data-ttu-id="68874-135">El principal desafío de migrar una aplicación de .NET Framework a .NET Core es que sus dependencias pueden funcionar de forma diferente o no funcionar en absoluto.</span><span class="sxs-lookup"><span data-stu-id="68874-135">The primary challenge of migrating a .NET Framework app to .NET Core is that its dependencies may work differently or not at all.</span></span> <span data-ttu-id="68874-136">La migración es mucho más fácil de lo que solía ser; muchos paquetes NuGet ahora se dirigen a .NET Standard.</span><span class="sxs-lookup"><span data-stu-id="68874-136">Migration is much easier than it used to be; many NuGet packages now target .NET Standard.</span></span> <span data-ttu-id="68874-137">A partir de .NET Core 2.0, las áreas de superficie de .NET Framework y .NET Core se han vuelto similares.</span><span class="sxs-lookup"><span data-stu-id="68874-137">Starting with .NET Core 2.0, the .NET Framework and .NET Core surface areas have become similar.</span></span> <span data-ttu-id="68874-138">Aún así, algunas diferencias (tanto en la compatibilidad con paquetes NuGet como en las API de .NET disponibles) permanecen.</span><span class="sxs-lookup"><span data-stu-id="68874-138">Even so, some differences (both in support from NuGet packages and in available .NET APIs) remain.</span></span> <span data-ttu-id="68874-139">El primer paso para migrar es revisar las dependencias de la aplicación y asegurarse de que las referencias están en un formato que se migra fácilmente a .NET Core.</span><span class="sxs-lookup"><span data-stu-id="68874-139">The first step in migrating is to review the app's dependencies and make sure references are in a format that's easily migrated to .NET Core.</span></span>

### <a name="upgrade-to-packagereference-nuget-references"></a><span data-ttu-id="68874-140">Actualización `<PackageReference>` a referencias NuGet</span><span class="sxs-lookup"><span data-stu-id="68874-140">Upgrade to `<PackageReference>` NuGet references</span></span>

<span data-ttu-id="68874-141">Los proyectos de .NET Framework más antiguos suelen enumerar sus dependencias NuGet en un archivo *packages.config.*</span><span class="sxs-lookup"><span data-stu-id="68874-141">Older .NET Framework projects typically list their NuGet dependencies in a *packages.config* file.</span></span> <span data-ttu-id="68874-142">El nuevo formato de archivo de proyecto [`<PackageReference>`](/nuget/consume-packages/package-references-in-project-files) de estilo SDK hace referencia a paquetes NuGet como elementos en el propio archivo csproj en lugar de en un archivo de configuración independiente.</span><span class="sxs-lookup"><span data-stu-id="68874-142">The new SDK-style project file format references NuGet packages as [`<PackageReference>`](/nuget/consume-packages/package-references-in-project-files) elements in the csproj file itself rather than in a separate config file.</span></span>

<span data-ttu-id="68874-143">Al migrar, hay dos ventajas `<PackageReference>`en el uso de referencias de estilo:</span><span class="sxs-lookup"><span data-stu-id="68874-143">When migrating, there are two advantages to using `<PackageReference>`-style references:</span></span>

- <span data-ttu-id="68874-144">Este es el estilo de referencia NuGet necesario para el nuevo archivo de proyecto de .NET Core.</span><span class="sxs-lookup"><span data-stu-id="68874-144">This is the style of NuGet reference that is required for the new .NET Core project file.</span></span> <span data-ttu-id="68874-145">Si ya está `<PackageReference>`utilizando , esos elementos del archivo de proyecto se pueden copiar y pegar directamente en el nuevo proyecto.</span><span class="sxs-lookup"><span data-stu-id="68874-145">If you're already using `<PackageReference>`, those project file elements can be copied and pasted directly into the new project.</span></span>
- <span data-ttu-id="68874-146">A diferencia de un `<PackageReference>` archivo packages.config, los elementos solo hacen referencia a las dependencias de nivel superior de las que depende el proyecto directamente.</span><span class="sxs-lookup"><span data-stu-id="68874-146">Unlike a packages.config file, `<PackageReference>` elements only refer to the top-level dependencies that your project depends on directly.</span></span> <span data-ttu-id="68874-147">Todos los demás paquetes NuGet transitivos se determinarán en el momento de la restauración y se registrarán en el archivo de obj.assets.json generado automáticamente.</span><span class="sxs-lookup"><span data-stu-id="68874-147">All other transitive NuGet packages will be determined at restore time and recorded in the autogenerated obj\project.assets.json file.</span></span> <span data-ttu-id="68874-148">Esto hace que sea mucho más fácil determinar qué dependencias tiene el proyecto, lo que resulta útil a la hora de determinar si las dependencias necesarias funcionarán en .NET Core o no.</span><span class="sxs-lookup"><span data-stu-id="68874-148">This makes it much easier to determine what dependencies your project has, which is useful when determining whether the necessary dependencies will work on .NET Core or not.</span></span>

<span data-ttu-id="68874-149">El primer paso para migrar una aplicación de .NET Framework `<PackageReference>` a .NET Core es actualizarla para usar referencias nuGet.</span><span class="sxs-lookup"><span data-stu-id="68874-149">The first step to migrating a .NET Framework app to .NET Core is to update it to use `<PackageReference>` NuGet references.</span></span> <span data-ttu-id="68874-150">Visual Studio hace esto simple.</span><span class="sxs-lookup"><span data-stu-id="68874-150">Visual Studio makes this simple.</span></span> <span data-ttu-id="68874-151">Simplemente haga clic con el botón secundario en el archivo *packages.config* del proyecto en el **Explorador**de soluciones de Visual Studio y, a continuación, seleccione **Migrar packages.config a PackageReference**.</span><span class="sxs-lookup"><span data-stu-id="68874-151">Just right-click the project's *packages.config* file in Visual Studio's **Solution Explorer**, and then select **Migrate packages.config to PackageReference**.</span></span>

![Actualización a PackageReference](./media/convert-project-from-net-framework/package-reference-migration.png)

<span data-ttu-id="68874-153">Aparece un cuadro de diálogo que muestra las dependencias NuGet calculadas de nivel superior y que pregunta qué otros paquetes NuGet se deben promocionar a nivel superior.</span><span class="sxs-lookup"><span data-stu-id="68874-153">A dialog appears showing calculated top-level NuGet dependencies and asking which other NuGet packages should be promoted to top-level.</span></span> <span data-ttu-id="68874-154">Ninguno de estos otros paquetes necesita ser de nivel superior para la muestra de Bean Trader, por lo que puede desmarcar todas esas casillas.</span><span class="sxs-lookup"><span data-stu-id="68874-154">None of these other packages need to be top-level for the Bean Trader sample, so you can uncheck all of those boxes.</span></span> <span data-ttu-id="68874-155">A continuación, haga clic en **Aceptar** `<PackageReference>` y se quita el archivo *packages.config* y los elementos se agregan al archivo de proyecto.</span><span class="sxs-lookup"><span data-stu-id="68874-155">Then, click **Ok** and the *packages.config* file is removed and `<PackageReference>` elements are added to the project file.</span></span>

<span data-ttu-id="68874-156">`<PackageReference>`Las referencias de estilo no almacenan paquetes NuGet localmente en una carpeta de paquetes.</span><span class="sxs-lookup"><span data-stu-id="68874-156">`<PackageReference>`-style references don't store NuGet packages locally in a packages folder.</span></span> <span data-ttu-id="68874-157">En su lugar, se almacenan globalmente como una optimización.</span><span class="sxs-lookup"><span data-stu-id="68874-157">Instead, they're stored globally as an optimization.</span></span> <span data-ttu-id="68874-158">Una vez completada la migración, edite el `<Analyzer>` archivo csproj y quite los elementos que hacen referencia a los analizadores que anteriormente procedían del *archivo .. Directorio de paquetes.*</span><span class="sxs-lookup"><span data-stu-id="68874-158">After the migration completes, edit the csproj file and remove any `<Analyzer>` elements referring to the analyzers that previously came from the *..\packages* directory.</span></span> <span data-ttu-id="68874-159">No te preocupes; puesto que todavía tiene las referencias de paquete NuGet, los analizadores se incluirán en el proyecto.</span><span class="sxs-lookup"><span data-stu-id="68874-159">Don't worry; since you still have the NuGet package references, the analyzers will be included in the project.</span></span> <span data-ttu-id="68874-160">Sólo tiene que limpiar los elementos `<Analyzer>` antiguos packages.config-style.</span><span class="sxs-lookup"><span data-stu-id="68874-160">You just need to clean up the old packages.config-style `<Analyzer>` elements.</span></span>

### <a name="review-nuget-packages"></a><span data-ttu-id="68874-161">Revisar paquetes NuGet</span><span class="sxs-lookup"><span data-stu-id="68874-161">Review NuGet packages</span></span>

<span data-ttu-id="68874-162">Ahora que puede ver los paquetes NuGet de nivel superior de los que depende el proyecto, puede revisar si esos paquetes están disponibles en .NET Core.</span><span class="sxs-lookup"><span data-stu-id="68874-162">Now that you can see the top-level NuGet packages that the project depends on, you can review whether those packages are available on .NET Core.</span></span> <span data-ttu-id="68874-163">Puede determinar si un paquete admite .NET Core examinando sus dependencias en [nuget.org](https://www.nuget.org/). El sitio [de fuget.org](https://www.fuget.org/) creado por la comunidad muestra esta información de forma prominente en la parte superior de la página de información del paquete.</span><span class="sxs-lookup"><span data-stu-id="68874-163">You can determine whether a package supports .NET Core by looking at its dependencies on [nuget.org](https://www.nuget.org/). The community-created [fuget.org](https://www.fuget.org/) site shows this information prominently at the top of the package information page.</span></span>

<span data-ttu-id="68874-164">Al tener como destino .NET Core 3.0, los paquetes destinados a .NET Core o .NET Standard deben funcionar (ya que .NET Core implementa el área de superficie de .NET Standard).</span><span class="sxs-lookup"><span data-stu-id="68874-164">When targeting .NET Core 3.0, any packages targeting .NET Core or .NET Standard should work (since .NET Core implements the .NET Standard surface area).</span></span> <span data-ttu-id="68874-165">En algunos casos, la versión específica de un paquete que se usa no tendrá como destino .NET Core o .NET Standard, pero las versiones más recientes.</span><span class="sxs-lookup"><span data-stu-id="68874-165">In some cases, the specific version of a package that's used won't target .NET Core or .NET Standard, but newer versions will.</span></span> <span data-ttu-id="68874-166">En este caso, debe considerar la posibilidad de actualizar a la versión más reciente del paquete.</span><span class="sxs-lookup"><span data-stu-id="68874-166">In this case, you should consider upgrading to the latest version of the package.</span></span>

<span data-ttu-id="68874-167">También puede usar paquetes destinados a .NET Framework, pero eso introduce algún riesgo.</span><span class="sxs-lookup"><span data-stu-id="68874-167">You can use packages targeting .NET Framework, as well, but that introduces some risk.</span></span> <span data-ttu-id="68874-168">Las dependencias de .NET Core a .NET Framework se permiten porque las áreas de superficie de .NET Core y .NET Framework son lo suficientemente similares como para que dichas dependencias *funcionen con frecuencia.*</span><span class="sxs-lookup"><span data-stu-id="68874-168">.NET Core to .NET Framework dependencies are allowed because .NET Core and .NET Framework surface areas are similar enough that such dependencies *often* work.</span></span> <span data-ttu-id="68874-169">Sin embargo, si el paquete intenta usar una API de .NET que no está presente en .NET Core, encontrará una excepción en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="68874-169">However, if the package tries to use a .NET API that isn't present in .NET Core, you'll encounter a runtime exception.</span></span> <span data-ttu-id="68874-170">Por este motivo, solo debe hacer referencia a paquetes de .NET Framework cuando no hay otras opciones disponibles y comprender que al hacerlo se impone una carga de prueba.</span><span class="sxs-lookup"><span data-stu-id="68874-170">Because of that, you should only reference .NET Framework packages when no other options are available and understand that doing so imposes a test burden.</span></span>

<span data-ttu-id="68874-171">Si hay paquetes a los que se hace referencia que no tienen como destino .NET Core o .NET Standard, tendrá que pensar en otras alternativas:</span><span class="sxs-lookup"><span data-stu-id="68874-171">If there are packages referenced that don't target .NET Core or .NET Standard, you'll have to think about other alternatives:</span></span>

- <span data-ttu-id="68874-172">¿Hay otros paquetes similares que se pueden utilizar en su lugar?</span><span class="sxs-lookup"><span data-stu-id="68874-172">Are there other similar packages that can be used instead?</span></span> <span data-ttu-id="68874-173">A veces, los autores de NuGet publican por separado '. Las versiones principales de sus bibliotecas se dirigen específicamente a .NET Core.</span><span class="sxs-lookup"><span data-stu-id="68874-173">Sometimes NuGet authors publish separate '.Core' versions of their libraries specifically targeting .NET Core.</span></span> <span data-ttu-id="68874-174">Los paquetes de Enterprise Library son un ejemplo de la publicación de la comunidad ". NetCore".</span><span class="sxs-lookup"><span data-stu-id="68874-174">Enterprise Library packages are an example of the community publishing ".NetCore" alternatives.</span></span> <span data-ttu-id="68874-175">En otros casos, los DEPARTAMENTOS de dominio más recientes para un servicio determinado (a veces con nombres de paquetes diferentes) están disponibles para .NET Standard.</span><span class="sxs-lookup"><span data-stu-id="68874-175">In other cases, newer SDKs for a particular service (sometimes with different package names) are available for .NET Standard.</span></span> <span data-ttu-id="68874-176">Si no hay alternativas disponibles, puede continuar con los paquetes de objeto de .NET Framework, teniendo en cuenta que deberá probarlos a fondo una vez que se ejecute n.o.NET Core.</span><span class="sxs-lookup"><span data-stu-id="68874-176">If no alternatives are available, you can proceed using the .NET Framework-targeted packages, bearing in mind that you'll need to test them thoroughly once running on .NET Core.</span></span>

<span data-ttu-id="68874-177">El ejemplo Bean Trader tiene las siguientes dependencias NuGet de nivel superior:</span><span class="sxs-lookup"><span data-stu-id="68874-177">The Bean Trader sample has the following top-level NuGet dependencies:</span></span>

- [<span data-ttu-id="68874-178">**Castle.Windsor, versión 4.1.1**</span><span class="sxs-lookup"><span data-stu-id="68874-178">**Castle.Windsor, version 4.1.1**</span></span>](https://www.castleproject.org/projects/windsor/)  

  <span data-ttu-id="68874-179">Este paquete tiene como destino .NET Standard 1.6, por lo que funciona en .NET Core.</span><span class="sxs-lookup"><span data-stu-id="68874-179">This package targets .NET Standard 1.6, so it works on .NET Core.</span></span>

- [<span data-ttu-id="68874-180">**Microsoft.CodeAnalysis.FxCopAnalyzers, versión 2.6.3**</span><span class="sxs-lookup"><span data-stu-id="68874-180">**Microsoft.CodeAnalysis.FxCopAnalyzers, version 2.6.3**</span></span>](https://www.nuget.org/packages/Microsoft.CodeAnalysis.FxCopAnalyzers/2.6.3)  
  <span data-ttu-id="68874-181">Se trata de un metapaquete, por lo que no es inmediatamente obvio qué plataformas admite, pero la [documentación](https://github.com/dotnet/roslyn-analyzers#microsoftcodeanalysisfxcopanalyzers) indica que su versión más reciente (2.9.2) funcionará tanto para .NET Framework como para .NET Core.</span><span class="sxs-lookup"><span data-stu-id="68874-181">This is a meta-package, so it's not immediately obvious which platforms it supports, but [documentation](https://github.com/dotnet/roslyn-analyzers#microsoftcodeanalysisfxcopanalyzers) indicates that its newest version (2.9.2) will work for both .NET Framework and .NET Core.</span></span>

- [<span data-ttu-id="68874-182">**Nito.AsyncEx, versión 4.0.1**</span><span class="sxs-lookup"><span data-stu-id="68874-182">**Nito.AsyncEx, version 4.0.1**</span></span>](https://www.nuget.org/packages/Nito.AsyncEx/4.0.1)  

  <span data-ttu-id="68874-183">Este paquete no tiene como destino .NET Core, pero la versión 5.0 más reciente sí.</span><span class="sxs-lookup"><span data-stu-id="68874-183">This package doesn't target .NET Core, but the newer 5.0 version does.</span></span> <span data-ttu-id="68874-184">Esto es común al migrar porque muchos paquetes NuGet han agregado compatibilidad con .NET Standard recientemente, pero las versiones anteriores del proyecto solo tendrán como destino .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="68874-184">This is common when migrating because many NuGet packages have added .NET Standard support recently, but older project versions will only target .NET Framework.</span></span> <span data-ttu-id="68874-185">Si la diferencia de versión es solo una diferencia de versión menor, a menudo es fácil actualizar a la versión más reciente.</span><span class="sxs-lookup"><span data-stu-id="68874-185">If the version difference is only a minor version difference, it's often easy to upgrade to the newer version.</span></span> <span data-ttu-id="68874-186">Dado que se trata de un cambio de versión importante, debe tener cuidado con la actualización, ya que podría haber cambios importantes en el paquete.</span><span class="sxs-lookup"><span data-stu-id="68874-186">Because this is a major version change, you need to be cautious upgrading since there could be breaking changes in the package.</span></span> <span data-ttu-id="68874-187">Sin embargo, hay un camino hacia adelante, que es bueno.</span><span class="sxs-lookup"><span data-stu-id="68874-187">There is a path forward, though, which is good.</span></span>

- [<span data-ttu-id="68874-188">**MahApps.Metro, versión 1.6.5**</span><span class="sxs-lookup"><span data-stu-id="68874-188">**MahApps.Metro, version 1.6.5**</span></span>](https://www.nuget.org/packages/MahApps.Metro/1.6.5)  

  <span data-ttu-id="68874-189">Este paquete tampoco tiene como destino .NET Core, pero tiene una versión preliminar más reciente (2.0-alpha) que lo hace.</span><span class="sxs-lookup"><span data-stu-id="68874-189">This package also doesn't target .NET Core, but has a newer pre-release (2.0-alpha) that does.</span></span> <span data-ttu-id="68874-190">Una vez más, usted tiene que mirar hacia fuera para los cambios de última hora, pero el paquete más nuevo es alentador.</span><span class="sxs-lookup"><span data-stu-id="68874-190">Again, you have to look out for breaking changes, but the newer package is encouraging.</span></span>

<span data-ttu-id="68874-191">Las dependencias NuGet del ejemplo Bean Trader tienen como destino .NET Standard/.NET Core o tienen versiones más recientes, por lo que es poco probable que haya problemas de bloqueo aquí.</span><span class="sxs-lookup"><span data-stu-id="68874-191">The Bean Trader sample's NuGet dependencies all either target .NET Standard/.NET Core or have newer versions that do, so there are unlikely to be any blocking issues here.</span></span>

### <a name="upgrade-nuget-packages"></a><span data-ttu-id="68874-192">Actualizar paquetes NuGet</span><span class="sxs-lookup"><span data-stu-id="68874-192">Upgrade NuGet packages</span></span>

<span data-ttu-id="68874-193">Si es posible, sería bueno actualizar las versiones de los paquetes que solo se dirigen a .NET Core o .NET Standard con versiones más recientes en este momento (con el proyecto todavía destinado a .NET Framework) para detectar y solucionar los cambios importantes antes de tiempo.</span><span class="sxs-lookup"><span data-stu-id="68874-193">If possible, it would be good to upgrade the versions of any packages that only target .NET Core or .NET Standard with more recent versions at this point (with the project still targeting .NET Framework) to discover and address any breaking changes early.</span></span>

<span data-ttu-id="68874-194">Si prefiere no realizar ningún cambio importante en la versión existente de .NET Framework de la aplicación, esto puede esperar hasta que tenga un nuevo archivo de proyecto destinado a .NET Core.</span><span class="sxs-lookup"><span data-stu-id="68874-194">If you would rather not make any material changes to the existing .NET Framework version of the app, this can wait until you have a new project file targeting .NET Core.</span></span> <span data-ttu-id="68874-195">Sin embargo, la actualización de los paquetes NuGet a versiones compatibles con .NET Core hace que el proceso de migración sea aún más fácil una vez que se crea el nuevo archivo de proyecto y se reduce el número de diferencias entre las versiones de .NET Framework y .NET Core de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="68874-195">However, upgrading the NuGet packages to .NET Core-compatible versions ahead of time makes the migration process even easier once you create the new project file and reduces the number of differences between the .NET Framework and .NET Core versions of the app.</span></span>

<span data-ttu-id="68874-196">Con el ejemplo Bean Trader, todas las actualizaciones necesarias se pueden realizar fácilmente (mediante el administrador de paquetes NuGet de Visual Studio) con una excepción: la actualización de **MahApps.Metro 1.6.5** a **2.0** revela cambios importantes relacionados con las API de administración de temas y acentos.</span><span class="sxs-lookup"><span data-stu-id="68874-196">With the Bean Trader sample, all of the necessary upgrades can be made easily (using Visual Studio's NuGet package manager) with one exception: upgrading from **MahApps.Metro 1.6.5** to **2.0** reveals breaking changes related to theme and accent management APIs.</span></span>

<span data-ttu-id="68874-197">Idealmente, la aplicación se actualizaría para usar la versión más reciente del paquete (ya que es más probable que funcione en .NET Core).</span><span class="sxs-lookup"><span data-stu-id="68874-197">Ideally, the app would be updated to use the newer version of the package (since that is more likely to work on .NET Core).</span></span> <span data-ttu-id="68874-198">En algunos casos, sin embargo, eso puede no ser factible.</span><span class="sxs-lookup"><span data-stu-id="68874-198">In some cases, however, that may not be feasible.</span></span> <span data-ttu-id="68874-199">En estos casos, no actualice **MahApps.Metro** porque los cambios necesarios no son triviales y este tutorial se centra en migrar a .NET Core 3, no a **MahApps.Metro 2.**</span><span class="sxs-lookup"><span data-stu-id="68874-199">In these cases, don't upgrade **MahApps.Metro** because the necessary changes are non-trivial and this tutorial focuses on migrating to .NET Core 3, not to **MahApps.Metro 2.**</span></span> <span data-ttu-id="68874-200">Además, se trata de una dependencia de bajo riesgo de .NET Framework porque la aplicación Bean Trader solo ejerce una pequeña parte de **MahApps.Metro.**</span><span class="sxs-lookup"><span data-stu-id="68874-200">Also, this is a low-risk .NET Framework dependency because the Bean Trader app only exercises a small part of **MahApps.Metro**.</span></span> <span data-ttu-id="68874-201">Por supuesto, requerirá pruebas para asegurarse de que todo funciona una vez completada la migración.</span><span class="sxs-lookup"><span data-stu-id="68874-201">It will, of course, require testing to make sure everything's working once the migration is complete.</span></span> <span data-ttu-id="68874-202">Si esto fuera un escenario del mundo real, sería bueno presentar un problema para realizar un seguimiento del trabajo para pasar a **MahApps.Metro** versión 2.0 ya que no hacer la migración ahora deja alguna deuda técnica.</span><span class="sxs-lookup"><span data-stu-id="68874-202">If this were a real-world scenario, it would be good to file an issue to track the work to move to **MahApps.Metro** version 2.0 since not doing the migration now leaves behind some technical debt.</span></span>

<span data-ttu-id="68874-203">Una vez que los paquetes NuGet se actualizan a versiones recientes, el `<PackageReference>` grupo de elementos en el archivo de proyecto del ejemplo de Bean Trader debe tener este aspecto.</span><span class="sxs-lookup"><span data-stu-id="68874-203">Once the NuGet packages are updated to recent versions, the `<PackageReference>` item group in the Bean Trader sample's project file should look like this.</span></span>

```xml
<ItemGroup>
  <PackageReference Include="Castle.Windsor">
    <Version>4.1.1</Version>
  </PackageReference>
  <PackageReference Include="MahApps.Metro">
    <Version>1.6.5</Version>
  </PackageReference>
  <PackageReference Include="Microsoft.CodeAnalysis.FxCopAnalyzers">
    <Version>2.9.2</Version>
  </PackageReference>
  <PackageReference Include="Nito.AsyncEx">
    <Version>5.0.0</Version>
  </PackageReference>
</ItemGroup>
```

### <a name="net-framework-portability-analysis"></a><span data-ttu-id="68874-204">Análisis de portabilidad de .NET Framework</span><span class="sxs-lookup"><span data-stu-id="68874-204">.NET Framework portability analysis</span></span>

<span data-ttu-id="68874-205">Una vez que comprenda el estado de las dependencias NuGet del proyecto, lo siguiente que debe tener en cuenta son las dependencias de la API de .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="68874-205">Once you understand the state of your project's NuGet dependencies, the next thing to consider is .NET Framework API dependencies.</span></span> <span data-ttu-id="68874-206">La herramienta Analizador de portabilidad de [.NET](../../standard/analyzers/portability-analyzer.md) es útil para comprender cuáles de las API de .NET usa el proyecto están disponibles en otras plataformas .NET.</span><span class="sxs-lookup"><span data-stu-id="68874-206">The [.NET Portability Analyzer](../../standard/analyzers/portability-analyzer.md) tool is useful for understanding which of the .NET APIs your project uses are available on other .NET platforms.</span></span>

<span data-ttu-id="68874-207">La herramienta viene como un plugin de [Visual Studio,](https://marketplace.visualstudio.com/items?itemName=ConnieYau.NETPortabilityAnalyzer)una [herramienta de línea de comandos](https://github.com/Microsoft/dotnet-apiport/releases)o envuelta en una [sencilla GUI,](https://github.com/Microsoft/dotnet-apiport-ui)que simplifica sus opciones.</span><span class="sxs-lookup"><span data-stu-id="68874-207">The tool comes as a [Visual Studio plugin](https://marketplace.visualstudio.com/items?itemName=ConnieYau.NETPortabilityAnalyzer), a [command-line tool](https://github.com/Microsoft/dotnet-apiport/releases), or wrapped in a [simple GUI](https://github.com/Microsoft/dotnet-apiport-ui), which simplifies its options.</span></span> <span data-ttu-id="68874-208">Puede obtener más información sobre el uso del Analizador de portabilidad de .NET (puerto API) mediante la GUI de la entrada de blog [Porting desktop apps to .NET Core.](https://devblogs.microsoft.com/dotnet/porting-desktop-apps-to-net-core/)</span><span class="sxs-lookup"><span data-stu-id="68874-208">You can read more about using the .NET Portability Analyzer (API Port) using the GUI in the [Porting desktop apps to .NET Core](https://devblogs.microsoft.com/dotnet/porting-desktop-apps-to-net-core/) blog post.</span></span> <span data-ttu-id="68874-209">Si prefiere utilizar la línea de comandos, los pasos necesarios son:</span><span class="sxs-lookup"><span data-stu-id="68874-209">If you prefer to use the command line, the necessary steps are:</span></span>

1. <span data-ttu-id="68874-210">Descargue el Analizador de portabilidad de [.NET](https://github.com/Microsoft/dotnet-apiport/releases) si aún no lo tiene.</span><span class="sxs-lookup"><span data-stu-id="68874-210">Download the [.NET Portability Analyzer](https://github.com/Microsoft/dotnet-apiport/releases) if you don't already have it.</span></span>
1. <span data-ttu-id="68874-211">Asegúrese de que la aplicación de .NET Framework que se va a migrar se compila correctamente (esta es una buena idea antes de la migración independientemente).</span><span class="sxs-lookup"><span data-stu-id="68874-211">Make sure the .NET Framework app to be ported builds successfully (this is a good idea prior to migration regardless).</span></span>
1. <span data-ttu-id="68874-212">Ejecute API Port con una línea de comandos como esta.</span><span class="sxs-lookup"><span data-stu-id="68874-212">Run API Port with a command line like this.</span></span>

    ```console
    ApiPort.exe analyze -f <PathToBeanTraderBinaries> -r html -r excel -t ".NET Core"
    ```

    <span data-ttu-id="68874-213">El `-f` argumento especifica la ruta de acceso que contiene los archivos binarios que se va a analizar.</span><span class="sxs-lookup"><span data-stu-id="68874-213">The `-f` argument specifies the path containing the binaries to analyze.</span></span> <span data-ttu-id="68874-214">El `-r` argumento especifica qué formato de archivo de salida desea.</span><span class="sxs-lookup"><span data-stu-id="68874-214">The `-r` argument specifies which output file format you want.</span></span> <span data-ttu-id="68874-215">El `-t` argumento especifica con qué plataforma .NET analizar el uso de la API.</span><span class="sxs-lookup"><span data-stu-id="68874-215">The `-t` argument specifies which .NET platform to analyze API usage against.</span></span> <span data-ttu-id="68874-216">En este caso, desea .NET Core.</span><span class="sxs-lookup"><span data-stu-id="68874-216">In this case, you want .NET Core.</span></span>

<span data-ttu-id="68874-217">Al abrir el informe HTML, la primera sección enumerará todos los archivos binarios analizados y qué porcentaje de las API de .NET que usan están disponibles en la plataforma de destino.</span><span class="sxs-lookup"><span data-stu-id="68874-217">When you open the HTML report, the first section will list all of the analyzed binaries and what percentage of the .NET APIs they use are available on the targeted platform.</span></span> <span data-ttu-id="68874-218">El porcentaje no es significativo por sí mismo.</span><span class="sxs-lookup"><span data-stu-id="68874-218">The percentage is not meaningful by itself.</span></span> <span data-ttu-id="68874-219">Lo que es más útil es ver las API específicas que faltan.</span><span class="sxs-lookup"><span data-stu-id="68874-219">What's more useful is to see the specific APIs that are missing.</span></span> <span data-ttu-id="68874-220">Para ello, seleccione un nombre de ensamblado o desplácese hacia abajo hasta los informes para ensamblajes individuales.</span><span class="sxs-lookup"><span data-stu-id="68874-220">To do that, either select an assembly name or scroll down to the reports for individual assemblies.</span></span>

<span data-ttu-id="68874-221">Céntrese en los ensamblados para los que es propietario del código fuente.</span><span class="sxs-lookup"><span data-stu-id="68874-221">Focus on the assemblies that you own the source code for.</span></span> <span data-ttu-id="68874-222">En el informe ApiPort de Bean Trader, por ejemplo, hay muchos binarios enumerados, pero la mayoría de ellos pertenecen a paquetes NuGet.</span><span class="sxs-lookup"><span data-stu-id="68874-222">In the Bean Trader ApiPort report, for example, there are many binaries listed, but most of them belong to NuGet packages.</span></span> <span data-ttu-id="68874-223">`Castle.Windsor`muestra que depende de algunas API de System.Web que faltan en .NET Core.</span><span class="sxs-lookup"><span data-stu-id="68874-223">`Castle.Windsor` shows that it depends on some System.Web APIs that are missing in .NET Core.</span></span> <span data-ttu-id="68874-224">Esto no es un problema porque `Castle.Windsor` se verificó anteriormente que admite .NET Core.</span><span class="sxs-lookup"><span data-stu-id="68874-224">This isn't a concern because you previously verified that `Castle.Windsor` supports .NET Core.</span></span> <span data-ttu-id="68874-225">Es común que los paquetes NuGet tengan diferentes archivos binarios para su uso `Castle.Windsor` con diferentes plataformas .NET, por lo que si la versión de .NET Framework de usa las API de System.Web o no es irrelevante siempre que el paquete también tenga como destino .NET Standard o .NET Core (lo que hace).</span><span class="sxs-lookup"><span data-stu-id="68874-225">It is common for NuGet packages to have different binaries for use with different .NET platforms, so whether the .NET Framework version of `Castle.Windsor` uses System.Web APIs or not is irrelevant as long as the package also targets .NET Standard or .NET Core (which it does).</span></span>

<span data-ttu-id="68874-226">Con el bean Trader ejemplo, el único binario que debe tener en cuenta es **BeanTraderClient** y el informe muestra que solo faltan dos API de .NET: `System.ServiceModel.ClientBase<T>.Close` y `System.ServiceModel.ClientBase<T>.Open`.</span><span class="sxs-lookup"><span data-stu-id="68874-226">With the Bean Trader sample, the only binary that you need to consider is **BeanTraderClient** and the report shows that only two .NET APIs are missing: `System.ServiceModel.ClientBase<T>.Close` and `System.ServiceModel.ClientBase<T>.Open`.</span></span>

![Informe de portabilidad de BeanTraderClient](./media/convert-project-from-net-framework/portability-report.png)

<span data-ttu-id="68874-228">Es poco probable que se bloqueen los problemas porque las API de cliente WCF (principalmente) se admiten en .NET Core, por lo que debe haber alternativas disponibles para estas API centrales.</span><span class="sxs-lookup"><span data-stu-id="68874-228">These are unlikely to be blocking issues because WCF Client APIs are (mostly) supported on .NET Core, so there must be alternatives available for these central APIs.</span></span> <span data-ttu-id="68874-229">De hecho, `System.ServiceModel`al examinar el área de <https://apisof.net>superficie de .NET Core de 's (using ), verá que hay alternativas asincrónicas en .NET Core en su lugar.</span><span class="sxs-lookup"><span data-stu-id="68874-229">In fact, looking at `System.ServiceModel`'s .NET Core surface area (using <https://apisof.net>), you see that there are async alternatives in .NET Core instead.</span></span>

<span data-ttu-id="68874-230">Según este informe y el análisis de dependencia nuGet anterior, parece que no debería haber problemas importantes al migrar el ejemplo de Bean Trader a .NET Core.</span><span class="sxs-lookup"><span data-stu-id="68874-230">Based on this report and the previous NuGet dependency analysis, it looks like there should be no major issues migrating the Bean Trader sample to .NET Core.</span></span> <span data-ttu-id="68874-231">Está listo para el siguiente paso en el que realmente iniciará la migración.</span><span class="sxs-lookup"><span data-stu-id="68874-231">You're ready for the next step in which you'll actually start the migration.</span></span>

## <a name="migrating-the-project-file"></a><span data-ttu-id="68874-232">Migración del archivo del proyecto</span><span class="sxs-lookup"><span data-stu-id="68874-232">Migrating the project file</span></span>

<span data-ttu-id="68874-233">Si la aplicación no usa el nuevo formato de [archivo de proyecto de estilo SDK,](../../core/tools/csproj.md)necesitará un nuevo archivo de proyecto para tener como destino .NET Core.</span><span class="sxs-lookup"><span data-stu-id="68874-233">If your app isn't using the new [SDK-style project file format](../../core/tools/csproj.md), you'll need a new project file to target .NET Core.</span></span> <span data-ttu-id="68874-234">Puede reemplazar el archivo csproj existente o, si prefiere mantener el proyecto existente intacto en su estado actual, puede agregar un nuevo archivo csproj destinado a .NET Core.</span><span class="sxs-lookup"><span data-stu-id="68874-234">You can replace the existing csproj file or, if you prefer to keep the existing project untouched in its current state, you can add a new csproj file targeting .NET Core.</span></span> <span data-ttu-id="68874-235">Puede crear versiones de la aplicación para .NET Framework y .NET Core con un único `<TargetFrameworks>` archivo de proyecto de estilo SDK con varias [destinos](../../standard/library-guidance/cross-platform-targeting.md) (especificando varios destinos).</span><span class="sxs-lookup"><span data-stu-id="68874-235">You can build versions of the app for .NET Framework and .NET Core with a single SDK-style project file with [multi-targeting](../../standard/library-guidance/cross-platform-targeting.md) (specifying multiple `<TargetFrameworks>` targets).</span></span>

<span data-ttu-id="68874-236">Para crear el nuevo archivo de proyecto, puede crear un `dotnet new wpf` nuevo proyecto WPF en Visual Studio o usar el comando en un directorio temporal para generar el archivo de proyecto y, a continuación, copiarlo o cambiarle el nombre a la ubicación correcta.</span><span class="sxs-lookup"><span data-stu-id="68874-236">To create the new project file, you can create a new WPF project in Visual Studio or use the `dotnet new wpf` command in a temporary directory to generate the project file and then copy/rename it to the correct location.</span></span> <span data-ttu-id="68874-237">También hay una herramienta creada por la comunidad, [CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017), que puede automatizar parte de la migración de archivos de proyecto.</span><span class="sxs-lookup"><span data-stu-id="68874-237">There is also a community-created tool, [CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017), that can automate some of the project file migration.</span></span> <span data-ttu-id="68874-238">La herramienta es útil, pero todavía necesita un humano para revisar los resultados para asegurarse de que todos los detalles de la migración son correctos.</span><span class="sxs-lookup"><span data-stu-id="68874-238">The tool is helpful but still needs a human to review the results to make sure all the details of the migration are correct.</span></span> <span data-ttu-id="68874-239">Un área concreta que la herramienta no controla de manera óptima es la migración de paquetes NuGet desde archivos *packages.config.*</span><span class="sxs-lookup"><span data-stu-id="68874-239">One particular area that the tool doesn't handle optimally is migrating NuGet packages from *packages.config* files.</span></span> <span data-ttu-id="68874-240">Si la herramienta se ejecuta en un archivo de proyecto que todavía utiliza un archivo *packages.config* para hacer referencia a paquetes NuGet, se migrará a `<PackageReference>` elementos automáticamente, pero agregará `<PackageReference>` elementos para todos *los* paquetes en lugar de solo los de nivel superior.</span><span class="sxs-lookup"><span data-stu-id="68874-240">If the tool runs on a project file that still uses a *packages.config* file to reference NuGet packages, it will migrate to `<PackageReference>` elements automatically, but will add `<PackageReference>` elements for *all* of the packages instead of just top-level ones.</span></span> <span data-ttu-id="68874-241">Si ya ha`<PackageReference>` migrado a elementos con Visual Studio (como ha hecho en este ejemplo), la herramienta puede ayudar con el resto de la conversión.</span><span class="sxs-lookup"><span data-stu-id="68874-241">If you have already migrated to`<PackageReference>` elements with Visual Studio (as you've done in this sample), then the tool can help with the rest of the conversion.</span></span> <span data-ttu-id="68874-242">Al igual que Scott Hanselman recomienda en su entrada de blog sobre la migración de [archivos csproj,](https://www.hanselman.com/blog/UpgradingAnExistingNETProjectFilesToTheLeanNewCSPROJFormatFromNETCore.aspx)la portabilidad a mano es educativa y dará mejores resultados si solo tienes unos pocos proyectos por acarrear.</span><span class="sxs-lookup"><span data-stu-id="68874-242">Like Scott Hanselman recommends in [his blog post on migrating csproj files](https://www.hanselman.com/blog/UpgradingAnExistingNETProjectFilesToTheLeanNewCSPROJFormatFromNETCore.aspx), porting by hand is educational and will give better results if you only have a few projects to port.</span></span> <span data-ttu-id="68874-243">Pero si usted está porteando docenas o cientos de archivos de proyecto, entonces una herramienta como [CsprojToVs2017] puede ser de ayuda.</span><span class="sxs-lookup"><span data-stu-id="68874-243">But if you are porting dozens or hundreds of project files, then a tool like [CsprojToVs2017] can be a help.</span></span>

<span data-ttu-id="68874-244">Para crear un nuevo archivo de proyecto `dotnet new wpf` para el ejemplo Bean Trader, ejecute en un directorio temporal y mueva el archivo *.csproj* generado a la carpeta *BeanTraderClient* y cámbiele el nombre a **BeanTraderClient.Core.csproj**.</span><span class="sxs-lookup"><span data-stu-id="68874-244">To create a new project file for the Bean Trader sample, run `dotnet new wpf` in a temporary directory and move the generated *.csproj* file into the *BeanTraderClient* folder and rename it **BeanTraderClient.Core.csproj**.</span></span>

<span data-ttu-id="68874-245">Debido a que el nuevo formato de archivo de proyecto incluye automáticamente archivos de C, archivos *resx* y archivos XAML que encuentra en o debajo de su directorio, ¡el archivo de proyecto ya está casi completo!</span><span class="sxs-lookup"><span data-stu-id="68874-245">Because the new project file format automatically includes C# files, *resx* files, and XAML files that it finds in or under its directory, the project file is already almost complete!</span></span> <span data-ttu-id="68874-246">Para finalizar la migración, abra los archivos de proyecto antiguos y nuevos en paralelo y examine el antiguo para ver si es necesario migrar cualquier información que contenga.</span><span class="sxs-lookup"><span data-stu-id="68874-246">To finish the migration, open the old and new project files side-by-side and look through the old one to see if any information it contains needs to be migrated.</span></span> <span data-ttu-id="68874-247">En el caso de ejemplo de Bean Trader, se deben copiar los siguientes elementos en el nuevo proyecto:</span><span class="sxs-lookup"><span data-stu-id="68874-247">In the Bean Trader sample case, the following items should be copied to the new project:</span></span>

- <span data-ttu-id="68874-248">Las `<RootNamespace>` `<AssemblyName>`propiedades `<ApplicationIcon>` , , y todas deben copiarse.</span><span class="sxs-lookup"><span data-stu-id="68874-248">The `<RootNamespace>`, `<AssemblyName>`, and `<ApplicationIcon>` properties should all be copied.</span></span>

- <span data-ttu-id="68874-249">También debe agregar `<GenerateAssemblyInfo>false</GenerateAssemblyInfo>` una propiedad al nuevo archivo de proyecto, ya que `[AssemblyTitle]`el ejemplo Bean Trader incluye atributos de nivel de ensamblado (como ) en un archivo AssemblyInfo.cs.</span><span class="sxs-lookup"><span data-stu-id="68874-249">You also need to add a `<GenerateAssemblyInfo>false</GenerateAssemblyInfo>` property to the new project file since the Bean Trader sample includes assembly-level attributes (like `[AssemblyTitle]`) in an AssemblyInfo.cs file.</span></span> <span data-ttu-id="68874-250">De forma predeterminada, los nuevos proyectos de estilo SDK generarán automáticamente estos atributos en función de las propiedades del archivo csproj.</span><span class="sxs-lookup"><span data-stu-id="68874-250">By default, new SDK-style projects will autogenerate these attributes based on properties in the csproj file.</span></span> <span data-ttu-id="68874-251">Dado que no desea que eso suceda en este caso (los atributos generados automáticamente entrarían `<GenerateAssemblyInfo>`en conflicto con los de AssemblyInfo.cs), deshabilite los atributos generados automáticamente con .</span><span class="sxs-lookup"><span data-stu-id="68874-251">Because you don't want that to happen in this case (the autogenerated attributes would conflict with those from AssemblyInfo.cs), you disable the autogenerated attributes with `<GenerateAssemblyInfo>`.</span></span>

- <span data-ttu-id="68874-252">Aunque los archivos *resx* se incluyen `<Resource>` automáticamente como recursos incrustados, otros elementos como imágenes no lo son.</span><span class="sxs-lookup"><span data-stu-id="68874-252">Although *resx* files are automatically included as embedded resources, other `<Resource>` items like images are not.</span></span> <span data-ttu-id="68874-253">Por lo `<Resource>` tanto, copie los elementos para incrustar archivos de imagen e icono.</span><span class="sxs-lookup"><span data-stu-id="68874-253">So, copy the `<Resource>` elements for embedding image and icon files.</span></span> <span data-ttu-id="68874-254">Puede simplificar las referencias png a una sola línea utilizando la compatibilidad del `<Resource Include="**\*.png" />`nuevo formato de archivo de proyecto para patrones de globbing: .</span><span class="sxs-lookup"><span data-stu-id="68874-254">You can simplify the png references to a single line by using the new project file format's support for globbing patterns: `<Resource Include="**\*.png" />`.</span></span>

- <span data-ttu-id="68874-255">Del `<None>` mismo modo, los elementos se incluyen automáticamente, pero no se copian en el directorio de salida, de forma predeterminada.</span><span class="sxs-lookup"><span data-stu-id="68874-255">Similarly, `<None>` items are included automatically, but they aren't copied to the output directory, by default.</span></span> <span data-ttu-id="68874-256">Dado que el proyecto `<None>` Bean Trader incluye un elemento `PreserveNewest` que *se* copia en el directorio de salida (mediante comportamientos), debe actualizar el elemento rellenado `<None>` automáticamente para ese archivo, como este.</span><span class="sxs-lookup"><span data-stu-id="68874-256">Because the Bean Trader project includes a `<None>` item that *is* copied to the output directory (using `PreserveNewest` behaviors), you need to update the automatically populated `<None>` item for that file, like this.</span></span>

  ```xml
  <None Update="BeanTrader.pfx">
    <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
  </None>
  ```

- <span data-ttu-id="68874-257">El ejemplo de Bean Trader incluye un archivo `Content` XAML (Default.Accent.xaml) como (en lugar de como un `Page`) porque los temas y acentos definidos en este archivo se cargan desde el XAML del archivo en tiempo de ejecución, en lugar de estar incrustados en la propia aplicación.</span><span class="sxs-lookup"><span data-stu-id="68874-257">The Bean Trader sample includes a XAML file (Default.Accent.xaml) as `Content` (rather than as a `Page`) because themes and accents defined in this file are loaded from the file's XAML at runtime, rather than being embedded in the app itself.</span></span> <span data-ttu-id="68874-258">Sin embargo, el nuevo `<Page>`sistema de proyectos incluye automáticamente este archivo como un archivo , ya que es un archivo XAML.</span><span class="sxs-lookup"><span data-stu-id="68874-258">The new project system automatically includes this file as a `<Page>`, however, since it's a XAML file.</span></span> <span data-ttu-id="68874-259">Por lo tanto, debe quitar el archivo`<Page Remove="**\Default.Accent.xaml" />`XAML como una página ( ) y agregarlo como contenido.</span><span class="sxs-lookup"><span data-stu-id="68874-259">So, you need to both remove the XAML file as a page (`<Page Remove="**\Default.Accent.xaml" />`) and add it as content.</span></span>

  ```xml
  <Content Include="Resources\Themes\Default.Accent.xaml">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
  </Content>
  ```

- <span data-ttu-id="68874-260">Por último, agregue referencias NuGet copiando el `<ItemGroup>` con todos los `<PackageReference>` elementos.</span><span class="sxs-lookup"><span data-stu-id="68874-260">Finally, add NuGet references by copying the `<ItemGroup>` with all the `<PackageReference>` elements.</span></span> <span data-ttu-id="68874-261">Si no había actualizado previamente los paquetes NuGet a versiones compatibles con .NET Core, podría hacerlo ahora que las referencias de paquete están en un proyecto específico de .NET Core.</span><span class="sxs-lookup"><span data-stu-id="68874-261">If you hadn't previously upgraded the NuGet packages to .NET Core-compatible versions, you could do that now that the package references are in a .NET Core-specific project.</span></span>

<span data-ttu-id="68874-262">En este punto, debería ser posible agregar el nuevo proyecto a la solución BeanTrader y abrirlo en Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="68874-262">At this point, it should be possible to add the new project to the BeanTrader solution and open it in Visual Studio.</span></span> <span data-ttu-id="68874-263">El proyecto debe tener un `dotnet restore BeanTraderClient.Core.csproj` aspecto correcto en el Explorador de **soluciones**y debe restaurar correctamente los paquetes (con dos advertencias esperadas relacionadas con la versión de MahApps.Metro que usa .NET Framework).</span><span class="sxs-lookup"><span data-stu-id="68874-263">The project should look correct in **Solution Explorer**, and `dotnet restore BeanTraderClient.Core.csproj` should successfully restore packages (with two expected warnings related to the MahApps.Metro version you're using targeting .NET Framework).</span></span>

<span data-ttu-id="68874-264">Aunque es posible mantener ambos archivos de proyecto en paralelo (e incluso puede ser deseable si desea seguir construyendo el proyecto antiguo exactamente como era), complica el proceso de migración (los dos proyectos intentarán usar las mismas carpetas bin y obj) y normalmente no es necesario.</span><span class="sxs-lookup"><span data-stu-id="68874-264">Although it's possible to keep both project files side-by-side (and may even be desirable if you want to keep building the old project exactly as it was), it complicates the migration process (the two projects will try to use the same bin and obj folders) and usually isn't necessary.</span></span> <span data-ttu-id="68874-265">Si desea compilar para los destinos de .NET Core y `<TargetFramework>netcoreapp3.0</TargetFramework>` .NET Framework, `<TargetFrameworks>netcoreapp3.0;net472</TargetFrameworks>` puede reemplazar la propiedad en el nuevo archivo de proyecto con en su lugar.</span><span class="sxs-lookup"><span data-stu-id="68874-265">If you want to build for both .NET Core and .NET Framework targets, you can replace the `<TargetFramework>netcoreapp3.0</TargetFramework>` property in the new project file with `<TargetFrameworks>netcoreapp3.0;net472</TargetFrameworks>` instead.</span></span> <span data-ttu-id="68874-266">Para el ejemplo de Bean Trader, elimine el archivo de proyecto antiguo (BeanTraderClient.csproj) ya que ya no es necesario.</span><span class="sxs-lookup"><span data-stu-id="68874-266">For the Bean Trader sample, delete the old project file (BeanTraderClient.csproj) since it's no longer needed.</span></span> <span data-ttu-id="68874-267">Si prefiere mantener ambos archivos de proyecto, asegúrese de que se compilan en diferentes rutas de salida e intermedio.</span><span class="sxs-lookup"><span data-stu-id="68874-267">If you prefer to keep both project files, be sure to have them build to different output and intermediate output paths.</span></span>

## <a name="fix-build-issues"></a><span data-ttu-id="68874-268">Solucionar problemas de compilación</span><span class="sxs-lookup"><span data-stu-id="68874-268">Fix build issues</span></span>

<span data-ttu-id="68874-269">El tercer paso del proceso de portabilidad es conseguir que el proyecto se compile.</span><span class="sxs-lookup"><span data-stu-id="68874-269">The third step of the porting process is getting the project to build.</span></span> <span data-ttu-id="68874-270">Algunas aplicaciones ya se compilarán correctamente una vez que el archivo de proyecto se convierta en un proyecto de estilo SDK.</span><span class="sxs-lookup"><span data-stu-id="68874-270">Some apps will already build successfully once the project file is converted to an SDK-style project.</span></span> <span data-ttu-id="68874-271">Si ese es el caso de su aplicación, ¡felicidades!</span><span class="sxs-lookup"><span data-stu-id="68874-271">If that's the case for your app, congratulations!</span></span> <span data-ttu-id="68874-272">Puede continuar con el paso 4.</span><span class="sxs-lookup"><span data-stu-id="68874-272">You can go on to Step 4.</span></span> <span data-ttu-id="68874-273">Otras aplicaciones necesitarán algunas actualizaciones para que se estén creando para .NET Core.</span><span class="sxs-lookup"><span data-stu-id="68874-273">Other apps will need some updates to get them building for .NET Core.</span></span> <span data-ttu-id="68874-274">Si intenta ejecutar `dotnet build` en el proyecto de ejemplo Bean Trader ahora, por ejemplo, (o compilarlo en Visual Studio), habrá muchos errores, pero los corregirá rápidamente.</span><span class="sxs-lookup"><span data-stu-id="68874-274">If you try to run `dotnet build` on the Bean Trader sample project now, for example, (or build it in Visual Studio), there will be many errors, but you'll get them fixed quickly.</span></span>

### <a name="systemservicemodel-references-and-microsoftwindowscompatibility"></a><span data-ttu-id="68874-275">Referencias system.ServiceModel y Microsoft.Windows.Compatibility</span><span class="sxs-lookup"><span data-stu-id="68874-275">System.ServiceModel references and Microsoft.Windows.Compatibility</span></span>

<span data-ttu-id="68874-276">A un origen común de errores le faltan referencias para las API que están disponibles para .NET Core pero que no se incluyen automáticamente en el metapaquete de la aplicación .NET Core.</span><span class="sxs-lookup"><span data-stu-id="68874-276">A common source of errors is missing references for APIs that are available for .NET Core but not automatically included in the .NET Core app metapackage.</span></span> <span data-ttu-id="68874-277">Para solucionar este tema, `Microsoft.Windows.Compatibility` debe hacer referencia al paquete.</span><span class="sxs-lookup"><span data-stu-id="68874-277">To address this, you should reference the `Microsoft.Windows.Compatibility` package.</span></span> <span data-ttu-id="68874-278">El paquete de compatibilidad incluye un amplio conjunto de API que son comunes en las aplicaciones de escritorio de Windows, como el cliente WCF, los servicios de directorio, el registro, la configuración, las API de ACL y mucho más.</span><span class="sxs-lookup"><span data-stu-id="68874-278">The compatibility package includes a broad set of APIs that are common in Windows desktop apps, such as WCF client, directory services, registry, configuration, ACLs APIs, and more.</span></span>

<span data-ttu-id="68874-279">Con el ejemplo de Bean Trader, la mayoría <xref:System.ServiceModel> de los errores de compilación se deben a tipos que faltan.</span><span class="sxs-lookup"><span data-stu-id="68874-279">With the Bean Trader sample, the majority of the build errors are due to missing <xref:System.ServiceModel> types.</span></span> <span data-ttu-id="68874-280">Estos podrían solucionarse haciendo referencia a los paquetes NuGet de WCF necesarios.</span><span class="sxs-lookup"><span data-stu-id="68874-280">These could be addressed by referencing the necessary WCF NuGet packages.</span></span> <span data-ttu-id="68874-281">Sin embargo, las API `Microsoft.Windows.Compatibility` de cliente WCF se encuentran entre las presentes en el paquete, por lo que hacer referencia al paquete de compatibilidad es una solución aún mejor (ya que también aborda los problemas relacionados con las API, así como las soluciones a los problemas de WCF que el paquete de compatibilidad pone a disposición).</span><span class="sxs-lookup"><span data-stu-id="68874-281">WCF client APIs are among those present in the `Microsoft.Windows.Compatibility` package, though, so referencing the compatibility package is an even better solution (since it also addresses any issues related to APIs as well as solutions to the WCF issues that the compatibility package makes available).</span></span> <span data-ttu-id="68874-282">El `Microsoft.Windows.Compatibility` paquete ayuda en la mayoría de los escenarios de portabilidad de WPF y WinForms de .NET Core 3.0.</span><span class="sxs-lookup"><span data-stu-id="68874-282">The `Microsoft.Windows.Compatibility` package helps in most .NET Core 3.0 WPF and WinForms porting scenarios.</span></span> <span data-ttu-id="68874-283">Después de agregar `Microsoft.Windows.Compatibility`la referencia NuGet a , ¡solo queda un error de compilación!</span><span class="sxs-lookup"><span data-stu-id="68874-283">After adding the NuGet reference to `Microsoft.Windows.Compatibility`, only one build error remains!</span></span>

### <a name="cleaning-up-unused-files"></a><span data-ttu-id="68874-284">Limpieza de archivos no utilizados</span><span class="sxs-lookup"><span data-stu-id="68874-284">Cleaning up unused files</span></span>

<span data-ttu-id="68874-285">Un tipo de problema de migración que surge a menudo se relaciona con los archivos XAML y de C que no se incluyeron anteriormente en la compilación que se recogen en los nuevos proyectos de estilo SDK que incluyen *todo* el origen automáticamente.</span><span class="sxs-lookup"><span data-stu-id="68874-285">One type of migration issue that comes up often relates to C# and XAML files that weren't previously included in the build getting picked up by the new SDK-style projects that include *all* source automatically.</span></span>

<span data-ttu-id="68874-286">El siguiente error de compilación que ve en el ejemplo Bean Trader se refiere a una implementación de interfaz incorrecta en *OldUnusedViewModel.cs*.</span><span class="sxs-lookup"><span data-stu-id="68874-286">The next build error you see in the Bean Trader sample refers to a bad interface implementation in *OldUnusedViewModel.cs*.</span></span> <span data-ttu-id="68874-287">El nombre del archivo es una sugerencia, pero en la inspección, encontrará que este archivo de origen es incorrecto.</span><span class="sxs-lookup"><span data-stu-id="68874-287">The file name is a hint, but on inspection, you'll find that this source file is incorrect.</span></span> <span data-ttu-id="68874-288">No provocaba problemas anteriormente porque no se incluía en el proyecto original de .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="68874-288">It didn't cause issues previously because it wasn't included in the original .NET Framework project.</span></span> <span data-ttu-id="68874-289">Los archivos de origen que estaban presentes en el disco pero no se incluyeban en el *antiguo csproj* ahora se incluyen automáticamente.</span><span class="sxs-lookup"><span data-stu-id="68874-289">Source files that were present on disk but not included in the old *csproj* are included automatically now.</span></span>

<span data-ttu-id="68874-290">Para problemas únicos como este, es fácil comparar con el *csproj* anterior para confirmar que `<Compile Remove="" />` el archivo no es necesario y, a continuación, o bien o, si el archivo de origen ya no es necesario en cualquier lugar, elimínelo.</span><span class="sxs-lookup"><span data-stu-id="68874-290">For one-off issues like this, it's easy to compare to the previous *csproj* to confirm that the file isn't needed, and then either `<Compile Remove="" />` it or, if the source file isn't needed anywhere anymore, delete it.</span></span> <span data-ttu-id="68874-291">En este caso, es seguro simplemente eliminar *OldUnusedViewModel.cs*.</span><span class="sxs-lookup"><span data-stu-id="68874-291">In this case, it's safe to just delete *OldUnusedViewModel.cs*.</span></span>

<span data-ttu-id="68874-292">Si tiene muchos archivos de origen que tendrían que excluirse de esta manera, `<EnableDefaultCompileItems>` puede deshabilitar la inclusión automática de archivos de C- estableciendo la propiedad en false en el archivo de proyecto.</span><span class="sxs-lookup"><span data-stu-id="68874-292">If you have many source files that would need to be excluded this way, you can disable auto-inclusion of C# files by setting the `<EnableDefaultCompileItems>` property to false in the project file.</span></span> <span data-ttu-id="68874-293">A continuación, `<Compile Include>` puede copiar elementos del archivo de proyecto antiguo en el nuevo para crear solo los orígenes que pretendía incluir.</span><span class="sxs-lookup"><span data-stu-id="68874-293">Then, you can copy `<Compile Include>` items from the old project file to the new one in order to only build sources you intended to include.</span></span> <span data-ttu-id="68874-294">De `<EnableDefaultPageItems>` forma similar, se puede usar para `<EnableDefaultItems>` desactivar la inclusión automática de páginas XAML y puede controlar ambas con una sola propiedad.</span><span class="sxs-lookup"><span data-stu-id="68874-294">Similarly, `<EnableDefaultPageItems>` can be used to turn off auto-inclusion of XAML pages and `<EnableDefaultItems>` can control both with a single property.</span></span>

### <a name="a-brief-aside-on-multi-pass-compilers"></a><span data-ttu-id="68874-295">Un breve aparte en los compiladores de varias pasadas</span><span class="sxs-lookup"><span data-stu-id="68874-295">A brief aside on multi-pass compilers</span></span>

<span data-ttu-id="68874-296">Después de eliminar el archivo infractor de la muestra de Bean Trader, puede volver a crear y obtendrá cuatro errores.</span><span class="sxs-lookup"><span data-stu-id="68874-296">After removing the offending file from the Bean Trader sample, you can re-build and will get four errors.</span></span> <span data-ttu-id="68874-297">¿No tenías uno antes?</span><span class="sxs-lookup"><span data-stu-id="68874-297">Didn't you have one before?</span></span> <span data-ttu-id="68874-298">¿Por qué saqué el número de errores?</span><span class="sxs-lookup"><span data-stu-id="68874-298">Why did the number of errors go up?</span></span> <span data-ttu-id="68874-299">El compilador de C. es un [compilador de varias pasadas.](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes)</span><span class="sxs-lookup"><span data-stu-id="68874-299">The C# compiler is a [multi-pass compiler](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes).</span></span> <span data-ttu-id="68874-300">Esto significa que pasa a través de cada archivo de origen dos veces.</span><span class="sxs-lookup"><span data-stu-id="68874-300">This means that it goes through each source file twice.</span></span> <span data-ttu-id="68874-301">En primer lugar, el compilador solo examina los metadatos y las declaraciones de cada archivo de origen e identifica los problemas de nivel de declaración.</span><span class="sxs-lookup"><span data-stu-id="68874-301">First, the compiler just looks at metadata and declarations in each source file and identifies any declaration-level problems.</span></span> <span data-ttu-id="68874-302">Esos son los errores que has corregido.</span><span class="sxs-lookup"><span data-stu-id="68874-302">Those are the errors you've fixed.</span></span> <span data-ttu-id="68874-303">A continuación, pasa por el código de nuevo para compilar el origen de C- en IL; esos son el segundo conjunto de errores que estás viendo ahora.</span><span class="sxs-lookup"><span data-stu-id="68874-303">Then it goes through the code again to build the C# source into IL; those are the second set of errors that you're seeing now.</span></span>

> [!NOTE]
> <span data-ttu-id="68874-304">El compilador de C- hace [más que solo dos pasadas,](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes)pero el resultado final es que los errores del compilador para cambios de código grandes como este tienden a venir en dos oleadas.</span><span class="sxs-lookup"><span data-stu-id="68874-304">The C# compiler does [more than just two passes](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes), but the end result is that compiler errors for large code changes like this tend to come in two waves.</span></span>

### <a name="third-party-dependency-fixes-castlewindsor"></a><span data-ttu-id="68874-305">Correcciones de dependencia sin terceros (Castle.Windsor)</span><span class="sxs-lookup"><span data-stu-id="68874-305">Third-party dependency fixes (Castle.Windsor)</span></span>

<span data-ttu-id="68874-306">Otra clase de problema que surge en algunos escenarios de migración es las diferencias de API entre las versiones de dependencias de .NET Framework y .NET Core.</span><span class="sxs-lookup"><span data-stu-id="68874-306">Another class of issue that comes up in some migration scenarios is API differences between .NET Framework and .NET Core versions of dependencies.</span></span> <span data-ttu-id="68874-307">Incluso si un paquete NuGet tiene como destino .NET Framework y .NET Standard o .NET Core, puede haber bibliotecas diferentes para su uso con diferentes destinos de .NET.</span><span class="sxs-lookup"><span data-stu-id="68874-307">Even if a NuGet package targets both .NET Framework and .NET Standard or .NET Core, there may be different libraries for use with different .NET targets.</span></span> <span data-ttu-id="68874-308">Esto permite que los paquetes admitan muchas plataformas .NET diferentes, que pueden requerir implementaciones diferentes.</span><span class="sxs-lookup"><span data-stu-id="68874-308">This allows the packages to support many different .NET platforms, which may require different implementations.</span></span> <span data-ttu-id="68874-309">También significa que puede haber pequeñas diferencias de API en las bibliotecas al dirigirse a diferentes plataformas .NET.</span><span class="sxs-lookup"><span data-stu-id="68874-309">It also means that there may be small API differences in the libraries when targeting different .NET platforms.</span></span>

<span data-ttu-id="68874-310">El siguiente conjunto de errores que verá en el `Castle.Windsor` ejemplo de Bean Trader está relacionado con las API.</span><span class="sxs-lookup"><span data-stu-id="68874-310">The next set of errors you'll see in the Bean Trader sample are related to `Castle.Windsor` APIs.</span></span> <span data-ttu-id="68874-311">El proyecto de .NET Core Bean `Castle.Windsor` Trader usa la misma versión que el proyecto de .NET Framework (4.1.1), pero las implementaciones para esas dos plataformas son ligeramente diferentes.</span><span class="sxs-lookup"><span data-stu-id="68874-311">The .NET Core Bean Trader project uses the same version of `Castle.Windsor` as the .NET Framework-targeted project (4.1.1), but the implementations for those two platforms are slightly different.</span></span>

<span data-ttu-id="68874-312">En este caso, verá los siguientes problemas que deben corregirse:</span><span class="sxs-lookup"><span data-stu-id="68874-312">In this case, you see the following issues that need to be fixed:</span></span>

1. <span data-ttu-id="68874-313">`Castle.MicroKernel.Registration.Classes.FromThisAssembly`no está disponible en .NET Core.</span><span class="sxs-lookup"><span data-stu-id="68874-313">`Castle.MicroKernel.Registration.Classes.FromThisAssembly` isn't available on .NET Core.</span></span> <span data-ttu-id="68874-314">Hay, sin embargo, `Classes.FromAssemblyContaining` la API similar disponible, `Classes.FromThisAssembly()` por `Classes.FromAssemblyContaining(t)`lo `t` que podemos reemplazar ambos usos de con llamadas a , donde está el tipo que realiza la llamada.</span><span class="sxs-lookup"><span data-stu-id="68874-314">There is, however, the similar API `Classes.FromAssemblyContaining` available, so we can replace both uses of `Classes.FromThisAssembly()` with calls to `Classes.FromAssemblyContaining(t)`, where `t` is the type making the call.</span></span>
1. <span data-ttu-id="68874-315">Del mismo modo, en *Bootstrapper.cs*, `Castle.Windsor.Installer.FromAssembly`. Esto no está disponible en .NET Core.</span><span class="sxs-lookup"><span data-stu-id="68874-315">Similarly, in *Bootstrapper.cs*, `Castle.Windsor.Installer.FromAssembly`.This is unavailable on .NET Core.</span></span> <span data-ttu-id="68874-316">En su lugar, esa `FromAssembly.Containing(typeof(Bootstrapper))`llamada se puede reemplazar con .</span><span class="sxs-lookup"><span data-stu-id="68874-316">Instead, that call can be replaced with `FromAssembly.Containing(typeof(Bootstrapper))`.</span></span>

### <a name="updating-wcf-client-usage"></a><span data-ttu-id="68874-317">Actualización del uso del cliente WCF</span><span class="sxs-lookup"><span data-stu-id="68874-317">Updating WCF client usage</span></span>

<span data-ttu-id="68874-318">Una vez `Castle.Windsor` fijadas las diferencias, el último error de compilación `BeanTraderServiceClient` restante en el `DuplexClientBase`proyecto de .NET Core Bean Trader es que (que deriva de ) no tiene un `Open` método.</span><span class="sxs-lookup"><span data-stu-id="68874-318">Having fixed the `Castle.Windsor` differences, the last remaining build error in the .NET Core Bean Trader project is that `BeanTraderServiceClient` (which derives from `DuplexClientBase`) doesn't have an `Open` method.</span></span> <span data-ttu-id="68874-319">Esto no es sorprendente, ya que se trata de una API que el Analizador de portabilidad de .NET destacó al principio de este proceso de migración.</span><span class="sxs-lookup"><span data-stu-id="68874-319">This isn't surprising since this is an API that was highlighted by the .NET Portability Analyzer at the beginning of this migration process.</span></span> <span data-ttu-id="68874-320">Sin `BeanTraderServiceClient` embargo, mirar nos llama la atención sobre un tema más amplio.</span><span class="sxs-lookup"><span data-stu-id="68874-320">Looking at `BeanTraderServiceClient` draws our attention to a larger issue, though.</span></span> <span data-ttu-id="68874-321">Este cliente WCF se generó automáticamente por la herramienta [Svcutil.exe.](../../framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md)</span><span class="sxs-lookup"><span data-stu-id="68874-321">This WCF client was autogenerated by the [Svcutil.exe](../../framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) tool.</span></span>

<span data-ttu-id="68874-322">**Los clientes WCF generados por Svcutil están diseñados para su uso en .NET Framework.**</span><span class="sxs-lookup"><span data-stu-id="68874-322">**WCF clients generated by Svcutil are meant for use on .NET Framework.**</span></span>

<span data-ttu-id="68874-323">Las soluciones que usan clientes WCF generados por svcutil necesitarán volver a generar clientes compatibles con .NET Standard para su uso con .NET Core.</span><span class="sxs-lookup"><span data-stu-id="68874-323">Solutions that use svcutil-generated WCF clients will need to regenerate .NET Standard-compatible clients for use with .NET Core.</span></span> <span data-ttu-id="68874-324">Una de las principales razones por las que los clientes antiguos no funcionarán es que dependen de la configuración de la aplicación para definir enlaces WCF y extremos.</span><span class="sxs-lookup"><span data-stu-id="68874-324">One of the main reasons the old clients won't work is that they depend on app configuration for defining WCF bindings and endpoints.</span></span> <span data-ttu-id="68874-325">Dado que las API de WCF estándar de .NET pueden trabajar multiplataforma (donde las API de System.Configuration no están disponibles), los clientes WCF para escenarios de .NET Core y .NET Standard deben definir enlaces y extremos mediante programación en lugar de en la configuración.</span><span class="sxs-lookup"><span data-stu-id="68874-325">Because .NET Standard WCF APIs can work cross-platform (where System.Configuration APIs aren't available), WCF clients for .NET Core and .NET Standard scenarios must define bindings and endpoints programmatically instead of in configuration.</span></span>

<span data-ttu-id="68874-326">De hecho, cualquier uso de `<system.serviceModel>` cliente WCF que depende de la sección app.config (si se crea con Svcutil o manualmente) deberá cambiarse para que funcione en .NET Core.</span><span class="sxs-lookup"><span data-stu-id="68874-326">In fact, any WCF client usage that depends on the `<system.serviceModel>` app.config section (whether created with Svcutil or manually) will need to be changed to work on .NET Core.</span></span>

<span data-ttu-id="68874-327">Hay dos maneras de generar automáticamente clientes WCF compatibles con .NET Standard:</span><span class="sxs-lookup"><span data-stu-id="68874-327">There are two ways to automatically generate .NET Standard-compatible WCF clients:</span></span>

- <span data-ttu-id="68874-328">La `dotnet-svcutil` herramienta es una herramienta de .NET que genera clientes WCF de una manera similar a cómo Svcutil funcionaba anteriormente.</span><span class="sxs-lookup"><span data-stu-id="68874-328">The `dotnet-svcutil` tool is a .NET tool that generates WCF clients in a way that is similar to how Svcutil worked previously.</span></span>
- <span data-ttu-id="68874-329">Visual Studio puede generar clientes WCF mediante la opción [Referencia de servicio Web WCF](../../core/additional-tools/wcf-web-service-reference-guide.md) de su característica Servicios conectados.</span><span class="sxs-lookup"><span data-stu-id="68874-329">Visual Studio can generate WCF clients using the [WCF Web Service Reference](../../core/additional-tools/wcf-web-service-reference-guide.md) option of its Connected Services feature.</span></span>

<span data-ttu-id="68874-330">Cualquiera de los dos enfoques funciona bien.</span><span class="sxs-lookup"><span data-stu-id="68874-330">Either approach works well.</span></span> <span data-ttu-id="68874-331">Como alternativa, por supuesto, podría escribir el código de cliente WCF usted mismo.</span><span class="sxs-lookup"><span data-stu-id="68874-331">Alternatively, of course, you could write the WCF client code yourself.</span></span> <span data-ttu-id="68874-332">Para este ejemplo, elegí usar la característica de servicio conectado de Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="68874-332">For this sample, I chose to use the Visual Studio Connected Service feature.</span></span> <span data-ttu-id="68874-333">Para ello, haga clic con el botón derecho en el proyecto *BeanTraderClient.Core* en el explorador de soluciones de Visual Studio y seleccione **Agregar** > **servicio conectado**.</span><span class="sxs-lookup"><span data-stu-id="68874-333">To do that, right-click on the *BeanTraderClient.Core* project in Visual Studio's solution explorer and select **Add** > **Connected Service**.</span></span> <span data-ttu-id="68874-334">A continuación, elija el proveedor de referencia de servicio Web WCF.</span><span class="sxs-lookup"><span data-stu-id="68874-334">Next, choose the WCF Web Service Reference Provider.</span></span> <span data-ttu-id="68874-335">Esto abrirá un cuadro de diálogo donde puede especificar la dirección`localhost:8080` del servicio web backend Bean Trader (si está ejecutando el servidor localmente) y el espacio de nombres que los tipos generados deben utilizar (**BeanTrader.Service**, por ejemplo).</span><span class="sxs-lookup"><span data-stu-id="68874-335">This will bring up a dialog where you can specify the address of the backend Bean Trader web service (`localhost:8080` if you are running the server locally) and the namespace that generated types should use (**BeanTrader.Service**, for example).</span></span>

![Cuadro de diálogo Servicio conectado de referencia de servicio Web WCF](./media/convert-project-from-net-framework/connected-service-dialog.png)

<span data-ttu-id="68874-337">Después de seleccionar **el** finalizar botón, se agrega un nuevo servicios conectados nodo se agrega al proyecto y se agrega un archivo de Reference.cs bajo ese nodo que contiene el nuevo cliente WCF estándar de .NET para tener acceso al servicio Bean Trader.</span><span class="sxs-lookup"><span data-stu-id="68874-337">After you select the **Finish** button, a new Connected Services node is added to the project and a Reference.cs file is added under that node containing the new .NET Standard WCF client for accessing the Bean Trader service.</span></span> <span data-ttu-id="68874-338">Si observa los `GetEndpointAddress` `GetBindingForEndpoint` métodos o en ese archivo, verá que los enlaces y los extremos ahora se generan mediante programación (en lugar de a través de la configuración de la aplicación).</span><span class="sxs-lookup"><span data-stu-id="68874-338">If you look at the `GetEndpointAddress` or `GetBindingForEndpoint` methods in that file, you'll see that bindings and endpoints are now generated programmatically (instead of via app config).</span></span> <span data-ttu-id="68874-339">La característica 'Agregar servicios conectados' también puede agregar referencias a algunos paquetes System.ServiceModel en el archivo de proyecto, que no son necesarios, ya que todos los paquetes WCF necesarios se incluyen a través de Microsoft.Windows.Compatibility.</span><span class="sxs-lookup"><span data-stu-id="68874-339">The 'Add Connected Services' feature may also add references to some System.ServiceModel packages in the project file, which aren't needed since all necessary WCF packages are included via Microsoft.Windows.Compatibility.</span></span> <span data-ttu-id="68874-340">Compruebe el csproj para ver si `<PackageReference>` se han agregado elementos System.ServiceModel adicionales y, si es así, quitarlos.</span><span class="sxs-lookup"><span data-stu-id="68874-340">Check the csproj to see if any extra System.ServiceModel `<PackageReference>` items have been added, and if so, remove them.</span></span>

<span data-ttu-id="68874-341">Nuestro proyecto tiene nuevas clases de cliente WCF ahora (en *Reference.cs*), pero también tiene las antiguas (en BeanTrader.cs).</span><span class="sxs-lookup"><span data-stu-id="68874-341">Our project has new WCF client classes now (in *Reference.cs*), but it also still has the old ones (in BeanTrader.cs).</span></span> <span data-ttu-id="68874-342">Hay dos opciones en este punto:</span><span class="sxs-lookup"><span data-stu-id="68874-342">There are two options at this point:</span></span>

- <span data-ttu-id="68874-343">Si desea poder compilar el proyecto original de .NET Framework (junto con el nuevo de `<Compile Remove="BeanTrader.cs" />` objeto de .NET Core), puede usar un elemento en el archivo csproj del proyecto de .NET Core para que las versiones de .NET Framework y .NET Core de la aplicación usen diferentes clientes WCF.</span><span class="sxs-lookup"><span data-stu-id="68874-343">If you want to be able to build the original .NET Framework project (alongside the new .NET Core-targeted one), you can use a `<Compile Remove="BeanTrader.cs" />` item in the .NET Core project's csproj file so that the .NET Framework and .NET Core versions of the app use different WCF clients.</span></span> <span data-ttu-id="68874-344">Esto tiene la ventaja de dejar el proyecto de .NET Framework existente sin cambios, pero tiene la desventaja de que el código que usa los clientes `#if` WCF generados puede necesitar ser ligeramente diferente en el caso de .NET Core que en el proyecto de .NET Framework, por lo que es probable que tenga que usar directivas para compilar condicionalmente algún uso de cliente WCF (crear clientes, por ejemplo) para trabajar de una manera cuando se compila para .NET Core y otra manera cuando se compila para .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="68874-344">This has the advantage of leaving the existing .NET Framework project unchanged, but has the disadvantage that code using the generated WCF clients may need to be slightly different in the .NET Core case than it was in the .NET Framework project, so you'll likely need to use `#if` directives to conditionally compile some WCF client usage (creating clients, for example) to work one way when built for .NET Core and another way when built for .NET Framework.</span></span>

- <span data-ttu-id="68874-345">Si, por otro lado, alguna renovación de código en el proyecto de .NET Framework existente es aceptable, puede quitar *BeanTrader.cs* todos juntos.</span><span class="sxs-lookup"><span data-stu-id="68874-345">If, on the other hand, some code churn in the existing .NET Framework project is acceptable, you can remove *BeanTrader.cs* all together.</span></span> <span data-ttu-id="68874-346">Dado que el nuevo cliente WCF está compilado para .NET Standard, funcionará en escenarios de .NET Core y .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="68874-346">Because the new WCF client is built for .NET Standard, it will work in both .NET Core and .NET Framework scenarios.</span></span> <span data-ttu-id="68874-347">Si está creando para .NET Framework además de .NET Core (ya sea por segmentación múltiple o por tener dos archivos csproj), puede usar este nuevo archivo *de Reference.cs* para ambos destinos.</span><span class="sxs-lookup"><span data-stu-id="68874-347">If you are building for .NET Framework in addition to .NET Core (either by multi-targeting or by having two csproj files), you can use this new *Reference.cs* file for both targets.</span></span> <span data-ttu-id="68874-348">Este enfoque tiene la ventaja de que el código no tendrá que bifurcarse para admitir dos clientes WCF diferentes; el mismo código se utilizará en todas partes.</span><span class="sxs-lookup"><span data-stu-id="68874-348">This approach has the advantage that the code won't need to bifurcate to support two different WCF clients; the same code will be used everywhere.</span></span> <span data-ttu-id="68874-349">El inconveniente es que implica cambiar el proyecto de .NET Framework (presumiblemente estable).</span><span class="sxs-lookup"><span data-stu-id="68874-349">The drawback is that it involves changing the (presumably stable) .NET Framework project.</span></span>

<span data-ttu-id="68874-350">En el caso del ejemplo Bean Trader, puede realizar pequeños cambios en el proyecto original si facilita la migración, por lo que siga estos pasos para conciliar el uso del cliente WCF:</span><span class="sxs-lookup"><span data-stu-id="68874-350">In the case of the Bean Trader sample, you can make small changes to the original project if it makes migration easier, so follow these steps to reconcile WCF client usage:</span></span>

01. <span data-ttu-id="68874-351">Agregue el nuevo archivo Reference.cs al proyecto *BeanTraderClient.csproj* de .NET Framework mediante el menú contextual 'Agregar elemento existente' del explorador de soluciones.</span><span class="sxs-lookup"><span data-stu-id="68874-351">Add the new Reference.cs file to the .NET Framework *BeanTraderClient.csproj* project using the 'Add existing item' context menu from the solution explorer.</span></span> <span data-ttu-id="68874-352">Asegúrese de agregar 'as link' para que ambos proyectos utilicen el mismo archivo (en lugar de copiar el archivo de C-).</span><span class="sxs-lookup"><span data-stu-id="68874-352">Be sure to add 'as link' so that the same file is used by both projects (as opposed to copying the C# file).</span></span> <span data-ttu-id="68874-353">Si está creando para .NET Core y .NET Framework con un único csproj (mediante la segmentación múltiple), este paso no es necesario.</span><span class="sxs-lookup"><span data-stu-id="68874-353">If you are building for both .NET Core and .NET Framework with a single csproj (using multi-targeting) then this step isn't necessary.</span></span>

01. <span data-ttu-id="68874-354">Eliminar *BeanTrader.cs*.</span><span class="sxs-lookup"><span data-stu-id="68874-354">Delete *BeanTrader.cs*.</span></span>

01. <span data-ttu-id="68874-355">El nuevo cliente WCF es similar al anterior, pero un número de espacios de nombres en el código generado son diferentes.</span><span class="sxs-lookup"><span data-stu-id="68874-355">The new WCF client is similar to the old one, but a number of namespaces in the generated code are different.</span></span> <span data-ttu-id="68874-356">Por este motivo, es necesario actualizar el proyecto para que los tipos de cliente WCF se utilicen desde BeanTrader.Service (o cualquier nombre de espacio de nombres que haya elegido) en lugar de BeanTrader.Model o sin un espacio de nombres.</span><span class="sxs-lookup"><span data-stu-id="68874-356">Because of this, it is necessary to update the project so that WCF client types are used from BeanTrader.Service (or whatever namespace name you chose) instead of BeanTrader.Model or without a namespace.</span></span> <span data-ttu-id="68874-357">La creación de *BeanTraderClient.Core.csproj* ayudará a identificar dónde se deben realizar estos cambios.</span><span class="sxs-lookup"><span data-stu-id="68874-357">Building *BeanTraderClient.Core.csproj* will help to identify where these changes need to be made.</span></span> <span data-ttu-id="68874-358">Se necesitarán correcciones tanto en C- como en archivos de código fuente XAML.</span><span class="sxs-lookup"><span data-stu-id="68874-358">Fixes will be needed both in C# and in XAML source files.</span></span>

01. <span data-ttu-id="68874-359">Por último, descubrirá que hay un error en *BeanTraderServiceClientFactory.cs* porque `BeanTraderServiceClient` los constructores disponibles para el tipo han cambiado.</span><span class="sxs-lookup"><span data-stu-id="68874-359">Finally, you'll discover that there is an error in *BeanTraderServiceClientFactory.cs* because the available constructors for the `BeanTraderServiceClient` type have changed.</span></span> <span data-ttu-id="68874-360">Solía ser posible proporcionar `InstanceContext` un argumento (que `CallbackHandler` se `Castle.Windsor` creó mediante un contenedor de IoC).</span><span class="sxs-lookup"><span data-stu-id="68874-360">It used to be possible to supply an `InstanceContext` argument (which was created using a `CallbackHandler` from the `Castle.Windsor` IoC container).</span></span> <span data-ttu-id="68874-361">Los nuevos constructores `CallbackHandler`crean nueva s.</span><span class="sxs-lookup"><span data-stu-id="68874-361">The new constructors create new `CallbackHandler`s.</span></span> <span data-ttu-id="68874-362">Sin embargo, hay `BeanTraderServiceClient`constructores en el tipo base de 's que coinciden con lo que desea.</span><span class="sxs-lookup"><span data-stu-id="68874-362">There are, however, constructors in `BeanTraderServiceClient`'s base type that match what you want.</span></span> <span data-ttu-id="68874-363">Puesto que el código de cliente WCF generado automáticamente existe en clases parciales, puede ampliarlo fácilmente.</span><span class="sxs-lookup"><span data-stu-id="68874-363">Since the autogenerated WCF client code all exists in partial classes, you can easily extend it.</span></span> <span data-ttu-id="68874-364">Para ello, cree un nuevo archivo denominado *BeanTraderServiceClient.cs* y, a continuación, cree una clase parcial con el mismo nombre (utilizando el espacio de nombres BeanTrader.Service).</span><span class="sxs-lookup"><span data-stu-id="68874-364">To do this, create a new file called *BeanTraderServiceClient.cs* and then create a partial class with that same name (using the BeanTrader.Service namespace).</span></span> <span data-ttu-id="68874-365">A continuación, agregue un constructor al tipo parcial como se muestra aquí.</span><span class="sxs-lookup"><span data-stu-id="68874-365">Then, add one constructor to the partial type as shown here.</span></span>

    ```csharp
    public BeanTraderServiceClient(System.ServiceModel.InstanceContext callbackInstance) :
        base(callbackInstance, EndpointConfiguration.NetTcpBinding_BeanTraderService)
            { }
    ```

<span data-ttu-id="68874-366">Con los cambios realizados, el bean Trader ejemplo ahora usará un nuevo cliente WCF compatible `Open` con .NET `await OpenAsync` Standard y puede realizar la corrección final de cambiar la llamada en *TradingService.cs* usar en su lugar.</span><span class="sxs-lookup"><span data-stu-id="68874-366">With those changes made, the Bean Trader sample will now be using a new .NET Standard-compatible WCF client and you can make the final fix of changing the `Open` call in *TradingService.cs* to use `await OpenAsync` instead.</span></span>

<span data-ttu-id="68874-367">Con los problemas de WCF solucionados, la versión de .NET Core de la bean Trader ejemplo ahora se compila limpiamente!</span><span class="sxs-lookup"><span data-stu-id="68874-367">With the WCF issues addressed, the .NET Core version of the Bean Trader sample now builds cleanly!</span></span>

## <a name="runtime-testing"></a><span data-ttu-id="68874-368">Pruebas en tiempo de ejecución</span><span class="sxs-lookup"><span data-stu-id="68874-368">Runtime testing</span></span>

<span data-ttu-id="68874-369">Es fácil olvidar que el trabajo de migración no se realiza tan pronto como el proyecto se compila limpiamente en .NET Core.</span><span class="sxs-lookup"><span data-stu-id="68874-369">It's easy to forget that migration work isn't done as soon as the project builds cleanly against .NET Core.</span></span> <span data-ttu-id="68874-370">También es importante dejar tiempo para probar la aplicación porteada.</span><span class="sxs-lookup"><span data-stu-id="68874-370">It's important to leave time for testing the ported app, too.</span></span> <span data-ttu-id="68874-371">Una vez que las cosas se compilan correctamente, asegúrese de que la aplicación se ejecuta y funciona según lo esperado, especialmente si usa paquetes destinados a .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="68874-371">Once things build successfully, make sure the app runs and works as expected, especially if you are using any packages targeting .NET Framework.</span></span>

<span data-ttu-id="68874-372">Vamos a tratar de iniciar la aplicación portado Bean Trader y ver qué pasa.</span><span class="sxs-lookup"><span data-stu-id="68874-372">Let's try launching the ported Bean Trader app and see what happens.</span></span> <span data-ttu-id="68874-373">La aplicación no llega mucho antes de fallar con la siguiente excepción.</span><span class="sxs-lookup"><span data-stu-id="68874-373">The app doesn't get far before failing with the following exception.</span></span>

```output
System.Configuration.ConfigurationErrorsException: 'Configuration system failed to initialize'

Inner Exception
ConfigurationErrorsException: Unrecognized configuration section system.serviceModel.
```

<span data-ttu-id="68874-374">Esto tiene sentido, por supuesto.</span><span class="sxs-lookup"><span data-stu-id="68874-374">This makes sense, of course.</span></span> <span data-ttu-id="68874-375">Recuerde que WCF ya no usa la configuración de la aplicación, por lo que debe quitarse la sección system.serviceModel anterior del archivo app.config.</span><span class="sxs-lookup"><span data-stu-id="68874-375">Remember that WCF no longer uses app configuration, so the old system.serviceModel section of the app.config file needs to be removed.</span></span> <span data-ttu-id="68874-376">El cliente WCF actualizado incluye toda la misma información en su código, por lo que la sección de configuración ya no es necesaria.</span><span class="sxs-lookup"><span data-stu-id="68874-376">The updated WCF client includes all of the same information in its code, so the config section isn't needed anymore.</span></span> <span data-ttu-id="68874-377">Si desea que el extremo WCF sea configurable en app.config, podría agregarlo como una configuración de aplicación y actualizar el código de cliente WCF para recuperar el extremo del servicio WCF de la configuración.</span><span class="sxs-lookup"><span data-stu-id="68874-377">If you wanted the WCF endpoint to be configurable in app.config, you could add it as an app setting and update the WCF client code to retrieve the WCF service endpoint from configuration.</span></span>

<span data-ttu-id="68874-378">Después de quitar la sección system.serviceModel de *app.config*, la aplicación se inicia pero se produce un error con otra excepción cuando un usuario inicia sesión.</span><span class="sxs-lookup"><span data-stu-id="68874-378">After removing the system.serviceModel section of *app.config*, the app launches but fails with another exception when a user signs in.</span></span>

```output
System.PlatformNotSupportedException: 'Operation is not supported on this platform.'
```

<span data-ttu-id="68874-379">La API no `Func<T>.BeginInvoke`admitida es .</span><span class="sxs-lookup"><span data-stu-id="68874-379">The unsupported API is `Func<T>.BeginInvoke`.</span></span> <span data-ttu-id="68874-380">Como se explica en [dotnet/corefx-5940](https://github.com/dotnet/corefx/issues/5940), .NET `BeginInvoke` `EndInvoke` Core no admite los métodos y en los tipos de delegado debido a las dependencias de comunicación remota subyacentes.</span><span class="sxs-lookup"><span data-stu-id="68874-380">As explained in [dotnet/corefx#5940](https://github.com/dotnet/corefx/issues/5940), .NET Core doesn't support the `BeginInvoke` and `EndInvoke` methods on delegate types due to underlying remoting dependencies.</span></span> <span data-ttu-id="68874-381">Este problema y su corrección se explican con más detalle en la entrada de blog [Migrating Delegate.BeginInvoke Calls for .NET Core,](https://devblogs.microsoft.com/dotnet/migrating-delegate-begininvoke-calls-for-net-core/) pero la esencia es esa `BeginInvoke` y `EndInvoke` las llamadas deben reemplazarse por `Task.Run` (o alternativas asincrónicas, si es posible).</span><span class="sxs-lookup"><span data-stu-id="68874-381">This issue and its fix are explained in more detail in the [Migrating Delegate.BeginInvoke Calls for .NET Core](https://devblogs.microsoft.com/dotnet/migrating-delegate-begininvoke-calls-for-net-core/) blog post, but the gist is that `BeginInvoke` and `EndInvoke` calls should be replaced with `Task.Run` (or async alternatives, if possible).</span></span> <span data-ttu-id="68874-382">Aplicando la solución `BeginInvoke` general aquí, la `Invoke` llamada se `Task.Run`puede substituir con una llamada lanzada por .</span><span class="sxs-lookup"><span data-stu-id="68874-382">Applying the general solution here, the `BeginInvoke` call can be replaced with an `Invoke` call launched by `Task.Run`.</span></span>

```csharp
Task.Run(() =>
{
    return userInfoRetriever.Invoke();
}).ContinueWith(result =>
{
    // BeginInvoke's callback is replaced with ContinueWith
    var task = result.ConfigureAwait(false);
    CurrentTrader = task.GetAwaiter().GetResult();
}, TaskScheduler.Default);
```

<span data-ttu-id="68874-383">Después `BeginInvoke` de eliminar el uso, la aplicación Bean Trader se ejecuta con éxito en .NET Core!</span><span class="sxs-lookup"><span data-stu-id="68874-383">After removing the `BeginInvoke` usage, the Bean Trader app runs successfully on .NET Core!</span></span>

![Bean Trader que se ejecuta en .NET Core](./media/convert-project-from-net-framework/running-on-core.png)

<span data-ttu-id="68874-385">Todas las aplicaciones son diferentes, por lo que los pasos específicos necesarios para migrar sus propias aplicaciones a .NET Core variarán.</span><span class="sxs-lookup"><span data-stu-id="68874-385">All apps are different, so the specific steps needed to migrate your own apps to .NET Core will vary.</span></span> <span data-ttu-id="68874-386">Pero esperemos que el ejemplo de Bean Trader muestre el flujo de trabajo general y los tipos de problemas que se pueden esperar.</span><span class="sxs-lookup"><span data-stu-id="68874-386">But hopefully the Bean Trader sample demonstrates the general workflow and the types of issues that can be expected.</span></span> <span data-ttu-id="68874-387">Y, a pesar de la duración de este artículo, los cambios reales necesarios en la muestra de Bean Trader para que funcionara en .NET Core eran bastante limitados.</span><span class="sxs-lookup"><span data-stu-id="68874-387">And, despite this article's length, the actual changes needed in the Bean Trader sample to make it work on .NET Core were fairly limited.</span></span> <span data-ttu-id="68874-388">Muchas aplicaciones migran a .NET Core de esta misma manera; con cambios de código limitados o incluso sin necesidad de cambios de código.</span><span class="sxs-lookup"><span data-stu-id="68874-388">Many apps migrate to .NET Core in this same way; with limited or even no code changes needed.</span></span>
