---
title: Generación y consumo de secuencias asincrónicas
description: En este tutorial avanzado se muestra cómo generar y consumir secuencias asincrónicas. Las secuencias asincrónicas proporcionan una forma más natural de trabajar con secuencias de datos que se pueden generar de forma asincrónica.
ms.date: 02/10/2019
ms.technology: csharp-async
ms.custom: mvc
ms.openlocfilehash: fd9fed3469d18c919102640df7bb501b116f5e0e
ms.sourcegitcommit: 9a4488a3625866335e83a20da5e9c5286b1f034c
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 05/15/2020
ms.locfileid: "83420375"
---
# <a name="tutorial-generate-and-consume-async-streams-using-c-80-and-net-core-30"></a><span data-ttu-id="2adef-104">Tutorial: Generación y uso de secuencias asincrónicas con C# 8.0 y .NET Core 3.0</span><span class="sxs-lookup"><span data-stu-id="2adef-104">Tutorial: Generate and consume async streams using C# 8.0 and .NET Core 3.0</span></span>

<span data-ttu-id="2adef-105">C# 8.0 presenta **secuencias asincrónicas**, que modelan un origen de datos de streaming.</span><span class="sxs-lookup"><span data-stu-id="2adef-105">C# 8.0 introduces **async streams**, which model a streaming source of data.</span></span> <span data-ttu-id="2adef-106">Las secuencias de datos suelen recuperar o generar elementos de forma asincrónica.</span><span class="sxs-lookup"><span data-stu-id="2adef-106">Data streams often retrieve or generate elements asynchronously.</span></span> <span data-ttu-id="2adef-107">Las secuencias asincrónicas se basan en nuevas interfaces introducidas en .NET Standard 2.1.</span><span class="sxs-lookup"><span data-stu-id="2adef-107">Async streams rely on new interfaces introduced in .NET Standard 2.1.</span></span> <span data-ttu-id="2adef-108">Dichas interfaces se admiten en .NET Core 3.0 y versiones posteriores.</span><span class="sxs-lookup"><span data-stu-id="2adef-108">These interfaces are supported in .NET Core 3.0 and later.</span></span> <span data-ttu-id="2adef-109">Proporcionan un modelo de programación natural para los orígenes de datos de streaming asincrónicos.</span><span class="sxs-lookup"><span data-stu-id="2adef-109">They provide a natural programming model for asynchronous streaming data sources.</span></span>

<span data-ttu-id="2adef-110">En este tutorial aprenderá lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="2adef-110">In this tutorial, you'll learn how to:</span></span>

> [!div class="checklist"]
>
> - <span data-ttu-id="2adef-111">Crear un origen de datos que genera una secuencia de elementos de datos de forma asincrónica.</span><span class="sxs-lookup"><span data-stu-id="2adef-111">Create a data source that generates a sequence of data elements asynchronously.</span></span>
> - <span data-ttu-id="2adef-112">Utilizar ese origen de datos de forma asincrónica.</span><span class="sxs-lookup"><span data-stu-id="2adef-112">Consume that data source asynchronously.</span></span>
> - <span data-ttu-id="2adef-113">Admitir la cancelación y los contextos capturados para secuencias asincrónicas.</span><span class="sxs-lookup"><span data-stu-id="2adef-113">Support cancellation and captured contexts for asynchronous streams.</span></span>
> - <span data-ttu-id="2adef-114">Reconocer cuándo la interfaz y el origen de datos nuevos son preferibles a las secuencias de datos sincrónicas anteriores.</span><span class="sxs-lookup"><span data-stu-id="2adef-114">Recognize when the new interface and data source are preferred to earlier synchronous data sequences.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="2adef-115">Requisitos previos</span><span class="sxs-lookup"><span data-stu-id="2adef-115">Prerequisites</span></span>

<span data-ttu-id="2adef-116">Deberá configurar la máquina para ejecutar .NET Core, incluido el compilador de C# 8.0.</span><span class="sxs-lookup"><span data-stu-id="2adef-116">You'll need to set up your machine to run .NET Core, including the C# 8.0 compiler.</span></span> <span data-ttu-id="2adef-117">El compilador de C# 8 está disponible a partir de la [versión 16.3 de Visual Studio 2019](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019) o del [SDK de .NET Core 3.0](https://dotnet.microsoft.com/download).</span><span class="sxs-lookup"><span data-stu-id="2adef-117">The C# 8 compiler is available starting with [Visual Studio 2019 version 16.3](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019) or [.NET Core 3.0 SDK](https://dotnet.microsoft.com/download).</span></span>

<span data-ttu-id="2adef-118">Deberá crear un [token de acceso de GitHub](https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/#creating-a-token) para poder tener acceso al punto de conexión de GraphQL de GitHub.</span><span class="sxs-lookup"><span data-stu-id="2adef-118">You'll need to create a [GitHub access token](https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/#creating-a-token) so that you can access the GitHub GraphQL endpoint.</span></span> <span data-ttu-id="2adef-119">Seleccione los siguientes permisos para el token de acceso de GitHub:</span><span class="sxs-lookup"><span data-stu-id="2adef-119">Select the following permissions for your GitHub Access Token:</span></span>

- <span data-ttu-id="2adef-120">repo:status</span><span class="sxs-lookup"><span data-stu-id="2adef-120">repo:status</span></span>
- <span data-ttu-id="2adef-121">public_repo</span><span class="sxs-lookup"><span data-stu-id="2adef-121">public_repo</span></span>

<span data-ttu-id="2adef-122">Guarde el token de acceso en un lugar seguro para usarlo a fin de obtener acceso al punto de conexión de API de GitHub.</span><span class="sxs-lookup"><span data-stu-id="2adef-122">Save the access token in a safe place so you can use it to gain access to the GitHub API endpoint.</span></span>

> [!WARNING]
> <span data-ttu-id="2adef-123">Mantenga seguro su token de acceso personal.</span><span class="sxs-lookup"><span data-stu-id="2adef-123">Keep your personal access token secure.</span></span> <span data-ttu-id="2adef-124">Cualquier software con su token de acceso personal podría realizar llamadas de API de GitHub con sus derechos de acceso.</span><span class="sxs-lookup"><span data-stu-id="2adef-124">Any software with your personal access token could make GitHub API calls using your access rights.</span></span>

<span data-ttu-id="2adef-125">En este tutorial se da por supuesto que está familiarizado con C# y. NET, incluidos Visual Studio o la CLI de .NET Core.</span><span class="sxs-lookup"><span data-stu-id="2adef-125">This tutorial assumes you're familiar with C# and .NET, including either Visual Studio or the .NET Core CLI.</span></span>

## <a name="run-the-starter-application"></a><span data-ttu-id="2adef-126">Ejecución de la aplicación de inicio</span><span class="sxs-lookup"><span data-stu-id="2adef-126">Run the starter application</span></span>

<span data-ttu-id="2adef-127">Puede obtener el código para la aplicación de inicio usada en este tutorial en el repositorio [dotnet/docs](https://github.com/dotnet/docs) de la carpeta [csharp/tutoriales/AsyncStreams](https://github.com/dotnet/docs/tree/master/docs/csharp/tutorials/snippets/generate-consume-asynchronous-streams/start).</span><span class="sxs-lookup"><span data-stu-id="2adef-127">You can get the code for the starter application used in this tutorial from the [dotnet/docs](https://github.com/dotnet/docs) repository in the [csharp/tutorials/AsyncStreams](https://github.com/dotnet/docs/tree/master/docs/csharp/tutorials/snippets/generate-consume-asynchronous-streams/start) folder.</span></span>

<span data-ttu-id="2adef-128">La aplicación de inicio es una aplicación de consola que usa la interfaz [GraphQL de GitHub](https://developer.github.com/v4/) para recuperar las incidencias recientes escritas en el repositorio [dotnet/docs](https://github.com/dotnet/docs).</span><span class="sxs-lookup"><span data-stu-id="2adef-128">The starter application is a console application that uses the [GitHub GraphQL](https://developer.github.com/v4/) interface to retrieve recent issues written in the [dotnet/docs](https://github.com/dotnet/docs) repository.</span></span> <span data-ttu-id="2adef-129">Comience por mirar el código siguiente para el método `Main` de la aplicación de inicio:</span><span class="sxs-lookup"><span data-stu-id="2adef-129">Start by looking at the following code for the starter app `Main` method:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/start/Program.cs" id="SnippetStarterAppMain" :::

<span data-ttu-id="2adef-130">Puede establecer una variable de entorno `GitHubKey` para el token de acceso personal, o bien puede reemplazar el último argumento en la llamada a `GenEnvVariable` por el token de acceso personal.</span><span class="sxs-lookup"><span data-stu-id="2adef-130">You can either set a `GitHubKey` environment variable to your personal access token, or you can replace the last argument in the call to `GenEnvVariable` with your personal access token.</span></span> <span data-ttu-id="2adef-131">No coloque el código de acceso en el código fuente si va a compartir el origen con otros usuarios.</span><span class="sxs-lookup"><span data-stu-id="2adef-131">Don't put your access code in source code if you'll be sharing the source with others.</span></span> <span data-ttu-id="2adef-132">No cargue nunca códigos de acceso en un repositorio de código fuente compartido.</span><span class="sxs-lookup"><span data-stu-id="2adef-132">Never upload access codes to a shared source repository.</span></span>

<span data-ttu-id="2adef-133">Después de crear el cliente de GitHub, el código de `Main` crea un objeto de informe de progreso y un token de cancelación.</span><span class="sxs-lookup"><span data-stu-id="2adef-133">After creating the GitHub client, the code in `Main` creates a progress reporting object and a cancellation token.</span></span> <span data-ttu-id="2adef-134">Una vez que se crean esos objetos, `Main` llama a `runPagedQueryAsync` para recuperar las 250 incidencias creadas más recientemente.</span><span class="sxs-lookup"><span data-stu-id="2adef-134">Once those objects are created, `Main` calls `runPagedQueryAsync` to retrieve the most recent 250 created issues.</span></span> <span data-ttu-id="2adef-135">Una vez finalizada esa tarea, se muestran los resultados.</span><span class="sxs-lookup"><span data-stu-id="2adef-135">After that task has finished, the results are displayed.</span></span>

<span data-ttu-id="2adef-136">Al ejecutar la aplicación inicial, puede realizar algunas observaciones importantes acerca de cómo se ejecuta esta aplicación.</span><span class="sxs-lookup"><span data-stu-id="2adef-136">When you run the starter application, you can make some important observations about how this application runs.</span></span>  <span data-ttu-id="2adef-137">Verá el progreso notificado para cada página devuelta desde GitHub.</span><span class="sxs-lookup"><span data-stu-id="2adef-137">You'll see progress reported for each page returned from GitHub.</span></span> <span data-ttu-id="2adef-138">Puede observar una pausa marcada antes de que GitHub devuelva cada nueva página de incidencias.</span><span class="sxs-lookup"><span data-stu-id="2adef-138">You can observe a noticeable pause before GitHub returns each new page of issues.</span></span> <span data-ttu-id="2adef-139">Por último, se muestran las incidencias solo después de que se hayan recuperado 10 páginas de GitHub.</span><span class="sxs-lookup"><span data-stu-id="2adef-139">Finally, the issues are displayed only after all 10 pages have been retrieved from GitHub.</span></span>

## <a name="examine-the-implementation"></a><span data-ttu-id="2adef-140">Examen de la implementación</span><span class="sxs-lookup"><span data-stu-id="2adef-140">Examine the implementation</span></span>

<span data-ttu-id="2adef-141">La implementación revela por qué observó el comportamiento descrito en la sección anterior.</span><span class="sxs-lookup"><span data-stu-id="2adef-141">The implementation reveals why you observed the behavior discussed in the previous section.</span></span> <span data-ttu-id="2adef-142">Examine el código de `runPagedQueryAsync`:</span><span class="sxs-lookup"><span data-stu-id="2adef-142">Examine the code for `runPagedQueryAsync`:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/start/Program.cs" id="SnippetRunPagedQuery" :::

<span data-ttu-id="2adef-143">Vamos a concentrarnos en el algoritmo de paginación y la estructura asincrónica del código anterior.</span><span class="sxs-lookup"><span data-stu-id="2adef-143">Let's concentrate on the paging algorithm and async structure of the preceding code.</span></span> <span data-ttu-id="2adef-144">(Puede consultar la [documentación de GraphQL de GitHub](https://developer.github.com/v4/guides/) para obtener más información sobre la API de GraphQL de GitHub). El método `runPagedQueryAsync` enumera las incidencias desde la más reciente hasta la más antigua.</span><span class="sxs-lookup"><span data-stu-id="2adef-144">(You can consult the [GitHub GraphQL documentation](https://developer.github.com/v4/guides/) for details on the GitHub GraphQL API.) The `runPagedQueryAsync` method enumerates the issues from most recent to oldest.</span></span> <span data-ttu-id="2adef-145">Solicita 25 incidencias por página y examina la estructura `pageInfo` de la respuesta para continuar con la página anterior.</span><span class="sxs-lookup"><span data-stu-id="2adef-145">It requests 25 issues per page and examines the `pageInfo` structure of the response to continue with the previous page.</span></span> <span data-ttu-id="2adef-146">Eso sigue al soporte de paginación estándar de GraphQL para respuestas de varias páginas.</span><span class="sxs-lookup"><span data-stu-id="2adef-146">That follows GraphQL's standard paging support for multi-page responses.</span></span> <span data-ttu-id="2adef-147">La respuesta incluye un objeto `pageInfo` que incluye a su vez un valor `hasPreviousPages` y un valor `startCursor` usado para solicitar la página anterior.</span><span class="sxs-lookup"><span data-stu-id="2adef-147">The response includes a `pageInfo` object that includes a `hasPreviousPages` value and a `startCursor` value used to request the previous page.</span></span> <span data-ttu-id="2adef-148">Las incidencias se encuentran en la matriz `nodes`.</span><span class="sxs-lookup"><span data-stu-id="2adef-148">The issues are in the `nodes` array.</span></span> <span data-ttu-id="2adef-149">El método `runPagedQueryAsync` anexa estos nodos a una matriz que contiene todos los resultados de todas las páginas.</span><span class="sxs-lookup"><span data-stu-id="2adef-149">The `runPagedQueryAsync` method appends these nodes to an array that contains all the results from all pages.</span></span>

<span data-ttu-id="2adef-150">Después de recuperar y restaurar una página de resultados, `runPagedQueryAsync` informa del progreso y comprueba la cancelación.</span><span class="sxs-lookup"><span data-stu-id="2adef-150">After retrieving and restoring a page of results, `runPagedQueryAsync` reports progress and checks for cancellation.</span></span> <span data-ttu-id="2adef-151">Si se ha solicitado la cancelación, `runPagedQueryAsync` lanza un <xref:System.OperationCanceledException>.</span><span class="sxs-lookup"><span data-stu-id="2adef-151">If cancellation has been requested, `runPagedQueryAsync` throws an <xref:System.OperationCanceledException>.</span></span>

<span data-ttu-id="2adef-152">Hay varios elementos en este código que se pueden mejorar.</span><span class="sxs-lookup"><span data-stu-id="2adef-152">There are several elements in this code that can be improved.</span></span> <span data-ttu-id="2adef-153">Lo más importante, `runPagedQueryAsync` debe asignar el almacenamiento para todas las incidencias devueltas.</span><span class="sxs-lookup"><span data-stu-id="2adef-153">Most importantly, `runPagedQueryAsync` must allocate storage for all the issues returned.</span></span> <span data-ttu-id="2adef-154">Este ejemplo se detiene en 250 incidencias porque la recuperación de todas las incidencias abiertas requeriría mucha más memoria para almacenar todas las incidencias recuperadas.</span><span class="sxs-lookup"><span data-stu-id="2adef-154">This sample stops at 250 issues because retrieving all open issues would require much more memory to store all the retrieved issues.</span></span> <span data-ttu-id="2adef-155">Los protocolos para admitir los informes de progreso y la cancelación hacen que el algoritmo sea más difícil de comprender en su primera lectura.</span><span class="sxs-lookup"><span data-stu-id="2adef-155">The protocols for supporting progress reports and cancellation make the algorithm harder to understand on its first reading.</span></span> <span data-ttu-id="2adef-156">Hay más tipos y API implicados.</span><span class="sxs-lookup"><span data-stu-id="2adef-156">More types and APIs are involved.</span></span> <span data-ttu-id="2adef-157">Debe realizar un seguimiento de las comunicaciones a través de <xref:System.Threading.CancellationTokenSource> y su <xref:System.Threading.CancellationToken> asociado para comprender dónde se solicita la cancelación y dónde se concede.</span><span class="sxs-lookup"><span data-stu-id="2adef-157">You must trace the communications through the <xref:System.Threading.CancellationTokenSource> and its associated <xref:System.Threading.CancellationToken> to understand where cancellation is requested and where it's granted.</span></span>

## <a name="async-streams-provide-a-better-way"></a><span data-ttu-id="2adef-158">Las secuencias asincrónicas ofrecen una manera mejor</span><span class="sxs-lookup"><span data-stu-id="2adef-158">Async streams provide a better way</span></span>

<span data-ttu-id="2adef-159">Las secuencias asincrónicas y el lenguaje asociado abordan todas estas cuestiones.</span><span class="sxs-lookup"><span data-stu-id="2adef-159">Async streams and the associated language support address all those concerns.</span></span> <span data-ttu-id="2adef-160">El código que genera la secuencia ahora puede usar `yield return` para devolver los elementos en un método que se declaró con el modificador `async`.</span><span class="sxs-lookup"><span data-stu-id="2adef-160">The code that generates the sequence can now use `yield return` to return elements in a method that was declared with the `async` modifier.</span></span> <span data-ttu-id="2adef-161">Puede usar una secuencia asincrónica utilizando un bucle `await foreach` igual que puede usar una secuencia mediante un bucle `foreach`.</span><span class="sxs-lookup"><span data-stu-id="2adef-161">You can consume an async stream using an `await foreach` loop just as you consume any sequence using a `foreach` loop.</span></span>

<span data-ttu-id="2adef-162">Estas nuevas características del lenguaje dependen de tres nuevas interfaces agregadas a .NET Standard 2.1 e implementadas en .NET Core 3.0:</span><span class="sxs-lookup"><span data-stu-id="2adef-162">These new language features depend on three new interfaces added to .NET Standard 2.1 and implemented in .NET Core 3.0:</span></span>

- <xref:System.Collections.Generic.IAsyncEnumerable%601?displayProperty=nameWithType>
- <xref:System.Collections.Generic.IAsyncEnumerator%601?displayProperty=nameWithType>
- <xref:System.IAsyncDisposable?displayProperty=nameWithType>

<span data-ttu-id="2adef-163">Estas tres interfaces deben resultar familiares a la mayoría de desarrolladores de C#.</span><span class="sxs-lookup"><span data-stu-id="2adef-163">These three interfaces should be familiar to most C# developers.</span></span> <span data-ttu-id="2adef-164">Se comportan de manera similar con sus contrapartes sincrónicas:</span><span class="sxs-lookup"><span data-stu-id="2adef-164">They behave in a manner similar to their synchronous counterparts:</span></span>

- <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>
- <xref:System.Collections.Generic.IEnumerator%601?displayProperty=nameWithType>
- <xref:System.IDisposable?displayProperty=nameWithType>

<span data-ttu-id="2adef-165">Un tipo que podría ser desconocido es <xref:System.Threading.Tasks.ValueTask?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2adef-165">One type that may be unfamiliar is <xref:System.Threading.Tasks.ValueTask?displayProperty=nameWithType>.</span></span> <span data-ttu-id="2adef-166">La estructura `ValueTask` proporciona una API similar a la clase <xref:System.Threading.Tasks.Task?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2adef-166">The `ValueTask` struct provides a similar API to the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> class.</span></span> <span data-ttu-id="2adef-167">`ValueTask` se usa en estas interfaces por motivos de rendimiento.</span><span class="sxs-lookup"><span data-stu-id="2adef-167">`ValueTask` is used in these interfaces for performance reasons.</span></span>

## <a name="convert-to-async-streams"></a><span data-ttu-id="2adef-168">Conversión en secuencias asincrónicas</span><span class="sxs-lookup"><span data-stu-id="2adef-168">Convert to async streams</span></span>

<span data-ttu-id="2adef-169">A continuación, convierta el método `runPagedQueryAsync` para generar una secuencia asincrónica.</span><span class="sxs-lookup"><span data-stu-id="2adef-169">Next, convert the `runPagedQueryAsync` method to generate an async stream.</span></span> <span data-ttu-id="2adef-170">En primer lugar, cambie la signatura de `runPagedQueryAsync` para que devuelva un `IAsyncEnumerable<JToken>`y quite el token de cancelación y los objetos de progreso de la lista de parámetros como se muestra en el código siguiente:</span><span class="sxs-lookup"><span data-stu-id="2adef-170">First, change the signature of `runPagedQueryAsync` to return an `IAsyncEnumerable<JToken>`, and remove the cancellation token and progress objects from the parameter list as shown in the following code:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/finished/Program.cs" id="SnippetUpdateSignature" :::

<span data-ttu-id="2adef-171">El código de inicio procesa cada página a medida que se recupera, tal como se muestra en el código siguiente:</span><span class="sxs-lookup"><span data-stu-id="2adef-171">The starter code processes each page as the page is retrieved, as shown in the following code:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/start/Program.cs" id="SnippetProcessPage" :::

<span data-ttu-id="2adef-172">Reemplace esas tres líneas por el código siguiente:</span><span class="sxs-lookup"><span data-stu-id="2adef-172">Replace those three lines with the following code:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/finished/Program.cs" id="SnippetYieldReturnPage" :::

<span data-ttu-id="2adef-173">También puede quitar la declaración de `finalResults` anteriormente en este método y la instrucción `return` que sigue al bucle modificado.</span><span class="sxs-lookup"><span data-stu-id="2adef-173">You can also remove the declaration of `finalResults` earlier in this method and the `return` statement that follows the loop you modified.</span></span>

<span data-ttu-id="2adef-174">Ha terminado los cambios para generar una secuencia asincrónica.</span><span class="sxs-lookup"><span data-stu-id="2adef-174">You've finished the changes to generate an async stream.</span></span> <span data-ttu-id="2adef-175">El método finalizado debería ser similar al código siguiente:</span><span class="sxs-lookup"><span data-stu-id="2adef-175">The finished method should resemble the following code:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/finished/Program.cs" id="SnippetGenerateAsyncStream" :::

<span data-ttu-id="2adef-176">A continuación, cambie el código que utiliza la colección para usar la secuencia asincrónica.</span><span class="sxs-lookup"><span data-stu-id="2adef-176">Next, you change the code that consumes the collection to consume the async stream.</span></span> <span data-ttu-id="2adef-177">Busque el código siguiente en `Main` que procesa la colección de incidencias:</span><span class="sxs-lookup"><span data-stu-id="2adef-177">Find the following code in `Main` that processes the collection of issues:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/start/Program.cs" id="SnippetEnumerateOldStyle" :::

<span data-ttu-id="2adef-178">Reemplace el código por el siguiente bucle `await foreach`:</span><span class="sxs-lookup"><span data-stu-id="2adef-178">Replace that code with the following `await foreach` loop:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/finished/Program.cs" id="SnippetEnumerateAsyncStream" :::

<span data-ttu-id="2adef-179">La nueva interfaz <xref:System.Collections.Generic.IAsyncEnumerator%601> deriva de <xref:System.IAsyncDisposable>.</span><span class="sxs-lookup"><span data-stu-id="2adef-179">The new interface <xref:System.Collections.Generic.IAsyncEnumerator%601> derives from <xref:System.IAsyncDisposable>.</span></span> <span data-ttu-id="2adef-180">Esto significa que el bucle anterior desechará la secuencia de forma asincrónica cuando finalice el bucle.</span><span class="sxs-lookup"><span data-stu-id="2adef-180">That means the preceding loop will asynchronously dispose the stream when the loop finishes.</span></span> <span data-ttu-id="2adef-181">Como imaginará, el bucle es similar al código siguiente:</span><span class="sxs-lookup"><span data-stu-id="2adef-181">You can imagine the loop looks like the following code:</span></span>

```csharp
int num = 0;
var enumerator = runPagedQueryAsync(client, PagedIssueQuery, "docs").GetEnumeratorAsync();
try
{
    while (await enumerator.MoveNextAsync())
    {
        var issue = enumerator.Current;
        Console.WriteLine(issue);
        Console.WriteLine($"Received {++num} issues in total");
    }
} finally
{
    if (enumerator != null)
        await enumerator.DisposeAsync();
}
```

<span data-ttu-id="2adef-182">Los elementos de secuencia se procesan de forma predeterminada en el contexto capturado.</span><span class="sxs-lookup"><span data-stu-id="2adef-182">By default, stream elements are processed in the captured context.</span></span> <span data-ttu-id="2adef-183">Si quiere deshabilitar la captura del contexto, use el método de extensión <xref:System.Threading.Tasks.TaskAsyncEnumerableExtensions.ConfigureAwait%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2adef-183">If you want to disable capturing of the context, use the <xref:System.Threading.Tasks.TaskAsyncEnumerableExtensions.ConfigureAwait%2A?displayProperty=nameWithType> extension method.</span></span> <span data-ttu-id="2adef-184">Para obtener más información sobre los contextos de sincronización y la captura del contexto actual, vea el artículo sobre el [consumo del patrón asincrónico basado en tareas](../../standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="2adef-184">For more information about synchronization contexts and capturing the current context, see the article on [consuming the Task-based asynchronous pattern](../../standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md).</span></span>

<span data-ttu-id="2adef-185">Las secuencias asincrónicas admiten la cancelación mediante el mismo protocolo que otros métodos `async`.</span><span class="sxs-lookup"><span data-stu-id="2adef-185">Async streams support cancellation using the same protocol as other `async` methods.</span></span> <span data-ttu-id="2adef-186">Para admitir la cancelación, debe modificar la firma del método de iterador asincrónico como se indica a continuación:</span><span class="sxs-lookup"><span data-stu-id="2adef-186">You would modify the signature for the async iterator method as follows to support cancellation:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/finished/Program.cs" id="SnippetGenerateWithCancellation" :::

<span data-ttu-id="2adef-187">El atributo <xref:System.Runtime.CompilerServices.EnumeratorCancellationAttribute?dipslayProperty=nameWithType> hace que el compilador genere código para <xref:System.Collections.Generic.IAsyncEnumerator%601>, que hace que el token que se pasa a `GetAsyncEnumerator` sea visible al cuerpo del iterador asincrónico como ese argumento.</span><span class="sxs-lookup"><span data-stu-id="2adef-187">The <xref:System.Runtime.CompilerServices.EnumeratorCancellationAttribute?dipslayProperty=nameWithType> attribute causes the compiler to generate code for the <xref:System.Collections.Generic.IAsyncEnumerator%601> that makes the token passed to `GetAsyncEnumerator` visible to the body of the async iterator as that argument.</span></span> <span data-ttu-id="2adef-188">En `runQueryAsync`, puede examinar el estado del token y cancelar el trabajo posterior si es necesario.</span><span class="sxs-lookup"><span data-stu-id="2adef-188">Inside `runQueryAsync`, you could examine the state of the token and cancel further work if requested.</span></span>

<span data-ttu-id="2adef-189">Se puede usar otro método de extensión, <xref:System.Threading.Tasks.TaskAsyncEnumerableExtensions.WithCancellation%2A>, para pasar el token de cancelación a la secuencia asincrónica.</span><span class="sxs-lookup"><span data-stu-id="2adef-189">You use another extension method, <xref:System.Threading.Tasks.TaskAsyncEnumerableExtensions.WithCancellation%2A>, to pass the cancellation token to the async stream.</span></span> <span data-ttu-id="2adef-190">Modifique el bucle que enumera los problemas de la siguiente manera:</span><span class="sxs-lookup"><span data-stu-id="2adef-190">You would modify the loop enumerating the issues as follows:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/finished/Program.cs" id="SnippetEnumerateWithCancellation" :::

<span data-ttu-id="2adef-191">Puede obtener el código para el tutorial finalizado en el repositorio [dotnet/docs](https://github.com/dotnet/docs) de la carpeta [csharp/tutoriales/AsyncStreams](https://github.com/dotnet/docs/tree/master/docs/csharp/tutorials/snippets/generate-consume-asynchronous-streams/finished).</span><span class="sxs-lookup"><span data-stu-id="2adef-191">You can get the code for the finished tutorial from the [dotnet/docs](https://github.com/dotnet/docs) repository in the [csharp/tutorials/AsyncStreams](https://github.com/dotnet/docs/tree/master/docs/csharp/tutorials/snippets/generate-consume-asynchronous-streams/finished) folder.</span></span>

## <a name="run-the-finished-application"></a><span data-ttu-id="2adef-192">Ejecución de la aplicación finalizada</span><span class="sxs-lookup"><span data-stu-id="2adef-192">Run the finished application</span></span>

<span data-ttu-id="2adef-193">Vuelva a ejecutar la aplicación.</span><span class="sxs-lookup"><span data-stu-id="2adef-193">Run the application again.</span></span> <span data-ttu-id="2adef-194">Compare su comportamiento con el comportamiento de la aplicación de inicio.</span><span class="sxs-lookup"><span data-stu-id="2adef-194">Contrast its behavior with the behavior of the starter application.</span></span> <span data-ttu-id="2adef-195">La primera página de resultados se enumera en cuanto está disponible.</span><span class="sxs-lookup"><span data-stu-id="2adef-195">The first page of results is enumerated as soon as it's available.</span></span> <span data-ttu-id="2adef-196">Hay una pausa marcada cada vez que se solicita y se recupera una página nueva; a continuación, se enumeran rápidamente los resultados de la página siguiente.</span><span class="sxs-lookup"><span data-stu-id="2adef-196">There's an observable pause as each new page is requested and retrieved, then the next page's results are quickly enumerated.</span></span> <span data-ttu-id="2adef-197">El bloque `try` / `catch` no es necesario para controlar la cancelación: el autor de la llamada puede detener la enumeración de la colección.</span><span class="sxs-lookup"><span data-stu-id="2adef-197">The `try` / `catch` block isn't needed to handle cancellation: the caller can stop enumerating the collection.</span></span> <span data-ttu-id="2adef-198">El progreso se notifica claramente porque la secuencia asincrónica genera resultados a medida que se descarga cada página.</span><span class="sxs-lookup"><span data-stu-id="2adef-198">Progress is clearly reported because the async stream generates results as each page is downloaded.</span></span> <span data-ttu-id="2adef-199">El estado de cada problema devuelto se incluye sin problemas en el bucle `await foreach`.</span><span class="sxs-lookup"><span data-stu-id="2adef-199">The status for each issue returned is seamlessly included in the `await foreach` loop.</span></span> <span data-ttu-id="2adef-200">No necesita un objeto de devolución de llamada para hacer un seguimiento del progreso.</span><span class="sxs-lookup"><span data-stu-id="2adef-200">You don't need a callback object to track progress.</span></span>

<span data-ttu-id="2adef-201">Puede ver mejoras en el uso de la memoria examinando el código.</span><span class="sxs-lookup"><span data-stu-id="2adef-201">You can see improvements in memory use by examining the code.</span></span> <span data-ttu-id="2adef-202">Ya no tiene que asignar una colección para almacenar todos los resultados antes de que se enumeren.</span><span class="sxs-lookup"><span data-stu-id="2adef-202">You no longer need to allocate a collection to store all the results before they're enumerated.</span></span> <span data-ttu-id="2adef-203">El autor de la llamada puede determinar cómo consumir los resultados y si se necesita una colección de almacenamiento.</span><span class="sxs-lookup"><span data-stu-id="2adef-203">The caller can determine how to consume the results and if a storage collection is needed.</span></span>

<span data-ttu-id="2adef-204">Ejecute las aplicaciones de inicio y finalizada y podrá ver las diferencias entre las implementaciones personalmente.</span><span class="sxs-lookup"><span data-stu-id="2adef-204">Run both the starter and finished applications and you can observe the differences between the implementations for yourself.</span></span> <span data-ttu-id="2adef-205">Puede eliminar el token de acceso de GitHub que creó cuando inició este tutorial cuando haya terminado.</span><span class="sxs-lookup"><span data-stu-id="2adef-205">You can delete the GitHub access token you created when you started this tutorial after you've finished.</span></span> <span data-ttu-id="2adef-206">Si un atacante obtuviera acceso a dicho token, podría tener acceso a sus API de GitHub con sus credenciales.</span><span class="sxs-lookup"><span data-stu-id="2adef-206">If an attacker gained access to that token, they could access GitHub APIs using your credentials.</span></span>
