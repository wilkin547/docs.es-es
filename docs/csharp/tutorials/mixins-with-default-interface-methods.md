---
title: Creación de tipos mixin mediante métodos de interfaz predeterminados
description: Con el uso de los miembros de interfaz predeterminados, puede extender las interfaces con implementaciones predeterminadas opcionales para los implementadores.
ms.technology: csharp-advanced-concepts
ms.date: 10/04/2019
ms.openlocfilehash: fb876731f1cf16840b583ea23b1dd09d8ff74bfe
ms.sourcegitcommit: 42d436ebc2a7ee02fc1848c7742bc7d80e13fc2f
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 03/04/2021
ms.locfileid: "102103717"
---
# <a name="tutorial-mix-functionality-in-when-creating-classes-using-interfaces-with-default-interface-methods"></a><span data-ttu-id="8faaf-103">Tutorial: Funcionalidad de combinación al crear clases mediante interfaces con métodos de interfaz predeterminados</span><span class="sxs-lookup"><span data-stu-id="8faaf-103">Tutorial: Mix functionality in when creating classes using interfaces with default interface methods</span></span>

<span data-ttu-id="8faaf-104">A partir de C# 8.0 en .NET Core 3.0, puede definir una implementación cuando declare un miembro de una interfaz.</span><span class="sxs-lookup"><span data-stu-id="8faaf-104">Beginning with C# 8.0 on .NET Core 3.0, you can define an implementation when you declare a member of an interface.</span></span> <span data-ttu-id="8faaf-105">Esta característica proporciona nuevas funcionalidades en las que puede definir implementaciones predeterminadas para las características declaradas en las interfaces.</span><span class="sxs-lookup"><span data-stu-id="8faaf-105">This feature provides new capabilities where you can define default implementations for features declared in interfaces.</span></span> <span data-ttu-id="8faaf-106">Las clases pueden elegir cuándo invalidar la funcionalidad, cuándo usar la funcionalidad predeterminada y cuándo no se debe declarar la compatibilidad con características discretas.</span><span class="sxs-lookup"><span data-stu-id="8faaf-106">Classes can pick when to override functionality, when to use the default functionality, and when not to declare support for discrete features.</span></span>

<span data-ttu-id="8faaf-107">En este tutorial aprenderá lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="8faaf-107">In this tutorial, you'll learn how to:</span></span>

> [!div class="checklist"]
>
> * <span data-ttu-id="8faaf-108">Creación de interfaces con implementaciones que describen características discretas.</span><span class="sxs-lookup"><span data-stu-id="8faaf-108">Create interfaces with implementations that describe discrete features.</span></span>
> * <span data-ttu-id="8faaf-109">Creación de clases que usan las implementaciones predeterminadas.</span><span class="sxs-lookup"><span data-stu-id="8faaf-109">Create classes that use the default implementations.</span></span>
> * <span data-ttu-id="8faaf-110">Creación de clases que invaliden algunas o todas las implementaciones predeterminadas.</span><span class="sxs-lookup"><span data-stu-id="8faaf-110">Create classes that override some or all of the default implementations.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="8faaf-111">Requisitos previos</span><span class="sxs-lookup"><span data-stu-id="8faaf-111">Prerequisites</span></span>

<span data-ttu-id="8faaf-112">Deberá configurar la máquina para ejecutar .NET Core, incluido el compilador de C# 8.0.</span><span class="sxs-lookup"><span data-stu-id="8faaf-112">You’ll need to set up your machine to run .NET Core, including the C# 8.0 compiler.</span></span> <span data-ttu-id="8faaf-113">El compilador de C# 8.0 está disponible a partir de la [versión 16.3 de Visual Studio 2019](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019) o del [SDK de .NET Core 3.0](https://dotnet.microsoft.com/download/dotnet) o versiones posteriores.</span><span class="sxs-lookup"><span data-stu-id="8faaf-113">The C# 8.0 compiler is available starting with [Visual Studio 2019 version 16.3](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019), or the [.NET Core 3.0 SDK](https://dotnet.microsoft.com/download/dotnet) or later.</span></span>

## <a name="limitations-of-extension-methods"></a><span data-ttu-id="8faaf-114">Limitaciones de los métodos de extensión</span><span class="sxs-lookup"><span data-stu-id="8faaf-114">Limitations of extension methods</span></span>

<span data-ttu-id="8faaf-115">Una manera de implementar el comportamiento que aparece como parte de una interfaz es definir [métodos de extensión](../programming-guide/classes-and-structs/extension-methods.md) que proporcionan el comportamiento predeterminado.</span><span class="sxs-lookup"><span data-stu-id="8faaf-115">One way you can implement behavior that appears as part of an interface is to define [extension methods](../programming-guide/classes-and-structs/extension-methods.md) that provide the default behavior.</span></span> <span data-ttu-id="8faaf-116">Las interfaces declaran un conjunto mínimo de miembros mientras proporcionan un área expuesta más grande para cualquier clase que implemente esa interfaz.</span><span class="sxs-lookup"><span data-stu-id="8faaf-116">Interfaces declare a minimum set of members while providing a greater surface area for any class that implements that interface.</span></span> <span data-ttu-id="8faaf-117">Por ejemplo, los métodos de extensión de <xref:System.Linq.Enumerable> proporcionan la implementación para que cualquier secuencia sea el origen de una consulta LINQ.</span><span class="sxs-lookup"><span data-stu-id="8faaf-117">For example, the extension methods in <xref:System.Linq.Enumerable> provide the implementation for any sequence to be the source of a LINQ query.</span></span>

<span data-ttu-id="8faaf-118">Los métodos de extensión se resuelven en tiempo de compilación, mediante el tipo declarado de la variable.</span><span class="sxs-lookup"><span data-stu-id="8faaf-118">Extension methods are resolved at compile time, using the declared type of the variable.</span></span> <span data-ttu-id="8faaf-119">Las clases que implementan la interfaz pueden proporcionar una mejor implementación para cualquier método de extensión.</span><span class="sxs-lookup"><span data-stu-id="8faaf-119">Classes that implement the interface can provide a better implementation for any extension method.</span></span> <span data-ttu-id="8faaf-120">Las declaraciones de variables deben coincidir con el tipo de implementación para que el compilador pueda elegir esa implementación.</span><span class="sxs-lookup"><span data-stu-id="8faaf-120">Variable declarations must match the implementing type to enable the compiler to choose that implementation.</span></span> <span data-ttu-id="8faaf-121">Cuando el tipo en tiempo de compilación coincide con la interfaz, las llamadas al método se resuelven en el método de extensión.</span><span class="sxs-lookup"><span data-stu-id="8faaf-121">When the compile-time type matches the interface, method calls resolve to the extension method.</span></span> <span data-ttu-id="8faaf-122">Otro problema con los métodos de extensión es que se puede tener acceso a esos métodos siempre que se pueda tener acceso a la clase que contiene los métodos de extensión.</span><span class="sxs-lookup"><span data-stu-id="8faaf-122">Another concern with extension methods is that those methods are accessible wherever the class containing the extension methods is accessible.</span></span> <span data-ttu-id="8faaf-123">Las clases no pueden declarar si deben o no deben proporcionar características declaradas en los métodos de extensión.</span><span class="sxs-lookup"><span data-stu-id="8faaf-123">Classes cannot declare if they should or should not provide features declared in extension methods.</span></span>

<span data-ttu-id="8faaf-124">A partir de C# 8.0, puede declarar las implementaciones predeterminadas como métodos de interfaz.</span><span class="sxs-lookup"><span data-stu-id="8faaf-124">Starting with C# 8.0, you can declare the default implementations as interface methods.</span></span> <span data-ttu-id="8faaf-125">Después, cada clase usa automáticamente la implementación predeterminada.</span><span class="sxs-lookup"><span data-stu-id="8faaf-125">Then, every class automatically uses the default implementation.</span></span> <span data-ttu-id="8faaf-126">Cualquier clase que pueda proporcionar una mejor implementación puede invalidar la definición del método de interfaz con un algoritmo mejor.</span><span class="sxs-lookup"><span data-stu-id="8faaf-126">Any class that can provide a better implementation can override the interface method definition with a better algorithm.</span></span> <span data-ttu-id="8faaf-127">En un sentido, esta técnica suena de forma similar a como se podían usar los [métodos de extensión](../programming-guide/classes-and-structs/extension-methods.md).</span><span class="sxs-lookup"><span data-stu-id="8faaf-127">In one sense, this technique sounds similar to how you could use [extension methods](../programming-guide/classes-and-structs/extension-methods.md).</span></span>

<span data-ttu-id="8faaf-128">En este artículo, aprenderá cómo las implementaciones de interfaces predeterminadas habilitan nuevos escenarios.</span><span class="sxs-lookup"><span data-stu-id="8faaf-128">In this article, you'll learn how default interface implementations enable new scenarios.</span></span>

## <a name="design-the-application"></a><span data-ttu-id="8faaf-129">Diseño de la aplicación</span><span class="sxs-lookup"><span data-stu-id="8faaf-129">Design the application</span></span>

<span data-ttu-id="8faaf-130">Considere una aplicación de automatización de dispositivos del hogar.</span><span class="sxs-lookup"><span data-stu-id="8faaf-130">Consider a home automation application.</span></span> <span data-ttu-id="8faaf-131">Probablemente tenga muchos tipos diferentes de luces e indicadores que podrían usarse en toda la casa.</span><span class="sxs-lookup"><span data-stu-id="8faaf-131">You probably have many different types of lights and indicators that could be used throughout the house.</span></span> <span data-ttu-id="8faaf-132">Cada luz debe admitir las API para encenderla y apagarla, y para notificar el estado actual.</span><span class="sxs-lookup"><span data-stu-id="8faaf-132">Every light must support APIs to turn them on and off, and to report the current state.</span></span> <span data-ttu-id="8faaf-133">Algunas luces e indicadores pueden admitir otras características, como:</span><span class="sxs-lookup"><span data-stu-id="8faaf-133">Some lights and indicators may support other features, such as:</span></span>

- <span data-ttu-id="8faaf-134">Encender la luz y apagarla después de un tiempo.</span><span class="sxs-lookup"><span data-stu-id="8faaf-134">Turn light on, then turn it off after a timer.</span></span>
- <span data-ttu-id="8faaf-135">Hacer parpadear la luz durante un período.</span><span class="sxs-lookup"><span data-stu-id="8faaf-135">Blink the light for a period of time.</span></span>

<span data-ttu-id="8faaf-136">Algunas de estas funcionalidades extendidas se pueden emular en los dispositivos que admiten el conjunto mínimo.</span><span class="sxs-lookup"><span data-stu-id="8faaf-136">Some of these extended capabilities could be emulated in devices that support the minimal set.</span></span> <span data-ttu-id="8faaf-137">Lo que indica que se proporciona una implementación predeterminada.</span><span class="sxs-lookup"><span data-stu-id="8faaf-137">That indicates providing a default implementation.</span></span> <span data-ttu-id="8faaf-138">En el caso de los dispositivos que tienen más funcionalidades integradas, el software del dispositivo usaría las funcionalidades nativas.</span><span class="sxs-lookup"><span data-stu-id="8faaf-138">For those devices that have more capabilities built in, the device software would use the native capabilities.</span></span> <span data-ttu-id="8faaf-139">Para otras luces, podrían optar por implementar la interfaz y usar la implementación predeterminada.</span><span class="sxs-lookup"><span data-stu-id="8faaf-139">For other lights, they could choose to implement the interface and use the default implementation.</span></span>

<span data-ttu-id="8faaf-140">Los miembros de interfaz predeterminados son una solución mejor para este escenario que los métodos de extensión.</span><span class="sxs-lookup"><span data-stu-id="8faaf-140">Default interface members is a better solution for this scenario than extension methods.</span></span> <span data-ttu-id="8faaf-141">Los autores de clases pueden controlar qué interfaces deciden implementar.</span><span class="sxs-lookup"><span data-stu-id="8faaf-141">Class authors can control which interfaces they choose to implement.</span></span> <span data-ttu-id="8faaf-142">Las interfaces que elijan están disponibles como métodos.</span><span class="sxs-lookup"><span data-stu-id="8faaf-142">Those interfaces they choose are available as methods.</span></span> <span data-ttu-id="8faaf-143">Además, dado que los métodos de interfaz predeterminados son virtuales de forma predeterminada, el envío del método siempre elige la implementación en la clase.</span><span class="sxs-lookup"><span data-stu-id="8faaf-143">In addition, because default interface methods are virtual by default, the method dispatch always chooses the implementation in the class.</span></span>

<span data-ttu-id="8faaf-144">Vamos a crear el código para mostrar estas diferencias.</span><span class="sxs-lookup"><span data-stu-id="8faaf-144">Let's create the code to demonstrate these differences.</span></span>

## <a name="create-interfaces"></a><span data-ttu-id="8faaf-145">Creación de interfaces</span><span class="sxs-lookup"><span data-stu-id="8faaf-145">Create interfaces</span></span>

<span data-ttu-id="8faaf-146">Empiece por crear la interfaz que define el comportamiento de todas las luces:</span><span class="sxs-lookup"><span data-stu-id="8faaf-146">Start by creating the interface that defines the behavior for all lights:</span></span>

[!code-csharp[Declare base interface](./snippets/mixins-with-default-interface-methods/UnusedExampleCode.cs?name=SnippetILightInterfaceV1)]

<span data-ttu-id="8faaf-147">Un accesorio básico de luces de techo puede implementar esta interfaz, tal como se muestra en el código siguiente:</span><span class="sxs-lookup"><span data-stu-id="8faaf-147">A basic overhead light fixture might implement this interface as shown in the following code:</span></span>

[!code-csharp[First overhead light](./snippets/mixins-with-default-interface-methods/UnusedExampleCode.cs?name=SnippetOverheadLightV1)]

<span data-ttu-id="8faaf-148">En este tutorial, el código no dispone de dispositivos IoT, pero emula esas actividades escribiendo mensajes en la consola.</span><span class="sxs-lookup"><span data-stu-id="8faaf-148">In this tutorial, the code doesn't drive IoT devices, but emulates those activities by writing messages to the console.</span></span> <span data-ttu-id="8faaf-149">Puede explorar el código sin automatizar los dispositivos de hogar.</span><span class="sxs-lookup"><span data-stu-id="8faaf-149">You can explore the code without automating your house.</span></span>

<span data-ttu-id="8faaf-150">A continuación, vamos a definir la interfaz para una luz que se pueda apagar automáticamente después de un tiempo de espera:</span><span class="sxs-lookup"><span data-stu-id="8faaf-150">Next, let's define the interface for a light that can automatically turn off after a timeout:</span></span>

[!code-csharp[pure Timer interface](./snippets/mixins-with-default-interface-methods/UnusedExampleCode.cs?name=SnippetPureTimerInterface)]

<span data-ttu-id="8faaf-151">Podría agregar una implementación básica a la luz de techo, pero una solución mejor es modificar esta definición de interfaz para proporcionar una implementación predeterminada `virtual`:</span><span class="sxs-lookup"><span data-stu-id="8faaf-151">You could add a basic implementation to the overhead light, but a better solution is to modify this interface definition to provide a `virtual` default implementation:</span></span>

[!code-csharp[Timer interface](./snippets/mixins-with-default-interface-methods/ITimerLight.cs?name=SnippetTimerLightFinal)]

<span data-ttu-id="8faaf-152">Al agregar ese cambio, la clase `OverheadLight` puede implementar la función de temporizador mediante la declaración de la compatibilidad con la interfaz:</span><span class="sxs-lookup"><span data-stu-id="8faaf-152">By adding that change, the `OverheadLight` class can implement the timer function by declaring support for the interface:</span></span>

```csharp
public class OverheadLight : ITimerLight { }
```

<span data-ttu-id="8faaf-153">Un tipo de luz diferente puede admitir un protocolo más sofisticado.</span><span class="sxs-lookup"><span data-stu-id="8faaf-153">A different light type may support a more sophisticated protocol.</span></span> <span data-ttu-id="8faaf-154">Puede proporcionar su propia implementación de `TurnOnFor`, como se muestra en el código siguiente:</span><span class="sxs-lookup"><span data-stu-id="8faaf-154">It can provide its own implementation for `TurnOnFor`, as shown in the following code:</span></span>

[!code-csharp[Override the timer function](./snippets/mixins-with-default-interface-methods/HalogenLight.cs?name=SnippetHalogenLight)]

<span data-ttu-id="8faaf-155">A diferencia de los métodos de clase virtual de invalidación, la declaración de `TurnOnFor` en la clase `HalogenLight` no utiliza la palabra clave `override`.</span><span class="sxs-lookup"><span data-stu-id="8faaf-155">Unlike overriding virtual class methods, the declaration of `TurnOnFor` in the `HalogenLight` class does not use the `override` keyword.</span></span>

## <a name="mix-and-match-capabilities"></a><span data-ttu-id="8faaf-156">Funcionalidades de combinación</span><span class="sxs-lookup"><span data-stu-id="8faaf-156">Mix and match capabilities</span></span>

<span data-ttu-id="8faaf-157">Las ventajas de los métodos de interfaz predeterminados resultan más claras a medida que se introducen funcionalidades más avanzadas.</span><span class="sxs-lookup"><span data-stu-id="8faaf-157">The advantages of default interface methods become clearer as you introduce more advanced capabilities.</span></span> <span data-ttu-id="8faaf-158">El uso de interfaces permite combinar las funcionalidades.</span><span class="sxs-lookup"><span data-stu-id="8faaf-158">Using interfaces enables you to mix and match capabilities.</span></span> <span data-ttu-id="8faaf-159">También permite que cada autor de clase elija entre la implementación predeterminada y una implementación personalizada.</span><span class="sxs-lookup"><span data-stu-id="8faaf-159">It also enables each class author to choose between the default implementation and a custom implementation.</span></span> <span data-ttu-id="8faaf-160">Vamos a agregar una interfaz con una implementación predeterminada para una luz parpadeante:</span><span class="sxs-lookup"><span data-stu-id="8faaf-160">Let's add an interface with a default implementation for a blinking light:</span></span>

[!code-csharp[Define the blinking light interface](./snippets/mixins-with-default-interface-methods/IBlinkingLight.cs?name=SnippetBlinkingLight)]

<span data-ttu-id="8faaf-161">La implementación predeterminada permite que cualquier luz parpadee.</span><span class="sxs-lookup"><span data-stu-id="8faaf-161">The default implementation enables any light to blink.</span></span> <span data-ttu-id="8faaf-162">La luz de techo puede agregar las funcionalidades de temporizador y de parpadeo mediante la implementación predeterminada:</span><span class="sxs-lookup"><span data-stu-id="8faaf-162">The overhead light can add both timer and blink capabilities using the default implementation:</span></span>

[!code-csharp[Use the default blink function](./snippets/mixins-with-default-interface-methods/OverheadLight.cs?name=SnippetOverheadLight)]

<span data-ttu-id="8faaf-163">Un nuevo tipo de luz, la clase `LEDLight`, admite la función de temporizador y la función de parpadeo directamente.</span><span class="sxs-lookup"><span data-stu-id="8faaf-163">A new light type, the `LEDLight` supports both the timer function and the blink function directly.</span></span> <span data-ttu-id="8faaf-164">Este estilo de luz implementa las interfaces `ITimerLight` y `IBlinkingLight`, e invalida el método `Blink`:</span><span class="sxs-lookup"><span data-stu-id="8faaf-164">This light style implements both the `ITimerLight` and `IBlinkingLight` interfaces, and overrides the `Blink` method:</span></span>

[!code-csharp[Override the blink function](./snippets/mixins-with-default-interface-methods/LEDLight.cs?name=SnippetLEDLight)]

<span data-ttu-id="8faaf-165">La clase `ExtraFancyLight` podría admitir funciones de parpadeo y de temporizador directamente:</span><span class="sxs-lookup"><span data-stu-id="8faaf-165">An `ExtraFancyLight` might support both blink and timer functions directly:</span></span>

[!code-csharp[Override the blink and timer function](./snippets/mixins-with-default-interface-methods/ExtraFancyLight.cs?name=SnippetExtraFancyLight)]

<span data-ttu-id="8faaf-166">La clase `HalogenLight` que ha creado anteriormente no admite el parpadeo.</span><span class="sxs-lookup"><span data-stu-id="8faaf-166">The `HalogenLight` you created earlier doesn't support blinking.</span></span> <span data-ttu-id="8faaf-167">Por lo tanto, no agregue la interfaz `IBlinkingLight` a la lista de interfaces compatibles.</span><span class="sxs-lookup"><span data-stu-id="8faaf-167">So, don't add the `IBlinkingLight` to the list of its supported interfaces.</span></span>

## <a name="detect-the-light-types-using-pattern-matching"></a><span data-ttu-id="8faaf-168">Detección de tipos de luz mediante la coincidencia de patrones</span><span class="sxs-lookup"><span data-stu-id="8faaf-168">Detect the light types using pattern matching</span></span>

<span data-ttu-id="8faaf-169">A continuación, vamos a escribir código de prueba.</span><span class="sxs-lookup"><span data-stu-id="8faaf-169">Next, let's write some test code.</span></span> <span data-ttu-id="8faaf-170">Puede usar la característica de C# de [coincidencia de patrones](../pattern-matching.md) para determinar las funcionalidades de una luz mediante el examen de las interfaces que admite.</span><span class="sxs-lookup"><span data-stu-id="8faaf-170">You can make use of C#'s [pattern matching](../pattern-matching.md) feature to determine a light's capabilities by examining which interfaces it supports.</span></span>  <span data-ttu-id="8faaf-171">El método siguiente ejercita las funcionalidades admitidas por cada luz:</span><span class="sxs-lookup"><span data-stu-id="8faaf-171">The following method exercises the supported capabilities of each light:</span></span>

[!code-csharp[Test a light's capabilities](./snippets/mixins-with-default-interface-methods/Program.cs?name=SnippetTestLightFunctions)]

<span data-ttu-id="8faaf-172">El código siguiente en el método `Main` crea cada tipo de luz secuencialmente y lo prueba:</span><span class="sxs-lookup"><span data-stu-id="8faaf-172">The following code in your `Main` method creates each light type in sequence and tests that light:</span></span>

[!code-csharp[Test a light's capabilities](./snippets/mixins-with-default-interface-methods/Program.cs?name=SnippetMainMethod)]

## <a name="how-the-compiler-determines-best-implementation"></a><span data-ttu-id="8faaf-173">Cómo determina el compilador la mejor implementación</span><span class="sxs-lookup"><span data-stu-id="8faaf-173">How the compiler determines best implementation</span></span>

<span data-ttu-id="8faaf-174">En este escenario se muestra una interfaz base sin ninguna implementación.</span><span class="sxs-lookup"><span data-stu-id="8faaf-174">This scenario shows a base interface without any implementations.</span></span> <span data-ttu-id="8faaf-175">Agregar un método a la interfaz `ILight` presenta nuevas complejidades.</span><span class="sxs-lookup"><span data-stu-id="8faaf-175">Adding a method into the `ILight` interface introduces new complexities.</span></span> <span data-ttu-id="8faaf-176">Las reglas del lenguaje que rigen los métodos de interfaz predeterminados minimizan el efecto en las clases concretas que implementan varias interfaces derivadas.</span><span class="sxs-lookup"><span data-stu-id="8faaf-176">The language rules governing default interface methods minimize the effect on the concrete classes that implement multiple derived interfaces.</span></span> <span data-ttu-id="8faaf-177">Vamos a mejorar la interfaz original con un nuevo método para mostrar cómo cambia su uso.</span><span class="sxs-lookup"><span data-stu-id="8faaf-177">Let's enhance the original interface with a new method to show how that changes its use.</span></span> <span data-ttu-id="8faaf-178">Cada luz del indicador puede informar de su estado de energía como un valor enumerado:</span><span class="sxs-lookup"><span data-stu-id="8faaf-178">Every indicator light can report its power status as an enumerated value:</span></span>

[!code-csharp[Enumeration for power status](./snippets/mixins-with-default-interface-methods/ILight.cs?name=SnippetPowerStatus)]

<span data-ttu-id="8faaf-179">La implementación predeterminada presupone la ausencia de alimentación:</span><span class="sxs-lookup"><span data-stu-id="8faaf-179">The default implementation assumes no power:</span></span>

[!code-csharp[Report a default power status](./snippets/mixins-with-default-interface-methods/ILight.cs?name=SnippetILightInterface)]

<span data-ttu-id="8faaf-180">Estos cambios se compilan correctamente, aunque la clase `ExtraFancyLight` declara la compatibilidad con la interfaz de `ILight` y las interfaces derivadas `ITimerLight` y `IBlinkingLight`.</span><span class="sxs-lookup"><span data-stu-id="8faaf-180">These changes compile cleanly, even though the `ExtraFancyLight` declares support for the `ILight` interface and both derived interfaces, `ITimerLight` and `IBlinkingLight`.</span></span> <span data-ttu-id="8faaf-181">Solo hay una implementación "más cercana" declarada en la interfaz `ILight`.</span><span class="sxs-lookup"><span data-stu-id="8faaf-181">There's only one "closest" implementation declared in the `ILight` interface.</span></span> <span data-ttu-id="8faaf-182">Cualquier clase que declare una invalidación se convertirá en la implementación "más cercana".</span><span class="sxs-lookup"><span data-stu-id="8faaf-182">Any class that declared an override would become the one "closest" implementation.</span></span> <span data-ttu-id="8faaf-183">Ha visto ejemplos en las clases anteriores que reemplazaron los miembros de otras interfaces derivadas.</span><span class="sxs-lookup"><span data-stu-id="8faaf-183">You saw examples in the preceding classes that overrode the members of other derived interfaces.</span></span>

<span data-ttu-id="8faaf-184">Evite reemplazar el mismo método en varias interfaces derivadas.</span><span class="sxs-lookup"><span data-stu-id="8faaf-184">Avoid overriding the same method in multiple derived interfaces.</span></span> <span data-ttu-id="8faaf-185">Al hacerlo, se crea una llamada de método ambiguo siempre que una clase implementa ambas interfaces derivadas.</span><span class="sxs-lookup"><span data-stu-id="8faaf-185">Doing so creates an ambiguous method call whenever a class implements both derived interfaces.</span></span> <span data-ttu-id="8faaf-186">El compilador no puede elegir un solo método mejor para que emita un error.</span><span class="sxs-lookup"><span data-stu-id="8faaf-186">The compiler can't pick a single better method so it issues an error.</span></span> <span data-ttu-id="8faaf-187">Por ejemplo, si tanto `IBlinkingLight` como `ITimerLight` implementaron una invalidación de `PowerStatus`, `OverheadLight` tendría que proporcionar una invalidación más específica.</span><span class="sxs-lookup"><span data-stu-id="8faaf-187">For example, if both the `IBlinkingLight` and `ITimerLight` implemented an override of `PowerStatus`, the `OverheadLight` would need to provide a more specific override.</span></span> <span data-ttu-id="8faaf-188">De lo contrario, el compilador no puede elegir entre las implementaciones en las dos interfaces derivadas.</span><span class="sxs-lookup"><span data-stu-id="8faaf-188">Otherwise, the compiler can't pick between the implementations in the two derived interfaces.</span></span> <span data-ttu-id="8faaf-189">Normalmente, puede evitar esta situación al mantener las definiciones de interfaz pequeñas y centradas en una característica.</span><span class="sxs-lookup"><span data-stu-id="8faaf-189">You can usually avoid this situation by keeping interface definitions small and focused on one feature.</span></span> <span data-ttu-id="8faaf-190">En este escenario, cada funcionalidad de una luz es su propia interfaz; solo las clases heredan varias interfaces.</span><span class="sxs-lookup"><span data-stu-id="8faaf-190">In this scenario, each capability of a light is its own interface; multiple interfaces are only inherited by classes.</span></span>

<span data-ttu-id="8faaf-191">En este ejemplo se muestra un escenario en el que puede definir características discretas que se pueden combinar en clases.</span><span class="sxs-lookup"><span data-stu-id="8faaf-191">This sample shows one scenario where you can define discrete features that can be mixed into classes.</span></span> <span data-ttu-id="8faaf-192">Declare cualquier conjunto de funcionalidades admitidas declarando qué interfaces admite una clase.</span><span class="sxs-lookup"><span data-stu-id="8faaf-192">You declare any set of supported functionality by declaring which interfaces a class supports.</span></span> <span data-ttu-id="8faaf-193">El uso de métodos de interfaz predeterminados virtuales permite a las clases usar o definir una implementación diferente para cualquiera de los métodos de interfaz o para todos.</span><span class="sxs-lookup"><span data-stu-id="8faaf-193">The use of virtual default interface methods enables classes to use or define a different implementation for any or all the interface methods.</span></span> <span data-ttu-id="8faaf-194">Esta funcionalidad del lenguaje proporciona nuevas formas de modelar los sistemas reales que se están compilando.</span><span class="sxs-lookup"><span data-stu-id="8faaf-194">This language capability provides new ways to model the real-world systems you're building.</span></span> <span data-ttu-id="8faaf-195">Los métodos de interfaz predeterminados proporcionan una forma más clara de expresar clases relacionadas que pueden combinar con diferentes características mediante implementaciones virtuales de esas funcionalidades.</span><span class="sxs-lookup"><span data-stu-id="8faaf-195">Default interface methods provide a clearer way to express related classes that may mix and match different features using virtual implementations of those capabilities.</span></span>
