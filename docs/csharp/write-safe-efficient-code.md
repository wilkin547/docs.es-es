---
title: Escritura de código C# seguro y eficaz
description: Las mejoras aplicadas recientemente al lenguaje C# permiten escribir código seguro verificable que anteriormente se hubiera asociado a código no seguro.
ms.date: 10/23/2018
ms.technology: csharp-advanced-concepts
ms.custom: mvc
ms.openlocfilehash: 365320fef5a2f9cd123086c1baed9a786ede9f05
ms.sourcegitcommit: 59e36e65ac81cdd094a5a84617625b2a0ff3506e
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 03/27/2020
ms.locfileid: "80345080"
---
# <a name="write-safe-and-efficient-c-code"></a><span data-ttu-id="7866d-103">Escritura de código C# seguro y eficaz</span><span class="sxs-lookup"><span data-stu-id="7866d-103">Write safe and efficient C# code</span></span>

<span data-ttu-id="7866d-104">Las nuevas características de C# permiten escribir código seguro verificable con un mejor rendimiento.</span><span class="sxs-lookup"><span data-stu-id="7866d-104">New features in C# enable you to write verifiable safe code with better performance.</span></span> <span data-ttu-id="7866d-105">Si aplica estas técnicas cuidadosamente, habrá menos escenarios que requieran código no seguro.</span><span class="sxs-lookup"><span data-stu-id="7866d-105">If you carefully apply these techniques, fewer scenarios require unsafe code.</span></span> <span data-ttu-id="7866d-106">Estas características permiten usar con más facilidad las referencias a tipos de valor como argumentos de método y devoluciones de método.</span><span class="sxs-lookup"><span data-stu-id="7866d-106">These features make it easier to use references to value types as method arguments and method returns.</span></span> <span data-ttu-id="7866d-107">Si aplica estas técnicas de forma segura, minimizará la copia de tipos de valor.</span><span class="sxs-lookup"><span data-stu-id="7866d-107">When done safely, these techniques minimize copying value types.</span></span> <span data-ttu-id="7866d-108">Al usar tipos de valor, también podrá minimizar el número de asignaciones y transferencias de recolección de elementos no utilizados.</span><span class="sxs-lookup"><span data-stu-id="7866d-108">By using value types, you can minimize the number of allocations and garbage collection passes.</span></span>

<span data-ttu-id="7866d-109">En gran parte del código de ejemplo de este artículo se utilizan las características agregadas a la versión 7.2 de C#.</span><span class="sxs-lookup"><span data-stu-id="7866d-109">Much of the sample code in this article uses features added in C# 7.2.</span></span> <span data-ttu-id="7866d-110">Para poder usar esas características, tiene que configurar el proyecto para que use la versión 7.2 de C# o una posterior.</span><span class="sxs-lookup"><span data-stu-id="7866d-110">To use those features, you must configure your project to use C# 7.2 or later.</span></span> <span data-ttu-id="7866d-111">Para obtener más información sobre cómo establecer la versión del lenguaje, vea cómo [configurar la versión del lenguaje](language-reference/configure-language-version.md).</span><span class="sxs-lookup"><span data-stu-id="7866d-111">For more information on setting the language version, see [configure the language version](language-reference/configure-language-version.md).</span></span>

<span data-ttu-id="7866d-112">Este artículo se centra en las técnicas que se deben aplicar para administrar recursos de forma eficaz.</span><span class="sxs-lookup"><span data-stu-id="7866d-112">This article focuses on techniques for efficient resource management.</span></span> <span data-ttu-id="7866d-113">Una de las ventajas de utilizar tipos de valor es que a menudo evitan las asignaciones de montón.</span><span class="sxs-lookup"><span data-stu-id="7866d-113">One advantage to using value types is that they often avoid heap allocations.</span></span> <span data-ttu-id="7866d-114">Pero también hay una desventaja, que es que se copian por valor.</span><span class="sxs-lookup"><span data-stu-id="7866d-114">The disadvantage is that they're copied by value.</span></span> <span data-ttu-id="7866d-115">Este último aspecto dificulta la optimización de los algoritmos que funcionan en grandes cantidades de datos.</span><span class="sxs-lookup"><span data-stu-id="7866d-115">This trade-off makes it harder to optimize algorithms that operate on large amounts of data.</span></span> <span data-ttu-id="7866d-116">Las nuevas características del lenguaje en C# 7.2 proporcionan mecanismos que permiten escribir código seguro y eficaz mediante referencias a tipos de valor.</span><span class="sxs-lookup"><span data-stu-id="7866d-116">New language features in C# 7.2 provide mechanisms that enable safe efficient code using references to value types.</span></span> <span data-ttu-id="7866d-117">Use estas características acertadamente para minimizar tanto las asignaciones como las operaciones de copia.</span><span class="sxs-lookup"><span data-stu-id="7866d-117">Use these features wisely to minimize both allocations and copy operations.</span></span> <span data-ttu-id="7866d-118">En este artículo se exploran estas nuevas características.</span><span class="sxs-lookup"><span data-stu-id="7866d-118">This article explores those new features.</span></span>

<span data-ttu-id="7866d-119">Este artículo se centra en estas técnicas de administración de recursos:</span><span class="sxs-lookup"><span data-stu-id="7866d-119">This article focuses on the following resource management techniques:</span></span>

- <span data-ttu-id="7866d-120">Declare un parámetro [`readonly struct`](language-reference/builtin-types/struct.md#readonly-struct) para expresar que un tipo es **inmutable**.</span><span class="sxs-lookup"><span data-stu-id="7866d-120">Declare a [`readonly struct`](language-reference/builtin-types/struct.md#readonly-struct) to express that a type is **immutable**.</span></span> <span data-ttu-id="7866d-121">Esto permite al compilador guardar copias defensivas cuando se usan parámetros [`in`](language-reference/keywords/in-parameter-modifier.md).</span><span class="sxs-lookup"><span data-stu-id="7866d-121">That enables the compiler to save defensive copies when using [`in`](language-reference/keywords/in-parameter-modifier.md) parameters.</span></span>
- <span data-ttu-id="7866d-122">Si un tipo no puede ser inmutable, declare miembros `readonly` de `struct` para indicar que el miembro no modifica el estado.</span><span class="sxs-lookup"><span data-stu-id="7866d-122">If a type can't be immutable, declare `struct` members `readonly` to indicate that the member doesn't modify state.</span></span>
- <span data-ttu-id="7866d-123">Utilice una devolución [`ref readonly`](language-reference/keywords/ref.md#reference-return-values) si el valor devuelto es un valor `struct` mayor que <xref:System.IntPtr.Size?displayProperty=nameWithType> y la duración del almacenamiento es superior al método que devuelve el valor.</span><span class="sxs-lookup"><span data-stu-id="7866d-123">Use a [`ref readonly`](language-reference/keywords/ref.md#reference-return-values) return when the return value is a `struct` larger than <xref:System.IntPtr.Size?displayProperty=nameWithType> and the storage lifetime is greater than the method returning the value.</span></span>
- <span data-ttu-id="7866d-124">Si el tamaño de un valor `readonly struct` es mayor que <xref:System.IntPtr.Size?displayProperty=nameWithType>, deberá pasarlo como parámetro `in` por motivos de rendimiento.</span><span class="sxs-lookup"><span data-stu-id="7866d-124">When the size of a `readonly struct` is bigger than <xref:System.IntPtr.Size?displayProperty=nameWithType>, you should pass it as an `in` parameter for performance reasons.</span></span>
- <span data-ttu-id="7866d-125">No pase nunca un elemento `struct` como parámetro `in` a menos que se declare con el modificador `readonly` o que el método solo llame a los miembros de `readonly` de la estructura.</span><span class="sxs-lookup"><span data-stu-id="7866d-125">Never pass a `struct` as an `in` parameter unless it's declared with the `readonly` modifier or the method calls only `readonly` members of the struct.</span></span> <span data-ttu-id="7866d-126">Infringir esta guía puede afectar negativamente al rendimiento y podría provocar un comportamiento oculto.</span><span class="sxs-lookup"><span data-stu-id="7866d-126">Violating this guidance may negatively affect performance and could lead to an obscure behavior.</span></span>
- <span data-ttu-id="7866d-127">Use un valor [`ref struct`](language-reference/keywords/ref.md#ref-struct-types), o bien un valor `readonly ref struct` como <xref:System.Span%601> o <xref:System.ReadOnlySpan%601>, para que funcione con la memoria como secuencia de bytes.</span><span class="sxs-lookup"><span data-stu-id="7866d-127">Use a [`ref struct`](language-reference/keywords/ref.md#ref-struct-types), or a `readonly ref struct` such as <xref:System.Span%601> or <xref:System.ReadOnlySpan%601> to work with memory as a sequence of bytes.</span></span>

<span data-ttu-id="7866d-128">Estas técnicas obligan a equilibrar dos objetivos contrapuestos en relación con las **referencias** y los **valores**.</span><span class="sxs-lookup"><span data-stu-id="7866d-128">These techniques force you to balance two competing goals with regard to **references** and **values**.</span></span> <span data-ttu-id="7866d-129">Las variables que son [tipos de referencia](programming-guide/types/index.md#reference-types) contienen una referencia a la ubicación en la memoria.</span><span class="sxs-lookup"><span data-stu-id="7866d-129">Variables that are [reference types](programming-guide/types/index.md#reference-types) hold a reference to the location in memory.</span></span> <span data-ttu-id="7866d-130">Las variables que son [tipos de valor](programming-guide/types/index.md#value-types) contienen directamente su valor.</span><span class="sxs-lookup"><span data-stu-id="7866d-130">Variables that are [value types](programming-guide/types/index.md#value-types) directly contain their value.</span></span> <span data-ttu-id="7866d-131">Estas son diferencias clave importantes para administrar recursos de memoria.</span><span class="sxs-lookup"><span data-stu-id="7866d-131">These differences highlight the key differences that are important for managing memory resources.</span></span> <span data-ttu-id="7866d-132">Los **tipos de valor** suelen copiarse cuando se pasan a un método o se devuelven desde uno.</span><span class="sxs-lookup"><span data-stu-id="7866d-132">**Value types** are typically copied when passed to a method or returned from a method.</span></span> <span data-ttu-id="7866d-133">Este comportamiento incluye la copia del valor de `this` al llamar a los miembros de un tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="7866d-133">This behavior includes copying the value of `this` when calling members of a value type.</span></span> <span data-ttu-id="7866d-134">El costo de dicha copia está relacionado con el tamaño del tipo.</span><span class="sxs-lookup"><span data-stu-id="7866d-134">The cost of the copy is related to the size of the type.</span></span> <span data-ttu-id="7866d-135">Los **tipos de referencia** se asignan en el montón administrado.</span><span class="sxs-lookup"><span data-stu-id="7866d-135">**Reference types** are allocated on the managed heap.</span></span> <span data-ttu-id="7866d-136">Cada nuevo objeto requiere una nueva asignación, y se debe reclamar posteriormente.</span><span class="sxs-lookup"><span data-stu-id="7866d-136">Each new object requires a new allocation, and subsequently must be reclaimed.</span></span> <span data-ttu-id="7866d-137">Ambas operaciones llevan cierto tiempo.</span><span class="sxs-lookup"><span data-stu-id="7866d-137">Both these operations take time.</span></span> <span data-ttu-id="7866d-138">La referencia se copia cuando un tipo de referencia se pasa como argumento a un método o se devuelve desde un método.</span><span class="sxs-lookup"><span data-stu-id="7866d-138">The reference is copied when a reference type is passed as an argument to a method or returned from a method.</span></span>

<span data-ttu-id="7866d-139">En este artículo se utiliza el concepto de ejemplo siguiente de la estructura de punto 3D para explicar estas recomendaciones:</span><span class="sxs-lookup"><span data-stu-id="7866d-139">This article uses the following example concept of the 3D-point structure to explain these recommendations:</span></span>

```csharp
public struct Point3D
{
    public double X;
    public double Y;
    public double Z;
}
```

<span data-ttu-id="7866d-140">Los distintos ejemplos utilizan implementaciones distintas de este concepto.</span><span class="sxs-lookup"><span data-stu-id="7866d-140">Different examples use different implementations of this concept.</span></span>

## <a name="declare-readonly-structs-for-immutable-value-types"></a><span data-ttu-id="7866d-141">Declaración de valores struct de solo lectura para tipos de valor inmutables</span><span class="sxs-lookup"><span data-stu-id="7866d-141">Declare readonly structs for immutable value types</span></span>

<span data-ttu-id="7866d-142">Al declarar un valor `struct` utilizando el modificador `readonly`, se informa al compilador de que su intención es crear un tipo inmutable.</span><span class="sxs-lookup"><span data-stu-id="7866d-142">Declaring a `struct` using the `readonly` modifier informs the compiler that your intent is to create an immutable type.</span></span> <span data-ttu-id="7866d-143">El compilador aplica esa decisión de diseño con las siguientes reglas:</span><span class="sxs-lookup"><span data-stu-id="7866d-143">The compiler enforces that design decision with the following rules:</span></span>

- <span data-ttu-id="7866d-144">Todos los miembro de campo deben ser `readonly`.</span><span class="sxs-lookup"><span data-stu-id="7866d-144">All field members must be `readonly`</span></span>
- <span data-ttu-id="7866d-145">Todas las propiedades deben ser de solo lectura, incluidas las implementadas automáticamente.</span><span class="sxs-lookup"><span data-stu-id="7866d-145">All properties must be read-only, including auto-implemented properties.</span></span>

<span data-ttu-id="7866d-146">Estas dos reglas son suficientes para garantizar que ningún miembro de un valor `readonly struct` vaya a modificar el estado de ese valor struct.</span><span class="sxs-lookup"><span data-stu-id="7866d-146">These two rules are sufficient to ensure that no member of a `readonly struct` modifies the state of that struct.</span></span> <span data-ttu-id="7866d-147">El valor `struct` es inmutable.</span><span class="sxs-lookup"><span data-stu-id="7866d-147">The `struct` is immutable.</span></span> <span data-ttu-id="7866d-148">La estructura de `Point3D` se podría definir como un valor struct inmutable tal como se muestra en este ejemplo:</span><span class="sxs-lookup"><span data-stu-id="7866d-148">The `Point3D` structure could be defined as an immutable struct as shown in the following example:</span></span>

```csharp
readonly public struct ReadonlyPoint3D
{
    public ReadonlyPoint3D(double x, double y, double z)
    {
        this.X = x;
        this.Y = y;
        this.Z = z;
    }

    public double X { get; }
    public double Y { get; }
    public double Z { get; }
}
```

<span data-ttu-id="7866d-149">Siga esta recomendación siempre que su intención de diseño sea crear un tipo de valor inmutable.</span><span class="sxs-lookup"><span data-stu-id="7866d-149">Follow this recommendation whenever your design intent is to create an immutable value type.</span></span> <span data-ttu-id="7866d-150">Cualquier mejora de rendimiento que se aplique es una ventaja adicional.</span><span class="sxs-lookup"><span data-stu-id="7866d-150">Any performance improvements are an added benefit.</span></span> <span data-ttu-id="7866d-151">El valor `readonly struct` expresa claramente su intención de diseño.</span><span class="sxs-lookup"><span data-stu-id="7866d-151">The `readonly struct` clearly expresses your design intent.</span></span>

## <a name="declare-readonly-members-when-a-struct-cant-be-immutable"></a><span data-ttu-id="7866d-152">Declaración de miembros de solo lectura cuando una estructura no pueda ser inmutable</span><span class="sxs-lookup"><span data-stu-id="7866d-152">Declare readonly members when a struct can't be immutable</span></span>

<span data-ttu-id="7866d-153">En C# 8.0 y versiones posteriores, cuando un tipo de estructura es mutable, debe declarar los miembros que no provocan la mutación para que sean `readonly`.</span><span class="sxs-lookup"><span data-stu-id="7866d-153">In C# 8.0 and later, when a struct type is mutable, you should declare members that don't cause mutation to be `readonly`.</span></span> <span data-ttu-id="7866d-154">Plantéese usar una aplicación diferente que necesite una estructura de punto 3D, pero que admita la mutabilidad.</span><span class="sxs-lookup"><span data-stu-id="7866d-154">Consider a different application that needs a 3D point structure, but must support mutability.</span></span> <span data-ttu-id="7866d-155">La siguiente versión de la estructura de punto 3D agrega el modificador `readonly` solo a los miembros que no modifican la estructura.</span><span class="sxs-lookup"><span data-stu-id="7866d-155">The following version of the 3D point structure adds the `readonly` modifier only to those members that don't modify the structure.</span></span> <span data-ttu-id="7866d-156">Siga este ejemplo cuando el diseño deba admitir modificaciones en el tipo de datos struct por parte de algunos miembros, pero desea obtener las ventajas de aplicar readonly en algunos miembros:</span><span class="sxs-lookup"><span data-stu-id="7866d-156">Follow this example when your design must support modifications to the struct by some members, but you still want the benefits of enforcing readonly on some members:</span></span>

```csharp
public struct Point3D
{
    public Point3D(double x, double y, double z)
    {
        _x = x;
        _y = y;
        _z = z;
    }

    private double _x;
    public double X
    {
        readonly get => _x;
        set => _x = value;
    }

    private double _y;
    public double Y
    {
        readonly get => _y;
        set => _y = value;
    }

    private double _z;
    public double Z
    {
        readonly get => _z;
        set => _z = value;
    }

    public readonly double Distance => Math.Sqrt(X * X + Y * Y + Z * Z);

    public readonly override string ToString() => $"{X}, {Y}, {Z}";
}
```

<span data-ttu-id="7866d-157">En el ejemplo anterior se muestran muchas de las ubicaciones en las que puede aplicar el modificador `readonly`: métodos, propiedades y descriptores de acceso de propiedad.</span><span class="sxs-lookup"><span data-stu-id="7866d-157">The preceding sample shows many of the locations where you can apply the `readonly` modifier: methods, properties, and property accessors.</span></span> <span data-ttu-id="7866d-158">Si usa propiedades implementadas automáticamente, el compilador agrega el modificador `readonly` al descriptor de acceso `get` para las propiedades de lectura y escritura.</span><span class="sxs-lookup"><span data-stu-id="7866d-158">If you use auto-implemented properties, the compiler adds the `readonly` modifier to the `get` accessor for read-write properties.</span></span> <span data-ttu-id="7866d-159">El compilador agrega el modificador `readonly` a las declaraciones de propiedad implementadas automáticamente para las propiedades con solo un descriptor de acceso `get`.</span><span class="sxs-lookup"><span data-stu-id="7866d-159">The compiler adds the `readonly` modifier to the auto-implemented property declarations for properties with only a `get` accessor.</span></span>

<span data-ttu-id="7866d-160">Agregar el modificador `readonly` a los miembros que no mutan el estado proporciona dos ventajas relacionadas.</span><span class="sxs-lookup"><span data-stu-id="7866d-160">Adding the `readonly` modifier to members that don't mutate state provides two related benefits.</span></span> <span data-ttu-id="7866d-161">En primer lugar, el compilador aplica su intención.</span><span class="sxs-lookup"><span data-stu-id="7866d-161">First, the compiler enforces your intent.</span></span> <span data-ttu-id="7866d-162">Ese miembro no puede mutar el estado de la estructura ni tener acceso a un miembro que no esté marcado también como `readonly`.</span><span class="sxs-lookup"><span data-stu-id="7866d-162">That member can't mutate the struct's state, nor can it access a member that isn't also marked `readonly`.</span></span> <span data-ttu-id="7866d-163">En segundo lugar, el compilador no crea copias defensivas de parámetros `in` al obtener acceso a un miembro de `readonly`.</span><span class="sxs-lookup"><span data-stu-id="7866d-163">Second, the compiler won't create defensive copies of `in` parameters when accessing a `readonly` member.</span></span> <span data-ttu-id="7866d-164">El compilador puede hacer que esta optimización sea segura, ya que garantiza que un miembro de `readonly` no modifique `struct`.</span><span class="sxs-lookup"><span data-stu-id="7866d-164">The compiler can make this optimization safely because it guarantees that the `struct` is not modified by a `readonly` member.</span></span>

## <a name="use-ref-readonly-return-statements-for-large-structures-when-possible"></a><span data-ttu-id="7866d-165">Uso de instrucciones `ref readonly return` para grandes estructuras en la medida de lo posible</span><span class="sxs-lookup"><span data-stu-id="7866d-165">Use `ref readonly return` statements for large structures when possible</span></span>

<span data-ttu-id="7866d-166">Puede devolver valores por referencia cuando el valor que se devuelva no sea local en el método de devolución.</span><span class="sxs-lookup"><span data-stu-id="7866d-166">You can return values by reference when the value being returned isn't local to the returning method.</span></span> <span data-ttu-id="7866d-167">Al devolverlos de esta forma, se copiará solo la referencia, no la estructura.</span><span class="sxs-lookup"><span data-stu-id="7866d-167">Returning by reference means that only the reference is copied, not the structure.</span></span> <span data-ttu-id="7866d-168">En el ejemplo siguiente, la propiedad `Origin` no puede usar ninguna devolución `ref` porque el valor que se está devolviendo es una variable local:</span><span class="sxs-lookup"><span data-stu-id="7866d-168">In the following example, the `Origin` property can't use a `ref` return because the value being returned is a local variable:</span></span>

```csharp
public Point3D Origin => new Point3D(0,0,0);
```

<span data-ttu-id="7866d-169">Sin embargo, la siguiente definición de propiedad se puede devolver por referencia porque el valor devuelto es un miembro estático:</span><span class="sxs-lookup"><span data-stu-id="7866d-169">However, the following property definition can be returned by reference because the returned value is a static member:</span></span>

```csharp
public struct Point3D
{
    private static Point3D origin = new Point3D(0,0,0);

    // Dangerous! returning a mutable reference to internal storage
    public ref Point3D Origin => ref origin;

    // other members removed for space
}
```

<span data-ttu-id="7866d-170">Como no quiere que los autores de llamada modifiquen el origen, debe devolver el valor según su `ref readonly`:</span><span class="sxs-lookup"><span data-stu-id="7866d-170">You don't want callers modifying the origin, so you should return the value by `ref readonly`:</span></span>

```csharp
public struct Point3D
{
    private static Point3D origin = new Point3D(0,0,0);

    public static ref readonly Point3D Origin => ref origin;

    // other members removed for space
}
```

<span data-ttu-id="7866d-171">Al devolver `ref readonly`, se podrá ahorrar procesos de copia de estructuras mayores y conservar la inmutabilidad de los miembros de datos internos.</span><span class="sxs-lookup"><span data-stu-id="7866d-171">Returning `ref readonly` enables you to save copying larger structures and preserve the immutability of your internal data members.</span></span>

<span data-ttu-id="7866d-172">En el sitio de llamada, los autores de dicha llamada eligen utilizar la propiedad `Origin` como `ref readonly` o como valor:</span><span class="sxs-lookup"><span data-stu-id="7866d-172">At the call site, callers make the choice to use the `Origin` property as a `ref readonly` or as a value:</span></span>

[!code-csharp[AssignRefReadonly](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#AssignRefReadonly "Assigning a ref readonly")]

<span data-ttu-id="7866d-173">La primera asignación en el código anterior realiza una copia de la constante `Origin` y asigna esa copia.</span><span class="sxs-lookup"><span data-stu-id="7866d-173">The first assignment in the preceding code makes a copy of the `Origin` constant and assigns that copy.</span></span> <span data-ttu-id="7866d-174">La segunda asigna una referencia.</span><span class="sxs-lookup"><span data-stu-id="7866d-174">The second assigns a reference.</span></span> <span data-ttu-id="7866d-175">Tenga en cuenta que el modificador `readonly` debe formar parte de la declaración de la variable.</span><span class="sxs-lookup"><span data-stu-id="7866d-175">Notice that the `readonly` modifier must be part of the declaration of the variable.</span></span> <span data-ttu-id="7866d-176">No se puede modificar la referencia a la que alude.</span><span class="sxs-lookup"><span data-stu-id="7866d-176">The reference to which it refers can't be modified.</span></span> <span data-ttu-id="7866d-177">Los intentos de hacerlo generarán un error en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="7866d-177">Attempts to do so result in a compile-time error.</span></span>

<span data-ttu-id="7866d-178">El modificador `readonly` es necesario en la declaración de `originReference`.</span><span class="sxs-lookup"><span data-stu-id="7866d-178">The `readonly` modifier is required on the declaration of `originReference`.</span></span>

<span data-ttu-id="7866d-179">El compilador exige que el autor de una llamada no pueda modificar la referencia.</span><span class="sxs-lookup"><span data-stu-id="7866d-179">The compiler enforces that the caller can't modify the reference.</span></span> <span data-ttu-id="7866d-180">Los intentos de asignar el valor directamente generan un error en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="7866d-180">Attempts to assign the value directly generate a compile-time error.</span></span> <span data-ttu-id="7866d-181">Sin embargo, el compilador no puede saber si algún método de miembro modifica el estado del valor struct.</span><span class="sxs-lookup"><span data-stu-id="7866d-181">However, the compiler can't know if any member method modifies the state of the struct.</span></span>
<span data-ttu-id="7866d-182">Para asegurarse de que el objeto no se modifique, el compilador crea una copia y llama a las referencias de miembro usando esa copia.</span><span class="sxs-lookup"><span data-stu-id="7866d-182">To ensure that the object isn't modified, the compiler creates a copy and calls member references using that copy.</span></span> <span data-ttu-id="7866d-183">Las modificaciones se realizan sobre esa copia defensiva.</span><span class="sxs-lookup"><span data-stu-id="7866d-183">Any modifications are to that defensive copy.</span></span>

## <a name="apply-the-in-modifier-to-readonly-struct-parameters-larger-than-systemintptrsize"></a><span data-ttu-id="7866d-184">Aplicación del modificador `in` en los parámetros `readonly struct` mayores que `System.IntPtr.Size`</span><span class="sxs-lookup"><span data-stu-id="7866d-184">Apply the `in` modifier to `readonly struct` parameters larger than `System.IntPtr.Size`</span></span>

<span data-ttu-id="7866d-185">La palabra clave `in` complementa las palabras clave `ref` y `out` existentes para pasar argumentos por referencia.</span><span class="sxs-lookup"><span data-stu-id="7866d-185">The `in` keyword complements the existing `ref` and `out` keywords to pass arguments by reference.</span></span> <span data-ttu-id="7866d-186">La palabra clave `in` especifica que se pasa el argumento por referencia, pero el método llamado no modifica el valor.</span><span class="sxs-lookup"><span data-stu-id="7866d-186">The `in` keyword specifies passing the argument by reference, but the called method doesn't modify the value.</span></span>

<span data-ttu-id="7866d-187">Esta novedad proporciona un vocabulario completo para expresar la intención del diseño.</span><span class="sxs-lookup"><span data-stu-id="7866d-187">This addition provides a full vocabulary to express your design intent.</span></span>
<span data-ttu-id="7866d-188">Los tipos de valor se copian al pasarlos a un método llamado cuando no se especifica ninguno de los siguientes modificadores en la firma de método.</span><span class="sxs-lookup"><span data-stu-id="7866d-188">Value types are copied when passed to a called method when you don't specify any of the following modifiers in the method signature.</span></span> <span data-ttu-id="7866d-189">Cada uno de estos modificadores especifica que una variable se pasa por referencia, evitando la copia.</span><span class="sxs-lookup"><span data-stu-id="7866d-189">Each of these modifiers specifies that a variable is passed by reference, avoiding the copy.</span></span> <span data-ttu-id="7866d-190">Cada modificador expresa un propósito diferente:</span><span class="sxs-lookup"><span data-stu-id="7866d-190">Each modifier expresses a different intent:</span></span>

- <span data-ttu-id="7866d-191">`out`: este método establece el valor del argumento utilizado como este parámetro.</span><span class="sxs-lookup"><span data-stu-id="7866d-191">`out`: This method sets the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="7866d-192">`ref`: este método puede establecer el valor del argumento utilizado como este parámetro.</span><span class="sxs-lookup"><span data-stu-id="7866d-192">`ref`: This method may set the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="7866d-193">`in`: este método no modifica el valor del argumento utilizado como este parámetro.</span><span class="sxs-lookup"><span data-stu-id="7866d-193">`in`: This method doesn't modify the value of the argument used as this parameter.</span></span>

<span data-ttu-id="7866d-194">Agregue el modificador `in` para pasar un argumento por referencia y declare la intención del diseño de pasar argumentos por referencia para evitar la copia innecesaria.</span><span class="sxs-lookup"><span data-stu-id="7866d-194">Add the `in` modifier to pass an argument by reference and declare your design intent to pass arguments by reference to avoid unnecessary copying.</span></span> <span data-ttu-id="7866d-195">No pretende modificar el objeto usado como ese argumento.</span><span class="sxs-lookup"><span data-stu-id="7866d-195">You don't intend to modify the object used as that argument.</span></span>

<span data-ttu-id="7866d-196">A menudo, esta práctica mejora el rendimiento de los tipos de valor de solo lectura que son mayores que <xref:System.IntPtr.Size?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="7866d-196">This practice often improves performance for readonly value types that are larger than <xref:System.IntPtr.Size?displayProperty=nameWithType>.</span></span> <span data-ttu-id="7866d-197">En el caso de los tipos simples (`sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, `decimal`, `bool` y `enum`), las posibles mejoras con respecto al rendimiento son mínimas.</span><span class="sxs-lookup"><span data-stu-id="7866d-197">For simple types (`sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, `decimal` and `bool`, and `enum` types), any potential performance gains are minimal.</span></span> <span data-ttu-id="7866d-198">De hecho, el rendimiento puede empeorar al usar un parámetro de paso por referencia para los tipos menores que <xref:System.IntPtr.Size?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="7866d-198">In fact, performance may degrade by using pass-by-reference for types smaller than <xref:System.IntPtr.Size?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="7866d-199">El código siguiente muestra un ejemplo de un método que calcula la distancia entre dos puntos en un espacio 3D.</span><span class="sxs-lookup"><span data-stu-id="7866d-199">The following code shows an example of a method that calculates the distance between two points in 3D space.</span></span>

[!code-csharp[InArgument](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#InArgument "Specifying an in argument")]

<span data-ttu-id="7866d-200">Los argumentos son dos estructuras que contienen cada una de ellas tres valores dobles.</span><span class="sxs-lookup"><span data-stu-id="7866d-200">The arguments are two structures that each contain three doubles.</span></span> <span data-ttu-id="7866d-201">Un valor doble tiene 8 bytes, por lo que cada argumento es de 24 bytes.</span><span class="sxs-lookup"><span data-stu-id="7866d-201">A double is 8 bytes, so each argument is 24 bytes.</span></span> <span data-ttu-id="7866d-202">Al especificar el modificador `in`, se pasa una referencia de 4 u 8 bytes a esos argumentos, en función de la arquitectura de la máquina.</span><span class="sxs-lookup"><span data-stu-id="7866d-202">By specifying the `in` modifier, you pass a 4 byte or 8-byte reference to those arguments, depending on the architecture of the machine.</span></span> <span data-ttu-id="7866d-203">La diferencia de tamaño es pequeña, pero aumenta rápidamente cuando la aplicación llama a este método en un bucle ajustado con muchos valores diferentes.</span><span class="sxs-lookup"><span data-stu-id="7866d-203">The difference in size is small, but it adds up when your application calls this method in a tight loop using many different values.</span></span>

<span data-ttu-id="7866d-204">El modificador `in` complementa también a `out` y `ref` de otras maneras.</span><span class="sxs-lookup"><span data-stu-id="7866d-204">The `in` modifier complements `out` and `ref` in other ways as well.</span></span> <span data-ttu-id="7866d-205">No puede crear sobrecargas de un método que difiere solo en cuanto a la presencia de `in`, `out` o `ref`.</span><span class="sxs-lookup"><span data-stu-id="7866d-205">You can't create overloads of a method that differ only in the presence of `in`, `out`, or `ref`.</span></span> <span data-ttu-id="7866d-206">Estas nuevas reglas extienden el mismo comportamiento que siempre se ha definido para los parámetros `out` y `ref`.</span><span class="sxs-lookup"><span data-stu-id="7866d-206">These new rules extend the same behavior that had always been defined for `out` and `ref` parameters.</span></span> <span data-ttu-id="7866d-207">Como en el caso de los modificadores `out` y `ref`, no se aplica la conversión boxing a los tipos de valor porque se aplica el modificador `in`.</span><span class="sxs-lookup"><span data-stu-id="7866d-207">Like the `out` and `ref` modifiers, value types aren't boxed because the `in` modifier is applied.</span></span>

<span data-ttu-id="7866d-208">El modificador `in` se puede aplicar a cualquier miembro que toma parámetros: métodos, delegados, expresiones lambda, funciones locales, indexadores u operadores.</span><span class="sxs-lookup"><span data-stu-id="7866d-208">The `in` modifier may be applied to any member that takes parameters: methods, delegates, lambdas, local functions, indexers, operators.</span></span>

<span data-ttu-id="7866d-209">Otra de las características de los parámetros `in` es que se pueden usar valores literales o constantes para el argumento en un parámetro `in`.</span><span class="sxs-lookup"><span data-stu-id="7866d-209">Another feature of `in` parameters is that you may use literal values or constants for the argument to an `in` parameter.</span></span> <span data-ttu-id="7866d-210">Además, a diferencia de un parámetro `ref` o `out`, no es necesario aplicar el modificador `in` en el sitio de llamada.</span><span class="sxs-lookup"><span data-stu-id="7866d-210">Also, unlike a `ref` or `out` parameter, you don't need to apply the `in` modifier at the call site.</span></span> <span data-ttu-id="7866d-211">El código siguiente muestra dos ejemplos de llamada al método `CalculateDistance`.</span><span class="sxs-lookup"><span data-stu-id="7866d-211">The following code shows you two examples of calling the `CalculateDistance` method.</span></span> <span data-ttu-id="7866d-212">El primero usa dos variables locales pasadas por referencia.</span><span class="sxs-lookup"><span data-stu-id="7866d-212">The first uses two local variables passed by reference.</span></span> <span data-ttu-id="7866d-213">El segundo incluye una variable temporal creada como parte de la llamada al método.</span><span class="sxs-lookup"><span data-stu-id="7866d-213">The second includes a temporary variable created as part of the method call.</span></span>

[!code-csharp[UseInArgument](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#UseInArgument "Specifying an In argument")]

<span data-ttu-id="7866d-214">El compilador tiene varias maneras de aplicar la naturaleza de solo lectura de un argumento `in`.</span><span class="sxs-lookup"><span data-stu-id="7866d-214">There are several ways in which the compiler enforces the read-only nature of an `in` argument.</span></span>  <span data-ttu-id="7866d-215">En primer lugar, el método llamado no se puede asignar directamente a un parámetro `in`.</span><span class="sxs-lookup"><span data-stu-id="7866d-215">First of all, the called method can't directly assign to an `in` parameter.</span></span> <span data-ttu-id="7866d-216">No se puede asignar directamente a ningún campo de un parámetro `in` cuando el valor es un tipo `struct`.</span><span class="sxs-lookup"><span data-stu-id="7866d-216">It can't directly assign to any field of an `in` parameter when that value is a `struct` type.</span></span> <span data-ttu-id="7866d-217">Además, no se puede pasar un parámetro `in` a ningún método que exija el modificador `ref` o `out`.</span><span class="sxs-lookup"><span data-stu-id="7866d-217">In addition, you can't pass an `in` parameter to any method using the `ref` or `out` modifier.</span></span>
<span data-ttu-id="7866d-218">Estas reglas se aplican a cualquier campo de un parámetro `in`, siempre que el campo sea un tipo `struct` y el parámetro también sea un tipo `struct`.</span><span class="sxs-lookup"><span data-stu-id="7866d-218">These rules apply to any field of an `in` parameter, provided the field is a `struct` type and the parameter is also a `struct` type.</span></span> <span data-ttu-id="7866d-219">De hecho, estas reglas se aplican para varios niveles de acceso a miembros, siempre que los tipos en todos los niveles de acceso a miembros sean `structs`.</span><span class="sxs-lookup"><span data-stu-id="7866d-219">In fact, these rules apply for multiple layers of member access provided the types at all levels of member access are `structs`.</span></span>
<span data-ttu-id="7866d-220">El compilador exige que los tipos `struct` que se pasan como argumentos `in` y sus miembros `struct` sean variables de solo lectura cuando se usan como argumentos para otros métodos.</span><span class="sxs-lookup"><span data-stu-id="7866d-220">The compiler enforces that `struct` types passed as  `in` arguments and their `struct` members are read-only variables when used as arguments to other methods.</span></span>

<span data-ttu-id="7866d-221">El uso de parámetros `in` puede evitar los posibles costos de rendimiento que conlleva realizar copias.</span><span class="sxs-lookup"><span data-stu-id="7866d-221">The use of `in` parameters can avoid the potential performance costs of making copies.</span></span> <span data-ttu-id="7866d-222">No cambia la semántica de ninguna llamada al método.</span><span class="sxs-lookup"><span data-stu-id="7866d-222">It doesn't change the semantics of any method call.</span></span> <span data-ttu-id="7866d-223">Por lo tanto, no es necesario especificar el modificador `in` en el sitio de llamada.</span><span class="sxs-lookup"><span data-stu-id="7866d-223">Therefore, you don't need to specify the `in` modifier at the call site.</span></span> <span data-ttu-id="7866d-224">Al omitir el modificador `in` en el sitio de llamada, se indica al compilador que está permitido realizar una copia del argumento por estos motivos:</span><span class="sxs-lookup"><span data-stu-id="7866d-224">Omitting the `in` modifier at the call site informs the compiler that it's allowed to make a copy of the argument for the following reasons:</span></span>

- <span data-ttu-id="7866d-225">Hay una conversión implícita, pero no una conversión de identidad desde el tipo de argumento hacia el tipo de parámetro.</span><span class="sxs-lookup"><span data-stu-id="7866d-225">There exists an implicit conversion but not an identity conversion from the argument type to the parameter type.</span></span>
- <span data-ttu-id="7866d-226">El argumento es una expresión, pero no tiene una variable de almacenamiento conocida.</span><span class="sxs-lookup"><span data-stu-id="7866d-226">The argument is an expression but doesn't have a known storage variable.</span></span>
- <span data-ttu-id="7866d-227">Existe una sobrecarga que se diferencia por la presencia o la ausencia de `in`.</span><span class="sxs-lookup"><span data-stu-id="7866d-227">An overload exists that differs by the presence or absence of `in`.</span></span> <span data-ttu-id="7866d-228">En ese caso, la sobrecarga por valor es una coincidencia mejor.</span><span class="sxs-lookup"><span data-stu-id="7866d-228">In that case, the by value overload is a better match.</span></span>

<span data-ttu-id="7866d-229">Estas reglas son útiles cuando se actualiza código existente para usar argumentos de referencia de solo lectura.</span><span class="sxs-lookup"><span data-stu-id="7866d-229">These rules are useful as you update existing code to use read-only reference arguments.</span></span> <span data-ttu-id="7866d-230">En el método llamado, puede llamar a cualquier método de instancia que use parámetros por valor.</span><span class="sxs-lookup"><span data-stu-id="7866d-230">Inside the called method, you can call any instance method that uses by value parameters.</span></span> <span data-ttu-id="7866d-231">En esos casos, se crea una copia del parámetro `in`.</span><span class="sxs-lookup"><span data-stu-id="7866d-231">In those instances, a copy of the `in` parameter is created.</span></span> <span data-ttu-id="7866d-232">Dado que el compilador puede crear una variable temporal para cualquier parámetro `in`, también puede especificar valores predeterminados para cualquier parámetro `in`.</span><span class="sxs-lookup"><span data-stu-id="7866d-232">Because the compiler may create a temporary variable for any `in` parameter, you can also specify default values for any `in` parameter.</span></span> <span data-ttu-id="7866d-233">En este código se especifica el origen (punto 0,0) como valor predeterminado para el segundo punto:</span><span class="sxs-lookup"><span data-stu-id="7866d-233">The following code specifies the origin (point 0,0) as the default value for the second point:</span></span>

[!code-csharp[InArgumentDefault](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#InArgumentDefault "Specifying defaults for an in parameter")]

<span data-ttu-id="7866d-234">Para forzar al compilador que pase argumentos de solo lectura por referencia, especifique el modificador `in` en los argumentos en el sitio de llamada, como se muestra en el este código:</span><span class="sxs-lookup"><span data-stu-id="7866d-234">To force the compiler to pass read-only arguments by reference, specify the `in` modifier on the arguments at the call site, as shown in the following code:</span></span>

[!code-csharp[UseInArgument](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#ExplicitInArgument "Specifying an In argument")]

<span data-ttu-id="7866d-235">Con este comportamiento es más fácil adoptar parámetros `in` con el tiempo en grandes bases de código donde es posible mejorar el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="7866d-235">This behavior makes it easier to adopt `in` parameters over time in large codebases where performance gains are possible.</span></span> <span data-ttu-id="7866d-236">Primero, puede agregar el modificador `in` para las firmas de método.</span><span class="sxs-lookup"><span data-stu-id="7866d-236">You add the `in` modifier to method signatures first.</span></span> <span data-ttu-id="7866d-237">Después, puede agregar el modificador `in` en sitios de llamada y crear tipos `readonly struct` para permitir al compilador que evite la creación de copias defensivas de parámetros `in` en más ubicaciones.</span><span class="sxs-lookup"><span data-stu-id="7866d-237">Then, you can add the `in` modifier at call sites and create `readonly struct` types to enable the compiler to avoid creating defensive copies of `in` parameters in more locations.</span></span>

<span data-ttu-id="7866d-238">La designación del parámetro `in` también se puede usar con tipos de referencia o valores numéricos.</span><span class="sxs-lookup"><span data-stu-id="7866d-238">The `in` parameter designation can also be used with reference types or numeric values.</span></span> <span data-ttu-id="7866d-239">Sin embargo, las ventajas de ambos casos son mínimas, si las hay.</span><span class="sxs-lookup"><span data-stu-id="7866d-239">However, the benefits in both cases are minimal, if any.</span></span>

## <a name="avoid-mutable-structs-as-an-in-argument"></a><span data-ttu-id="7866d-240">Evitar structs mutables como un argumento `in`</span><span class="sxs-lookup"><span data-stu-id="7866d-240">Avoid mutable structs as an `in` argument</span></span>

<span data-ttu-id="7866d-241">En las técnicas descritas anteriormente se explica cómo evitar copias devolviendo referencias y pasando los valores por referencia.</span><span class="sxs-lookup"><span data-stu-id="7866d-241">The techniques described above explain how to avoid copies by returning references and passing values by reference.</span></span> <span data-ttu-id="7866d-242">Estas técnicas funcionan mejor cuando los tipos de argumento se declaran como tipos `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="7866d-242">These techniques work best when the argument types are declared as `readonly struct` types.</span></span> <span data-ttu-id="7866d-243">En caso contrario, el compilador deberá crear **copias defensivas** en muchas situaciones para aplicar la característica de solo lectura en cualquier argumento.</span><span class="sxs-lookup"><span data-stu-id="7866d-243">Otherwise, the compiler must create **defensive copies** in many situations to enforce the readonly-ness of any arguments.</span></span> <span data-ttu-id="7866d-244">Tenga en cuenta el comentario siguiente, en el que se calcula la distancia de un punto 3D respecto del origen:</span><span class="sxs-lookup"><span data-stu-id="7866d-244">Consider the following example that calculates the distance of a 3D point from the origin:</span></span>

[!code-csharp[InArgument](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#InArgument "Specifying an in argument")]

<span data-ttu-id="7866d-245">La estructura `Point3D`*no* es un valor struct de solo lectura.</span><span class="sxs-lookup"><span data-stu-id="7866d-245">The `Point3D` structure is *not* a readonly struct.</span></span> <span data-ttu-id="7866d-246">Hay seis llamadas de acceso a propiedades en el cuerpo de este método.</span><span class="sxs-lookup"><span data-stu-id="7866d-246">There are six different property access calls in the body of this method.</span></span> <span data-ttu-id="7866d-247">En el primer examen, es posible que haya pensado que esos accesos son seguros.</span><span class="sxs-lookup"><span data-stu-id="7866d-247">On first examination, you may have thought these accesses were safe.</span></span> <span data-ttu-id="7866d-248">Al fin y al cabo, un descriptor de acceso `get` no debe modificar el estado del objeto.</span><span class="sxs-lookup"><span data-stu-id="7866d-248">After all, a `get` accessor shouldn't modify the state of the object.</span></span> <span data-ttu-id="7866d-249">Sin embargo, no hay ninguna regla de lenguaje que lo exija.</span><span class="sxs-lookup"><span data-stu-id="7866d-249">But there's no language rule that enforces that.</span></span> <span data-ttu-id="7866d-250">Se trata solo de una convención habitual.</span><span class="sxs-lookup"><span data-stu-id="7866d-250">It's only a common convention.</span></span> <span data-ttu-id="7866d-251">Cualquier tipo podría implementar un descriptor de acceso `get` que haya modificado el estado interno.</span><span class="sxs-lookup"><span data-stu-id="7866d-251">Any type could implement a `get` accessor that modified the internal state.</span></span> <span data-ttu-id="7866d-252">Si el compilador no dispone de ninguna garantía relativa al lenguaje, debe crear una copia temporal del argumento antes de llamar a algún miembro no marcado con el modificador `readonly`.</span><span class="sxs-lookup"><span data-stu-id="7866d-252">Without some language guarantee, the compiler must create a temporary copy of the argument before calling any member not marked with the `readonly` modifier.</span></span> <span data-ttu-id="7866d-253">El almacenamiento temporal se crea en la pila, los valores del argumento se copian al almacenamiento temporal y el valor se copia en la pila por cada acceso de miembro como argumento `this`.</span><span class="sxs-lookup"><span data-stu-id="7866d-253">The temporary storage is created on the stack, the values of the argument are copied to the temporary storage, and the value is copied to the stack for each member access as the `this` argument.</span></span> <span data-ttu-id="7866d-254">En muchas situaciones, estas copias perjudican tanto el rendimiento que el parámetro de paso por valor es más rápido que el de paso por referencia cuando el tipo de argumento no es un valor `readonly struct`, y el método llama a los miembros no marcados con `readonly`.</span><span class="sxs-lookup"><span data-stu-id="7866d-254">In many situations, these copies harm performance enough that pass-by-value is faster than pass-by-readonly-reference when the argument type isn't a `readonly struct` and the method calls members that aren't marked `readonly`.</span></span> <span data-ttu-id="7866d-255">Si marca todos los métodos que no modifican el estado de struct como `readonly`, el compilador puede determinar con seguridad que no se modifica el estado de struct y no se necesita una copia defensiva.</span><span class="sxs-lookup"><span data-stu-id="7866d-255">If you mark all methods that don't modify the struct state as `readonly`, the compiler can safely determine that the struct state isn't modified, and a defensive copy is not needed.</span></span>

<span data-ttu-id="7866d-256">En lugar de ello, si en el cálculo de distancia se usa la estructura inmutable, `ReadonlyPoint3D`, no se necesitan objetos temporales:</span><span class="sxs-lookup"><span data-stu-id="7866d-256">Instead, if the distance calculation uses the immutable struct, `ReadonlyPoint3D`, temporary objects aren't needed:</span></span>

[!code-csharp[readonlyInArgument](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#ReadOnlyInArgument "Specifying a readonly in argument")]

<span data-ttu-id="7866d-257">El compilador genera un código más eficaz cuando se llama a los miembros de un valor `readonly struct`: La referencia `this`, en lugar de una copia del receptor, es siempre un parámetro `in` pasado por referencia al método del miembro.</span><span class="sxs-lookup"><span data-stu-id="7866d-257">The compiler generates more efficient code when you call members of a `readonly struct`: The `this` reference, instead of a copy of the receiver, is always an `in` parameter passed by reference to the member method.</span></span> <span data-ttu-id="7866d-258">Esta optimización ahorra procesos de copia cuando se utiliza `readonly struct` como argumento `in`.</span><span class="sxs-lookup"><span data-stu-id="7866d-258">This optimization saves copying when you use a `readonly struct` as an `in` argument.</span></span>

<span data-ttu-id="7866d-259">No se debe pasar un tipo de valor que admite un valor NULL como argumento `in`.</span><span class="sxs-lookup"><span data-stu-id="7866d-259">You shouldn't pass a nullable value type as an `in` argument.</span></span> <span data-ttu-id="7866d-260">El tipo <xref:System.Nullable%601> no se declara como una estructura de solo lectura.</span><span class="sxs-lookup"><span data-stu-id="7866d-260">The <xref:System.Nullable%601> type isn't declared as a read-only struct.</span></span> <span data-ttu-id="7866d-261">Eso significa que el compilador debe generar copias defensivas de cualquier argumento de tipo de valor que acepta valores NULL pasado a un método con el modificador `in` en la declaración de parámetros.</span><span class="sxs-lookup"><span data-stu-id="7866d-261">That means the compiler must generate defensive copies for any nullable value type argument passed to a method using the `in` modifier on the parameter declaration.</span></span>

<span data-ttu-id="7866d-262">Puede ver un programa de ejemplo en el que se muestran las diferencias de rendimiento con [BenchmarkDotNet](https://www.nuget.org/packages/BenchmarkDotNet/) en el [repositorio de ejemplos](https://github.com/dotnet/samples/tree/master/csharp/safe-efficient-code/benchmark) de GitHub.</span><span class="sxs-lookup"><span data-stu-id="7866d-262">You can see an example program that demonstrates the performance differences using [BenchmarkDotNet](https://www.nuget.org/packages/BenchmarkDotNet/) in our [samples repository](https://github.com/dotnet/samples/tree/master/csharp/safe-efficient-code/benchmark) on GitHub.</span></span> <span data-ttu-id="7866d-263">Compara la transmisión de un valor struct mutable por valor y por referencia con la transmisión de un valor struct inmutable por valor y por referencia.</span><span class="sxs-lookup"><span data-stu-id="7866d-263">It compares passing a mutable struct by value and by reference with passing an immutable struct by value and by reference.</span></span> <span data-ttu-id="7866d-264">El uso de un valor struct inmutable y de la transmisión por referencia es un proceso más rápido.</span><span class="sxs-lookup"><span data-stu-id="7866d-264">The use of the immutable struct and pass by reference is fastest.</span></span>

## <a name="use-ref-struct-types-to-work-with-blocks-or-memory-on-a-single-stack-frame"></a><span data-ttu-id="7866d-265">Uso de los tipos `ref struct` para trabajar con bloques o memoria en un solo marco de pila</span><span class="sxs-lookup"><span data-stu-id="7866d-265">Use `ref struct` types to work with blocks or memory on a single stack frame</span></span>

<span data-ttu-id="7866d-266">Una característica de lenguaje relacionada es la capacidad de declarar un tipo de valor que debe limitarse a un solo marco de pila.</span><span class="sxs-lookup"><span data-stu-id="7866d-266">A related language feature is the ability to declare a value type that must be constrained to a single stack frame.</span></span> <span data-ttu-id="7866d-267">Esta restricción permite al compilador aplicar una serie de optimizaciones.</span><span class="sxs-lookup"><span data-stu-id="7866d-267">This restriction enables the compiler to make several optimizations.</span></span> <span data-ttu-id="7866d-268">La principal motivación para esta característica era <xref:System.Span%601> y las estructuras relacionadas.</span><span class="sxs-lookup"><span data-stu-id="7866d-268">The primary motivation for this feature was <xref:System.Span%601> and related structures.</span></span> <span data-ttu-id="7866d-269">Conseguirá mejoras en el rendimiento a partir de estas optimizaciones usando las API de .NET nuevas y actualizadas que utilizan el tipo <xref:System.Span%601>.</span><span class="sxs-lookup"><span data-stu-id="7866d-269">You'll achieve performance improvements from these enhancements by using new and updated .NET APIs that make use of the <xref:System.Span%601> type.</span></span>

<span data-ttu-id="7866d-270">Puede tener requisitos similares al trabajar con memoria creada mediante [`stackalloc`](language-reference/operators/stackalloc.md) o al usar memoria de las API de interoperabilidad.</span><span class="sxs-lookup"><span data-stu-id="7866d-270">You may have similar requirements working with memory created using [`stackalloc`](language-reference/operators/stackalloc.md) or when using memory from interop APIs.</span></span> <span data-ttu-id="7866d-271">Puede definir sus propios tipos de `ref struct` para esas necesidades.</span><span class="sxs-lookup"><span data-stu-id="7866d-271">You can define your own `ref struct` types for those needs.</span></span>

## <a name="readonly-ref-struct-type"></a><span data-ttu-id="7866d-272">Tipo de `readonly ref struct`</span><span class="sxs-lookup"><span data-stu-id="7866d-272">`readonly ref struct` type</span></span>

<span data-ttu-id="7866d-273">Si declara una estructura como `readonly ref` se combinan las ventajas y las restricciones de las declaraciones `ref struct` y `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="7866d-273">Declaring a struct as `readonly ref` combines the benefits and restrictions of `ref struct` and `readonly struct` declarations.</span></span> <span data-ttu-id="7866d-274">La memoria utilizada por el intervalo de solo lectura está limitada a un solo marco de pila y no se puede modificar.</span><span class="sxs-lookup"><span data-stu-id="7866d-274">The memory used by the readonly span is restricted to a single stack frame, and the memory used by the readonly span can't be modified.</span></span>

## <a name="conclusions"></a><span data-ttu-id="7866d-275">Conclusiones</span><span class="sxs-lookup"><span data-stu-id="7866d-275">Conclusions</span></span>

<span data-ttu-id="7866d-276">El uso de tipos de valor minimiza el número de operaciones de asignación:</span><span class="sxs-lookup"><span data-stu-id="7866d-276">Using value types minimizes the number of allocation operations:</span></span>

- <span data-ttu-id="7866d-277">El almacenamiento de los tipos de valor está asignado a la pila en las variables locales y los argumentos de método.</span><span class="sxs-lookup"><span data-stu-id="7866d-277">Storage for value types is stack allocated for local variables and method arguments.</span></span>
- <span data-ttu-id="7866d-278">En cuanto al almacenamiento de tipos de valor que son miembros de otros objetos, está asignado como parte del objeto en cuestión, no como una asignación separada.</span><span class="sxs-lookup"><span data-stu-id="7866d-278">Storage for value types that are members of other objects is allocated as part of that object, not as a separate allocation.</span></span>
- <span data-ttu-id="7866d-279">Respecto a los valores devueltos por tipo de valor, están asignados a la pila.</span><span class="sxs-lookup"><span data-stu-id="7866d-279">Storage for value type return values is stack allocated.</span></span>

<span data-ttu-id="7866d-280">Es necesario contrastar eso con los tipos de referencia en estas mismas situaciones:</span><span class="sxs-lookup"><span data-stu-id="7866d-280">Contrast that with reference types in those same situations:</span></span>

- <span data-ttu-id="7866d-281">El almacenamiento de los tipos de referencia se asigna al montón en las variables locales y los argumentos de método.</span><span class="sxs-lookup"><span data-stu-id="7866d-281">Storage for reference types are heap allocated for local variables and method arguments.</span></span> <span data-ttu-id="7866d-282">La referencia se almacena en la pila.</span><span class="sxs-lookup"><span data-stu-id="7866d-282">The reference is stored on the stack.</span></span>
- <span data-ttu-id="7866d-283">El almacenamiento de tipos de referencia que son miembros de otros objetos está asignado por separado en la pila.</span><span class="sxs-lookup"><span data-stu-id="7866d-283">Storage for reference types that are members of other objects are separately allocated on the heap.</span></span> <span data-ttu-id="7866d-284">El objeto contenedor almacena la referencia.</span><span class="sxs-lookup"><span data-stu-id="7866d-284">The containing object stores the reference.</span></span>
- <span data-ttu-id="7866d-285">El almacenamiento de los valores devueltos por tipo de referencia está asignado a la pila.</span><span class="sxs-lookup"><span data-stu-id="7866d-285">Storage for reference type return values is heap allocated.</span></span> <span data-ttu-id="7866d-286">La referencia a ese almacenamiento se guarda en la pila.</span><span class="sxs-lookup"><span data-stu-id="7866d-286">The reference to that storage is stored on the stack.</span></span>

<span data-ttu-id="7866d-287">La minimización de asignaciones conlleva una serie de renuncias.</span><span class="sxs-lookup"><span data-stu-id="7866d-287">Minimizing allocations comes with tradeoffs.</span></span> <span data-ttu-id="7866d-288">Se copia más memoria cuando el tamaño del valor `struct` es mayor que el de una referencia.</span><span class="sxs-lookup"><span data-stu-id="7866d-288">You copy more memory when the size of the `struct` is larger than the size of a reference.</span></span> <span data-ttu-id="7866d-289">Habitualmente, las referencias son de 64 o 32 bits y dependen de la CPU de la máquina de destino.</span><span class="sxs-lookup"><span data-stu-id="7866d-289">A reference is typically 64 bits or 32 bits, and depends on the target machine CPU.</span></span>

<span data-ttu-id="7866d-290">Dichas renuncias suelen tener un impacto mínimo en el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="7866d-290">These tradeoffs generally have minimal performance impact.</span></span> <span data-ttu-id="7866d-291">Sin embargo, en el caso de los valores struct grandes o de las colecciones de mayor tamaño, el impacto sobre el rendimiento es mayor.</span><span class="sxs-lookup"><span data-stu-id="7866d-291">However, for large structs or larger collections, the performance impact increases.</span></span> <span data-ttu-id="7866d-292">Dicho impacto puede ser considerable en los bucles estrechos y las rutas de acceso activas de los programas.</span><span class="sxs-lookup"><span data-stu-id="7866d-292">The impact can be large in tight loops and hot paths for programs.</span></span>

<span data-ttu-id="7866d-293">Estas mejoras del lenguaje C# están diseñadas para algoritmos en los que el rendimiento es fundamental y la minimización de asignaciones de memoria es un factor principal para lograr el rendimiento necesario.</span><span class="sxs-lookup"><span data-stu-id="7866d-293">These enhancements to the C# language are designed for performance critical algorithms where minimizing memory allocations is a major factor in achieving the necessary performance.</span></span> <span data-ttu-id="7866d-294">Es posible que no use a menudo estas características en el código que escribe.</span><span class="sxs-lookup"><span data-stu-id="7866d-294">You may find that you don't often use these features in the code you write.</span></span> <span data-ttu-id="7866d-295">Sin embargo, estas mejoras se han adoptado a través de .NET.</span><span class="sxs-lookup"><span data-stu-id="7866d-295">However, these enhancements have been adopted throughout .NET.</span></span> <span data-ttu-id="7866d-296">Dado que cada vez son más las API que utilizan estas características, verá que el rendimiento de sus aplicaciones aumenta.</span><span class="sxs-lookup"><span data-stu-id="7866d-296">As more and more APIs make use of these features, you'll see the performance of your applications improve.</span></span>

## <a name="see-also"></a><span data-ttu-id="7866d-297">Vea también</span><span class="sxs-lookup"><span data-stu-id="7866d-297">See also</span></span>

- [<span data-ttu-id="7866d-298">ref (palabra clave)</span><span class="sxs-lookup"><span data-stu-id="7866d-298">ref keyword</span></span>](language-reference/keywords/ref.md)
- [<span data-ttu-id="7866d-299">Devoluciones y variables locales ref</span><span class="sxs-lookup"><span data-stu-id="7866d-299">Ref returns and ref locals</span></span>](programming-guide/classes-and-structs/ref-returns.md)
