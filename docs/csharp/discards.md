---
title: Descartes - Guía de C#
description: Describe la compatibilidad de C# con descartes, que son variables sin asignar y descartables, así como las maneras en que pueden usarse.
ms.technology: csharp-fundamentals
ms.date: 09/22/2020
ms.openlocfilehash: 7562da880ff3136dfc04ce4061bafa8ed55f5a23
ms.sourcegitcommit: 38999dc0ec4f7c4404de5ce0951b64c55997d9ab
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 02/02/2021
ms.locfileid: "99426923"
---
# <a name="discards---c-guide"></a><span data-ttu-id="69bb8-103">Descartes - Guía de C#</span><span class="sxs-lookup"><span data-stu-id="69bb8-103">Discards - C# Guide</span></span>

<span data-ttu-id="69bb8-104">A partir de C# 7.0, C# admite descartes, que son variables de marcador de posición que no se usan deliberadamente en el código de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="69bb8-104">Starting with C# 7.0, C# supports discards, which are placeholder variables that are intentionally unused in application code.</span></span> <span data-ttu-id="69bb8-105">Los descartes son equivalentes a variables sin asignar, ya que no tienen un valor.</span><span class="sxs-lookup"><span data-stu-id="69bb8-105">Discards are equivalent to unassigned variables; they don't have a value.</span></span> <span data-ttu-id="69bb8-106">Un descarte comunica la intención al compilador y otros usuarios que leen el código: Pretendía ignorar el resultado de una expresión.</span><span class="sxs-lookup"><span data-stu-id="69bb8-106">A discard communicates intent to the compiler and others that read your code: You intended to ignore the result of an expression.</span></span> <span data-ttu-id="69bb8-107">Es posible que desee ignorar el resultado de una expresión, uno o varios miembros de una expresión de tupla, un parámetro `out` de un método o el destino de una expresión de coincidencia de patrones.</span><span class="sxs-lookup"><span data-stu-id="69bb8-107">You may want to ignore the result of an expression, one or more members of a tuple expression, an `out` parameter to a method, or the target of a pattern matching expression.</span></span>

<span data-ttu-id="69bb8-108">Puesto que solo hay una variable de descarte única, es posible que a dicha variable no se le haya asignado almacenamiento.</span><span class="sxs-lookup"><span data-stu-id="69bb8-108">Because there's only a single discard variable, that variable may not even be allocated storage.</span></span> <span data-ttu-id="69bb8-109">Los descartes pueden reducir las asignaciones de memoria.</span><span class="sxs-lookup"><span data-stu-id="69bb8-109">Discards can reduce memory allocations.</span></span> <span data-ttu-id="69bb8-110">Los descartes aclaran la intención del código.</span><span class="sxs-lookup"><span data-stu-id="69bb8-110">Discards make the intent of your code clear.</span></span> <span data-ttu-id="69bb8-111">Mejoran la legibilidad y el mantenimiento.</span><span class="sxs-lookup"><span data-stu-id="69bb8-111">They enhance its readability and maintainability.</span></span>

<span data-ttu-id="69bb8-112">Para indicar que una variable es un descarte, se le asigna como nombre el carácter de subrayado (`_`).</span><span class="sxs-lookup"><span data-stu-id="69bb8-112">You indicate that a variable is a discard by assigning it the underscore (`_`) as its name.</span></span> <span data-ttu-id="69bb8-113">Por ejemplo, la siguiente llamada de método devuelve una tupla en la que el primer y el segundo valor son descartes.</span><span class="sxs-lookup"><span data-stu-id="69bb8-113">For example, the following method call returns a tuple in which the first and second values are discards.</span></span> <span data-ttu-id="69bb8-114">`area` es una variable declarada previamente establecida en el tercer componente devuelto por `GetCityInformation`:</span><span class="sxs-lookup"><span data-stu-id="69bb8-114">`area` is a previously declared variable set to the third component returned by `GetCityInformation`:</span></span>

```csharp
(_, _, area) = city.GetCityInformation(cityName);
```

<span data-ttu-id="69bb8-115">A partir de C# 9.0, se pueden usar descartes para especificar los parámetros de entrada de una expresión lambda que no se utilizan.</span><span class="sxs-lookup"><span data-stu-id="69bb8-115">Beginning with C# 9.0, you can use discards to specify unused input parameters of a lambda expression.</span></span> <span data-ttu-id="69bb8-116">Para más información, consulte sección sobre [parámetros de entrada de una expresión lambda](language-reference/operators/lambda-expressions.md#input-parameters-of-a-lambda-expression) en el artículo sobre [expresiones lambda](language-reference/operators/lambda-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="69bb8-116">For more information, see the [Input parameters of a lambda expression](language-reference/operators/lambda-expressions.md#input-parameters-of-a-lambda-expression) section of the [Lambda expressions](language-reference/operators/lambda-expressions.md) article.</span></span>

<span data-ttu-id="69bb8-117">Cuando `_` es un descarte válido, si se intenta recuperar su valor o usarlo en una operación de asignación, se genera el error del compilador CS0301: "El nombre '\_' no existe en el contexto actual".</span><span class="sxs-lookup"><span data-stu-id="69bb8-117">When `_` is a valid discard, attempting to retrieve its value or use it in an assignment operation generates compiler error CS0301, "The name '\_' doesn't exist in the current context".</span></span> <span data-ttu-id="69bb8-118">Este error se debe a que no se le ha asignado un valor a `_`, y es posible que tampoco se le haya asignado una ubicación de almacenamiento.</span><span class="sxs-lookup"><span data-stu-id="69bb8-118">This error is because `_` isn't assigned a value, and may not even be assigned a storage location.</span></span> <span data-ttu-id="69bb8-119">Si fuese una variable real no se podría descartar más de un valor, como en el ejemplo anterior.</span><span class="sxs-lookup"><span data-stu-id="69bb8-119">If it were an actual variable, you couldn't discard more than one value, as the previous example did.</span></span>

## <a name="tuple-and-object-deconstruction"></a><span data-ttu-id="69bb8-120">Deconstrucción de tuplas y objetos</span><span class="sxs-lookup"><span data-stu-id="69bb8-120">Tuple and object deconstruction</span></span>

<span data-ttu-id="69bb8-121">Los descartes son útiles en el trabajo con tuplas, cuando el código de la aplicación usa algunos elementos de tupla pero omite otros.</span><span class="sxs-lookup"><span data-stu-id="69bb8-121">Discards are useful in working with tuples when your application code uses some tuple elements but ignores others.</span></span> <span data-ttu-id="69bb8-122">Por ejemplo, el siguiente método `QueryCityDataForYears` devuelve una tupla con el nombre de una ciudad, su superficie, un año, la población de la ciudad en ese año, un segundo año y la población de la ciudad en ese segundo año.</span><span class="sxs-lookup"><span data-stu-id="69bb8-122">For example, the following `QueryCityDataForYears` method returns a tuple with the name of a city, its area, a year, the city's population for that year, a second year, and the city's population for that second year.</span></span> <span data-ttu-id="69bb8-123">En el ejemplo se muestra la evolución de la población entre esos dos años.</span><span class="sxs-lookup"><span data-stu-id="69bb8-123">The example shows the change in population between those two years.</span></span> <span data-ttu-id="69bb8-124">De los datos disponibles en la tupla, no nos interesa la superficie de la ciudad, y conocemos el nombre de la ciudad y las dos fechas en tiempo de diseño.</span><span class="sxs-lookup"><span data-stu-id="69bb8-124">Of the data available from the tuple, we're unconcerned with the city area, and we know the city name and the two dates at design-time.</span></span> <span data-ttu-id="69bb8-125">Como resultado, solo nos interesan los dos valores de población almacenados en la tupla, y podemos controlar los valores restantes como descartes.</span><span class="sxs-lookup"><span data-stu-id="69bb8-125">As a result, we're only interested in the two population values stored in the tuple, and can handle its remaining values as discards.</span></span>  

:::code language="csharp" source="snippets/discards/discard-tuple.cs" ID="DiscardTupleMember" :::

<span data-ttu-id="69bb8-126">Para obtener más información sobre la deconstrucción de tuplas con descartes, vea [Deconstructing tuples and other types](deconstruct.md#deconstructing-tuple-elements-with-discards) (Deconstruir tuplas y otros tipos).</span><span class="sxs-lookup"><span data-stu-id="69bb8-126">For more information on deconstructing tuples with discards, see [Deconstructing tuples and other types](deconstruct.md#deconstructing-tuple-elements-with-discards).</span></span>

<span data-ttu-id="69bb8-127">El método `Deconstruct` de una clase, estructura o interfaz también permite recuperar y deconstruir un conjunto de datos específico de un objeto.</span><span class="sxs-lookup"><span data-stu-id="69bb8-127">The `Deconstruct` method of a class, structure, or interface also allows you to retrieve and deconstruct a specific set of data from an object.</span></span> <span data-ttu-id="69bb8-128">Puede usar descartes cuando le interese trabajar con un solo subconjunto de los valores deconstruidos.</span><span class="sxs-lookup"><span data-stu-id="69bb8-128">You can use discards when you're interested in working with only a subset of the deconstructed values.</span></span> <span data-ttu-id="69bb8-129">En el siguiente ejemplo se deconstruye un objeto `Person` en cuatro cadenas (el nombre propio, los apellidos, la ciudad y el estado), pero se descartan los apellidos y el estado.</span><span class="sxs-lookup"><span data-stu-id="69bb8-129">The following example deconstructs a `Person` object into four strings (the first and last names, the city, and the state), but discards the last name and the state.</span></span>

:::code language="csharp" source="snippets/discards/discard-class.cs" :::

<span data-ttu-id="69bb8-130">Para obtener más información sobre la deconstrucción de tipos definidos por el usuario con descartes, vea [Deconstructing tuples and other types](deconstruct.md#deconstructing-a-user-defined-type-with-discards) (Deconstruir tuplas y otros tipos).</span><span class="sxs-lookup"><span data-stu-id="69bb8-130">For more information on deconstructing user-defined types with discards, see [Deconstructing tuples and other types](deconstruct.md#deconstructing-a-user-defined-type-with-discards).</span></span>

## <a name="pattern-matching-with-switch"></a><span data-ttu-id="69bb8-131">Coincidencia de patrones con switch</span><span class="sxs-lookup"><span data-stu-id="69bb8-131">Pattern matching with \`switch</span></span>

<span data-ttu-id="69bb8-132">El *patrón de descarte* se puede usar en la coincidencia de patrones con la palabra clave [switch](language-reference/keywords/switch.md).</span><span class="sxs-lookup"><span data-stu-id="69bb8-132">The *discard pattern* can be used in pattern matching with the [switch](language-reference/keywords/switch.md) keyword.</span></span> <span data-ttu-id="69bb8-133">Todas las expresiones siempre coinciden con el patrón de descarte.</span><span class="sxs-lookup"><span data-stu-id="69bb8-133">Every expression always matches the discard pattern.</span></span> <span data-ttu-id="69bb8-134">(Se puede utilizar con expresiones [is](language-reference/keywords/is.md).</span><span class="sxs-lookup"><span data-stu-id="69bb8-134">(It can be used with [is](language-reference/keywords/is.md) expressions.</span></span> <span data-ttu-id="69bb8-135">Sin embargo, ese uso es poco frecuente porque el descarte se puede quitar sin cambiar su significado).</span><span class="sxs-lookup"><span data-stu-id="69bb8-135">However, that use is rare because the discard can be removed without changing its meaning).</span></span>

<span data-ttu-id="69bb8-136">En el ejemplo siguiente se define un método `ProvidesFormatInfo` que usa instrucciones [is](language-reference/keywords/is.md) para determinar si un objeto proporciona una implementación de <xref:System.IFormatProvider> y probar si el objeto es `null`.</span><span class="sxs-lookup"><span data-stu-id="69bb8-136">The following example defines a `ProvidesFormatInfo` method that uses [is](language-reference/keywords/is.md) statements to determine whether an object provides an <xref:System.IFormatProvider> implementation and tests whether the object is `null`.</span></span> <span data-ttu-id="69bb8-137">También se usa el patrón de descarte para controlar los objetos que no son NULL de cualquier otro tipo.</span><span class="sxs-lookup"><span data-stu-id="69bb8-137">It also uses the discard pattern to handle non-null objects of any other type.</span></span>

:::code language="csharp" source="snippets/discards/discard-pattern2.cs" ID="DiscardSwitchExample" :::

## <a name="calls-to-methods-with-out-parameters"></a><span data-ttu-id="69bb8-138">Llamadas a métodos con parámetros `out`</span><span class="sxs-lookup"><span data-stu-id="69bb8-138">Calls to methods with `out` parameters</span></span>

<span data-ttu-id="69bb8-139">Cuando se llama al método `Deconstruct` para deconstruir un tipo definido por el usuario (una instancia de una clase, estructura o interfaz), puede descartar los valores de argumentos `out` individuales.</span><span class="sxs-lookup"><span data-stu-id="69bb8-139">When calling the `Deconstruct` method to deconstruct a user-defined type (an instance of a class, structure, or interface), you can discard the values of individual `out` arguments.</span></span> <span data-ttu-id="69bb8-140">Pero también puede descartar el valor de argumentos `out` al llamar a cualquier método con un parámetro `out`.</span><span class="sxs-lookup"><span data-stu-id="69bb8-140">But you can also discard the value of `out` arguments when calling any method with an `out` parameter.</span></span>

<span data-ttu-id="69bb8-141">En el ejemplo siguiente se llama al método [DateTime.TryParse(String, out DateTime)](<xref:System.DateTime.TryParse(System.String,System.DateTime@)>) para determinar si la representación de cadena de una fecha es válida en la referencia cultural actual.</span><span class="sxs-lookup"><span data-stu-id="69bb8-141">The following example calls the [DateTime.TryParse(String, out DateTime)](<xref:System.DateTime.TryParse(System.String,System.DateTime@)>) method to determine whether the string representation of a date is valid in the current culture.</span></span> <span data-ttu-id="69bb8-142">Dado que al ejemplo solo le interesa validar la cadena de fecha, y no analizarla para extraer la fecha, el argumento `out` para el método es un descarte.</span><span class="sxs-lookup"><span data-stu-id="69bb8-142">Because the example is concerned only with validating the date string and not with parsing it to extract the date, the `out` argument to the method is a discard.</span></span>

:::code language="csharp" source="snippets/discards/discard-out1.cs" ID="DiscardOutParameter" :::

## <a name="a-standalone-discard"></a><span data-ttu-id="69bb8-143">Descarte independiente</span><span class="sxs-lookup"><span data-stu-id="69bb8-143">A standalone discard</span></span>

<span data-ttu-id="69bb8-144">Puede usar un descarte independiente para indicar cualquier variable que decida omitir.</span><span class="sxs-lookup"><span data-stu-id="69bb8-144">You can use a standalone discard to indicate any variable that you choose to ignore.</span></span> <span data-ttu-id="69bb8-145">Un uso típico es usar una asignación para asegurarse de que un argumento no sea NULL.</span><span class="sxs-lookup"><span data-stu-id="69bb8-145">One typical use is to use an assignment to ensure that an argument isn't null.</span></span> <span data-ttu-id="69bb8-146">En el código siguiente se usa un descarte para forzar una asignación.</span><span class="sxs-lookup"><span data-stu-id="69bb8-146">The following code uses a discard to force an assignment.</span></span> <span data-ttu-id="69bb8-147">El lado derecho de la asignación utiliza el [operador de uso combinado de NULL](language-reference/operators/null-coalescing-operator.md) para producir <xref:System.ArgumentNullException?displayProperty=nameWithType> cuando el argumento es `null`.</span><span class="sxs-lookup"><span data-stu-id="69bb8-147">The right side of the assignment uses the [null coalescing operator](language-reference/operators/null-coalescing-operator.md) to throw an <xref:System.ArgumentNullException?displayProperty=nameWithType> when the argument is `null`.</span></span> <span data-ttu-id="69bb8-148">El código no necesita el resultado de la asignación, por lo que se descarta.</span><span class="sxs-lookup"><span data-stu-id="69bb8-148">The code doesn't need the result of the assignment, so it's discarded.</span></span> <span data-ttu-id="69bb8-149">La expresión fuerza una comprobación nula.</span><span class="sxs-lookup"><span data-stu-id="69bb8-149">The expression forces a null check.</span></span> <span data-ttu-id="69bb8-150">El descarte aclara su intención: el resultado de la asignación no es necesario ni se usa.</span><span class="sxs-lookup"><span data-stu-id="69bb8-150">The discard clarifies your intent: the result of the assignment isn't needed or used.</span></span>

:::code language="csharp" source="snippets/discards/standalone-discard1.cs" ID="ArgNullCheck" :::

<span data-ttu-id="69bb8-151">En el ejemplo siguiente se usa un descarte independiente para omitir el objeto <xref:System.Threading.Tasks.Task> devuelto por una operación asincrónica.</span><span class="sxs-lookup"><span data-stu-id="69bb8-151">The following example uses a standalone discard to ignore the <xref:System.Threading.Tasks.Task> object returned by an asynchronous operation.</span></span> <span data-ttu-id="69bb8-152">La asignación de la tarea tiene el efecto de suprimir la excepción que se produce en la operación cuando está a punto de completarse.</span><span class="sxs-lookup"><span data-stu-id="69bb8-152">Assigning the task has the effect of suppressing the exception that the operation throws as it is about to complete.</span></span> <span data-ttu-id="69bb8-153">Hace que su intención sea clara: Quiere descartar `Task` y omitir los errores generados a partir de esa operación asincrónica.</span><span class="sxs-lookup"><span data-stu-id="69bb8-153">It makes your intent clear: You want to discard the `Task`, and ignore any errors generated from that asynchronous operation.</span></span>

:::code language="csharp" source="snippets/discards/standalone-discard1.cs" ID="SnippetDiscardTask" :::

<span data-ttu-id="69bb8-154">Sin asignar la tarea a un descarte, el código siguiente genera una advertencia del compilador:</span><span class="sxs-lookup"><span data-stu-id="69bb8-154">Without assigning the task to a discard, the following code generates a compiler warning:</span></span>

:::code language="csharp" source="snippets/discards/standalone-discard1.cs" ID="SnippetNoDiscardTask" :::

> [!NOTE]
> <span data-ttu-id="69bb8-155">Si ejecuta cualquiera de los dos ejemplos anteriores mediante un depurador, este detendrá el programa cuando se produzca la excepción.</span><span class="sxs-lookup"><span data-stu-id="69bb8-155">If you run either of the preceding two samples using a debugger, the debugger will stop the program when the exception is thrown.</span></span> <span data-ttu-id="69bb8-156">Sin un depurador asociado, la excepción se omite en ambos casos en modo silencioso.</span><span class="sxs-lookup"><span data-stu-id="69bb8-156">Without a debugger attached, the exception is silently ignored in both cases.</span></span>

<span data-ttu-id="69bb8-157">`_` también es un identificador válido.</span><span class="sxs-lookup"><span data-stu-id="69bb8-157">`_` is also a valid identifier.</span></span> <span data-ttu-id="69bb8-158">Cuando se usa fuera de un contexto compatible, `_` no se trata como un descarte, sino como una variable válida.</span><span class="sxs-lookup"><span data-stu-id="69bb8-158">When used outside of a supported context, `_` is treated not as a discard but as a valid variable.</span></span> <span data-ttu-id="69bb8-159">Si un identificador denominado `_` ya está en el ámbito, el uso de `_` como descarte independiente puede producir lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="69bb8-159">If an identifier named `_` is already in scope, the use of `_` as a standalone discard can result in:</span></span>

- <span data-ttu-id="69bb8-160">La modificación accidental del valor de la variable `_` en el ámbito, al asignarle el valor del descarte previsto.</span><span class="sxs-lookup"><span data-stu-id="69bb8-160">Accidental modification of the value of the in-scope `_` variable by assigning it the value of the intended discard.</span></span> <span data-ttu-id="69bb8-161">Por ejemplo:</span><span class="sxs-lookup"><span data-stu-id="69bb8-161">For example:</span></span>
   :::code language="csharp" source="snippets/discards/standalone-discard2.cs" ID="VariableIdentifier" :::
- <span data-ttu-id="69bb8-162">Un error del compilador por infringir la seguridad de tipos.</span><span class="sxs-lookup"><span data-stu-id="69bb8-162">A compiler error for violating type safety.</span></span> <span data-ttu-id="69bb8-163">Por ejemplo:</span><span class="sxs-lookup"><span data-stu-id="69bb8-163">For example:</span></span>
   :::code language="csharp" source="snippets/discards/standalone-discard2.cs" ID="VariableTypeInference" :::
- <span data-ttu-id="69bb8-164">Error del compilador CS0136: "Una variable local o un parámetro denominados '\_' no se pueden declarar en este ámbito porque ese nombre se está usando en un ámbito local envolvente para definir una variable local o un parámetro".</span><span class="sxs-lookup"><span data-stu-id="69bb8-164">Compiler error CS0136, "A local or parameter named '\_' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter."</span></span> <span data-ttu-id="69bb8-165">Por ejemplo:</span><span class="sxs-lookup"><span data-stu-id="69bb8-165">For example:</span></span>
   :::code language="csharp" source="snippets/discards/standalone-discard2.cs" ID="CannotRedeclare" :::

## <a name="see-also"></a><span data-ttu-id="69bb8-166">Consulte también</span><span class="sxs-lookup"><span data-stu-id="69bb8-166">See also</span></span>

- [<span data-ttu-id="69bb8-167">Deconstruir tuplas y otros tipos</span><span class="sxs-lookup"><span data-stu-id="69bb8-167">Deconstructing tuples and other types</span></span>](deconstruct.md)
- [<span data-ttu-id="69bb8-168">Palabra clave `is`</span><span class="sxs-lookup"><span data-stu-id="69bb8-168">`is` keyword</span></span>](language-reference/keywords/is.md)
- [<span data-ttu-id="69bb8-169">Palabra clave `switch`</span><span class="sxs-lookup"><span data-stu-id="69bb8-169">`switch` keyword</span></span>](language-reference/keywords/switch.md)
