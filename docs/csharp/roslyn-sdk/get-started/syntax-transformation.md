---
title: Introducción a la transformación de sintaxis (API de Roslyn)
description: Introducción para recorrer y consultar árboles de sintaxis.
ms.date: 06/01/2018
ms.custom: mvc
ms.openlocfilehash: 706e4643ecc81d252a9192dc5e8850024770628f
ms.sourcegitcommit: 456b3cd82a87b453fa737b4661295070d1b6d684
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 02/17/2021
ms.locfileid: "100639408"
---
# <a name="get-started-with-syntax-transformation"></a><span data-ttu-id="978e3-103">Introducción a la transformación de sintaxis</span><span class="sxs-lookup"><span data-stu-id="978e3-103">Get started with syntax transformation</span></span>

<span data-ttu-id="978e3-104">Este tutorial se basa en conceptos y técnicas explorados en los tutoriales rápidos [Introducción al análisis de sintaxis](syntax-analysis.md) e [Introducción al análisis semántico](semantic-analysis.md).</span><span class="sxs-lookup"><span data-stu-id="978e3-104">This tutorial builds on concepts and techniques explored in the [Get started with syntax analysis](syntax-analysis.md) and [Get started with semantic analysis](semantic-analysis.md) quickstarts.</span></span> <span data-ttu-id="978e3-105">Si aún no lo ha hecho, debería completar esos tutoriales antes de comenzar con este.</span><span class="sxs-lookup"><span data-stu-id="978e3-105">If you haven't already, you should complete those quickstarts before beginning this one.</span></span>

<span data-ttu-id="978e3-106">En este tutorial rápido, se exploran las técnicas para crear y transformar árboles de sintaxis.</span><span class="sxs-lookup"><span data-stu-id="978e3-106">In this quickstart, you explore techniques for creating and transforming syntax trees.</span></span> <span data-ttu-id="978e3-107">En combinación con las técnicas que aprendió en los tutoriales anteriores, podrá crear la primera refactorización de línea de comandos.</span><span class="sxs-lookup"><span data-stu-id="978e3-107">In combination with the techniques you learned in previous quickstarts, you create your first command-line refactoring!</span></span>

[!INCLUDE[interactive-note](~/includes/roslyn-installation.md)]

## <a name="immutability-and-the-net-compiler-platform"></a><span data-ttu-id="978e3-108">Inmutabilidad y .NET Compiler Platform</span><span class="sxs-lookup"><span data-stu-id="978e3-108">Immutability and the .NET compiler platform</span></span>

<span data-ttu-id="978e3-109">La **inmutabilidad** es un principio fundamental de .NET Compiler Platform.</span><span class="sxs-lookup"><span data-stu-id="978e3-109">**Immutability** is a fundamental tenet of the .NET compiler platform.</span></span> <span data-ttu-id="978e3-110">Las estructuras de datos inmutables no se pueden cambiar una vez creadas.</span><span class="sxs-lookup"><span data-stu-id="978e3-110">Immutable data structures can't be changed after they're created.</span></span> <span data-ttu-id="978e3-111">Las estructuras de datos inmutables se pueden compartir y someter al análisis de varios consumidores al mismo tiempo sin riesgo alguno.</span><span class="sxs-lookup"><span data-stu-id="978e3-111">Immutable data structures can be safely shared and analyzed by multiple consumers simultaneously.</span></span> <span data-ttu-id="978e3-112">No se corre el peligro de que la acción de un consumidor afecte a otro de manera impredecible.</span><span class="sxs-lookup"><span data-stu-id="978e3-112">There's no danger that one consumer affects another in unpredictable ways.</span></span> <span data-ttu-id="978e3-113">El analizador no necesita bloqueos u otras medidas de simultaneidad.</span><span class="sxs-lookup"><span data-stu-id="978e3-113">Your analyzer doesn't need locks or other concurrency measures.</span></span> <span data-ttu-id="978e3-114">Esta regla se aplica a los árboles de sintaxis, las compilaciones, los símbolos, los modelos semánticos y cualquier otra estructura de datos que encuentre.</span><span class="sxs-lookup"><span data-stu-id="978e3-114">This rule applies to syntax trees, compilations, symbols, semantic models, and every other data structure you encounter.</span></span> <span data-ttu-id="978e3-115">En lugar de modificar las estructuras existentes, las API crean nuevos objetos según las diferencias especificadas en los antiguos.</span><span class="sxs-lookup"><span data-stu-id="978e3-115">Instead of modifying existing structures, APIs create new objects based on specified differences to the old ones.</span></span> <span data-ttu-id="978e3-116">Este concepto se aplica a los árboles de sintaxis para crear nuevos árboles que usan transformaciones.</span><span class="sxs-lookup"><span data-stu-id="978e3-116">You apply this concept to syntax trees to create new trees using transformations.</span></span>

## <a name="create-and-transform-trees"></a><span data-ttu-id="978e3-117">Creación y transformación de árboles</span><span class="sxs-lookup"><span data-stu-id="978e3-117">Create and transform trees</span></span>

<span data-ttu-id="978e3-118">Elija una de las dos estrategias para las transformaciones de sintaxis.</span><span class="sxs-lookup"><span data-stu-id="978e3-118">You choose one of two strategies for syntax transformations.</span></span> <span data-ttu-id="978e3-119">Los patrones de diseño **Factory Method** son útiles cuando se buscan nodos específicos para reemplazar, o ubicaciones específicas donde desea insertar el nuevo código.</span><span class="sxs-lookup"><span data-stu-id="978e3-119">**Factory methods** are best used when you're searching for specific nodes to replace, or specific locations where you want to insert new code.</span></span> <span data-ttu-id="978e3-120">Las **reescrituras** son la mejor opción si desea buscar patrones de código que se van a reemplazar en todo un proyecto.</span><span class="sxs-lookup"><span data-stu-id="978e3-120">**Rewriters** are best when you want to scan an entire project for code patterns that you want to replace.</span></span>

### <a name="create-nodes-with-factory-methods"></a><span data-ttu-id="978e3-121">Creación de nodos con patrones de diseño Factory Method</span><span class="sxs-lookup"><span data-stu-id="978e3-121">Create nodes with factory methods</span></span>

<span data-ttu-id="978e3-122">En la primera transformación de sintaxis se muestran los patrones de diseño Factory Method.</span><span class="sxs-lookup"><span data-stu-id="978e3-122">The first syntax transformation demonstrates the factory methods.</span></span> <span data-ttu-id="978e3-123">Va a reemplazar una instrucción `using System.Collections;` por una instrucción `using System.Collections.Generic;`.</span><span class="sxs-lookup"><span data-stu-id="978e3-123">You're going to replace a `using System.Collections;` statement with a `using System.Collections.Generic;` statement.</span></span> <span data-ttu-id="978e3-124">En este ejemplo se muestra cómo crear objetos <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode?displayProperty=nameWithType> mediante los patrones de diseño Factory Method <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="978e3-124">This example demonstrates how you create <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode?displayProperty=nameWithType> objects using the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> factory methods.</span></span> <span data-ttu-id="978e3-125">Para cada tipo de **nodo**, **token** o **curiosidades** hay un patrón Factory Method que crea una instancia de ese tipo.</span><span class="sxs-lookup"><span data-stu-id="978e3-125">For each kind of **node**, **token**, or **trivia** there's a factory method that creates an instance of that type.</span></span> <span data-ttu-id="978e3-126">Creará árboles de sintaxis mediante la composición de nodos jerárquicamente de abajo arriba.</span><span class="sxs-lookup"><span data-stu-id="978e3-126">You create syntax trees by composing nodes hierarchically in a bottom-up fashion.</span></span> <span data-ttu-id="978e3-127">Luego, transformará el programa existente para reemplazar los nodos existentes por el nuevo árbol que ha creado.</span><span class="sxs-lookup"><span data-stu-id="978e3-127">Then, you'll transform the existing program be replacing existing nodes with the new tree you've created.</span></span>

<span data-ttu-id="978e3-128">Inicie Visual Studio y cree un proyecto de **Stand-Alone Code Analysis Tool** (Herramienta de análisis de código independiente) de C#.</span><span class="sxs-lookup"><span data-stu-id="978e3-128">Start Visual Studio, and create a new C# **Stand-Alone Code Analysis Tool** project.</span></span> <span data-ttu-id="978e3-129">En Visual Studio, elija **Archivo** > **Nuevo** > **Proyecto** para mostrar el cuadro de diálogo Nuevo proyecto.</span><span class="sxs-lookup"><span data-stu-id="978e3-129">In Visual Studio, choose **File** > **New** > **Project** to display the New Project dialog.</span></span> <span data-ttu-id="978e3-130">En **Visual C#**  > **Extensibilidad**, elija **Stand-Alone Code Analysis Tool** (Herramienta de análisis de código independiente).</span><span class="sxs-lookup"><span data-stu-id="978e3-130">Under **Visual C#** > **Extensibility** choose a **Stand-Alone Code Analysis Tool**.</span></span> <span data-ttu-id="978e3-131">Este tutorial rápido tiene dos proyectos de ejemplo, así que llame a la solución **SyntaxTransformationQuickStart** y al proyecto **ConstructionCS**.</span><span class="sxs-lookup"><span data-stu-id="978e3-131">This quickstart has two example projects, so name the solution **SyntaxTransformationQuickStart**, and name the project **ConstructionCS**.</span></span> <span data-ttu-id="978e3-132">Haga clic en **Aceptar**.</span><span class="sxs-lookup"><span data-stu-id="978e3-132">Click **OK**.</span></span>

<span data-ttu-id="978e3-133">Este proyecto usa los métodos de clase <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> para construir un <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType> que representa el espacio de nombres `System.Collections.Generic`.</span><span class="sxs-lookup"><span data-stu-id="978e3-133">This project uses the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> class methods to construct a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType> representing the `System.Collections.Generic` namespace.</span></span>

<span data-ttu-id="978e3-134">Agregue esta directiva a la parte superior de `Program.cs`.</span><span class="sxs-lookup"><span data-stu-id="978e3-134">Add the following using directive to the top of the `Program.cs`.</span></span>

[!code-csharp[import the SyntaxFactory class](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#StaticUsings "import the Syntax Factory class and the System.Console class")]

<span data-ttu-id="978e3-135">Creará **nodos de sintaxis de nombre** para generar el árbol que representa la instrucción `using System.Collections.Generic;`.</span><span class="sxs-lookup"><span data-stu-id="978e3-135">You'll create **name syntax nodes** to build the tree that represents the `using System.Collections.Generic;` statement.</span></span> <span data-ttu-id="978e3-136"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> es la clase base para los cuatro tipos de nombres que aparecen en C#.</span><span class="sxs-lookup"><span data-stu-id="978e3-136"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> is the base class for four types of names that appear in C#.</span></span> <span data-ttu-id="978e3-137">Junte estos cuatro tipos de nombres para crear cualquier nombre que pueda aparecer en el lenguaje C#:</span><span class="sxs-lookup"><span data-stu-id="978e3-137">You compose these four types of names together to create any name that can appear in the C# language:</span></span>

* <span data-ttu-id="978e3-138"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType>, que representa los nombres de identificador único simple, como `System` y `Microsoft`.</span><span class="sxs-lookup"><span data-stu-id="978e3-138"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType>, which represents simple single identifier names like `System` and `Microsoft`.</span></span>
* <span data-ttu-id="978e3-139"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax?displayProperty=nameWithType>, que representa un nombre de tipo o método genérico, como `List<int>`.</span><span class="sxs-lookup"><span data-stu-id="978e3-139"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax?displayProperty=nameWithType>, which represents a generic type or method name such as `List<int>`.</span></span>
* <span data-ttu-id="978e3-140"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax?displayProperty=nameWithType>, que representa un nombre completo del formulario `<left-name>.<right-identifier-or-generic-name>`, como `System.IO`.</span><span class="sxs-lookup"><span data-stu-id="978e3-140"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax?displayProperty=nameWithType>, which represents a qualified name of the form `<left-name>.<right-identifier-or-generic-name>` such as `System.IO`.</span></span>
* <span data-ttu-id="978e3-141"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax?displayProperty=nameWithType>, que representa un nombre que usa un alias de ensamblado externo, como `LibraryV2::Foo`.</span><span class="sxs-lookup"><span data-stu-id="978e3-141"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax?displayProperty=nameWithType>, which represents a name using an assembly extern alias such a `LibraryV2::Foo`.</span></span>

<span data-ttu-id="978e3-142">Use el método <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IdentifierName(System.String)> para crear un nodo <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax>.</span><span class="sxs-lookup"><span data-stu-id="978e3-142">You use the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IdentifierName(System.String)> method to create a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> node.</span></span> <span data-ttu-id="978e3-143">Agregue el código siguiente al método `Main` en `Program.cs`:</span><span class="sxs-lookup"><span data-stu-id="978e3-143">Add the following code in your `Main` method in `Program.cs`:</span></span>

[!code-csharp[create the system identifier](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateIdentifierName "Create and display the system name identifier")]

<span data-ttu-id="978e3-144">El código anterior crea un objeto <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> y lo asigna a la variable `name`.</span><span class="sxs-lookup"><span data-stu-id="978e3-144">The preceding code creates an <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> object and assigns it to the variable `name`.</span></span> <span data-ttu-id="978e3-145">Muchas de las API de Roslyn devuelven clases base para que sea más fácil trabajar con tipos relacionados.</span><span class="sxs-lookup"><span data-stu-id="978e3-145">Many of the Roslyn APIs return base classes to make it easier to work with related types.</span></span> <span data-ttu-id="978e3-146">La variable `name`, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax>, puede volver a usarse al crear <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span><span class="sxs-lookup"><span data-stu-id="978e3-146">The variable `name`, an <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax>, can be reused as you build the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span></span> <span data-ttu-id="978e3-147">No use la inferencia de tipo al crear el ejemplo.</span><span class="sxs-lookup"><span data-stu-id="978e3-147">Don't use type inference as you build the sample.</span></span> <span data-ttu-id="978e3-148">Podrá automatizar ese paso en este proyecto.</span><span class="sxs-lookup"><span data-stu-id="978e3-148">You'll automate that step in this project.</span></span>

<span data-ttu-id="978e3-149">Ha creado el nombre.</span><span class="sxs-lookup"><span data-stu-id="978e3-149">You've created the name.</span></span> <span data-ttu-id="978e3-150">Ahora, es el momento de crear más nodos en el árbol mediante la creación de <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span><span class="sxs-lookup"><span data-stu-id="978e3-150">Now, it's time to build more nodes into the tree by building a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span></span> <span data-ttu-id="978e3-151">El nuevo árbol usa `name` como parte izquierda del nombre, y un nuevo <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> para el espacio de nombres `Collections` como parte derecha de <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span><span class="sxs-lookup"><span data-stu-id="978e3-151">The new tree uses `name` as the left of the name, and a new <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> for the `Collections` namespace as the right side of the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span></span> <span data-ttu-id="978e3-152">Agrega el código siguiente a `program.cs`:</span><span class="sxs-lookup"><span data-stu-id="978e3-152">Add the following code to `program.cs`:</span></span>

[!code-csharp[create the collections identifier](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateQualifiedIdentifierName "Build the System.Collections identifier")]

<span data-ttu-id="978e3-153">Vuelva a ejecutar el código y observe los resultados.</span><span class="sxs-lookup"><span data-stu-id="978e3-153">Run the code again, and see the results.</span></span> <span data-ttu-id="978e3-154">Está creando un árbol de nodos que representa código.</span><span class="sxs-lookup"><span data-stu-id="978e3-154">You're building a tree of nodes that represents code.</span></span> <span data-ttu-id="978e3-155">Continuará con este patrón para compilar <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax> para el espacio de nombres `System.Collections.Generic`.</span><span class="sxs-lookup"><span data-stu-id="978e3-155">You'll continue this pattern to build the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax> for the namespace `System.Collections.Generic`.</span></span> <span data-ttu-id="978e3-156">Agrega el código siguiente a `Program.cs`:</span><span class="sxs-lookup"><span data-stu-id="978e3-156">Add the following code to `Program.cs`:</span></span>

[!code-csharp[create the full identifier](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateFullNamespace "Build the System.Collections.Generic identifier")]

<span data-ttu-id="978e3-157">Ejecute el programa de nuevo para ver si ha creado el árbol para agregar el código.</span><span class="sxs-lookup"><span data-stu-id="978e3-157">Run the program again to see that you've built the tree for the code to add.</span></span>

### <a name="create-a-modified-tree"></a><span data-ttu-id="978e3-158">Creación de un árbol modificado</span><span class="sxs-lookup"><span data-stu-id="978e3-158">Create a modified tree</span></span>

<span data-ttu-id="978e3-159">Ha creado un pequeño árbol de sintaxis que contiene una instrucción.</span><span class="sxs-lookup"><span data-stu-id="978e3-159">You've built a small syntax tree that contains one statement.</span></span> <span data-ttu-id="978e3-160">Las API para crear nuevos nodos son la opción correcta para crear instrucciones únicas u otros bloques de código pequeño.</span><span class="sxs-lookup"><span data-stu-id="978e3-160">The APIs to create new nodes are the right choice to create single statements or other small code blocks.</span></span> <span data-ttu-id="978e3-161">Sin embargo, para generar bloques más grandes de código, debe usar los métodos que reemplazan nodos o insertan nodos en un árbol existente.</span><span class="sxs-lookup"><span data-stu-id="978e3-161">However, to build larger blocks of code, you should use methods that replace nodes or insert nodes into an existing tree.</span></span> <span data-ttu-id="978e3-162">Recuerde que los árboles de sintaxis son inmutables.</span><span class="sxs-lookup"><span data-stu-id="978e3-162">Remember that syntax trees are immutable.</span></span> <span data-ttu-id="978e3-163">La **API de sintaxis** no proporciona ningún mecanismo para modificar un árbol de sintaxis existente después de la construcción.</span><span class="sxs-lookup"><span data-stu-id="978e3-163">The **Syntax API** doesn't provide any mechanism for modifying an existing syntax tree after construction.</span></span> <span data-ttu-id="978e3-164">En su lugar, proporciona métodos que generan nuevos árboles en función de los cambios en los existentes.</span><span class="sxs-lookup"><span data-stu-id="978e3-164">Instead, it provides methods that produce new trees based on changes to existing ones.</span></span> <span data-ttu-id="978e3-165">Se han definido métodos `With*` en clases concretas que se derivan de <xref:Microsoft.CodeAnalysis.SyntaxNode> o en métodos de extensión declarados en la clase <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions>.</span><span class="sxs-lookup"><span data-stu-id="978e3-165">`With*` methods are defined in concrete classes that derive from <xref:Microsoft.CodeAnalysis.SyntaxNode> or in extension methods declared in the <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions> class.</span></span> <span data-ttu-id="978e3-166">Estos métodos crean un nuevo nodo al aplicar cambios a las propiedades del elemento secundario de un nodo existente.</span><span class="sxs-lookup"><span data-stu-id="978e3-166">These methods create a new node by applying changes to an existing node's child properties.</span></span> <span data-ttu-id="978e3-167">Además, el método de extensión <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> se puede utilizar para reemplazar un nodo descendiente en un subárbol.</span><span class="sxs-lookup"><span data-stu-id="978e3-167">Additionally, the <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> extension method can be used to replace a descendent node in a subtree.</span></span> <span data-ttu-id="978e3-168">Este método también actualiza el elemento primario para que apunte al formulario secundario recién creado y repite este proceso por todo el árbol: un proceso conocido como _volver a hacer girar el árbol_.</span><span class="sxs-lookup"><span data-stu-id="978e3-168">This method also updates the parent to point to the newly created child and repeats this process up the entire tree - a process known as _re-spinning_ the tree.</span></span>

<span data-ttu-id="978e3-169">El siguiente paso consiste en crear un árbol que representa todo un programa (pequeño) y, a continuación, modificarlo.</span><span class="sxs-lookup"><span data-stu-id="978e3-169">The next step is to create a tree that represents an entire (small) program and then modify it.</span></span> <span data-ttu-id="978e3-170">Agregue el siguiente código al principio de la clase `Program`:</span><span class="sxs-lookup"><span data-stu-id="978e3-170">Add the following code to the beginning of the `Program` class:</span></span>

[!code-csharp[create a parse tree](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#DeclareSampleCode "Create a tree that represents a small program")]

> [!NOTE]
> <span data-ttu-id="978e3-171">El código de ejemplo utiliza el espacio de nombres `System.Collections` y no el espacio de nombres `System.Collections.Generic`.</span><span class="sxs-lookup"><span data-stu-id="978e3-171">The example code uses the `System.Collections` namespace and not the `System.Collections.Generic` namespace.</span></span>

<span data-ttu-id="978e3-172">A continuación, agregue el código siguiente a la parte inferior del método `Main` para analizar el texto y crear un árbol:</span><span class="sxs-lookup"><span data-stu-id="978e3-172">Next, add the following code to the bottom of the `Main` method to parse the text and create a tree:</span></span>

[!code-csharp[create a parse tree](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateParseTree "Create a tree that represents a small program")]

<span data-ttu-id="978e3-173">En este ejemplo se utiliza el método <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)?displayProperty=NameWithType> para reemplazar el nombre de un nodo <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> por el que se creó en el código anterior.</span><span class="sxs-lookup"><span data-stu-id="978e3-173">This example uses the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)?displayProperty=NameWithType> method to replace the name in a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> node with the one constructed in the preceding code.</span></span>

<span data-ttu-id="978e3-174">Cree un nuevo nodo <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> mediante el método <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)> para actualizar el nombre `System.Collections` con el nombre que creó en el código anterior.</span><span class="sxs-lookup"><span data-stu-id="978e3-174">Create a new <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> node using the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)> method to update the `System.Collections` name with the name you created in the preceding code.</span></span> <span data-ttu-id="978e3-175">Agregue el siguiente código en la parte inferior del método `Main`:</span><span class="sxs-lookup"><span data-stu-id="978e3-175">Add the following code to the bottom of the `Main` method:</span></span>

[!code-csharp[create a new subtree](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#BuildNewUsing "Create the subtree with the replaced namespace")]

<span data-ttu-id="978e3-176">Ejecute el programa y observe con detenimiento el resultado.</span><span class="sxs-lookup"><span data-stu-id="978e3-176">Run the program and look carefully at the output.</span></span> <span data-ttu-id="978e3-177">`newUsing` todavía no se ha colocado en el árbol de la raíz.</span><span class="sxs-lookup"><span data-stu-id="978e3-177">The `newUsing` hasn't been placed in the root tree.</span></span> <span data-ttu-id="978e3-178">No se ha modificado el árbol original.</span><span class="sxs-lookup"><span data-stu-id="978e3-178">The original tree hasn't been changed.</span></span>

<span data-ttu-id="978e3-179">Agregue el siguiente código utilizando el método de extensión <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> para crear un nuevo árbol.</span><span class="sxs-lookup"><span data-stu-id="978e3-179">Add the following code using the <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> extension method to create a new tree.</span></span> <span data-ttu-id="978e3-180">El nuevo árbol es el resultado de reemplazar la importación existente por el nodo `newUsing` actualizado.</span><span class="sxs-lookup"><span data-stu-id="978e3-180">The new tree is the result of replacing the existing import with the updated `newUsing` node.</span></span> <span data-ttu-id="978e3-181">Asigne este nuevo árbol a la variable `root` existente:</span><span class="sxs-lookup"><span data-stu-id="978e3-181">You assign this new tree to the existing `root` variable:</span></span>

[!code-csharp[create a new root tree](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#TransformTree "Create the transformed root tree with the replaced namespace")]

<span data-ttu-id="978e3-182">Ejecute el programa otra vez.</span><span class="sxs-lookup"><span data-stu-id="978e3-182">Run the program again.</span></span> <span data-ttu-id="978e3-183">Esta vez el árbol importa correctamente el espacio de nombres `System.Collections.Generic`.</span><span class="sxs-lookup"><span data-stu-id="978e3-183">This time the tree now correctly imports the `System.Collections.Generic` namespace.</span></span>

### <a name="transform-trees-using-syntaxrewriters"></a><span data-ttu-id="978e3-184">Transformación de árboles mediante `SyntaxRewriters`</span><span class="sxs-lookup"><span data-stu-id="978e3-184">Transform trees using `SyntaxRewriters`</span></span>

<span data-ttu-id="978e3-185">Los métodos `With*` y <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> proporcionan un medio cómodo para transformar ramas individuales de un árbol de sintaxis.</span><span class="sxs-lookup"><span data-stu-id="978e3-185">The `With*` and <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> methods provide convenient means to transform individual branches of a syntax tree.</span></span> <span data-ttu-id="978e3-186">La clase <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> realiza varias transformaciones en un árbol de sintaxis.</span><span class="sxs-lookup"><span data-stu-id="978e3-186">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> class performs multiple transformations on a syntax tree.</span></span> <span data-ttu-id="978e3-187">La clase <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> es una subclase de <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor%601?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="978e3-187">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> class is a subclass of <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="978e3-188"><xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> aplica una transformación a un tipo específico de <xref:Microsoft.CodeAnalysis.SyntaxNode>.</span><span class="sxs-lookup"><span data-stu-id="978e3-188">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> applies a transformation to a specific type of <xref:Microsoft.CodeAnalysis.SyntaxNode>.</span></span> <span data-ttu-id="978e3-189">Puede aplicar transformaciones a varios tipos de objetos <xref:Microsoft.CodeAnalysis.SyntaxNode> dondequiera que aparezcan en un árbol de sintaxis.</span><span class="sxs-lookup"><span data-stu-id="978e3-189">You can apply transformations to multiple types of <xref:Microsoft.CodeAnalysis.SyntaxNode> objects wherever they appear in a syntax tree.</span></span> <span data-ttu-id="978e3-190">En el segundo proyecto de este tutorial rápido se crea una refactorización de línea de comandos que quita tipos explícitos en declaraciones de variable local en cualquier lugar en que pudiera utilizarse una inferencia de tipos.</span><span class="sxs-lookup"><span data-stu-id="978e3-190">The second project in this quickstart creates a command-line refactoring that removes explicit types in local variable declarations anywhere that type inference could be used.</span></span>

<span data-ttu-id="978e3-191">Cree un proyecto de **Stand-Alone Code Analysis Tool** (Herramienta de análisis de código independiente) de C#.</span><span class="sxs-lookup"><span data-stu-id="978e3-191">Create a new C# **Stand-Alone Code Analysis Tool** project.</span></span> <span data-ttu-id="978e3-192">En Visual Studio, haga clic en el nodo de la solución `SyntaxTransformationQuickStart`.</span><span class="sxs-lookup"><span data-stu-id="978e3-192">In Visual Studio, right-click the `SyntaxTransformationQuickStart` solution node.</span></span> <span data-ttu-id="978e3-193">Elija **Agregar** > **Nuevo proyecto** para mostrar el **cuadro de diálogo Nuevo proyecto**.</span><span class="sxs-lookup"><span data-stu-id="978e3-193">Choose **Add** > **New Project** to display the **New Project dialog**.</span></span> <span data-ttu-id="978e3-194">En **Visual C#**  > **Extensibilidad**, elija **Stand-Alone Code Analysis Tool** (Herramienta de análisis de código independiente).</span><span class="sxs-lookup"><span data-stu-id="978e3-194">Under **Visual C#** > **Extensibility**, choose **Stand-Alone Code Analysis Tool**.</span></span> <span data-ttu-id="978e3-195">Proporcione un nombre al proyecto `TransformationCS` y haga clic en Aceptar.</span><span class="sxs-lookup"><span data-stu-id="978e3-195">Name your project `TransformationCS` and click OK.</span></span>

<span data-ttu-id="978e3-196">El primer paso es crear una clase que se derive de <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> para realizar las transformaciones.</span><span class="sxs-lookup"><span data-stu-id="978e3-196">The first step is to create a class that derives from <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> to perform your transformations.</span></span> <span data-ttu-id="978e3-197">Agregue un nuevo archivo de clase al proyecto.</span><span class="sxs-lookup"><span data-stu-id="978e3-197">Add a new class file to the project.</span></span> <span data-ttu-id="978e3-198">En Visual Studio, elija **Proyecto** > **Agregar clase...** . En el cuadro de diálogo **Agregar nuevo elemento**, escriba `TypeInferenceRewriter.cs` como nombre de archivo.</span><span class="sxs-lookup"><span data-stu-id="978e3-198">In Visual Studio, choose **Project** > **Add Class...**. In the **Add New Item** dialog type `TypeInferenceRewriter.cs` as the filename.</span></span>

<span data-ttu-id="978e3-199">Agregue las siguientes directivas using al archivo `TypeInferenceRewriter.cs`:</span><span class="sxs-lookup"><span data-stu-id="978e3-199">Add the following using directives to the `TypeInferenceRewriter.cs` file:</span></span>

[!code-csharp[add necessary usings](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#AddUsings "Add required usings")]

<span data-ttu-id="978e3-200">A continuación, haga que la clase `TypeInferenceRewriter` se extienda a la clase <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter>:</span><span class="sxs-lookup"><span data-stu-id="978e3-200">Next, make the `TypeInferenceRewriter` class extend the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> class:</span></span>

[!code-csharp[add base class](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#BaseClass "Add base class")]

<span data-ttu-id="978e3-201">Agregue el código siguiente para declarar un campo privado de solo lectura para que contenga un <xref:Microsoft.CodeAnalysis.SemanticModel> e inicializarlo en el constructor.</span><span class="sxs-lookup"><span data-stu-id="978e3-201">Add the following code to declare a private read-only field to hold a <xref:Microsoft.CodeAnalysis.SemanticModel> and initialize it in the constructor.</span></span> <span data-ttu-id="978e3-202">Necesitará este campo más adelante para determinar donde se puede usar la inferencia de tipos:</span><span class="sxs-lookup"><span data-stu-id="978e3-202">You will need this field later on to determine where type inference can be used:</span></span>

[!code-csharp[initialize members](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#Construction "Declare and initialize member variables")]

<span data-ttu-id="978e3-203">Invalide el método <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)>:</span><span class="sxs-lookup"><span data-stu-id="978e3-203">Override the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> method:</span></span>

```csharp
public override SyntaxNode VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node)
{

}
```

> [!NOTE]
> <span data-ttu-id="978e3-204">Muchas de las API de Roslyn declaran tipos de valor devuelto que son clases base de los tipos en tiempo de ejecución reales devueltos.</span><span class="sxs-lookup"><span data-stu-id="978e3-204">Many of the Roslyn APIs declare return types that are base classes of the actual runtime types returned.</span></span> <span data-ttu-id="978e3-205">En muchos escenarios, un tipo de nodo puede reemplazarse por otro tipo de nodo por completo, e incluso eliminarse.</span><span class="sxs-lookup"><span data-stu-id="978e3-205">In many scenarios, one kind of node may be replaced by another kind of node entirely - or even removed.</span></span> <span data-ttu-id="978e3-206">En este ejemplo, el método <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> devuelve un <xref:Microsoft.CodeAnalysis.SyntaxNode>, en lugar del tipo derivado de <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax>.</span><span class="sxs-lookup"><span data-stu-id="978e3-206">In this example, the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> method returns a <xref:Microsoft.CodeAnalysis.SyntaxNode>, instead of the derived type of   <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax>.</span></span> <span data-ttu-id="978e3-207">Este sistema de reescritura devuelve un nuevo nodo <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> basado en el existente.</span><span class="sxs-lookup"><span data-stu-id="978e3-207">This rewriter returns a new <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> node based on the existing one.</span></span>

<span data-ttu-id="978e3-208">Este tutorial rápido controla las declaraciones de variable locales.</span><span class="sxs-lookup"><span data-stu-id="978e3-208">This quickstart handles local variable declarations.</span></span> <span data-ttu-id="978e3-209">Puede ampliarlo para otras declaraciones como bucles `foreach`, bucles `for`, expresiones LINQ y expresiones lambda.</span><span class="sxs-lookup"><span data-stu-id="978e3-209">You could extend it to other declarations such as `foreach` loops, `for` loops, LINQ expressions, and lambda expressions.</span></span> <span data-ttu-id="978e3-210">Además, este sistema de reescritura transformará solo las declaraciones de la forma más sencilla:</span><span class="sxs-lookup"><span data-stu-id="978e3-210">Furthermore this rewriter will only transform declarations of the simplest form:</span></span>

```csharp
Type variable = expression;
```

<span data-ttu-id="978e3-211">Si desea explorar por su cuenta, considere la posibilidad de extender el ejemplo finalizado para estos tipos de declaraciones de variable:</span><span class="sxs-lookup"><span data-stu-id="978e3-211">If you want to explore on your own, consider extending the finished sample for these types of variable declarations:</span></span>

```csharp
// Multiple variables in a single declaration.
Type variable1 = expression1,
     variable2 = expression2;
// No initializer.
Type variable;
```

<span data-ttu-id="978e3-212">Agregue el código siguiente al cuerpo del método `VisitLocalDeclarationStatement` para que omita la reescritura de estas formas de declaraciones:</span><span class="sxs-lookup"><span data-stu-id="978e3-212">Add the following code to the body of the `VisitLocalDeclarationStatement` method to skip rewriting these forms of declarations:</span></span>

[!code-csharp[exclude other declarations](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#Exclusions "Exclude variables declarations not processed by this sample")]

<span data-ttu-id="978e3-213">El método indica que no se realiza la reescritura mediante la devolución del parámetro `node` sin modificar.</span><span class="sxs-lookup"><span data-stu-id="978e3-213">The method indicates that no rewriting takes place by returning the `node` parameter unmodified.</span></span> <span data-ttu-id="978e3-214">Si ninguna de esas expresiones `if` son verdaderas, el nodo representa una declaración posible con la inicialización.</span><span class="sxs-lookup"><span data-stu-id="978e3-214">If neither of those `if` expressions are true, the node represents a possible declaration with initialization.</span></span> <span data-ttu-id="978e3-215">Agregue estas instrucciones para extraer el nombre del tipo especificado en la declaración y asócielo con el campo <xref:Microsoft.CodeAnalysis.SemanticModel> para obtener un símbolo de tipo:</span><span class="sxs-lookup"><span data-stu-id="978e3-215">Add these statements to extract the type name specified in the declaration and bind it using the <xref:Microsoft.CodeAnalysis.SemanticModel> field to obtain a type symbol:</span></span>

[!code-csharp[extract type name](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#ExtractTypeSymbol "Extract the type name specified by the declaration")]

<span data-ttu-id="978e3-216">Ahora, agregue esta instrucción para enlazar la expresión de inicializador:</span><span class="sxs-lookup"><span data-stu-id="978e3-216">Now, add this statement to bind the initializer expression:</span></span>

[!code-csharp[bind initializer](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#BindInitializer "Bind the initializer expressions")]

<span data-ttu-id="978e3-217">Por último, agregue la siguiente instrucción `if` para reemplazar el nombre de tipo existente por la palabra clave `var` si el tipo de la expresión de inicializador coincide con el tipo especificado:</span><span class="sxs-lookup"><span data-stu-id="978e3-217">Finally, add the following `if` statement to replace the existing type name with the `var` keyword if the type of the initializer expression matches the type specified:</span></span>

[!code-csharp[ReplaceNode](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#ReplaceNode "Replace the initializer node")]

<span data-ttu-id="978e3-218">El atributo condicional es necesario porque la declaración puede convertir la expresión de inicializador en una interfaz o clase base.</span><span class="sxs-lookup"><span data-stu-id="978e3-218">The conditional is required because the declaration may cast the initializer expression to a base class or interface.</span></span> <span data-ttu-id="978e3-219">Si se desea, los tipos del lado izquierdo y derecho de la asignación no coinciden.</span><span class="sxs-lookup"><span data-stu-id="978e3-219">If that's desired, the types on the left and right-hand side of the assignment don't match.</span></span> <span data-ttu-id="978e3-220">El hecho de quitar el tipo explícito en estos casos también cambiaría la semántica de un programa.</span><span class="sxs-lookup"><span data-stu-id="978e3-220">Removing the explicit type in these cases would change the semantics of a program.</span></span> <span data-ttu-id="978e3-221">`var` se especifica como un identificador en lugar de una palabra clave porque `var` es una palabra clave contextual.</span><span class="sxs-lookup"><span data-stu-id="978e3-221">`var` is specified as an identifier rather than a keyword because `var` is a contextual keyword.</span></span> <span data-ttu-id="978e3-222">Las curiosidades iniciales y finales (espacios en blanco) se transfieren desde el nombre de tipo anterior a la palabra clave `var` para mantener el espacio en blanco vertical y la sangría.</span><span class="sxs-lookup"><span data-stu-id="978e3-222">The leading and trailing trivia (white space) are transferred from the old type name to the `var` keyword to maintain vertical white space and indentation.</span></span> <span data-ttu-id="978e3-223">Es más fácil utilizar `ReplaceNode` en lugar de `With*` para transformar el <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> porque el nombre de tipo es realmente el descendiente del elemento secundario de la instrucción de declaración.</span><span class="sxs-lookup"><span data-stu-id="978e3-223">It's simpler to use `ReplaceNode` rather than `With*` to transform the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> because the type name is actually the grandchild of the declaration statement.</span></span>

<span data-ttu-id="978e3-224">Ha terminado el `TypeInferenceRewriter`.</span><span class="sxs-lookup"><span data-stu-id="978e3-224">You've finished the `TypeInferenceRewriter`.</span></span> <span data-ttu-id="978e3-225">Ahora vuelva a su archivo `Program.cs` para finalizar el ejemplo.</span><span class="sxs-lookup"><span data-stu-id="978e3-225">Now return to your `Program.cs` file to finish the example.</span></span> <span data-ttu-id="978e3-226">Cree una prueba <xref:Microsoft.CodeAnalysis.Compilation> y obtenga <xref:Microsoft.CodeAnalysis.SemanticModel> de ella.</span><span class="sxs-lookup"><span data-stu-id="978e3-226">Create a test <xref:Microsoft.CodeAnalysis.Compilation> and obtain the <xref:Microsoft.CodeAnalysis.SemanticModel> from it.</span></span> <span data-ttu-id="978e3-227">Use ese <xref:Microsoft.CodeAnalysis.SemanticModel> para probar su `TypeInferenceRewriter`.</span><span class="sxs-lookup"><span data-stu-id="978e3-227">Use that <xref:Microsoft.CodeAnalysis.SemanticModel> to try your `TypeInferenceRewriter`.</span></span> <span data-ttu-id="978e3-228">Llevará a cabo este último paso.</span><span class="sxs-lookup"><span data-stu-id="978e3-228">You'll do this step last.</span></span> <span data-ttu-id="978e3-229">Mientras tanto, declare una variable de marcador de posición que represente la compilación de prueba:</span><span class="sxs-lookup"><span data-stu-id="978e3-229">In the meantime declare a placeholder variable representing your test compilation:</span></span>

[!code-csharp[DeclareCompilation](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#DeclareTestCompilation "Declare the test compilation")]

<span data-ttu-id="978e3-230">Después de un momento de pausa, debería aparecer un subrayado ondulado de error que indica que no existe ningún método `CreateTestCompilation`.</span><span class="sxs-lookup"><span data-stu-id="978e3-230">After pausing a moment, you should see an error squiggle appear reporting that no `CreateTestCompilation` method exists.</span></span> <span data-ttu-id="978e3-231">Presione **CTRL+Punto** para abrir la bombilla y, a continuación, presione Entrar para invocar el comando **Generar código auxiliar del método**.</span><span class="sxs-lookup"><span data-stu-id="978e3-231">Press **Ctrl+Period** to open the light-bulb and then press Enter to invoke the **Generate Method Stub** command.</span></span> <span data-ttu-id="978e3-232">Este comando generará un código auxiliar para el método `CreateTestCompilation` en la clase `Program`.</span><span class="sxs-lookup"><span data-stu-id="978e3-232">This command will generate a method stub for the `CreateTestCompilation` method in the `Program` class.</span></span> <span data-ttu-id="978e3-233">Podrá volver a rellenar este método más adelante:</span><span class="sxs-lookup"><span data-stu-id="978e3-233">You'll come back to fill in this method later:</span></span>

![Generación de método de C# a partir del uso](./media/syntax-transformation/generate-from-usage.png)

<span data-ttu-id="978e3-235">Escriba el código siguiente para recorrer en iteración cada <xref:Microsoft.CodeAnalysis.SyntaxTree> en la prueba <xref:Microsoft.CodeAnalysis.Compilation>.</span><span class="sxs-lookup"><span data-stu-id="978e3-235">Write the following code to iterate over each <xref:Microsoft.CodeAnalysis.SyntaxTree> in the test <xref:Microsoft.CodeAnalysis.Compilation>.</span></span> <span data-ttu-id="978e3-236">Para cada una de ellas, inicialice un nuevo `TypeInferenceRewriter` con el <xref:Microsoft.CodeAnalysis.SemanticModel> para ese árbol:</span><span class="sxs-lookup"><span data-stu-id="978e3-236">For each one, initialize a new `TypeInferenceRewriter` with the <xref:Microsoft.CodeAnalysis.SemanticModel> for that tree:</span></span>

[!code-csharp[IterateTrees](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#IterateTrees "Iterate all the source trees in the test compilation")]

<span data-ttu-id="978e3-237">Dentro de la instrucción `foreach` que ha creado, agregue el código siguiente para realizar la transformación en cada árbol de origen.</span><span class="sxs-lookup"><span data-stu-id="978e3-237">Inside the `foreach` statement you created, add the following code to perform the transformation on each source tree.</span></span> <span data-ttu-id="978e3-238">Este código escribe condicionalmente el nuevo árbol transformado si se hicieron modificaciones.</span><span class="sxs-lookup"><span data-stu-id="978e3-238">This code conditionally writes out the new transformed tree if any edits were made.</span></span> <span data-ttu-id="978e3-239">El sistema de reescritura sólo debe modificar un árbol si encuentra una o más declaraciones de variables locales que pudieron simplificarse mediante la inferencia de tipos:</span><span class="sxs-lookup"><span data-stu-id="978e3-239">Your rewriter should only modify a tree if it encounters one or more local variable declarations that could be simplified using type inference:</span></span>

[!code-csharp[TransformTrees](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#TransformTrees "Transform and save any trees that are modified by the rewriter")]

<span data-ttu-id="978e3-240">Debería ver los subrayados ondulados bajo el código `File.WriteAllText`.</span><span class="sxs-lookup"><span data-stu-id="978e3-240">You should see squiggles under the `File.WriteAllText` code.</span></span> <span data-ttu-id="978e3-241">Seleccione la bombilla y agregue la instrucción `using System.IO;` necesaria.</span><span class="sxs-lookup"><span data-stu-id="978e3-241">Select the light bulb, and add the necessary `using System.IO;` statement.</span></span>

<span data-ttu-id="978e3-242">Casi ha terminado.</span><span class="sxs-lookup"><span data-stu-id="978e3-242">You're almost done!</span></span> <span data-ttu-id="978e3-243">Queda un último paso: crear una prueba <xref:Microsoft.CodeAnalysis.Compilation>.</span><span class="sxs-lookup"><span data-stu-id="978e3-243">There's one step left: creating a test <xref:Microsoft.CodeAnalysis.Compilation>.</span></span> <span data-ttu-id="978e3-244">Puesto que no ha utilizado ninguna inferencia de tipos durante este tutorial rápido, habría sido un caso de prueba perfecto.</span><span class="sxs-lookup"><span data-stu-id="978e3-244">Since you haven't been using type inference at all during this quickstart, it would have made a perfect test case.</span></span> <span data-ttu-id="978e3-245">Desafortunadamente, la creación de una compilación desde un archivo de proyecto de C# queda fuera del ámbito de este tutorial.</span><span class="sxs-lookup"><span data-stu-id="978e3-245">Unfortunately, creating a Compilation from a C# project file is beyond the scope of this walkthrough.</span></span> <span data-ttu-id="978e3-246">Pero afortunadamente, si ha seguido las instrucciones con cuidado, hay esperanza.</span><span class="sxs-lookup"><span data-stu-id="978e3-246">But fortunately, if you've been following instructions carefully, there's hope.</span></span> <span data-ttu-id="978e3-247">Reemplace el contenido del método `CreateTestCompilation` con el código siguiente.</span><span class="sxs-lookup"><span data-stu-id="978e3-247">Replace the contents of the `CreateTestCompilation` method with the following code.</span></span> <span data-ttu-id="978e3-248">Crea una compilación de prueba que casualmente coincide con el proyecto descrito en este tutorial rápido:</span><span class="sxs-lookup"><span data-stu-id="978e3-248">It creates a test compilation that coincidentally matches the project described in this quickstart:</span></span>

[!code-csharp[CreateTestCompilation](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#CreateTestCompilation "Create a test compilation using the code written for this quickstart.")]

<span data-ttu-id="978e3-249">Cruce los dedos y ejecute el proyecto.</span><span class="sxs-lookup"><span data-stu-id="978e3-249">Cross your fingers and run the project.</span></span> <span data-ttu-id="978e3-250">En Visual Studio, elija **Depurar** > **Iniciar depuración**.</span><span class="sxs-lookup"><span data-stu-id="978e3-250">In Visual Studio, choose **Debug** > **Start Debugging**.</span></span> <span data-ttu-id="978e3-251">Visual Studio le debería notificar que los archivos de su proyecto han cambiado.</span><span class="sxs-lookup"><span data-stu-id="978e3-251">You should be prompted by Visual Studio that the files in your project have changed.</span></span> <span data-ttu-id="978e3-252">Haga clic en "**Sí a todo**" para volver a cargar los archivos modificados.</span><span class="sxs-lookup"><span data-stu-id="978e3-252">Click "**Yes to All**" to reload the modified files.</span></span> <span data-ttu-id="978e3-253">Examínelos para observar su genialidad.</span><span class="sxs-lookup"><span data-stu-id="978e3-253">Examine them to observe your awesomeness.</span></span> <span data-ttu-id="978e3-254">Observe que el código se ve mucho más limpio sin todos los especificadores de tipo explícitos y redundantes.</span><span class="sxs-lookup"><span data-stu-id="978e3-254">Note how much cleaner the code looks without all those explicit and redundant type specifiers.</span></span>

<span data-ttu-id="978e3-255">¡Enhorabuena!</span><span class="sxs-lookup"><span data-stu-id="978e3-255">Congratulations!</span></span> <span data-ttu-id="978e3-256">Ha usado las **API de compilador** para escribir su propia refactorización que busca en todos los archivos de un proyecto C# ciertos patrones sintácticos, analiza la semántica del código fuente que coincide con esos patrones y la transforma.</span><span class="sxs-lookup"><span data-stu-id="978e3-256">You've used the **Compiler APIs** to write your own refactoring that searches all files in a C# project for certain syntactic patterns, analyzes the semantics of source code that matches those patterns, and transforms it.</span></span> <span data-ttu-id="978e3-257">¡Ya es oficialmente un autor de refactorización!</span><span class="sxs-lookup"><span data-stu-id="978e3-257">You're now officially a refactoring author!</span></span>
