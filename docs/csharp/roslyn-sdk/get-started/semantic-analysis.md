---
title: Introducción al análisis semántico
description: En este tutorial, se proporciona una introducción sobre cómo trabajar con el análisis semántico mediante el SDK de .NET Compiler.
ms.date: 02/06/2018
ms.custom: mvc
ms.openlocfilehash: 3119363822328c0e5fc67c2a2a4a917a7d37cfd2
ms.sourcegitcommit: c7f0beaa2bd66ebca86362ca17d673f7e8256ca6
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 03/23/2021
ms.locfileid: "104872566"
---
# <a name="get-started-with-semantic-analysis"></a><span data-ttu-id="22724-103">Introducción al análisis semántico</span><span class="sxs-lookup"><span data-stu-id="22724-103">Get started with semantic analysis</span></span>

<span data-ttu-id="22724-104">En este tutorial, se asume que conoce la API de sintaxis.</span><span class="sxs-lookup"><span data-stu-id="22724-104">This tutorial assumes you're familiar with the Syntax API.</span></span> <span data-ttu-id="22724-105">En el artículo [Introducción al análisis de sintaxis](syntax-analysis.md) se proporciona una introducción suficiente.</span><span class="sxs-lookup"><span data-stu-id="22724-105">The [get started with syntax analysis](syntax-analysis.md) article provides sufficient introduction.</span></span>

<span data-ttu-id="22724-106">En este tutorial, explorará las **API de símbolo** y **enlace**.</span><span class="sxs-lookup"><span data-stu-id="22724-106">In this tutorial, you explore the **Symbol** and **Binding APIs**.</span></span> <span data-ttu-id="22724-107">Estas API ofrecen información sobre el _significado semántico_ de un programa.</span><span class="sxs-lookup"><span data-stu-id="22724-107">These APIs provide information about the _semantic meaning_ of a program.</span></span> <span data-ttu-id="22724-108">Le permiten formular y responder preguntas sobre los tipos representados por cualquier símbolo en el programa.</span><span class="sxs-lookup"><span data-stu-id="22724-108">They enable you to ask and answer questions about the types represented by any symbol in your program.</span></span>

<span data-ttu-id="22724-109">Deberá instalar el **SDK de .NET Compiler Platform**:</span><span class="sxs-lookup"><span data-stu-id="22724-109">You'll need to install the **.NET Compiler Platform SDK**:</span></span>

[!INCLUDE[interactive-note](~/includes/roslyn-installation.md)]

## <a name="understanding-compilations-and-symbols"></a><span data-ttu-id="22724-110">Comprender las compilaciones y los símbolos</span><span class="sxs-lookup"><span data-stu-id="22724-110">Understanding Compilations and Symbols</span></span>

<span data-ttu-id="22724-111">Conforme trabaja más con el SDK de .NET Compiler, empieza a familiarizarse con las diferencias entre la API de sintaxis y la API semántica.</span><span class="sxs-lookup"><span data-stu-id="22724-111">As you work more with the .NET Compiler SDK, you become familiar with the distinctions between Syntax API and the Semantic API.</span></span> <span data-ttu-id="22724-112">La **API de sintaxis** le permite buscar en la _estructura_ de un programa.</span><span class="sxs-lookup"><span data-stu-id="22724-112">The **Syntax API** allows you to look at the _structure_ of a program.</span></span> <span data-ttu-id="22724-113">En cambio, a menudo quiere una información más completa sobre la semántica o el _significado_ de un programa.</span><span class="sxs-lookup"><span data-stu-id="22724-113">However, often you want richer information about the semantics or _meaning_ of a program.</span></span> <span data-ttu-id="22724-114">Aunque un fragmento de código o archivo de código dinámico de Visual Basic o C# se puede analizar sintácticamente de forma aislada, no tiene sentido formular preguntas como "¿cuál es el tipo de esta variable?" de manera unilateral.</span><span class="sxs-lookup"><span data-stu-id="22724-114">While a loose code file or snippet of Visual Basic or C# code can be syntactically analyzed in isolation, it's not meaningful to ask questions such as "what's the type of this variable" in a vacuum.</span></span> <span data-ttu-id="22724-115">El significado de un nombre de tipo puede depender de las referencias de ensamblado, las importaciones de espacio de nombres u otros archivos de código.</span><span class="sxs-lookup"><span data-stu-id="22724-115">The meaning of a type name may be dependent on assembly references, namespace imports, or other code files.</span></span> <span data-ttu-id="22724-116">Esas preguntas se responden mediante la **API semántica**, concretamente la clase <xref:Microsoft.CodeAnalysis.Compilation?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="22724-116">Those questions are answered using the **Semantic API**, specifically the <xref:Microsoft.CodeAnalysis.Compilation?displayProperty=nameWithType> class.</span></span>

<span data-ttu-id="22724-117">Una instancia de <xref:Microsoft.CodeAnalysis.Compilation> es análoga a un único proyecto, tal como muestra el compilador y representa todo lo necesario para compilar un programa de Visual Basic o C#.</span><span class="sxs-lookup"><span data-stu-id="22724-117">An instance of <xref:Microsoft.CodeAnalysis.Compilation> is analogous to a single project as seen by the compiler and represents everything needed to compile a Visual Basic or C# program.</span></span> <span data-ttu-id="22724-118">La **compilación** incluye el conjunto de archivos de código fuente que se compilarán, las referencias de ensamblado y las opciones del compilador.</span><span class="sxs-lookup"><span data-stu-id="22724-118">The **compilation** includes the set of source files to be compiled, assembly references, and compiler options.</span></span> <span data-ttu-id="22724-119">Puede analizar el significado del código con toda la demás información en este contexto.</span><span class="sxs-lookup"><span data-stu-id="22724-119">You can reason about the meaning of the code using all the other information in this context.</span></span> <span data-ttu-id="22724-120">Una <xref:Microsoft.CodeAnalysis.Compilation> permite buscar **símbolos** (entidades como tipos, espacios de nombres, miembros y variables a los que hacen referencia nombres y otras expresiones).</span><span class="sxs-lookup"><span data-stu-id="22724-120">A <xref:Microsoft.CodeAnalysis.Compilation> allows you to find **Symbols** - entities such as types, namespaces, members, and variables which names and other expressions refer to.</span></span> <span data-ttu-id="22724-121">El proceso de asociar los nombres y las expresiones con **símbolos** se denomina **enlace**.</span><span class="sxs-lookup"><span data-stu-id="22724-121">The process of associating names and expressions with **Symbols** is called **Binding**.</span></span>

<span data-ttu-id="22724-122">Como <xref:Microsoft.CodeAnalysis.SyntaxTree?displayProperty=nameWithType>, <xref:Microsoft.CodeAnalysis.Compilation> es una clase abstracta con derivados específicos del lenguaje.</span><span class="sxs-lookup"><span data-stu-id="22724-122">Like <xref:Microsoft.CodeAnalysis.SyntaxTree?displayProperty=nameWithType>, <xref:Microsoft.CodeAnalysis.Compilation> is an abstract class with language-specific derivatives.</span></span> <span data-ttu-id="22724-123">Al crear una instancia de la compilación, debe invocar un método de generador en la clase <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation?displayProperty=nameWithType> (o <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation?displayProperty=nameWithType>).</span><span class="sxs-lookup"><span data-stu-id="22724-123">When creating an instance of Compilation, you must invoke a factory method on the <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation?displayProperty=nameWithType> (or <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation?displayProperty=nameWithType>) class.</span></span>

## <a name="querying-symbols"></a><span data-ttu-id="22724-124">Consultar símbolos</span><span class="sxs-lookup"><span data-stu-id="22724-124">Querying symbols</span></span>

<span data-ttu-id="22724-125">En este tutorial, volverá a examinar el programa "Hola mundo".</span><span class="sxs-lookup"><span data-stu-id="22724-125">In this tutorial, you look at the "Hello World" program again.</span></span> <span data-ttu-id="22724-126">En esta ocasión, consultará los símbolos del programa para comprender qué tipos representan esos símbolos.</span><span class="sxs-lookup"><span data-stu-id="22724-126">This time, you query the symbols in the program to understand what types those symbols represent.</span></span> <span data-ttu-id="22724-127">Consultará los tipos en un espacio de nombres y aprenderá a buscar los métodos disponibles en un tipo.</span><span class="sxs-lookup"><span data-stu-id="22724-127">You query for the types in a namespace, and learn to find the methods available on a type.</span></span>

<span data-ttu-id="22724-128">Puede ver el código terminado de este ejemplo en [nuestro repositorio de GitHub](https://github.com/dotnet/samples/tree/main/csharp/roslyn-sdk/SemanticQuickStart).</span><span class="sxs-lookup"><span data-stu-id="22724-128">You can see the finished code for this sample in [our GitHub repository](https://github.com/dotnet/samples/tree/main/csharp/roslyn-sdk/SemanticQuickStart).</span></span>

> [!NOTE]
> <span data-ttu-id="22724-129">Los tipos de árbol de sintaxis usan la herencia para describir los diferentes elementos de sintaxis que son válidos en diferentes ubicaciones del programa.</span><span class="sxs-lookup"><span data-stu-id="22724-129">The Syntax Tree types use inheritance to describe the different syntax elements that are valid at different locations in the program.</span></span> <span data-ttu-id="22724-130">A menudo, usar estas API significa convertir propiedades o miembros de colección en tipos derivados concretos.</span><span class="sxs-lookup"><span data-stu-id="22724-130">Using these APIs often means casting properties or collection members to specific derived types.</span></span> <span data-ttu-id="22724-131">En los ejemplos siguientes, la asignación y las conversiones son instrucciones independientes, con variables con tipo explícito.</span><span class="sxs-lookup"><span data-stu-id="22724-131">In the following examples, the assignment and the casts are separate statements, using explicitly typed variables.</span></span> <span data-ttu-id="22724-132">Puede leer el código para ver los tipos de valor devuelto de la API y el tipo de motor de ejecución de los objetos devueltos.</span><span class="sxs-lookup"><span data-stu-id="22724-132">You can read the code to see the return types of the API and the runtime type of the objects returned.</span></span> <span data-ttu-id="22724-133">En la práctica, es más habitual usar variables con tipo implícito y basarse en nombres de API para describir el tipo de los objetos que se examinan.</span><span class="sxs-lookup"><span data-stu-id="22724-133">In practice, it's more common to use implicitly typed variables and rely on API names to describe the type of objects being examined.</span></span>

<span data-ttu-id="22724-134">Cree un proyecto de **Stand-Alone Code Analysis Tool** (Herramienta de análisis de código independiente) de C#:</span><span class="sxs-lookup"><span data-stu-id="22724-134">Create a new C# **Stand-Alone Code Analysis Tool** project:</span></span>

* <span data-ttu-id="22724-135">En Visual Studio, elija **Archivo** > **Nuevo** > **Proyecto** para mostrar el cuadro de diálogo Nuevo proyecto.</span><span class="sxs-lookup"><span data-stu-id="22724-135">In Visual Studio, choose **File** > **New** > **Project** to display the New Project dialog.</span></span>
* <span data-ttu-id="22724-136">En **Visual C#**  > **Extensibilidad**, elija **Stand-Alone Code Analysis Tool** (Herramienta de análisis de código independiente).</span><span class="sxs-lookup"><span data-stu-id="22724-136">Under **Visual C#** > **Extensibility**, choose **Stand-Alone Code Analysis Tool**.</span></span>
* <span data-ttu-id="22724-137">Asigne al proyecto el nombre "**SemanticQuickStart**" y haga clic en Aceptar.</span><span class="sxs-lookup"><span data-stu-id="22724-137">Name your project "**SemanticQuickStart**" and click OK.</span></span>

<span data-ttu-id="22724-138">Va a analizar el programa básico "Hola mundo"</span><span class="sxs-lookup"><span data-stu-id="22724-138">You're going to analyze the basic "Hello World!"</span></span> <span data-ttu-id="22724-139">mostrado anteriormente.</span><span class="sxs-lookup"><span data-stu-id="22724-139">program shown earlier.</span></span>
<span data-ttu-id="22724-140">Agregue el texto para el programa Hola mundo como una constante en su clase `Program`:</span><span class="sxs-lookup"><span data-stu-id="22724-140">Add the text for the Hello World program as a constant in your `Program` class:</span></span>

[!code-csharp[Declare the program test](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#1 "Declare a constant string for the program text to analyze")]

<span data-ttu-id="22724-141">A continuación, agregue el código siguiente para crear el árbol de sintaxis para el texto del código de la constante `programText`.</span><span class="sxs-lookup"><span data-stu-id="22724-141">Next, add the following code to build the syntax tree for the code text in the `programText` constant.</span></span>  <span data-ttu-id="22724-142">Agregue la línea siguiente al método `Main`:</span><span class="sxs-lookup"><span data-stu-id="22724-142">Add the following line to your `Main` method:</span></span>

[!code-csharp[Create the tree](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#2 "Create the syntax tree")]

<span data-ttu-id="22724-143">A continuación, compile una <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation> del árbol que ya ha creado.</span><span class="sxs-lookup"><span data-stu-id="22724-143">Next, build a <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation> from the tree you already created.</span></span> <span data-ttu-id="22724-144">El ejemplo "Hola mundo" se basa en los tipos <xref:System.String> y <xref:System.Console>.</span><span class="sxs-lookup"><span data-stu-id="22724-144">The "Hello World" sample relies on the <xref:System.String> and <xref:System.Console> types.</span></span> <span data-ttu-id="22724-145">Debe hacer referencia al ensamblado que declara esos dos tipos en la compilación.</span><span class="sxs-lookup"><span data-stu-id="22724-145">You need to reference the assembly that declares those two types in your compilation.</span></span> <span data-ttu-id="22724-146">Agregue la siguiente línea a su método `Main` para crear una compilación de su árbol de sintaxis, incluida la referencia al ensamblado adecuado:</span><span class="sxs-lookup"><span data-stu-id="22724-146">Add the following line to your `Main` method to create a compilation of your syntax tree, including the reference to the appropriate assembly:</span></span>

[!code-csharp[Create the compilation](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#3 "Create the compilation for the semantic model")]

<span data-ttu-id="22724-147">El método <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.AddReferences%2A?displayProperty=nameWithType> agrega referencias a la compilación.</span><span class="sxs-lookup"><span data-stu-id="22724-147">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.AddReferences%2A?displayProperty=nameWithType> method adds references to the compilation.</span></span> <span data-ttu-id="22724-148">El método <xref:Microsoft.CodeAnalysis.MetadataReference.CreateFromFile%2A?displayProperty=nameWithType> carga un ensamblado como referencia.</span><span class="sxs-lookup"><span data-stu-id="22724-148">The <xref:Microsoft.CodeAnalysis.MetadataReference.CreateFromFile%2A?displayProperty=nameWithType> method loads an assembly as a reference.</span></span>

## <a name="querying-the-semantic-model"></a><span data-ttu-id="22724-149">Consultar el modelo semántico</span><span class="sxs-lookup"><span data-stu-id="22724-149">Querying the semantic model</span></span>

<span data-ttu-id="22724-150">Una vez que tenga una <xref:Microsoft.CodeAnalysis.Compilation>, puede pedirle un <xref:Microsoft.CodeAnalysis.SemanticModel> para cualquier <xref:Microsoft.CodeAnalysis.SyntaxTree> incluido en esa <xref:Microsoft.CodeAnalysis.Compilation>.</span><span class="sxs-lookup"><span data-stu-id="22724-150">Once you have a <xref:Microsoft.CodeAnalysis.Compilation> you can ask it for a <xref:Microsoft.CodeAnalysis.SemanticModel> for any <xref:Microsoft.CodeAnalysis.SyntaxTree> contained in that <xref:Microsoft.CodeAnalysis.Compilation>.</span></span> <span data-ttu-id="22724-151">Puede considerar el modelo semántico como el origen de toda la información que normalmente obtendría de IntelliSense.</span><span class="sxs-lookup"><span data-stu-id="22724-151">You can think of the semantic model as the source for all the information you would normally get from intellisense.</span></span> <span data-ttu-id="22724-152">Un <xref:Microsoft.CodeAnalysis.SemanticModel> puede responder a preguntas como "¿Qué nombres entran en el ámbito de esta ubicación?", "¿A qué miembros se puede acceder desde este método?", "¿Qué variables se usan en este bloque de texto?" y "¿A qué hace referencia este nombre o expresión?".</span><span class="sxs-lookup"><span data-stu-id="22724-152">A <xref:Microsoft.CodeAnalysis.SemanticModel> can answer questions like "What names are in scope at this location?", "What members are accessible from this method?", "What variables are used in this block of text?", and "What does this name/expression refer to?"</span></span> <span data-ttu-id="22724-153">Agregue esta instrucción para crear el modelo semántico:</span><span class="sxs-lookup"><span data-stu-id="22724-153">Add this statement to create the semantic model:</span></span>

[!code-csharp[Create the semantic model](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#4 "Create the semantic model")]

## <a name="binding-a-name"></a><span data-ttu-id="22724-154">Enlazar un nombre</span><span class="sxs-lookup"><span data-stu-id="22724-154">Binding a name</span></span>

<span data-ttu-id="22724-155">La <xref:Microsoft.CodeAnalysis.Compilation> crea el <xref:Microsoft.CodeAnalysis.SemanticModel> desde el <xref:Microsoft.CodeAnalysis.SyntaxTree>.</span><span class="sxs-lookup"><span data-stu-id="22724-155">The <xref:Microsoft.CodeAnalysis.Compilation> creates the  <xref:Microsoft.CodeAnalysis.SemanticModel> from the <xref:Microsoft.CodeAnalysis.SyntaxTree>.</span></span> <span data-ttu-id="22724-156">Después de crear el modelo, puede consultarlo para buscar la primera directiva `using` y recuperar la información de símbolo del espacio de nombres `System`.</span><span class="sxs-lookup"><span data-stu-id="22724-156">After creating the model, you can query it to find the first `using` directive, and retrieve the symbol information for the `System` namespace.</span></span> <span data-ttu-id="22724-157">Agregue estas dos líneas en su método `Main` para crear el modelo semántico y recuperar el símbolo de la primera instrucción using:</span><span class="sxs-lookup"><span data-stu-id="22724-157">Add these two lines to your `Main` method to create the semantic model and retrieve the symbol for the first using statement:</span></span>

[!code-csharp[Find the namespace symbol for the first using](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#5 "Find the namespace symbol for the first using")]

<span data-ttu-id="22724-158">En el código anterior se muestra cómo enlazar el nombre de la primera directiva de `using` para recuperar un <xref:Microsoft.CodeAnalysis.SymbolInfo?displayProperty=nameWithType> para el espacio de nombres `System`.</span><span class="sxs-lookup"><span data-stu-id="22724-158">The preceding code shows how to bind the name in the first `using` directive to retrieve a <xref:Microsoft.CodeAnalysis.SymbolInfo?displayProperty=nameWithType> for the `System` namespace.</span></span> <span data-ttu-id="22724-159">El código anterior también muestra que usa el **modelo de sintaxis** para buscar la estructura del código y usa el **modelo semántico** para entender su significado.</span><span class="sxs-lookup"><span data-stu-id="22724-159">The preceding code also illustrates that you use the **syntax model** to find the structure of the code; you use the **semantic model** to understand its meaning.</span></span> <span data-ttu-id="22724-160">El **modelo de sintaxis** busca la cadena `System` en la instrucción using.</span><span class="sxs-lookup"><span data-stu-id="22724-160">The **syntax model** finds the string `System` in the using statement.</span></span> <span data-ttu-id="22724-161">El **modelo semántico** tiene toda la información sobre los tipos definidos en el espacio de nombres `System`.</span><span class="sxs-lookup"><span data-stu-id="22724-161">The **semantic model** has all the information about the types defined in the `System` namespace.</span></span>

<span data-ttu-id="22724-162">Desde el objeto <xref:Microsoft.CodeAnalysis.SymbolInfo> puede obtener el <xref:Microsoft.CodeAnalysis.ISymbol?displayProperty=nameWithType> mediante la propiedad <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="22724-162">From the <xref:Microsoft.CodeAnalysis.SymbolInfo> object you can obtain the <xref:Microsoft.CodeAnalysis.ISymbol?displayProperty=nameWithType> using the <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="22724-163">Esta propiedad devuelve el símbolo al que hace referencia esta expresión.</span><span class="sxs-lookup"><span data-stu-id="22724-163">This property returns the symbol this expression refers to.</span></span> <span data-ttu-id="22724-164">Para las expresiones que no hacen referencia a ningún elemento (por ejemplo, los literales numéricos), esta propiedad es `null`.</span><span class="sxs-lookup"><span data-stu-id="22724-164">For expressions that don't refer to anything (such as numeric literals) this property is `null`.</span></span> <span data-ttu-id="22724-165">Cuando el <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType> no es NULL, el <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> denota el tipo del símbolo.</span><span class="sxs-lookup"><span data-stu-id="22724-165">When the <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType> is not null, the <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> denotes the type of the symbol.</span></span> <span data-ttu-id="22724-166">En este ejemplo, la propiedad <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> es un <xref:Microsoft.CodeAnalysis.SymbolKind.Namespace?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="22724-166">In this example, the <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> property is a <xref:Microsoft.CodeAnalysis.SymbolKind.Namespace?displayProperty=nameWithType>.</span></span> <span data-ttu-id="22724-167">Agregue el código siguiente al método `Main`.</span><span class="sxs-lookup"><span data-stu-id="22724-167">Add the following code to your `Main` method.</span></span> <span data-ttu-id="22724-168">Recupera el símbolo del espacio de nombres `System` y, después, muestra todos los espacios de nombres secundarios que se declaran en el espacio de nombres `System`:</span><span class="sxs-lookup"><span data-stu-id="22724-168">It retrieves the symbol for the `System` namespace and then displays all the child namespaces declared in the `System` namespace:</span></span>

[!code-csharp[Display all the child namespaces](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#6 "Display all the child namespaces from this compilation")]

<span data-ttu-id="22724-169">Ejecute el programa y debería ver la siguiente salida:</span><span class="sxs-lookup"><span data-stu-id="22724-169">Run the program and you should see the following output:</span></span>

```output
System.Collections
System.Configuration
System.Deployment
System.Diagnostics
System.Globalization
System.IO
System.Numerics
System.Reflection
System.Resources
System.Runtime
System.Security
System.StubHelpers
System.Text
System.Threading
Press any key to continue . . .
```

> [!NOTE]
> <span data-ttu-id="22724-170">La salida no incluye todos los espacios de nombres que son secundarios del espacio de nombres `System`.</span><span class="sxs-lookup"><span data-stu-id="22724-170">The output does not include every namespace that is a child namespace of the `System` namespace.</span></span> <span data-ttu-id="22724-171">Muestra cada espacio de nombres que se encuentra en esta compilación, que solo hace referencia al ensamblado donde se declara `System.String`.</span><span class="sxs-lookup"><span data-stu-id="22724-171">It displays every namespace that is present in this compilation, which only references the assembly where `System.String` is declared.</span></span> <span data-ttu-id="22724-172">Esta compilación no conoce ningún espacio de nombres declarado en otros ensamblados.</span><span class="sxs-lookup"><span data-stu-id="22724-172">Any namespaces declared in other assemblies are not known to this compilation</span></span>

### <a name="binding-an-expression"></a><span data-ttu-id="22724-173">Enlazar una expresión</span><span class="sxs-lookup"><span data-stu-id="22724-173">Binding an expression</span></span>

<span data-ttu-id="22724-174">El código anterior muestra cómo buscar un símbolo al enlazarlo a un nombre.</span><span class="sxs-lookup"><span data-stu-id="22724-174">The preceding code shows how to find a symbol by binding to a name.</span></span> <span data-ttu-id="22724-175">Hay otras expresiones en un programa de C# que se pueden enlazar que no son nombres.</span><span class="sxs-lookup"><span data-stu-id="22724-175">There are other expressions in a C# program that can be bound that aren't names.</span></span> <span data-ttu-id="22724-176">Para demostrar esta funcionalidad, accederemos al enlace a un literal de cadena sencillo.</span><span class="sxs-lookup"><span data-stu-id="22724-176">To demonstrate this capability, let's access the binding to a simple string literal.</span></span>

<span data-ttu-id="22724-177">El programa "Hola mundo" contiene una <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax?displayProperty=nameWithType>, la cadena "Hello, World!"</span><span class="sxs-lookup"><span data-stu-id="22724-177">The "Hello World" program contains a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax?displayProperty=nameWithType>, the "Hello, World!"</span></span> <span data-ttu-id="22724-178">que se muestra en la consola.</span><span class="sxs-lookup"><span data-stu-id="22724-178">string displayed to the console.</span></span>

<span data-ttu-id="22724-179">Encontrará la cadena "Hello, World!"</span><span class="sxs-lookup"><span data-stu-id="22724-179">You find the "Hello, World!"</span></span> <span data-ttu-id="22724-180">si busca el literal de cadena único en el programa.</span><span class="sxs-lookup"><span data-stu-id="22724-180">string by locating the single string literal in the program.</span></span> <span data-ttu-id="22724-181">A continuación, una vez que haya encontrado el nodo de sintaxis, obtenga la información de tipo de ese nodo del modelo semántico.</span><span class="sxs-lookup"><span data-stu-id="22724-181">Then, once you've located the syntax node, get the type info for that node from the semantic model.</span></span> <span data-ttu-id="22724-182">Agregue el código siguiente al método `Main`:</span><span class="sxs-lookup"><span data-stu-id="22724-182">Add the following code to your `Main` method:</span></span>

[!code-csharp[Find the namespace symbol for the only using](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#7 "Find the namespace symbol for the only using")]

<span data-ttu-id="22724-183">La estructura <xref:Microsoft.CodeAnalysis.TypeInfo?displayProperty=nameWithType> incluye una propiedad <xref:Microsoft.CodeAnalysis.TypeInfo.Type?displayProperty=nameWithType> que permite el acceso a la información semántica sobre el tipo del literal.</span><span class="sxs-lookup"><span data-stu-id="22724-183">The <xref:Microsoft.CodeAnalysis.TypeInfo?displayProperty=nameWithType> struct includes a <xref:Microsoft.CodeAnalysis.TypeInfo.Type?displayProperty=nameWithType> property that enables access to the semantic information about the type of the literal.</span></span> <span data-ttu-id="22724-184">En este ejemplo, es el tipo `string`.</span><span class="sxs-lookup"><span data-stu-id="22724-184">In this example, that's the `string` type.</span></span> <span data-ttu-id="22724-185">Agregue una declaración que asigne esta propiedad a una variable local:</span><span class="sxs-lookup"><span data-stu-id="22724-185">Add a declaration that assigns this property to a local variable:</span></span>

[!code-csharp[Find the semantic information about the string type](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#8 "Use the string literal to access the semantic information in the string type.")]

<span data-ttu-id="22724-186">Para finalizar este tutorial, crearemos una consulta LINQ que crea una secuencia de todos los métodos públicos declarados en el tipo `string` que devuelven una `string`.</span><span class="sxs-lookup"><span data-stu-id="22724-186">To finish this tutorial, let's build a LINQ query that creates a sequence of all the public methods declared on the `string` type that return a `string`.</span></span> <span data-ttu-id="22724-187">Esta consulta es más compleja, así que la compilaremos línea a línea y, después, la volveremos a construir como una única consulta.</span><span class="sxs-lookup"><span data-stu-id="22724-187">This query gets complex, so let's build it line by line, then reconstruct it as a single query.</span></span> <span data-ttu-id="22724-188">El origen de esta consulta es la secuencia de todos los miembros declarados en el tipo `string`:</span><span class="sxs-lookup"><span data-stu-id="22724-188">The source for this query is the sequence of all members declared on the `string` type:</span></span>

[!code-csharp[Access the sequence of members on the string type](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#9 "Access the sequence of members on the string type.")]

<span data-ttu-id="22724-189">Esa secuencia de origen contiene todos los miembros, incluidas las propiedades y los campos, de modo que tiene que filtrarlos con el método <xref:System.Collections.Immutable.ImmutableArray%601.OfType%2A?displayProperty=nameWithType> para buscar los elementos que son objetos <xref:Microsoft.CodeAnalysis.IMethodSymbol?displayProperty=nameWithType>:</span><span class="sxs-lookup"><span data-stu-id="22724-189">That source sequence contains all members, including properties and fields, so filter it using the <xref:System.Collections.Immutable.ImmutableArray%601.OfType%2A?displayProperty=nameWithType> method to find elements that are <xref:Microsoft.CodeAnalysis.IMethodSymbol?displayProperty=nameWithType> objects:</span></span>

[!code-csharp[Filter the sequence to only methods](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#10 "Find the subset of the collection that is the methods.")]

<span data-ttu-id="22724-190">A continuación, agregue otro filtro para devolver solo aquellos métodos que son públicos y devuelven una `string`:</span><span class="sxs-lookup"><span data-stu-id="22724-190">Next, add another filter to return only those methods that are public and return a `string`:</span></span>

[!code-csharp[Filter on return type and accessibility](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#11 "Find only the public methods that return a string.")]

<span data-ttu-id="22724-191">Seleccione solo la propiedad name y solo los nombres distintos; para ello, elimine las sobrecargas:</span><span class="sxs-lookup"><span data-stu-id="22724-191">Select only the name property, and only distinct names by removing any overloads:</span></span>

[!code-csharp[find the distinct names.](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#12 "Use the string literal to access the semantic information in the string type.")]

<span data-ttu-id="22724-192">También puede compilar la consulta completa con la sintaxis de consulta LINQ y, después, mostrar todos los nombres de método en la consola:</span><span class="sxs-lookup"><span data-stu-id="22724-192">You can also build the full query using the LINQ query syntax, and then display all the method names in  the console:</span></span>

[!code-csharp[build and display the results of this query.](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#13 "Build and display the results of the query.")]

<span data-ttu-id="22724-193">Compile y ejecute el programa.</span><span class="sxs-lookup"><span data-stu-id="22724-193">Build and run the program.</span></span> <span data-ttu-id="22724-194">Debería ver la siguiente salida:</span><span class="sxs-lookup"><span data-stu-id="22724-194">You should see the following output:</span></span>

```output
Join
Substring
Trim
TrimStart
TrimEnd
Normalize
PadLeft
PadRight
ToLower
ToLowerInvariant
ToUpper
ToUpperInvariant
ToString
Insert
Replace
Remove
Format
Copy
Concat
Intern
IsInterned
Press any key to continue . . .
```

<span data-ttu-id="22724-195">Ha usado la API semántica para buscar y mostrar información sobre los símbolos que forman parte de este programa.</span><span class="sxs-lookup"><span data-stu-id="22724-195">You've used the Semantic API to find and display information about the symbols that are part of this program.</span></span>
