---
title: Introducción al análisis de sintaxis (API de Roslyn)
description: Introducción para recorrer y consultar árboles de sintaxis.
ms.date: 02/05/2018
ms.custom: mvc
ms.openlocfilehash: 7fea6145ed927ed197295b08ab35dbf177920061
ms.sourcegitcommit: c7f0beaa2bd66ebca86362ca17d673f7e8256ca6
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 03/23/2021
ms.locfileid: "104872514"
---
# <a name="get-started-with-syntax-analysis"></a><span data-ttu-id="c1cd5-103">Introducción al análisis de sintaxis</span><span class="sxs-lookup"><span data-stu-id="c1cd5-103">Get started with syntax analysis</span></span>

<span data-ttu-id="c1cd5-104">En este tutorial, explorará la **API de sintaxis**.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-104">In this tutorial, you'll explore the **Syntax API**.</span></span> <span data-ttu-id="c1cd5-105">La API de sintaxis proporciona acceso a las estructuras de datos que describen un programa de C# o Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-105">The Syntax API provides access to the data structures that describe a C# or Visual Basic program.</span></span> <span data-ttu-id="c1cd5-106">Estas estructuras de datos tienen suficientes detalles para representar completamente un programa de cualquier tamaño.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-106">These data structures have enough detail that they can fully represent any program of any size.</span></span> <span data-ttu-id="c1cd5-107">Estas estructuras pueden describir programas completos que se compilen y ejecuten correctamente.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-107">These structures can describe complete programs that compile and run correctly.</span></span> <span data-ttu-id="c1cd5-108">También pueden describir programas incompletos, conforme los escribe, en el editor.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-108">They can also describe incomplete programs, as you write them, in the editor.</span></span>

<span data-ttu-id="c1cd5-109">Para habilitar esta expresión completa, las estructuras de datos y las API que constituyen la API de sintaxis son necesariamente complejas.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-109">To enable this rich expression, the data structures and APIs that make up the Syntax API are necessarily complex.</span></span> <span data-ttu-id="c1cd5-110">Empecemos con el aspecto de la estructura de datos para el programa típico “Hola mundo”:</span><span class="sxs-lookup"><span data-stu-id="c1cd5-110">Let's start with what the data structure looks like for the typical "Hello World" program:</span></span>

```csharp
using System;
using System.Collections.Generic;
using System.Linq;

namespace HelloWorld
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");
        }
    }
}
```

<span data-ttu-id="c1cd5-111">Mire el texto del programa anterior.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-111">Look at the text of the previous program.</span></span> <span data-ttu-id="c1cd5-112">Reconoce elementos conocidos.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-112">You recognize familiar elements.</span></span> <span data-ttu-id="c1cd5-113">Todo el texto representa un único archivo de código fuente o una **unidad de compilación**.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-113">The entire text represents a single source file, or a **compilation unit**.</span></span> <span data-ttu-id="c1cd5-114">Las tres primeras líneas del archivo de código fuente son **directivas using**.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-114">The first three lines of that source file are **using directives**.</span></span> <span data-ttu-id="c1cd5-115">El código fuente restante se encuentra en una **declaración de espacio de nombres**.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-115">The remaining source is contained in a **namespace declaration**.</span></span> <span data-ttu-id="c1cd5-116">La declaración de espacio de nombres contiene una **declaración de clase** secundaria.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-116">The namespace declaration contains a child **class declaration**.</span></span> <span data-ttu-id="c1cd5-117">La declaración de clase contiene una **declaración de método**.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-117">The class declaration contains one **method declaration**.</span></span>

<span data-ttu-id="c1cd5-118">La API de sintaxis crea una estructura de árbol y la raíz representa la unidad de compilación.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-118">The Syntax API creates a tree structure with the root representing the compilation unit.</span></span> <span data-ttu-id="c1cd5-119">Los nodos del árbol representan las directivas using, la declaración del espacio de nombres y todos los demás elementos del programa.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-119">Nodes in the tree represent the using directives, namespace declaration and all the other elements of the program.</span></span> <span data-ttu-id="c1cd5-120">La estructura de árbol continúa hasta los niveles inferiores: la cadena "Hello World!"</span><span class="sxs-lookup"><span data-stu-id="c1cd5-120">The tree structure continues down to the lowest levels: the string "Hello World!"</span></span> <span data-ttu-id="c1cd5-121">es un **token de literal de cadena** que es un descendiente de un **argumento**.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-121">is a **string literal token** that is a descendent of an **argument**.</span></span> <span data-ttu-id="c1cd5-122">La API de sintaxis proporciona acceso a la estructura del programa.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-122">The Syntax API provides access to the structure of the program.</span></span> <span data-ttu-id="c1cd5-123">Puede consultar los procedimientos de código concretos, recorrer el árbol completo para entender el código y crear árboles al modificar el árbol existente.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-123">You can query for specific code practices, walk the entire tree to understand the code, and create new trees by modifying the existing tree.</span></span>

<span data-ttu-id="c1cd5-124">Esa descripción breve proporciona información general sobre el tipo de información accesible mediante la API de sintaxis.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-124">That brief description provides an overview of the kind of information accessible using the Syntax API.</span></span> <span data-ttu-id="c1cd5-125">La API de sintaxis no es nada más que una API formal que describe las construcciones de código que ya conoce de C#.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-125">The Syntax API is nothing more than a formal API that describes the familiar code constructs you know from C#.</span></span> <span data-ttu-id="c1cd5-126">Entre las funcionalidades completas, se incluye información sobre cómo se da formato al código, incluidos los saltos de línea, los espacios en blanco y la sangría.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-126">The full capabilities include information about how the code is formatted including line breaks, white space, and indenting.</span></span> <span data-ttu-id="c1cd5-127">Con esta información, puede representar por completo el código tal y como lo escriben y leen los programadores humanos o el compilador.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-127">Using this information, you can fully represent the code as written and read by human programmers or the compiler.</span></span> <span data-ttu-id="c1cd5-128">Con esta estructura, puede interactuar con el código fuente de forma muy significativa.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-128">Using this structure enables you to interact with the source code on a deeply meaningful level.</span></span> <span data-ttu-id="c1cd5-129">Ya no son cadenas de texto, sino datos que representan la estructura de un programa de C#.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-129">It's no longer text strings, but data that represents the structure of a C# program.</span></span>

<span data-ttu-id="c1cd5-130">Para empezar, debe instalar el **SDK de .NET Compiler Platform**:</span><span class="sxs-lookup"><span data-stu-id="c1cd5-130">To get started, you'll need to install the **.NET Compiler Platform SDK**:</span></span>

[!INCLUDE[interactive-note](~/includes/roslyn-installation.md)]

## <a name="understanding-syntax-trees"></a><span data-ttu-id="c1cd5-131">Comprender los árboles de sintaxis</span><span class="sxs-lookup"><span data-stu-id="c1cd5-131">Understanding syntax trees</span></span>

<span data-ttu-id="c1cd5-132">Use la API de sintaxis para cualquier análisis de la estructura del código de C#.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-132">You use the Syntax API for any analysis of the structure of C# code.</span></span> <span data-ttu-id="c1cd5-133">La **API de sintaxis** expone los analizadores, los árboles de sintaxis y las utilidades para analizar y construir árboles de sintaxis.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-133">The **Syntax API** exposes the parsers, the syntax trees, and utilities for analyzing and constructing syntax trees.</span></span> <span data-ttu-id="c1cd5-134">Es la forma en que busca en el código cualquier elemento de sintaxis específica o lee el código de un programa.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-134">It's how you search code for specific syntax elements or read the code for a program.</span></span>

<span data-ttu-id="c1cd5-135">Un árbol de sintaxis es una estructura de datos que usan los compiladores de C# y Visual Basic para comprender los programas de C# y Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-135">A syntax tree is a data structure used by the C# and Visual Basic compilers to understand C# and Visual Basic programs.</span></span> <span data-ttu-id="c1cd5-136">Los árboles de sintaxis los produce el mismo analizador que se ejecuta cuando se compila un proyecto o un programador presiona F5.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-136">Syntax trees are produced by the same parser that runs when a project is built or a developer hits F5.</span></span> <span data-ttu-id="c1cd5-137">Los árboles de sintaxis tienen una fidelidad completa con el lenguaje; cada bit de información en un archivo de código se representa en el árbol.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-137">The syntax trees have full-fidelity with the language; every bit of information in a code file is represented in the tree.</span></span> <span data-ttu-id="c1cd5-138">Escribir un árbol de sintaxis en texto reproduce el texto original exacto que se ha analizado.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-138">Writing a syntax tree to text reproduces the exact original text that was parsed.</span></span> <span data-ttu-id="c1cd5-139">Los árboles de sintaxis también son **inmutables**; una vez creado un árbol de sintaxis, nunca se puede modificar.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-139">The syntax trees are also **immutable**; once created a syntax tree can never be changed.</span></span> <span data-ttu-id="c1cd5-140">Los consumidores de los árboles pueden analizarlos en varios subprocesos, sin bloqueos ni otras medidas de simultaneidad, sabiendo que los datos nunca cambian.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-140">Consumers of the trees can analyze the trees on multiple threads, without locks or other concurrency measures, knowing the data never changes.</span></span> <span data-ttu-id="c1cd5-141">Puede usar las API para crear árboles que sean el resultado de modificar un árbol existente.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-141">You can use APIs to create new trees that are the result of modifying an existing tree.</span></span>

<span data-ttu-id="c1cd5-142">Los cuatro pilares principales de los árboles de sintaxis son los siguientes:</span><span class="sxs-lookup"><span data-stu-id="c1cd5-142">The four primary building blocks of syntax trees are:</span></span>

* <span data-ttu-id="c1cd5-143">La clase <xref:Microsoft.CodeAnalysis.SyntaxTree?displayProperty=nameWithType>, una instancia de lo que representa un árbol de análisis completo.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-143">The <xref:Microsoft.CodeAnalysis.SyntaxTree?displayProperty=nameWithType> class, an instance of which represents an entire parse tree.</span></span> <span data-ttu-id="c1cd5-144"><xref:Microsoft.CodeAnalysis.SyntaxTree> es una clase abstracta que tiene derivados específicos del lenguaje.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-144"><xref:Microsoft.CodeAnalysis.SyntaxTree> is an abstract class that has language-specific derivatives.</span></span> <span data-ttu-id="c1cd5-145">Use los métodos de análisis de la clase <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree?displayProperty=nameWithType> (o <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree?displayProperty=nameWithType>) para analizar texto en C# o (Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="c1cd5-145">You use the parse methods of the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree?displayProperty=nameWithType> (or <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree?displayProperty=nameWithType>) class to parse text in C# (or Visual Basic).</span></span>
* <span data-ttu-id="c1cd5-146">La clase <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>, instancias de lo que representan las construcciones sintácticas como declaraciones, instrucciones, cláusulas y expresiones.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-146">The <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType> class, instances of which represent syntactic constructs such as declarations, statements, clauses, and expressions.</span></span>
* <span data-ttu-id="c1cd5-147">La estructura <xref:Microsoft.CodeAnalysis.SyntaxToken?displayProperty=nameWithType>, que representa una palabra clave, identificador, operador o puntuación individuales.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-147">The <xref:Microsoft.CodeAnalysis.SyntaxToken?displayProperty=nameWithType> structure, which represents an individual keyword, identifier, operator, or punctuation.</span></span>
* <span data-ttu-id="c1cd5-148">Por último, la estructura <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType>, que representa sintácticamente bits de información insignificante, como el espacio en blanco entre tokens, las directivas de preprocesamiento y los comentarios.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-148">And lastly the <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType> structure, which represents syntactically insignificant bits of information such as the white space between tokens, preprocessing directives, and comments.</span></span>

<span data-ttu-id="c1cd5-149">La trivialidad, los tokens y los nodos se componen de forma jerárquica para formar un árbol que representa por completo todo lo que hay en un fragmento de código de Visual Basic o C#.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-149">Trivia, tokens, and nodes are composed hierarchically to form a tree that completely represents everything in a fragment of Visual Basic or C# code.</span></span> <span data-ttu-id="c1cd5-150">Puede ver esta estructura mediante la ventana **Syntax Visualizer** (Visualizador de sintaxis).</span><span class="sxs-lookup"><span data-stu-id="c1cd5-150">You can see this structure using the **Syntax Visualizer** window.</span></span> <span data-ttu-id="c1cd5-151">En Visual Studio, elija **Vista** > **Otras ventanas** > **Syntax Visualizer** (Visualizador de sintaxis).</span><span class="sxs-lookup"><span data-stu-id="c1cd5-151">In Visual Studio, choose **View** > **Other Windows** > **Syntax Visualizer**.</span></span> <span data-ttu-id="c1cd5-152">Por ejemplo, el archivo de código fuente de C# anterior examinado con **Syntax Visualizer** (Visualizador de sintaxis) tiene el mismo aspecto que en la siguiente ilustración:</span><span class="sxs-lookup"><span data-stu-id="c1cd5-152">For example, the preceding C# source file examined using the **Syntax Visualizer** looks like the following figure:</span></span>

<span data-ttu-id="c1cd5-153">**SyntaxNode**: azul | **SyntaxToken**: verde | **SyntaxTrivia**: rojo ![Archivo de código de C#](media/walkthrough-csharp-syntax-figure1.png)</span><span class="sxs-lookup"><span data-stu-id="c1cd5-153">**SyntaxNode**: Blue | **SyntaxToken**: Green | **SyntaxTrivia**: Red ![C# Code File](media/walkthrough-csharp-syntax-figure1.png)</span></span>

<span data-ttu-id="c1cd5-154">Si se desplaza por esta estructura de árbol, podrá encontrar cualquier instrucción, expresión, token o bit de espacio en blanco en un archivo de código.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-154">By navigating this tree structure, you can find any statement, expression, token, or bit of white space in a code file.</span></span>

<span data-ttu-id="c1cd5-155">Aunque puede buscar cualquier elemento en un archivo de código mediante las API de sintaxis, la mayoría de los escenarios implican examinar pequeños fragmentos de código o buscar instrucciones o fragmentos concretos.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-155">While you can find anything in a code file using the Syntax APIs, most scenarios involve examining small snippets of code, or searching for particular statements or fragments.</span></span> <span data-ttu-id="c1cd5-156">Los dos ejemplos siguientes muestran usos típicos para examinar la estructura del código o buscar instrucciones únicas.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-156">The two examples that follow show typical uses to browse the structure of code, or search for single statements.</span></span>

## <a name="traversing-trees"></a><span data-ttu-id="c1cd5-157">Recorrer árboles</span><span class="sxs-lookup"><span data-stu-id="c1cd5-157">Traversing trees</span></span>

<span data-ttu-id="c1cd5-158">Puede examinar los nodos de un árbol de sintaxis de dos maneras.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-158">You can examine the nodes in a syntax tree in two ways.</span></span> <span data-ttu-id="c1cd5-159">Puede recorrer el árbol para examinar cada nodo o puede consultar elementos o nodos concretos.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-159">You can traverse the tree to examine each node, or you can query for specific elements or nodes.</span></span>

### <a name="manual-traversal"></a><span data-ttu-id="c1cd5-160">Recorrido manual</span><span class="sxs-lookup"><span data-stu-id="c1cd5-160">Manual traversal</span></span>

<span data-ttu-id="c1cd5-161">Puede ver el código terminado de este ejemplo en [nuestro repositorio de GitHub](https://github.com/dotnet/samples/tree/main/csharp/roslyn-sdk/SyntaxQuickStart).</span><span class="sxs-lookup"><span data-stu-id="c1cd5-161">You can see the finished code for this sample in [our GitHub repository](https://github.com/dotnet/samples/tree/main/csharp/roslyn-sdk/SyntaxQuickStart).</span></span>

> [!NOTE]
> <span data-ttu-id="c1cd5-162">Los tipos de árbol de sintaxis usan la herencia para describir los diferentes elementos de sintaxis que son válidos en diferentes ubicaciones del programa.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-162">The Syntax Tree types use inheritance to describe the different syntax elements that are valid at different locations in the program.</span></span> <span data-ttu-id="c1cd5-163">A menudo, usar estas API significa convertir propiedades o miembros de colección en tipos derivados concretos.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-163">Using these APIs often means casting properties or collection members to specific derived types.</span></span> <span data-ttu-id="c1cd5-164">En los ejemplos siguientes, la asignación y las conversiones son instrucciones independientes, con variables con tipo explícito.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-164">In the following examples, the assignment and the casts are separate statements, using explicitly typed variables.</span></span> <span data-ttu-id="c1cd5-165">Puede leer el código para ver los tipos de valor devuelto de la API y el tipo de motor de ejecución de los objetos devueltos.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-165">You can read the code to see the return types of the API and the runtime type of the objects returned.</span></span> <span data-ttu-id="c1cd5-166">En la práctica, es más habitual usar variables con tipo implícito y basarse en nombres de API para describir el tipo de los objetos que se examinan.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-166">In practice, it's more common to use implicitly typed variables and rely on API names to describe the type of objects being examined.</span></span>

<span data-ttu-id="c1cd5-167">Cree un proyecto de **Stand-Alone Code Analysis Tool** (Herramienta de análisis de código independiente) de C#:</span><span class="sxs-lookup"><span data-stu-id="c1cd5-167">Create a new C# **Stand-Alone Code Analysis Tool** project:</span></span>

* <span data-ttu-id="c1cd5-168">En Visual Studio, elija **Archivo** > **Nuevo** > **Proyecto** para mostrar el cuadro de diálogo Nuevo proyecto.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-168">In Visual Studio, choose **File** > **New** > **Project** to display the New Project dialog.</span></span>
* <span data-ttu-id="c1cd5-169">En **Visual C#**  > **Extensibilidad**, elija **Stand-Alone Code Analysis Tool** (Herramienta de análisis de código independiente).</span><span class="sxs-lookup"><span data-stu-id="c1cd5-169">Under **Visual C#** > **Extensibility**, choose **Stand-Alone Code Analysis Tool**.</span></span>
* <span data-ttu-id="c1cd5-170">Asigne al proyecto el nombre "**SyntaxTreeManualTraversal**" y haga clic en Aceptar.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-170">Name your project "**SyntaxTreeManualTraversal**" and click OK.</span></span>

<span data-ttu-id="c1cd5-171">Va a analizar el programa básico "Hola mundo"</span><span class="sxs-lookup"><span data-stu-id="c1cd5-171">You're going to analyze the basic "Hello World!"</span></span> <span data-ttu-id="c1cd5-172">mostrado anteriormente.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-172">program shown earlier.</span></span>
<span data-ttu-id="c1cd5-173">Agregue el texto para el programa Hola mundo como una constante en su clase `Program`:</span><span class="sxs-lookup"><span data-stu-id="c1cd5-173">Add the text for the Hello World program as a constant in your `Program` class:</span></span>

[!code-csharp[Declare the program text](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#1 "Declare a constant string for the program text to analyze")]

<span data-ttu-id="c1cd5-174">A continuación, agregue el código siguiente para crear el **árbol de sintaxis** para el texto del código de la constante `programText`.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-174">Next, add the following code to build the **syntax tree** for the code text in the `programText` constant.</span></span>  <span data-ttu-id="c1cd5-175">Agregue la línea siguiente al método `Main`:</span><span class="sxs-lookup"><span data-stu-id="c1cd5-175">Add the following line to your `Main` method:</span></span>

[!code-csharp[Create the tree](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#2 "Create the syntax tree")]

<span data-ttu-id="c1cd5-176">Estas dos líneas crean el árbol y recuperan su nodo raíz.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-176">Those two lines create the tree and retrieve the root node of that tree.</span></span> <span data-ttu-id="c1cd5-177">Ahora puede examinar los nodos del árbol.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-177">You can now examine the nodes in the tree.</span></span> <span data-ttu-id="c1cd5-178">Agregue estas líneas al método `Main` para mostrar algunas de las propiedades del nodo raíz en el árbol:</span><span class="sxs-lookup"><span data-stu-id="c1cd5-178">Add these lines to your `Main` method to display some of the properties of the root node in the tree:</span></span>

[!code-csharp[Examine the root node](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#3 "Examine the root node")]

<span data-ttu-id="c1cd5-179">Ejecute la aplicación para ver lo que ha detectado el código sobre el nodo raíz de este árbol.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-179">Run the application to see what your code has discovered about the root node in this tree.</span></span>

<span data-ttu-id="c1cd5-180">Normalmente, recorrería el árbol para obtener información sobre el código.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-180">Typically, you'd traverse the tree to learn about the code.</span></span> <span data-ttu-id="c1cd5-181">En este ejemplo, analiza código que conoce para explorar las API.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-181">In this example, you're analyzing code you know to explore the APIs.</span></span> <span data-ttu-id="c1cd5-182">Agregue el código siguiente para examinar el primer miembro del nodo `root`:</span><span class="sxs-lookup"><span data-stu-id="c1cd5-182">Add the following code to examine the first member of the `root` node:</span></span>

[!code-csharp[Find the first member](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#4 "Find the first member")]

<span data-ttu-id="c1cd5-183">Ese miembro es una <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-183">That member is a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c1cd5-184">Representa todo lo que se incluye en el ámbito de la declaración `namespace HelloWorld`.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-184">It represents everything in the scope of the `namespace HelloWorld` declaration.</span></span> <span data-ttu-id="c1cd5-185">Agregue el código siguiente para examinar qué nodos se declaran en el espacio de nombres `HelloWorld`:</span><span class="sxs-lookup"><span data-stu-id="c1cd5-185">Add the following code to examine what nodes are declared inside the `HelloWorld` namespace:</span></span>

[!code-csharp[Find the class declaration](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#5 "Find the class declaration")]

<span data-ttu-id="c1cd5-186">Ejecute el programa para ver lo que ha aprendido.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-186">Run the program to see what you've learned.</span></span>

<span data-ttu-id="c1cd5-187">Ahora que sabe que la declaración es una <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax?displayProperty=nameWithType>, declare una nueva variable de ese tipo para examinar la declaración de clase.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-187">Now that you know the declaration is a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax?displayProperty=nameWithType>, declare a new variable of that type to examine the class declaration.</span></span> <span data-ttu-id="c1cd5-188">Esta clase solo contiene un miembro: el método `Main`.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-188">This class only contains one member: the `Main` method.</span></span> <span data-ttu-id="c1cd5-189">Agregue el código siguiente para buscar el método `Main` y conviértalo en una <xref:Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-189">Add the following code to find the `Main` method, and cast it to a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax?displayProperty=nameWithType>.</span></span>

[!code-csharp[Find the main declaration](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#6 "Find the main declaration")]

<span data-ttu-id="c1cd5-190">El nodo de declaración de método contiene toda la información sintáctica sobre el método.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-190">The method declaration node contains all the syntactic information about the method.</span></span> <span data-ttu-id="c1cd5-191">Vamos a mostrar el tipo de valor devuelto del método `Main`, el número y los tipos de los argumentos, y el texto del cuerpo del método.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-191">Let's display the return type of the `Main` method, the number and types of the arguments, and the body text of the method.</span></span> <span data-ttu-id="c1cd5-192">Agregue el código siguiente:</span><span class="sxs-lookup"><span data-stu-id="c1cd5-192">Add the following code:</span></span>

[!code-csharp[Examine the syntax of the main method](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#7 "Display information about the main method")]

<span data-ttu-id="c1cd5-193">Ejecute el programa para ver toda la información que ya conoce sobre este programa:</span><span class="sxs-lookup"><span data-stu-id="c1cd5-193">Run the program to see all the information you've discovered about this program:</span></span>

```text
The tree is a CompilationUnit node.
The tree has 1 elements in it.
The tree has 4 using statements. They are:
        System
        System.Collections
        System.Linq
        System.Text
The first member is a NamespaceDeclaration.
There are 1 members declared in this namespace.
The first member is a ClassDeclaration.
There are 1 members declared in the Program class.
The first member is a MethodDeclaration.
The return type of the Main method is void.
The method has 1 parameters.
The type of the args parameter is string[].
The body text of the Main method follows:
        {
            Console.WriteLine("Hello, World!");
        }
```

### <a name="query-methods"></a><span data-ttu-id="c1cd5-194">Métodos de consulta</span><span class="sxs-lookup"><span data-stu-id="c1cd5-194">Query methods</span></span>

<span data-ttu-id="c1cd5-195">Además de recorrer árboles, también puede explorar el árbol de sintaxis mediante los métodos de consulta definidos en <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-195">In addition to traversing trees, you can also explore the syntax tree using the query methods defined on <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c1cd5-196">Cualquier persona que conozca XPath debería conocer estos métodos.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-196">These methods should be immediately familiar to anyone familiar with XPath.</span></span> <span data-ttu-id="c1cd5-197">Puede usarlos con LINQ para buscar elementos rápidamente en un árbol.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-197">You can use these methods with LINQ to quickly find things in a tree.</span></span> <span data-ttu-id="c1cd5-198"><xref:Microsoft.CodeAnalysis.SyntaxNode> tiene métodos de consulta como <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A>, <xref:Microsoft.CodeAnalysis.SyntaxNode.AncestorsAndSelf%2A> y <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes%2A>.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-198">The <xref:Microsoft.CodeAnalysis.SyntaxNode> has query methods such as <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A>, <xref:Microsoft.CodeAnalysis.SyntaxNode.AncestorsAndSelf%2A> and <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes%2A>.</span></span>

<span data-ttu-id="c1cd5-199">Puede usar estos métodos de consulta para buscar el argumento para el método `Main` como una alternativa a navegar por el árbol.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-199">You can use these query methods to find the argument to the `Main` method as an alternative to navigating the tree.</span></span> <span data-ttu-id="c1cd5-200">Agregue el siguiente código en la parte inferior del método `Main`:</span><span class="sxs-lookup"><span data-stu-id="c1cd5-200">Add the following code to the bottom of your `Main` method:</span></span>

[!code-csharp[Query the tree for the arguments to Main](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#8 "Query the tree for the arguments to Main")]

<span data-ttu-id="c1cd5-201">La primera instrucción usa una expresión LINQ y el método <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A> para buscar el mismo parámetro que en el ejemplo anterior.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-201">The first statement uses a LINQ expression and the <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A> method to locate the same parameter as in the previous example.</span></span>

<span data-ttu-id="c1cd5-202">Ejecute el programa y compruebe que la expresión LINQ ha encontrado el mismo parámetro que se encuentra al navegar por el árbol de forma manual.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-202">Run the program, and you can see that the LINQ expression found the same parameter as manually navigating the tree.</span></span>

<span data-ttu-id="c1cd5-203">En el ejemplo, se usan instrucciones `WriteLine` para mostrar información sobre los árboles de sintaxis conforme se recorren.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-203">The sample uses `WriteLine` statements to display information about the syntax trees as they are traversed.</span></span> <span data-ttu-id="c1cd5-204">Puede obtener mucha más información si ejecuta el programa terminado en el depurador.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-204">You can also learn much more by running the finished program under the debugger.</span></span> <span data-ttu-id="c1cd5-205">Puede examinar más propiedades y métodos que forman parte del árbol de sintaxis creado para el programa Hola mundo.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-205">You can examine more of the properties and methods that are part of the syntax tree created for the hello world program.</span></span>

## <a name="syntax-walkers"></a><span data-ttu-id="c1cd5-206">Rastreadores de sintaxis</span><span class="sxs-lookup"><span data-stu-id="c1cd5-206">Syntax walkers</span></span>

<span data-ttu-id="c1cd5-207">A menudo, quiere buscar todos los nodos de un tipo concreto en un árbol de sintaxis, por ejemplo, todas las declaraciones de propiedad de un archivo.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-207">Often you want to find all nodes of a specific type in a syntax tree, for example, every property declaration in a file.</span></span> <span data-ttu-id="c1cd5-208">Si extiende la clase <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker?displayProperty=nameWithType> e invalida el método <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitPropertyDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax)>, se procesan todas las declaraciones de propiedad de un árbol de sintaxis sin conocer su estructura de antemano.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-208">By extending the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker?displayProperty=nameWithType> class and overriding the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitPropertyDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax)> method, you process every property declaration in a syntax tree without knowing its structure beforehand.</span></span> <span data-ttu-id="c1cd5-209"><xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> es un tipo determinado de <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor> que visita de forma recurrente un nodo y todos sus elementos secundarios.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-209"><xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> is a specific kind of <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor> that recursively visits a node and each of its children.</span></span>

<span data-ttu-id="c1cd5-210">En este ejemplo, se implementa un <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> que examina un árbol de sintaxis.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-210">This example implements a <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> that examines a syntax tree.</span></span> <span data-ttu-id="c1cd5-211">Recopila directivas `using` que determina que no implementan un espacio de nombres `System`.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-211">It collects `using` directives it finds that aren't importing a `System` namespace.</span></span>

<span data-ttu-id="c1cd5-212">Cree un proyecto de **Stand-Alone Code Analysis Tool** (Herramienta de análisis de código independiente) de C# y asígnele el nombre “**SyntaxWalker**”.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-212">Create a new C# **Stand-Alone Code Analysis Tool** project; name it "**SyntaxWalker**."</span></span>

<span data-ttu-id="c1cd5-213">Puede ver el código terminado de este ejemplo en [nuestro repositorio de GitHub](https://github.com/dotnet/samples/tree/main/csharp/roslyn-sdk/SyntaxQuickStart).</span><span class="sxs-lookup"><span data-stu-id="c1cd5-213">You can see the finished code for this sample in [our GitHub repository](https://github.com/dotnet/samples/tree/main/csharp/roslyn-sdk/SyntaxQuickStart).</span></span> <span data-ttu-id="c1cd5-214">El ejemplo de GitHub contiene los dos proyectos que se describen en este tutorial.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-214">The sample on GitHub contains both projects described in this tutorial.</span></span>

<span data-ttu-id="c1cd5-215">Como en el ejemplo anterior, puede definir una constante de cadena para que contenga el texto del programa que se va a analizar:</span><span class="sxs-lookup"><span data-stu-id="c1cd5-215">As in the previous sample, you can define a string constant to hold the text of the program you're going to analyze:</span></span>

[!code-csharp[Define the code text to analyzer](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/Program.cs#1 "Define the program text to analyze")]

<span data-ttu-id="c1cd5-216">Este texto de origen contiene directivas `using` dispersas por cuatro ubicaciones diferentes: el nivel de archivo, en el espacio de nombres de nivel superior y en los dos espacios de nombres anidados.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-216">This source text contains `using` directives scattered across four different locations: the file-level, in the top-level namespace, and in the two nested namespaces.</span></span> <span data-ttu-id="c1cd5-217">En este ejemplo, se destaca un escenario principal para usar la clase <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> en el código de la consulta.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-217">This example highlights a core scenario for using the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> class to query code.</span></span> <span data-ttu-id="c1cd5-218">Sería complejo visitar todos los nodos del árbol de sintaxis raíz para buscar las declaraciones using.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-218">It would be cumbersome to visit every node in the root syntax tree to find using declarations.</span></span> <span data-ttu-id="c1cd5-219">En su lugar, cree una clase derivada y reemplace el método al que se llama solo cuando el nodo actual del árbol sea una directiva using.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-219">Instead, you create a derived class and override the method that gets called only when the current node in the tree is a using directive.</span></span> <span data-ttu-id="c1cd5-220">El visitante no hace ningún trabajo en ningún otro tipo de nodo.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-220">Your visitor does not do any work on any other node types.</span></span> <span data-ttu-id="c1cd5-221">Este método único examina todas las instrucciones `using` y compila una colección de los espacios de nombres que no están en el espacio de nombres `System`.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-221">This single method examines each of the `using` statements and builds a collection of the namespaces that aren't in the `System` namespace.</span></span> <span data-ttu-id="c1cd5-222">Compile un <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> que examine todas las instrucciones `using`, pero solo las instrucciones `using`.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-222">You build a <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> that examines all the `using` statements, but only the `using` statements.</span></span>

<span data-ttu-id="c1cd5-223">Ahora que ha definido el texto del programa, debe crear un `SyntaxTree` y obtener la raíz de ese árbol:</span><span class="sxs-lookup"><span data-stu-id="c1cd5-223">Now that you've defined the program text, you need to create a `SyntaxTree` and get the root of that tree:</span></span>

[!code-csharp[Create the Syntax tree and access the root](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/Program.cs#2 "Create the Syntax tree and access the root node.")]

<span data-ttu-id="c1cd5-224">A continuación, cree una clase.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-224">Next, create a new class.</span></span> <span data-ttu-id="c1cd5-225">En Visual Studio, elija **Proyecto** > **Agregar nuevo elemento**.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-225">In Visual Studio, choose **Project** > **Add New Item**.</span></span> <span data-ttu-id="c1cd5-226">En el cuadro de diálogo **Agregar nuevo elemento**, escriba *UsingCollector.cs* como nombre de archivo.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-226">In the **Add New Item** dialog type *UsingCollector.cs* as the filename.</span></span>

<span data-ttu-id="c1cd5-227">Implemente la funcionalidad del visitante `using` en la clase `UsingCollector`.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-227">You implement the `using` visitor functionality in the `UsingCollector` class.</span></span> <span data-ttu-id="c1cd5-228">Para empezar, haga que la clase `UsingCollector` derive de <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker>.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-228">Start by making the `UsingCollector` class derive from <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker>.</span></span>

[!code-csharp[Declare the base class for the using collector](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/UsingCollector.cs#3 "Declare the base class for the UsingCollector")]

<span data-ttu-id="c1cd5-229">Necesita almacenamiento para contener los nodos del espacio de nombres que está recopilando.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-229">You need storage to hold the namespace nodes that you're collecting.</span></span>  <span data-ttu-id="c1cd5-230">Declare una propiedad pública de solo lectura en la clase `UsingCollector`; use esta variable para almacenar los nodos <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> que encuentre:</span><span class="sxs-lookup"><span data-stu-id="c1cd5-230">Declare a public read-only property in the `UsingCollector` class; you use this variable to store the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> nodes you find:</span></span>

[!code-csharp[Declare storage for the using syntax nodes](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/UsingCollector.cs#4 "Declare storage for the using syntax nodes")]

<span data-ttu-id="c1cd5-231">La clase base, <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker>, implementa la lógica para visitar todos los nodos del árbol de sintaxis.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-231">The base class, <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> implements the logic to visit each node in the syntax tree.</span></span> <span data-ttu-id="c1cd5-232">La clase derivada reemplaza los métodos llamados por los nodos específicos que le interesan.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-232">The derived class overrides the methods called for the specific nodes you're interested in.</span></span> <span data-ttu-id="c1cd5-233">En este caso, le interesa cualquier directiva `using`.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-233">In this case, you're interested in any `using` directive.</span></span> <span data-ttu-id="c1cd5-234">Por tanto, debe invalidar el método <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax)>.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-234">That means you must override the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax)> method.</span></span> <span data-ttu-id="c1cd5-235">El único argumento de este método es un objeto <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-235">The one argument to this method is a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax?displayProperty=nameWithType> object.</span></span> <span data-ttu-id="c1cd5-236">Se trata de una ventaja importante de usar los visitantes: llaman a los métodos invalidados con argumentos que ya se han convertido al tipo de nodo concreto.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-236">That's an important advantage to using the visitors: they call the overridden methods with arguments already cast to the specific node type.</span></span> <span data-ttu-id="c1cd5-237">La clase <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax?displayProperty=nameWithType> tiene una propiedad <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.Name> que almacena el nombre del espacio de nombres que se va a importar.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-237">The <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax?displayProperty=nameWithType> class has a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.Name> property that stores the name of the namespace being imported.</span></span> <span data-ttu-id="c1cd5-238">Es una <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-238">It is a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c1cd5-239">Agregue el código siguiente en la invalidación <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax)>:</span><span class="sxs-lookup"><span data-stu-id="c1cd5-239">Add the following code in the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax)> override:</span></span>

[!code-csharp[Examine using nodes for the System namespace](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/UsingCollector.cs#5 "Examine all using nodes for the System namespace.")]

<span data-ttu-id="c1cd5-240">Como con el ejemplo anterior, ha agregado una variedad de instrucciones `WriteLine` para ayudar a comprender este método.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-240">As with the earlier example, you've added a variety of `WriteLine` statements to aid in understanding of this method.</span></span> <span data-ttu-id="c1cd5-241">Puede ver cuándo se llama y qué argumentos se le pasan cada vez.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-241">You can see when it's called, and what arguments are passed to it each time.</span></span>

<span data-ttu-id="c1cd5-242">Por último, debe agregar dos líneas de código para crear el `UsingCollector` y hacer que visite el nodo raíz y recopile todas las instrucciones `using`.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-242">Finally, you need to add two lines of code to create the `UsingCollector` and have it visit the root node, collecting all the `using` statements.</span></span> <span data-ttu-id="c1cd5-243">A continuación, agregue un bucle `foreach` para que muestre todas las instrucciones `using` que encuentre el recopilador:</span><span class="sxs-lookup"><span data-stu-id="c1cd5-243">Then, add a `foreach` loop to display all the `using` statements your collector found:</span></span>

[!code-csharp[Create the UsingCollector and visit the root node.](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/Program.cs#6 "Create the UsingCollector and visit the root node.")]

<span data-ttu-id="c1cd5-244">Compile y ejecute el programa.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-244">Compile and run the program.</span></span> <span data-ttu-id="c1cd5-245">Debería ver los siguientes resultados:</span><span class="sxs-lookup"><span data-stu-id="c1cd5-245">You should see the following output:</span></span>

```console
        VisitUsingDirective called with System.
        VisitUsingDirective called with System.Collections.Generic.
        VisitUsingDirective called with System.Linq.
        VisitUsingDirective called with System.Text.
        VisitUsingDirective called with Microsoft.CodeAnalysis.
                Success. Adding Microsoft.CodeAnalysis.
        VisitUsingDirective called with Microsoft.CodeAnalysis.CSharp.
                Success. Adding Microsoft.CodeAnalysis.CSharp.
        VisitUsingDirective called with Microsoft.
                Success. Adding Microsoft.
        VisitUsingDirective called with System.ComponentModel.
        VisitUsingDirective called with Microsoft.Win32.
                Success. Adding Microsoft.Win32.
        VisitUsingDirective called with System.Runtime.InteropServices.
        VisitUsingDirective called with System.CodeDom.
        VisitUsingDirective called with Microsoft.CSharp.
                Success. Adding Microsoft.CSharp.
Microsoft.CodeAnalysis
Microsoft.CodeAnalysis.CSharp
Microsoft
Microsoft.Win32
Microsoft.CSharp
Press any key to continue . . .
```

<span data-ttu-id="c1cd5-246">¡Enhorabuena!</span><span class="sxs-lookup"><span data-stu-id="c1cd5-246">Congratulations!</span></span> <span data-ttu-id="c1cd5-247">Ha usado la **API de sintaxis** para buscar tipos concretos de instrucciones y declaraciones de C# en el código fuente de C#.</span><span class="sxs-lookup"><span data-stu-id="c1cd5-247">You've used the **Syntax API** to locate specific kinds of C# statements and declarations in C# source code.</span></span>
