---
title: Un paseo por C# - Guía de C#
description: ¿Nuevo en C#? Conozca los conceptos básicos del lenguaje. Comience con esta información general.
ms.date: 01/28/2021
ms.openlocfilehash: 016edf331d8cbdca2902cb033963b6aea11df513
ms.sourcegitcommit: 68c9d9d9a97aab3b59d388914004b5474cf1dbd7
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 01/30/2021
ms.locfileid: "99216647"
---
# <a name="a-tour-of-the-c-language"></a><span data-ttu-id="99e68-105">Paseo por el lenguaje C#</span><span class="sxs-lookup"><span data-stu-id="99e68-105">A tour of the C# language</span></span>

<span data-ttu-id="99e68-106">C# (pronunciado "si sharp" en inglés) es un lenguaje de programación moderno, basado en objetos y con seguridad de tipos.</span><span class="sxs-lookup"><span data-stu-id="99e68-106">C# (pronounced "See Sharp") is a modern, object-oriented, and type-safe programming language.</span></span> <span data-ttu-id="99e68-107">que permite a los desarrolladores crear muchos tipos de aplicaciones seguras y sólidas que se ejecutan en el ecosistema de .NET.</span><span class="sxs-lookup"><span data-stu-id="99e68-107">C# enables developers to build many types of secure and robust applications that run in the .NET ecosystem.</span></span> <span data-ttu-id="99e68-108">C# tiene sus raíces en la familia de lenguajes C, y a los programadores de C, C++, Java y JavaScript les resultará familiar inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="99e68-108">C# has its roots in the C family of languages and will be immediately familiar to C, C++, Java, and JavaScript programmers.</span></span> <span data-ttu-id="99e68-109">Este paseo proporciona información general de los principales componentes del lenguaje en C# 8 y versiones anteriores.</span><span class="sxs-lookup"><span data-stu-id="99e68-109">This tour provides an overview of the major components of the language in C# 8 and earlier.</span></span> <span data-ttu-id="99e68-110">Si quiere explorar el lenguaje a través de ejemplos interactivos, pruebe los tutoriales de [introducción a C#](../tutorials/intro-to-csharp/index.md).</span><span class="sxs-lookup"><span data-stu-id="99e68-110">If you want to explore the language through interactive examples, try the [introduction to C#](../tutorials/intro-to-csharp/index.md) tutorials.</span></span>

<span data-ttu-id="99e68-111">C# es un lenguaje de programación \***orientado a componentes** _, orientado a objetos.</span><span class="sxs-lookup"><span data-stu-id="99e68-111">C# is an object-oriented, \***component-oriented** _ programming language.</span></span> <span data-ttu-id="99e68-112">C# proporciona construcciones de lenguaje para admitir directamente estos conceptos, por lo que se trata de un lenguaje natural en el que crear y usar componentes de software.</span><span class="sxs-lookup"><span data-stu-id="99e68-112">C# provides language constructs to directly support these concepts, making C# a natural language in which to create and use software components.</span></span> <span data-ttu-id="99e68-113">Desde su origen, C# ha agregado características para admitir nuevas cargas de trabajo y prácticas de diseño de software emergentes.</span><span class="sxs-lookup"><span data-stu-id="99e68-113">Since its origin, C# has added features to support new workloads and emerging software design practices.</span></span>

<span data-ttu-id="99e68-114">Varias características de C# facilitan la creación de aplicaciones sólidas y duraderas.</span><span class="sxs-lookup"><span data-stu-id="99e68-114">Several C# features help create robust and durable applications.</span></span> <span data-ttu-id="99e68-115">La [_*_recolección de elementos no utilizados_*_](../../standard/garbage-collection/index.md) reclama de forma automática la memoria ocupada por objetos no utilizados inalcanzables.</span><span class="sxs-lookup"><span data-stu-id="99e68-115">[_*_Garbage collection_*_](../../standard/garbage-collection/index.md) automatically reclaims memory occupied by unreachable unused objects.</span></span> <span data-ttu-id="99e68-116">Los [_*_tipos que aceptan valores NULL_*_](../nullable-references.md) ofrecen protección ante variables que no hacen referencia a objetos asignados.</span><span class="sxs-lookup"><span data-stu-id="99e68-116">[_*_Nullable types_*_](../nullable-references.md) guard against variables that don't refer to allocated objects.</span></span> <span data-ttu-id="99e68-117">El [_*_control de excepciones_*_](../programming-guide/exceptions/index.md) proporciona un enfoque estructurado y extensible para la detección y recuperación de errores.</span><span class="sxs-lookup"><span data-stu-id="99e68-117">[_*_Exception handling_*_](../programming-guide/exceptions/index.md) provides a structured and extensible approach to error detection and recovery.</span></span> <span data-ttu-id="99e68-118">Las [_*_expresiones lambda_*_](../language-reference/operators/lambda-expressions.md) admiten técnicas de programación funcional.</span><span class="sxs-lookup"><span data-stu-id="99e68-118">[_*_Lambda expressions_*_](../language-reference/operators/lambda-expressions.md) support functional programming techniques.</span></span> <span data-ttu-id="99e68-119">La sintaxis de [_*_Language Integrated Query (LINQ)_*_](../linq/index.md) crea un patrón común para trabajar con datos de cualquier origen.</span><span class="sxs-lookup"><span data-stu-id="99e68-119">[_*_Language Integrated Query (LINQ)_*_](../linq/index.md) syntax creates a common pattern for working with data from any source.</span></span> <span data-ttu-id="99e68-120">La compatibilidad del lenguaje con las [_*_operaciones asincrónicas_*_](../programming-guide/concepts/async/index.md) proporciona la sintaxis para crear sistemas distribuidos.</span><span class="sxs-lookup"><span data-stu-id="99e68-120">Language support for [_*_asynchronous operations_*_](../programming-guide/concepts/async/index.md) provides syntax for building distributed systems.</span></span> <span data-ttu-id="99e68-121">C# tiene un [_*_sistema de tipos unificados_*_](../programming-guide/types/index.md).</span><span class="sxs-lookup"><span data-stu-id="99e68-121">C# has a [_*_unified type system_*_](../programming-guide/types/index.md).</span></span> <span data-ttu-id="99e68-122">Todos los tipos de C#, incluidos los tipos primitivos como `int` y `double`, se heredan de un único tipo `object` raíz.</span><span class="sxs-lookup"><span data-stu-id="99e68-122">All C# types, including primitive types such as `int` and `double`, inherit from a single root `object` type.</span></span> <span data-ttu-id="99e68-123">Todos los tipos comparten un conjunto de operaciones comunes.</span><span class="sxs-lookup"><span data-stu-id="99e68-123">All types share a set of common operations.</span></span> <span data-ttu-id="99e68-124">Los valores de cualquier tipo se pueden almacenar, transportar y operar de forma coherente.</span><span class="sxs-lookup"><span data-stu-id="99e68-124">Values of any type can be stored, transported, and operated upon in a consistent manner.</span></span> <span data-ttu-id="99e68-125">Además, C# admite tanto [tipos de referencia](../language-reference/builtin-types/reference-types.md) definidos por el usuario como [tipos de valor](../language-reference/builtin-types/value-types.md).</span><span class="sxs-lookup"><span data-stu-id="99e68-125">Furthermore, C# supports both user-defined [reference types](../language-reference/builtin-types/reference-types.md) and [value types](../language-reference/builtin-types/value-types.md).</span></span> <span data-ttu-id="99e68-126">C# permite la asignación dinámica de objetos y el almacenamiento en línea de estructuras ligeras.</span><span class="sxs-lookup"><span data-stu-id="99e68-126">C# allows dynamic allocation of objects and in-line storage of lightweight structures.</span></span> <span data-ttu-id="99e68-127">C# admite métodos y tipos genéricos, que proporcionan una mayor seguridad de tipos, así como un mejor rendimiento.</span><span class="sxs-lookup"><span data-stu-id="99e68-127">C# supports generic methods and types, which provide increased type safety and performance.</span></span> <span data-ttu-id="99e68-128">C# también proporciona iteradores, gracias a los que los implementadores de clases de colecciones pueden definir comportamientos personalizados para el código de cliente.</span><span class="sxs-lookup"><span data-stu-id="99e68-128">C# provides iterators, which enable implementers of collection classes to define custom behaviors for client code.</span></span>

<span data-ttu-id="99e68-129">C# resalta el _*_control de versiones_*_ para garantizar que los programas y las bibliotecas puedan evolucionar con el tiempo de manera compatible.</span><span class="sxs-lookup"><span data-stu-id="99e68-129">C# emphasizes _*_versioning_*_ to ensure programs and libraries can evolve over time in a compatible manner.</span></span> <span data-ttu-id="99e68-130">Los aspectos del diseño de C# afectados directamente por las consideraciones de versionamiento incluyen los modificadores `virtual` y `override` independientes, las reglas para la resolución de sobrecargas de métodos y la compatibilidad para declaraciones explícitas de miembros de interfaz.</span><span class="sxs-lookup"><span data-stu-id="99e68-130">Aspects of C#'s design that were directly influenced by versioning considerations include the separate `virtual` and `override` modifiers, the rules for method overload resolution, and support for explicit interface member declarations.</span></span>

## <a name="net-architecture"></a><span data-ttu-id="99e68-131">Arquitectura de .NET</span><span class="sxs-lookup"><span data-stu-id="99e68-131">.NET architecture</span></span>

<span data-ttu-id="99e68-132">Los programas de C# se ejecutan en .NET, un sistema de ejecución virtual denominado Common Language Runtime (CLR) y un conjunto de bibliotecas de clases.</span><span class="sxs-lookup"><span data-stu-id="99e68-132">C# programs run on .NET, a virtual execution system called the common language runtime (CLR) and a set of class libraries.</span></span> <span data-ttu-id="99e68-133">CLR es la implementación de Microsoft del estándar internacional Common Language Infrastructure (CLI).</span><span class="sxs-lookup"><span data-stu-id="99e68-133">The CLR is the implementation by Microsoft of the common language infrastructure (CLI), an international standard.</span></span> <span data-ttu-id="99e68-134">CLI es la base para crear entornos de ejecución y desarrollo en los que los lenguajes y las bibliotecas funcionan juntos sin problemas.</span><span class="sxs-lookup"><span data-stu-id="99e68-134">The CLI is the basis for creating execution and development environments in which languages and libraries work together seamlessly.</span></span>

<span data-ttu-id="99e68-135">El código fuente escrito en C# se compila en un [lenguaje intermedio (IL)](../../standard/managed-code.md) que guarda conformidad con la especificación de CLI.</span><span class="sxs-lookup"><span data-stu-id="99e68-135">Source code written in C# is compiled into an [intermediate language (IL)](../../standard/managed-code.md) that conforms to the CLI specification.</span></span> <span data-ttu-id="99e68-136">El código y los recursos de IL, como los mapas de bits y las cadenas, se almacenan en un ensamblado, normalmente con una extensión _.dll\*.</span><span class="sxs-lookup"><span data-stu-id="99e68-136">The IL code and resources, such as bitmaps and strings, are stored in an assembly, typically with an extension of _.dll\*.</span></span> <span data-ttu-id="99e68-137">Un ensamblado contiene un manifiesto que proporciona información sobre los tipos, la versión y la referencia cultural.</span><span class="sxs-lookup"><span data-stu-id="99e68-137">An assembly contains a manifest that provides information about the assembly's types, version, and culture.</span></span>

<span data-ttu-id="99e68-138">Cuando se ejecuta el programa C#, el ensamblado se carga en CLR.</span><span class="sxs-lookup"><span data-stu-id="99e68-138">When the C# program is executed, the assembly is loaded into the CLR.</span></span> <span data-ttu-id="99e68-139">CLR realiza la compilación Just-In-Time (JIT) para convertir el código IL en instrucciones de máquina nativas.</span><span class="sxs-lookup"><span data-stu-id="99e68-139">The CLR performs Just-In-Time (JIT) compilation to convert the IL code to native machine instructions.</span></span> <span data-ttu-id="99e68-140">Además, CLR proporciona otros servicios relacionados con la recolección de elementos no utilizados, el control de excepciones y la administración de recursos.</span><span class="sxs-lookup"><span data-stu-id="99e68-140">The CLR provides other services related to automatic garbage collection, exception handling, and resource management.</span></span> <span data-ttu-id="99e68-141">El código que se ejecuta en el CLR se conoce a veces como "código administrado", a diferencia del "código no administrado", que se compila en un lenguaje nativo de la máquina destinado a un sistema específico.</span><span class="sxs-lookup"><span data-stu-id="99e68-141">Code that's executed by the CLR is sometimes referred to as "managed code," in contrast to "unmanaged code," which is compiled into native machine language that targets a specific platform.</span></span>

<span data-ttu-id="99e68-142">La interoperabilidad entre lenguajes es una característica principal de .NET.</span><span class="sxs-lookup"><span data-stu-id="99e68-142">Language interoperability is a key feature of .NET.</span></span> <span data-ttu-id="99e68-143">El código IL generado por el compilador de C# se ajusta a la especificación de tipo común (CTS).</span><span class="sxs-lookup"><span data-stu-id="99e68-143">IL code produced by the C# compiler conforms to the Common Type Specification (CTS).</span></span> <span data-ttu-id="99e68-144">El código IL generado desde C# puede interactuar con el código generado a partir de las versiones de .NET de F# , Visual Basic, C++ o cualquiera de los más de 20 lenguajes compatibles con CTS.</span><span class="sxs-lookup"><span data-stu-id="99e68-144">IL code generated from C# can interact with code that was generated from the .NET versions of F#, Visual Basic, C++, or any of more than 20 other CTS-compliant languages.</span></span> <span data-ttu-id="99e68-145">Un solo ensamblado puede contener varios módulos escritos en diferentes lenguajes .NET y los tipos se pueden hacer referencia mutuamente igual que si estuvieran escritos en el mismo lenguaje.</span><span class="sxs-lookup"><span data-stu-id="99e68-145">A single assembly may contain multiple modules written in different .NET languages, and the types can reference each other as if they were written in the same language.</span></span>

<span data-ttu-id="99e68-146">Además de los servicios en tiempo de ejecución, .NET también incluye amplias bibliotecas,</span><span class="sxs-lookup"><span data-stu-id="99e68-146">In addition to the run time services, .NET also includes extensive libraries.</span></span> <span data-ttu-id="99e68-147">que admiten muchas cargas de trabajo diferentes.</span><span class="sxs-lookup"><span data-stu-id="99e68-147">These libraries support many different workloads.</span></span> <span data-ttu-id="99e68-148">Se organizan en espacios de nombres que proporcionan una gran variedad de funciones útiles para todo, desde la entrada y salida de archivos, la manipulación de cadenas y el análisis de XML hasta los marcos de aplicaciones web y los controles de Windows Forms.</span><span class="sxs-lookup"><span data-stu-id="99e68-148">They're organized into namespaces that provide a wide variety of useful functionality for everything from file input and output to string manipulation to XML parsing, to web application frameworks to Windows Forms controls.</span></span> <span data-ttu-id="99e68-149">En una aplicación de C# típica se usa la biblioteca de clases de .NET de forma extensa para controlar tareas comunes de infraestructura.</span><span class="sxs-lookup"><span data-stu-id="99e68-149">The typical C# application uses the .NET class library extensively to handle common "plumbing" chores.</span></span>

<span data-ttu-id="99e68-150">Para obtener más información sobre .NET, vea [Introducción a .NET](../../core/introduction.md).</span><span class="sxs-lookup"><span data-stu-id="99e68-150">For more information about .NET, see [Overview of .NET](../../core/introduction.md).</span></span>

## <a name="hello-world"></a><span data-ttu-id="99e68-151">Hola a todos</span><span class="sxs-lookup"><span data-stu-id="99e68-151">Hello world</span></span>

<span data-ttu-id="99e68-152">El programa "Hola mundo" tradicionalmente se usa para presentar un lenguaje de programación.</span><span class="sxs-lookup"><span data-stu-id="99e68-152">The "Hello, World" program is traditionally used to introduce a programming language.</span></span> <span data-ttu-id="99e68-153">En este caso, se usa C#:</span><span class="sxs-lookup"><span data-stu-id="99e68-153">Here it is in C#:</span></span>

:::code language="csharp" interactive="try-dotnet" source="./snippets/shared/HelloWorld.cs":::

<span data-ttu-id="99e68-154">El programa "Hola mundo" empieza con una directiva `using` que hace referencia al espacio de nombres `System`.</span><span class="sxs-lookup"><span data-stu-id="99e68-154">The "Hello, World" program starts with a `using` directive that references the `System` namespace.</span></span> <span data-ttu-id="99e68-155">Los espacios de nombres proporcionan un método jerárquico para organizar las bibliotecas y los programas de C#.</span><span class="sxs-lookup"><span data-stu-id="99e68-155">Namespaces provide a hierarchical means of organizing C# programs and libraries.</span></span> <span data-ttu-id="99e68-156">Los espacios de nombres contienen tipos y otros espacios de nombres; por ejemplo, el espacio de nombres `System` contiene varios tipos, como la clase `Console` a la que se hace referencia en el programa, y otros espacios de nombres, como `IO` y `Collections`.</span><span class="sxs-lookup"><span data-stu-id="99e68-156">Namespaces contain types and other namespaces—for example, the `System` namespace contains a number of types, such as the `Console` class referenced in the program, and a number of other namespaces, such as `IO` and `Collections`.</span></span> <span data-ttu-id="99e68-157">Una directiva `using` que hace referencia a un espacio de nombres determinado permite el uso no calificado de los tipos que son miembros de ese espacio de nombres.</span><span class="sxs-lookup"><span data-stu-id="99e68-157">A `using` directive that references a given namespace enables unqualified use of the types that are members of that namespace.</span></span> <span data-ttu-id="99e68-158">Debido a la directiva `using`, puede utilizar el programa `Console.WriteLine` como abreviatura de `System.Console.WriteLine`.</span><span class="sxs-lookup"><span data-stu-id="99e68-158">Because of the `using` directive, the program can use `Console.WriteLine` as shorthand for `System.Console.WriteLine`.</span></span>

<span data-ttu-id="99e68-159">La clase `Hello` declarada por el programa "Hola mundo" tiene un miembro único, el método llamado `Main`.</span><span class="sxs-lookup"><span data-stu-id="99e68-159">The `Hello` class declared by the "Hello, World" program has a single member, the method named `Main`.</span></span> <span data-ttu-id="99e68-160">El método `Main` se declara con el modificador `static`.</span><span class="sxs-lookup"><span data-stu-id="99e68-160">The `Main` method is declared with the `static` modifier.</span></span> <span data-ttu-id="99e68-161">Mientras que los métodos de instancia pueden hacer referencia a una instancia de objeto envolvente determinada utilizando la palabra clave `this`, los métodos estáticos funcionan sin referencia a un objeto determinado.</span><span class="sxs-lookup"><span data-stu-id="99e68-161">While instance methods can reference a particular enclosing object instance using the keyword `this`, static methods operate without reference to a particular object.</span></span> <span data-ttu-id="99e68-162">Por convención, un método estático denominado `Main` sirve como punto de entrada de un programa de C#.</span><span class="sxs-lookup"><span data-stu-id="99e68-162">By convention, a static method named `Main` serves as the entry point of a C# program.</span></span>

<span data-ttu-id="99e68-163">La salida del programa la genera el método `WriteLine` de la clase `Console` en el espacio de nombres `System`.</span><span class="sxs-lookup"><span data-stu-id="99e68-163">The output of the program is produced by the `WriteLine` method of the `Console` class in the `System` namespace.</span></span> <span data-ttu-id="99e68-164">Esta clase la proporcionan las bibliotecas de clase estándar, a las que, de forma predeterminada, el compilador hace referencia automáticamente.</span><span class="sxs-lookup"><span data-stu-id="99e68-164">This class is provided by the standard class libraries, which, by default, are automatically referenced by the compiler.</span></span>

## <a name="types-and-variables"></a><span data-ttu-id="99e68-165">Tipos y variables</span><span class="sxs-lookup"><span data-stu-id="99e68-165">Types and variables</span></span>

<span data-ttu-id="99e68-166">Hay dos clases de tipos en C#: *tipos de valor* y *tipos de referencia*.</span><span class="sxs-lookup"><span data-stu-id="99e68-166">There are two kinds of types in C#: *value types* and *reference types*.</span></span> <span data-ttu-id="99e68-167">Las variables de tipos de valor contienen directamente sus datos.</span><span class="sxs-lookup"><span data-stu-id="99e68-167">Variables of value types directly contain their data.</span></span> <span data-ttu-id="99e68-168">Las variables de tipos de referencia almacenan referencias a los datos, lo que se conoce como objetos.</span><span class="sxs-lookup"><span data-stu-id="99e68-168">Variables of reference types store references to their data, the latter being known as objects.</span></span> <span data-ttu-id="99e68-169">Con los tipos de referencia, es posible que dos variables hagan referencia al mismo objeto y que, por tanto, las operaciones en una variable afecten al objeto al que hace referencia la otra.</span><span class="sxs-lookup"><span data-stu-id="99e68-169">With reference types, it's possible for two variables to reference the same object and possible for operations on one variable to affect the object referenced by the other variable.</span></span> <span data-ttu-id="99e68-170">Con los tipos de valor, cada variable tiene su propia copia de los datos y no es posible que las operaciones en una variable afecten a la otra (excepto para las variables de parámetro `ref` y `out`).</span><span class="sxs-lookup"><span data-stu-id="99e68-170">With value types, the variables each have their own copy of the data, and it isn't possible for operations on one to affect the other (except for `ref` and `out` parameter variables).</span></span>

<span data-ttu-id="99e68-171">Un \***identificador** _ es un nombre de variable.</span><span class="sxs-lookup"><span data-stu-id="99e68-171">An \***identifier** _ is a variable name.</span></span> <span data-ttu-id="99e68-172">Un identificador es una secuencia de caracteres Unicode sin ningún espacio en blanco.</span><span class="sxs-lookup"><span data-stu-id="99e68-172">An identifier is a sequence of unicode characters without any whitespace.</span></span> <span data-ttu-id="99e68-173">Un identificador puede ser una palabra reservada de C# si tiene el prefijo `@`.</span><span class="sxs-lookup"><span data-stu-id="99e68-173">An identifier may be a C# reserved word, if it's prefixed by `@`.</span></span> <span data-ttu-id="99e68-174">El uso de una palabra reservada como identificador puede ser útil al interactuar con otros lenguajes.</span><span class="sxs-lookup"><span data-stu-id="99e68-174">Using a reserved word as an identifier can be useful when interacting with other languages.</span></span>

<span data-ttu-id="99e68-175">Los tipos de valor de C# se dividen en _tipos simples\*, *tipos de enumeración*, *tipos de estructura*, *tipos de valor que aceptan valores NULL* y *tipos de valor de tupla*.</span><span class="sxs-lookup"><span data-stu-id="99e68-175">C#'s value types are further divided into _simple types\*, *enum types*, *struct types*, *nullable value types*, and *tuple value types*.</span></span> <span data-ttu-id="99e68-176">Los tipos de referencia de C# se dividen en *tipos de clase*, *tipos de interfaz*, *tipos de matriz* y *tipos delegados*.</span><span class="sxs-lookup"><span data-stu-id="99e68-176">C#'s reference types are further divided into *class types*, *interface types*, *array types*, and *delegate types*.</span></span>

<span data-ttu-id="99e68-177">En el esquema siguiente se ofrece información general del sistema de tipos de C#.</span><span class="sxs-lookup"><span data-stu-id="99e68-177">The following outline provides an overview of C#'s type system.</span></span>

- [<span data-ttu-id="99e68-178">Tipos de valor</span><span class="sxs-lookup"><span data-stu-id="99e68-178">Value types</span></span>](../language-reference/builtin-types/value-types.md)
  - [<span data-ttu-id="99e68-179">Tipos simples</span><span class="sxs-lookup"><span data-stu-id="99e68-179">Simple types</span></span>](../language-reference/builtin-types/value-types.md#built-in-value-types)
    - <span data-ttu-id="99e68-180">[Entero con signo](../language-reference/builtin-types/integral-numeric-types.md): `sbyte`, `short`, `int`, `long`</span><span class="sxs-lookup"><span data-stu-id="99e68-180">[Signed integral](../language-reference/builtin-types/integral-numeric-types.md): `sbyte`, `short`, `int`, `long`</span></span>
    - <span data-ttu-id="99e68-181">[Entero sin signo](../language-reference/builtin-types/integral-numeric-types.md): `byte`, `ushort`, `uint`, `ulong`</span><span class="sxs-lookup"><span data-stu-id="99e68-181">[Unsigned integral](../language-reference/builtin-types/integral-numeric-types.md): `byte`, `ushort`, `uint`, `ulong`</span></span>
    - <span data-ttu-id="99e68-182">[Caracteres Unicode](../../standard/base-types/character-encoding-introduction.md): `char`, que representa una unidad de código UTF-16</span><span class="sxs-lookup"><span data-stu-id="99e68-182">[Unicode characters](../../standard/base-types/character-encoding-introduction.md): `char`, which represents a UTF-16 code unit</span></span>
    - <span data-ttu-id="99e68-183">[Punto flotante binario IEEE](../language-reference/builtin-types/floating-point-numeric-types.md): `float`, `double`</span><span class="sxs-lookup"><span data-stu-id="99e68-183">[IEEE binary floating-point](../language-reference/builtin-types/floating-point-numeric-types.md): `float`, `double`</span></span>
    - <span data-ttu-id="99e68-184">[Punto flotante decimal de alta precisión](../language-reference/builtin-types/floating-point-numeric-types.md): `decimal`</span><span class="sxs-lookup"><span data-stu-id="99e68-184">[High-precision decimal floating-point](../language-reference/builtin-types/floating-point-numeric-types.md): `decimal`</span></span>
    - <span data-ttu-id="99e68-185">Booleano: `bool`, que representa valores booleanos, valores que son `true` o `false`</span><span class="sxs-lookup"><span data-stu-id="99e68-185">Boolean: `bool`, which represents Boolean values—values that are either `true` or `false`</span></span>
  - [<span data-ttu-id="99e68-186">Tipos de enumeración</span><span class="sxs-lookup"><span data-stu-id="99e68-186">Enum types</span></span>](../language-reference/builtin-types/enum.md)
    - <span data-ttu-id="99e68-187">Tipos definidos por el usuario con el formato `enum E {...}`.</span><span class="sxs-lookup"><span data-stu-id="99e68-187">User-defined types of the form `enum E {...}`.</span></span> <span data-ttu-id="99e68-188">Un tipo `enum` es un tipo distinto con constantes con nombre.</span><span class="sxs-lookup"><span data-stu-id="99e68-188">An `enum` type is a distinct type with named constants.</span></span> <span data-ttu-id="99e68-189">Cada tipo `enum` tiene un tipo subyacente, que debe ser uno de los ocho tipos enteros.</span><span class="sxs-lookup"><span data-stu-id="99e68-189">Every `enum` type has an underlying type, which must be one of the eight integral types.</span></span> <span data-ttu-id="99e68-190">El conjunto de valores de un tipo `enum` es igual que el conjunto de valores del tipo subyacente.</span><span class="sxs-lookup"><span data-stu-id="99e68-190">The set of values of an `enum` type is the same as the set of values of the underlying type.</span></span>
  - [<span data-ttu-id="99e68-191">Tipos de estructura</span><span class="sxs-lookup"><span data-stu-id="99e68-191">Struct types</span></span>](../language-reference/builtin-types/struct.md)
    - <span data-ttu-id="99e68-192">Tipos definidos por el usuario con el formato `struct S {...}`</span><span class="sxs-lookup"><span data-stu-id="99e68-192">User-defined types of the form `struct S {...}`</span></span>
  - [<span data-ttu-id="99e68-193">Tipos de valores que aceptan valores NULL</span><span class="sxs-lookup"><span data-stu-id="99e68-193">Nullable value types</span></span>](../language-reference/builtin-types/nullable-value-types.md)
    - <span data-ttu-id="99e68-194">Extensiones de todos los demás tipos de valor con un valor `null`</span><span class="sxs-lookup"><span data-stu-id="99e68-194">Extensions of all other value types with a `null` value</span></span>
  - [<span data-ttu-id="99e68-195">Tipos de valor de tupla</span><span class="sxs-lookup"><span data-stu-id="99e68-195">Tuple value types</span></span>](../language-reference/builtin-types/value-tuples.md)
    - <span data-ttu-id="99e68-196">Tipos definidos por el usuario con el formato `(T1, T2, ...)`</span><span class="sxs-lookup"><span data-stu-id="99e68-196">User-defined types of the form `(T1, T2, ...)`</span></span>
- [<span data-ttu-id="99e68-197">Tipos de referencia</span><span class="sxs-lookup"><span data-stu-id="99e68-197">Reference types</span></span>](../language-reference/keywords/reference-types.md)
  - [<span data-ttu-id="99e68-198">Tipos de clase</span><span class="sxs-lookup"><span data-stu-id="99e68-198">Class types</span></span>](../language-reference/keywords/class.md)
    - <span data-ttu-id="99e68-199">Clase base definitiva de todos los demás tipos: `object`</span><span class="sxs-lookup"><span data-stu-id="99e68-199">Ultimate base class of all other types: `object`</span></span>
    - <span data-ttu-id="99e68-200">[Cadenas Unicode](../../standard/base-types/character-encoding-introduction.md): `string`, que representa una secuencia de unidades de código UTF-16</span><span class="sxs-lookup"><span data-stu-id="99e68-200">[Unicode strings](../../standard/base-types/character-encoding-introduction.md): `string`, which represents a sequence of UTF-16 code units</span></span>
    - <span data-ttu-id="99e68-201">Tipos definidos por el usuario con el formato `class C {...}`</span><span class="sxs-lookup"><span data-stu-id="99e68-201">User-defined types of the form `class C {...}`</span></span>
  - [<span data-ttu-id="99e68-202">Tipos de interfaz</span><span class="sxs-lookup"><span data-stu-id="99e68-202">Interface types</span></span>](../language-reference/keywords/interface.md)
    - <span data-ttu-id="99e68-203">Tipos definidos por el usuario con el formato `interface I {...}`</span><span class="sxs-lookup"><span data-stu-id="99e68-203">User-defined types of the form `interface I {...}`</span></span>
  - [<span data-ttu-id="99e68-204">Tipos de matriz</span><span class="sxs-lookup"><span data-stu-id="99e68-204">Array types</span></span>](../programming-guide/arrays/index.md)
    - <span data-ttu-id="99e68-205">Unidimensional, multidimensional y escalonada.</span><span class="sxs-lookup"><span data-stu-id="99e68-205">Single-dimensional, multi-dimensional, and jagged.</span></span> <span data-ttu-id="99e68-206">Por ejemplo, `int[]`, `int[,]` y `int[][]`.</span><span class="sxs-lookup"><span data-stu-id="99e68-206">For example: `int[]`, `int[,]`, and `int[][]`</span></span>
  - [<span data-ttu-id="99e68-207">Tipos delegados</span><span class="sxs-lookup"><span data-stu-id="99e68-207">Delegate types</span></span>](../language-reference/builtin-types/reference-types.md#the-delegate-type)
    - <span data-ttu-id="99e68-208">Tipos definidos por el usuario con el formato `delegate int D(...)`</span><span class="sxs-lookup"><span data-stu-id="99e68-208">User-defined types of the form `delegate int D(...)`</span></span>

<span data-ttu-id="99e68-209">Los programas de C# utilizan *declaraciones de tipos* para crear nuevos tipos.</span><span class="sxs-lookup"><span data-stu-id="99e68-209">C# programs use *type declarations* to create new types.</span></span> <span data-ttu-id="99e68-210">Una declaración de tipos especifica el nombre y los miembros del nuevo tipo.</span><span class="sxs-lookup"><span data-stu-id="99e68-210">A type declaration specifies the name and the members of the new type.</span></span> <span data-ttu-id="99e68-211">Seis de las categorías de tipos de C# las define el usuario: tipos de clase, tipos de estructura, tipos de interfaz, tipos de enumeración, tipos de delegado y tipos de valor de tupla.</span><span class="sxs-lookup"><span data-stu-id="99e68-211">Six of C#'s categories of types are user-definable: class types, struct types, interface types, enum types, delegate types, and tuple value types.</span></span>

- <span data-ttu-id="99e68-212">A tipo `class` define una estructura de datos que contiene miembros de datos (campos) y miembros de función (métodos, propiedades y otros).</span><span class="sxs-lookup"><span data-stu-id="99e68-212">A `class` type defines a data structure that contains data members (fields) and function members (methods, properties, and others).</span></span> <span data-ttu-id="99e68-213">Los tipos de clase admiten herencia única y polimorfismo, mecanismos por los que las clases derivadas pueden extender y especializar clases base.</span><span class="sxs-lookup"><span data-stu-id="99e68-213">Class types support single inheritance and polymorphism, mechanisms whereby derived classes can extend and specialize base classes.</span></span>
- <span data-ttu-id="99e68-214">Un tipo `struct` es similar a un tipo de clase, por el hecho de que representa una estructura con miembros de datos y miembros de función.</span><span class="sxs-lookup"><span data-stu-id="99e68-214">A `struct` type is similar to a class type in that it represents a structure with data members and function members.</span></span> <span data-ttu-id="99e68-215">Pero a diferencia de las clases, las estructuras son tipos de valor y no suelen requerir la asignación del montón.</span><span class="sxs-lookup"><span data-stu-id="99e68-215">However, unlike classes, structs are value types and don't typically require heap allocation.</span></span> <span data-ttu-id="99e68-216">Los tipos de estructura no admiten la herencia especificada por el usuario y todos se heredan implícitamente del tipo `object`.</span><span class="sxs-lookup"><span data-stu-id="99e68-216">Struct types don't support user-specified inheritance, and all struct types implicitly inherit from type `object`.</span></span>
- <span data-ttu-id="99e68-217">Un tipo `interface` define un contrato como un conjunto con nombre de miembros públicos.</span><span class="sxs-lookup"><span data-stu-id="99e68-217">An `interface` type defines a contract as a named set of public members.</span></span> <span data-ttu-id="99e68-218">Un valor `class` o `struct` que implementa `interface` debe proporcionar implementaciones de miembros de la interfaz.</span><span class="sxs-lookup"><span data-stu-id="99e68-218">A `class` or `struct` that implements an `interface` must provide implementations of the interface's members.</span></span> <span data-ttu-id="99e68-219">Un `interface` puede heredar de varias interfaces base, y un `class` o `struct` pueden implementar varias interfaces.</span><span class="sxs-lookup"><span data-stu-id="99e68-219">An `interface` may inherit from multiple base interfaces, and a `class` or `struct` may implement multiple interfaces.</span></span>
- <span data-ttu-id="99e68-220">Un tipo `delegate` representa las referencias a métodos con una lista de parámetros determinada y un tipo de valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="99e68-220">A `delegate` type represents references to methods with a particular parameter list and return type.</span></span> <span data-ttu-id="99e68-221">Los delegados permiten tratar métodos como entidades que se puedan asignar a variables y se puedan pasar como parámetros.</span><span class="sxs-lookup"><span data-stu-id="99e68-221">Delegates make it possible to treat methods as entities that can be assigned to variables and passed as parameters.</span></span> <span data-ttu-id="99e68-222">Los delegados son análogos a los tipos de función proporcionados por los lenguajes funcionales.</span><span class="sxs-lookup"><span data-stu-id="99e68-222">Delegates are analogous to function types provided by functional languages.</span></span> <span data-ttu-id="99e68-223">También son similares al concepto de punteros de función de otros lenguajes.</span><span class="sxs-lookup"><span data-stu-id="99e68-223">They're also similar to the concept of function pointers found in some other languages.</span></span> <span data-ttu-id="99e68-224">A diferencia de los punteros de función, los delegados están orientados a objetos y tienen seguridad de tipos.</span><span class="sxs-lookup"><span data-stu-id="99e68-224">Unlike function pointers, delegates are object-oriented and type-safe.</span></span>

<span data-ttu-id="99e68-225">Los tipos `class`, `struct`, `interface` y `delegate` admiten parámetros genéricos, mediante los que se pueden parametrizar con otros tipos.</span><span class="sxs-lookup"><span data-stu-id="99e68-225">The `class`, `struct`, `interface`, and `delegate` types all support generics, whereby they can be parameterized with other types.</span></span>

<span data-ttu-id="99e68-226">C# admite matrices unidimensionales y multidimensionales de cualquier tipo.</span><span class="sxs-lookup"><span data-stu-id="99e68-226">C# supports single-dimensional and multi-dimensional arrays of any type.</span></span> <span data-ttu-id="99e68-227">A diferencia de los tipos enumerados antes, no es necesario declarar los tipos de matriz antes de usarlos.</span><span class="sxs-lookup"><span data-stu-id="99e68-227">Unlike the types listed above, array types don't have to be declared before they can be used.</span></span> <span data-ttu-id="99e68-228">En su lugar, los tipos de matriz se crean mediante un nombre de tipo entre corchetes.</span><span class="sxs-lookup"><span data-stu-id="99e68-228">Instead, array types are constructed by following a type name with square brackets.</span></span> <span data-ttu-id="99e68-229">Por ejemplo, `int[]` es una matriz unidimensional de `int`, `int[,]` es una matriz bidimensional de `int` y `int[][]` es una matriz unidimensional de las matrices unidimensionales, o la matriz "escalonada", de `int`.</span><span class="sxs-lookup"><span data-stu-id="99e68-229">For example, `int[]` is a single-dimensional array of `int`, `int[,]` is a two-dimensional array of `int`, and `int[][]` is a single-dimensional array of single-dimensional arrays, or a "jagged" array, of `int`.</span></span>

<span data-ttu-id="99e68-230">Los tipos que aceptan valores NULL no requieren una definición independiente.</span><span class="sxs-lookup"><span data-stu-id="99e68-230">Nullable types don't require a separate definition.</span></span> <span data-ttu-id="99e68-231">Para cada tipo `T` que no acepta valores NULL, existe un tipo `T?` que acepta valores NULL correspondiente, que puede tener un valor adicional, `null`.</span><span class="sxs-lookup"><span data-stu-id="99e68-231">For each non-nullable type `T`, there's a corresponding nullable type `T?`, which can hold an additional value, `null`.</span></span> <span data-ttu-id="99e68-232">Por ejemplo, `int?` es un tipo que puede contener cualquier entero de 32 bits o el valor `null` y `string?` es un tipo que puede contener cualquier `string` o el valor `null`.</span><span class="sxs-lookup"><span data-stu-id="99e68-232">For instance, `int?` is a type that can hold any 32-bit integer or the value `null`, and `string?` is a type that can hold any `string` or the value `null`.</span></span>

<span data-ttu-id="99e68-233">El sistema de tipos de C# está unificado, de tal forma que un valor de cualquier tipo puede tratarse como `object`.</span><span class="sxs-lookup"><span data-stu-id="99e68-233">C#'s type system is unified such that a value of any type can be treated as an `object`.</span></span> <span data-ttu-id="99e68-234">Todos los tipos de C# directa o indirectamente se derivan del tipo de clase `object`, y `object` es la clase base definitiva de todos los tipos.</span><span class="sxs-lookup"><span data-stu-id="99e68-234">Every type in C# directly or indirectly derives from the `object` class type, and `object` is the ultimate base class of all types.</span></span> <span data-ttu-id="99e68-235">Los valores de tipos de referencia se tratan como objetos mediante la visualización de los valores como tipo `object`.</span><span class="sxs-lookup"><span data-stu-id="99e68-235">Values of reference types are treated as objects simply by viewing the values as type `object`.</span></span> <span data-ttu-id="99e68-236">Los valores de tipos de valor se tratan como objetos mediante la realización de *operaciones de conversión boxing* y *operaciones de conversión unboxing*.</span><span class="sxs-lookup"><span data-stu-id="99e68-236">Values of value types are treated as objects by performing *boxing* and *unboxing operations*.</span></span> <span data-ttu-id="99e68-237">En el ejemplo siguiente, un valor `int` se convierte en `object` y vuelve a `int`.</span><span class="sxs-lookup"><span data-stu-id="99e68-237">In the following example, an `int` value is converted to `object` and back again to `int`.</span></span>

:::code language="csharp" source="./snippets/shared/Program.cs" ID="boxing" :::

<span data-ttu-id="99e68-238">Cuando se asigna un valor de un tipo de valor a una referencia `object`, se asigna un "box" para contener el valor.</span><span class="sxs-lookup"><span data-stu-id="99e68-238">When a value of a value type is assigned to an `object` reference, a "box" is allocated to hold the value.</span></span> <span data-ttu-id="99e68-239">Ese box es una instancia de un tipo de referencia, y es donde se copia el valor.</span><span class="sxs-lookup"><span data-stu-id="99e68-239">That box is an instance of a reference type, and the value is copied into that box.</span></span> <span data-ttu-id="99e68-240">Por el contrario, cuando una referencia `object` se convierte en un tipo de valor, se comprueba si el elemento `object` al que se hace referencia es un box del tipo de valor correcto.</span><span class="sxs-lookup"><span data-stu-id="99e68-240">Conversely, when an `object` reference is cast to a value type, a check is made that the referenced `object` is a box of the correct value type.</span></span> <span data-ttu-id="99e68-241">Si la comprobación se realiza correctamente, el valor del box se copia en el tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="99e68-241">If the check succeeds, the value in the box is copied to the value type.</span></span>

<span data-ttu-id="99e68-242">El sistema de tipos unificado de C# conlleva efectivamente que los tipos de valor se tratan como referencias `object` "a petición".</span><span class="sxs-lookup"><span data-stu-id="99e68-242">C#'s unified type system effectively means that value types are treated as `object` references "on demand."</span></span> <span data-ttu-id="99e68-243">Debido a la unificación, las bibliotecas de uso general que utilizan el tipo `object` pueden usarse con todos los tipos que se derivan de `object`, como, por ejemplo, los tipos de referencia y los tipos de valor.</span><span class="sxs-lookup"><span data-stu-id="99e68-243">Because of the unification, general-purpose libraries that use type `object` can be used with all types that derive from `object`, including both reference types and value types.</span></span>

<span data-ttu-id="99e68-244">Hay varios tipos de *variables* en C#, entre otras, campos, elementos de matriz, variables locales y parámetros.</span><span class="sxs-lookup"><span data-stu-id="99e68-244">There are several kinds of *variables* in C#, including fields, array elements, local variables, and parameters.</span></span> <span data-ttu-id="99e68-245">Las variables representan ubicaciones de almacenamiento.</span><span class="sxs-lookup"><span data-stu-id="99e68-245">Variables represent storage locations.</span></span> <span data-ttu-id="99e68-246">Cada variable tiene un tipo que determina qué valores se pueden almacenar en ella, como se muestra a continuación.</span><span class="sxs-lookup"><span data-stu-id="99e68-246">Every variable has a type that determines what values can be stored in the variable, as shown below.</span></span>

- <span data-ttu-id="99e68-247">Tipo de valor distinto a NULL</span><span class="sxs-lookup"><span data-stu-id="99e68-247">Non-nullable value type</span></span>
  - <span data-ttu-id="99e68-248">Un valor de ese tipo exacto</span><span class="sxs-lookup"><span data-stu-id="99e68-248">A value of that exact type</span></span>
- <span data-ttu-id="99e68-249">Tipos de valor NULL</span><span class="sxs-lookup"><span data-stu-id="99e68-249">Nullable value type</span></span>
  - <span data-ttu-id="99e68-250">Un valor `null` o un valor de ese tipo exacto</span><span class="sxs-lookup"><span data-stu-id="99e68-250">A `null` value or a value of that exact type</span></span>
- <span data-ttu-id="99e68-251">objeto</span><span class="sxs-lookup"><span data-stu-id="99e68-251">object</span></span>
  - <span data-ttu-id="99e68-252">Una referencia `null`, una referencia a un objeto de cualquier tipo de referencia o una referencia a un valor de conversión boxing de cualquier tipo de valor</span><span class="sxs-lookup"><span data-stu-id="99e68-252">A `null` reference, a reference to an object of any reference type, or a reference to a boxed value of any value type</span></span>
- <span data-ttu-id="99e68-253">Tipo de clase</span><span class="sxs-lookup"><span data-stu-id="99e68-253">Class type</span></span>
  - <span data-ttu-id="99e68-254">Una referencia `null`, una referencia a una instancia de ese tipo de clase o una referencia a una instancia de una clase derivada de ese tipo de clase</span><span class="sxs-lookup"><span data-stu-id="99e68-254">A `null` reference, a reference to an instance of that class type, or a reference to an instance of a class derived from that class type</span></span>
- <span data-ttu-id="99e68-255">Tipo de interfaz</span><span class="sxs-lookup"><span data-stu-id="99e68-255">Interface type</span></span>
  - <span data-ttu-id="99e68-256">Un referencia `null`, una referencia a una instancia de un tipo de clase que implementa dicho tipo de interfaz o una referencia a un valor de conversión boxing de un tipo de valor que implementa dicho tipo de interfaz</span><span class="sxs-lookup"><span data-stu-id="99e68-256">A `null` reference, a reference to an instance of a class type that implements that interface type, or a reference to a boxed value of a value type that implements that interface type</span></span>
- <span data-ttu-id="99e68-257">Tipo de matriz</span><span class="sxs-lookup"><span data-stu-id="99e68-257">Array type</span></span>
  - <span data-ttu-id="99e68-258">Una referencia `null`, una referencia a una instancia de ese tipo de matriz o una referencia a una instancia de un tipo de matriz compatible</span><span class="sxs-lookup"><span data-stu-id="99e68-258">A `null` reference, a reference to an instance of that array type, or a reference to an instance of a compatible array type</span></span>
- <span data-ttu-id="99e68-259">Tipo delegado</span><span class="sxs-lookup"><span data-stu-id="99e68-259">Delegate type</span></span>
  - <span data-ttu-id="99e68-260">Una referencia `null` o una referencia a una instancia de un tipo delegado compatible</span><span class="sxs-lookup"><span data-stu-id="99e68-260">A `null` reference or a reference to an instance of a compatible delegate type</span></span>

## <a name="program-structure"></a><span data-ttu-id="99e68-261">Estructura del programa</span><span class="sxs-lookup"><span data-stu-id="99e68-261">Program structure</span></span>

<span data-ttu-id="99e68-262">Los conceptos organizativos clave de C# son [\***programas** _](../programming-guide/inside-a-program/index.md), [_*_espacios de nombres_*_](../programming-guide/namespaces/index.md), [_*_tipos_*_](../programming-guide/types/index.md), [_*_miembros_*_](../programming-guide/classes-and-structs/members.md) y [_*_ensamblados_*_ ](../../standard/assembly/index.md).</span><span class="sxs-lookup"><span data-stu-id="99e68-262">The key organizational concepts in C# are [\***programs** _](../programming-guide/inside-a-program/index.md), [_*_namespaces_*_](../programming-guide/namespaces/index.md), [_*_types_*_](../programming-guide/types/index.md), [_*_members_*_](../programming-guide/classes-and-structs/members.md), and [_*_assemblies_*_](../../standard/assembly/index.md).</span></span> <span data-ttu-id="99e68-263">Los programas declaran tipos, que contienen miembros y pueden organizarse en espacios de nombres.</span><span class="sxs-lookup"><span data-stu-id="99e68-263">Programs declare types, which contain members and can be organized into namespaces.</span></span> <span data-ttu-id="99e68-264">Las clases, estructuras e interfaces son ejemplos de tipos.</span><span class="sxs-lookup"><span data-stu-id="99e68-264">Classes, structs, and interfaces are examples of types.</span></span> <span data-ttu-id="99e68-265">Los campos, los métodos, las propiedades y los eventos son ejemplos de miembros.</span><span class="sxs-lookup"><span data-stu-id="99e68-265">Fields, methods, properties, and events are examples of members.</span></span> <span data-ttu-id="99e68-266">Cuando se compilan programas de C#, se empaquetan físicamente en ensamblados.</span><span class="sxs-lookup"><span data-stu-id="99e68-266">When C# programs are compiled, they're physically packaged into assemblies.</span></span> <span data-ttu-id="99e68-267">Normalmente, los ensamblados tienen la extensión de archivo `.exe` o `.dll`, en función de si implementan _*_aplicaciones_*_ o _*_bibliotecas_*_, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="99e68-267">Assemblies typically have the file extension `.exe` or `.dll`, depending on whether they implement _*_applications_*_ or _*_libraries_*_, respectively.</span></span>

<span data-ttu-id="99e68-268">Como ejemplo pequeño, considere la posibilidad de usar un ensamblado que contenga el código siguiente:</span><span class="sxs-lookup"><span data-stu-id="99e68-268">As a small example, consider an assembly that contains the following code:</span></span>

:::code language="csharp" source="./snippets/shared/AcmeStack.cs":::

<span data-ttu-id="99e68-269">El nombre completo de esta clase es `Acme.Collections.Stack`.</span><span class="sxs-lookup"><span data-stu-id="99e68-269">The fully qualified name of this class is `Acme.Collections.Stack`.</span></span> <span data-ttu-id="99e68-270">La clase contiene varios miembros: un campo denominado `top`, dos métodos denominados `Push` y `Pop`, y una clase anidada denominada `Entry`.</span><span class="sxs-lookup"><span data-stu-id="99e68-270">The class contains several members: a field named `top`, two methods named `Push` and `Pop`, and a nested class named `Entry`.</span></span> <span data-ttu-id="99e68-271">La clase `Entry` contiene además tres miembros: un campo denominado `next`, un campo denominado `data` y un constructor.</span><span class="sxs-lookup"><span data-stu-id="99e68-271">The `Entry` class further contains three members: a field named `next`, a field named `data`, and a constructor.</span></span> <span data-ttu-id="99e68-272">`Stack` es una clase _genérica\*.</span><span class="sxs-lookup"><span data-stu-id="99e68-272">The `Stack` is a _generic\* class.</span></span> <span data-ttu-id="99e68-273">Tiene un parámetro de tipo, `T`, que se reemplaza con un tipo concreto cuando se usa.</span><span class="sxs-lookup"><span data-stu-id="99e68-273">It has one type parameter, `T` that is replaced with a concrete type when it's used.</span></span>

> [!NOTE]
> <span data-ttu-id="99e68-274">Una *pila* es una colección de tipo "el primero que entra es el último que sale" (FILO).</span><span class="sxs-lookup"><span data-stu-id="99e68-274">A *stack* is a "first in - last out" (FILO) collection.</span></span> <span data-ttu-id="99e68-275">Los elementos nuevos se agregan a la parte superior de la pila.</span><span class="sxs-lookup"><span data-stu-id="99e68-275">New elements are added to the top of the stack.</span></span> <span data-ttu-id="99e68-276">Cuando se quita un elemento, se quita de la parte superior de la pila.</span><span class="sxs-lookup"><span data-stu-id="99e68-276">When an element is removed, it is removed from the top of the stack.</span></span>

<span data-ttu-id="99e68-277">Los ensamblados contienen código ejecutable en forma de instrucciones de lenguaje intermedio (IL) e información simbólica en forma de metadatos.</span><span class="sxs-lookup"><span data-stu-id="99e68-277">Assemblies contain executable code in the form of Intermediate Language (IL) instructions, and symbolic information in the form of metadata.</span></span> <span data-ttu-id="99e68-278">Antes de ejecutarlo, el compilador Just-In-Time (JIT) del entorno de ejecución de .NET convierte el código de IL de un ensamblado en código específico del procesador.</span><span class="sxs-lookup"><span data-stu-id="99e68-278">Before it's executed, the Just-In-Time (JIT) compiler of .NET Common Language Runtime converts the IL code in an assembly to processor-specific code.</span></span>

<span data-ttu-id="99e68-279">Como un ensamblado es una unidad autodescriptiva de funcionalidad que contiene código y metadatos, no hay necesidad de directivas `#include` ni archivos de encabezado de C#.</span><span class="sxs-lookup"><span data-stu-id="99e68-279">Because an assembly is a self-describing unit of functionality containing both code and metadata, there's no need for `#include` directives and header files in C#.</span></span> <span data-ttu-id="99e68-280">Los tipos y miembros públicos contenidos en un ensamblado determinado estarán disponibles en un programa de C# simplemente haciendo referencia a dicho ensamblado al compilar el programa.</span><span class="sxs-lookup"><span data-stu-id="99e68-280">The public types and members contained in a particular assembly are made available in a C# program simply by referencing that assembly when compiling the program.</span></span> <span data-ttu-id="99e68-281">Por ejemplo, este programa usa la clase `Acme.Collections.Stack` desde el ensamblado `acme.dll`:</span><span class="sxs-lookup"><span data-stu-id="99e68-281">For example, this program uses the `Acme.Collections.Stack` class from the `acme.dll` assembly:</span></span>

:::code language="csharp" source="./snippets/shared/StackUsage.cs":::

<span data-ttu-id="99e68-282">Para compilar este programa, necesitaría *hacer referencia* al ensamblado que contiene la clase de pila que se define en el ejemplo anterior.</span><span class="sxs-lookup"><span data-stu-id="99e68-282">To compile this program, you would need to *reference* the assembly containing the stack class defined in the earlier example.</span></span>

<span data-ttu-id="99e68-283">Los programas de C# se pueden almacenar en varios archivos de origen.</span><span class="sxs-lookup"><span data-stu-id="99e68-283">C# programs can be stored in several source files.</span></span> <span data-ttu-id="99e68-284">Cuando se compila un programa de C#, todos los archivos de origen se procesan juntos y se pueden hacer referencia entre sí de manera libre.</span><span class="sxs-lookup"><span data-stu-id="99e68-284">When a C# program is compiled, all of the source files are processed together, and the source files can freely reference each other.</span></span> <span data-ttu-id="99e68-285">Conceptualmente, es como si todos los archivos de origen estuviesen concatenados en un archivo de gran tamaño antes de que se procesen.</span><span class="sxs-lookup"><span data-stu-id="99e68-285">Conceptually, it's as if all the source files were concatenated into one large file before being processed.</span></span> <span data-ttu-id="99e68-286">En C# nunca se necesitan declaraciones adelantadas porque, excepto en contadas ocasiones, el orden de declaración es insignificante.</span><span class="sxs-lookup"><span data-stu-id="99e68-286">Forward declarations are never needed in C# because, with few exceptions, declaration order is insignificant.</span></span> <span data-ttu-id="99e68-287">C# no limita un archivo de origen a declarar solamente un tipo público ni precisa que el nombre del archivo de origen coincida con un tipo declarado en el archivo de origen.</span><span class="sxs-lookup"><span data-stu-id="99e68-287">C# doesn't limit a source file to declaring only one public type nor does it require the name of the source file to match a type declared in the source file.</span></span>

<span data-ttu-id="99e68-288">En otros artículos de este paseo se explican estos bloques organizativos.</span><span class="sxs-lookup"><span data-stu-id="99e68-288">Further articles in this tour explain these organizational blocks.</span></span>

>[!div class="step-by-step"]
>[<span data-ttu-id="99e68-289">Siguiente</span><span class="sxs-lookup"><span data-stu-id="99e68-289">Next</span></span>](types.md)
