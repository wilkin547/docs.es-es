---
title: 'Definición de tipos y sus miembros: un recorrido por C#'
description: Los bloques de creación de los programas son los tipos. Aprenda a crear clases, estructuras, interfaces y mucho más en C#.
ms.date: 08/06/2020
ms.openlocfilehash: b1ce24611fec6fdf01d5ecb8d6ae974e147c78c5
ms.sourcegitcommit: 68c9d9d9a97aab3b59d388914004b5474cf1dbd7
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 01/30/2021
ms.locfileid: "99216608"
---
# <a name="types-and-members"></a><span data-ttu-id="c82e1-104">Tipos y miembros</span><span class="sxs-lookup"><span data-stu-id="c82e1-104">Types and members</span></span>

<span data-ttu-id="c82e1-105">En cuanto lenguaje orientado a objetos, C# admite los conceptos de encapsulación, herencia y polimorfismo.</span><span class="sxs-lookup"><span data-stu-id="c82e1-105">As an object-oriented language, C# supports the concepts of encapsulation, inheritance, and polymorphism.</span></span> <span data-ttu-id="c82e1-106">Una clase puede heredar directamente de una clase primaria e implementar cualquier número de interfaces.</span><span class="sxs-lookup"><span data-stu-id="c82e1-106">A class may inherit directly from one parent class, and it may implement any number of interfaces.</span></span> <span data-ttu-id="c82e1-107">Los métodos que invalidan los métodos virtuales en una clase primaria requieren la palabra clave `override` como una manera de evitar redefiniciones accidentales.</span><span class="sxs-lookup"><span data-stu-id="c82e1-107">Methods that override virtual methods in a parent class require the `override` keyword as a way to avoid accidental redefinition.</span></span> <span data-ttu-id="c82e1-108">En C#, un struct es como una clase ligera; es un tipo asignado en la pila que puede implementar interfaces pero que no admite la herencia.</span><span class="sxs-lookup"><span data-stu-id="c82e1-108">In C#, a struct is like a lightweight class; it's a stack-allocated type that can implement interfaces but doesn't support inheritance.</span></span> <span data-ttu-id="c82e1-109">C# también proporciona registros, que son tipos de clase cuyo propósito es, principalmente, almacenar valores de datos.</span><span class="sxs-lookup"><span data-stu-id="c82e1-109">C# also provides records, which are class types whose purpose is primarily storing data values.</span></span>

## <a name="classes-and-objects"></a><span data-ttu-id="c82e1-110">Clases y objetos</span><span class="sxs-lookup"><span data-stu-id="c82e1-110">Classes and objects</span></span>

<span data-ttu-id="c82e1-111">Las *clases* son los tipos más fundamentales de C#.</span><span class="sxs-lookup"><span data-stu-id="c82e1-111">*Classes* are the most fundamental of C#’s types.</span></span> <span data-ttu-id="c82e1-112">Una clase es una estructura de datos que combina estados (campos) y acciones (métodos y otros miembros de función) en una sola unidad.</span><span class="sxs-lookup"><span data-stu-id="c82e1-112">A class is a data structure that combines state (fields) and actions (methods and other function members) in a single unit.</span></span> <span data-ttu-id="c82e1-113">Una clase proporciona una definición para *instancias* de la clase, también conocidas como *objetos*.</span><span class="sxs-lookup"><span data-stu-id="c82e1-113">A class provides a definition for *instances* of the class, also known as *objects*.</span></span> <span data-ttu-id="c82e1-114">Las clases admiten *herencia* y *polimorfismo*, mecanismos por los que las *clases derivadas* pueden extender y especializar *clases base*.</span><span class="sxs-lookup"><span data-stu-id="c82e1-114">Classes support *inheritance* and *polymorphism*, mechanisms whereby *derived classes* can extend and specialize *base classes*.</span></span>

<span data-ttu-id="c82e1-115">Las clases nuevas se crean mediante declaraciones de clase.</span><span class="sxs-lookup"><span data-stu-id="c82e1-115">New classes are created using class declarations.</span></span> <span data-ttu-id="c82e1-116">Una declaración de clase comienza con un encabezado.</span><span class="sxs-lookup"><span data-stu-id="c82e1-116">A class declaration starts with a header.</span></span> <span data-ttu-id="c82e1-117">El encabezado especifica lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="c82e1-117">The header specifies:</span></span>

- <span data-ttu-id="c82e1-118">Atributos y modificadores de la clase</span><span class="sxs-lookup"><span data-stu-id="c82e1-118">The attributes and modifiers of the class</span></span>
- <span data-ttu-id="c82e1-119">Nombre de la clase</span><span class="sxs-lookup"><span data-stu-id="c82e1-119">The name of the class</span></span>
- <span data-ttu-id="c82e1-120">Clase base (al heredar de una [clase base](#base-classes))</span><span class="sxs-lookup"><span data-stu-id="c82e1-120">The base class (when inheriting from a [base class](#base-classes))</span></span>
- <span data-ttu-id="c82e1-121">Interfaces implementadas por la clase</span><span class="sxs-lookup"><span data-stu-id="c82e1-121">The interfaces implemented by the class.</span></span>

<span data-ttu-id="c82e1-122">Al encabezado le sigue el cuerpo de la clase, que consta de una lista de declaraciones de miembros escritas entre los delimitadores `{` y `}`.</span><span class="sxs-lookup"><span data-stu-id="c82e1-122">The header is followed by the class body, which consists of a list of member declarations written between the delimiters `{` and `}`.</span></span>

<span data-ttu-id="c82e1-123">En el código siguiente se muestra una declaración de una clase simple denominada `Point`:</span><span class="sxs-lookup"><span data-stu-id="c82e1-123">The following code shows a declaration of a simple class named `Point`:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="PointClass":::

<span data-ttu-id="c82e1-124">Las instancias de clases se crean mediante el operador `new`, que asigna memoria para una nueva instancia, invoca un constructor para inicializar la instancia y devuelve una referencia a la instancia.</span><span class="sxs-lookup"><span data-stu-id="c82e1-124">Instances of classes are created using the `new` operator, which allocates memory for a new instance, invokes a constructor to initialize the instance, and returns a reference to the instance.</span></span> <span data-ttu-id="c82e1-125">Las instrucciones siguientes crean dos objetos `Point` y almacenan las referencias en esos objetos en dos variables:</span><span class="sxs-lookup"><span data-stu-id="c82e1-125">The following statements create two `Point` objects and store references to those objects in two variables:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="CreatePoints":::

<span data-ttu-id="c82e1-126">La memoria ocupada por un objeto se reclama automáticamente cuando el objeto ya no es accesible.</span><span class="sxs-lookup"><span data-stu-id="c82e1-126">The memory occupied by an object is automatically reclaimed when the object is no longer reachable.</span></span> <span data-ttu-id="c82e1-127">En C#, no es necesario ni posible desasignar objetos de forma explícita.</span><span class="sxs-lookup"><span data-stu-id="c82e1-127">It's not necessary or possible to explicitly deallocate objects in C#.</span></span>

### <a name="type-parameters"></a><span data-ttu-id="c82e1-128">Parámetros de tipo</span><span class="sxs-lookup"><span data-stu-id="c82e1-128">Type parameters</span></span>

<span data-ttu-id="c82e1-129">Las clases genéricas definen [\***parámetros de tipo** _](../programming-guide/generics/index.md).</span><span class="sxs-lookup"><span data-stu-id="c82e1-129">Generic classes define [\***type parameters** _](../programming-guide/generics/index.md).</span></span> <span data-ttu-id="c82e1-130">Los parámetros de tipo son una lista de nombres de parámetros de tipo entre paréntesis angulares.</span><span class="sxs-lookup"><span data-stu-id="c82e1-130">Type parameters are a list of type parameter names enclosed in angle brackets.</span></span> <span data-ttu-id="c82e1-131">Los parámetros de tipo siguen el nombre de la clase.</span><span class="sxs-lookup"><span data-stu-id="c82e1-131">Type parameters follow the class name.</span></span> <span data-ttu-id="c82e1-132">Los parámetros de tipo pueden usarse luego en el cuerpo de las declaraciones de clase para definir a los miembros de la clase.</span><span class="sxs-lookup"><span data-stu-id="c82e1-132">The type parameters can then be used in the body of the class declarations to define the members of the class.</span></span> <span data-ttu-id="c82e1-133">En el ejemplo siguiente, los parámetros de tipo de `Pair` son `TFirst` y `TSecond`:</span><span class="sxs-lookup"><span data-stu-id="c82e1-133">In the following example, the type parameters of `Pair` are `TFirst` and `TSecond`:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="DefinePairClass":::

<span data-ttu-id="c82e1-134">Un tipo de clase que se declara para tomar parámetros de tipo se denomina _tipo de clase genérica\*.</span><span class="sxs-lookup"><span data-stu-id="c82e1-134">A class type that is declared to take type parameters is called a _generic class type\*.</span></span> <span data-ttu-id="c82e1-135">Los tipos de estructura, interfaz y delegado también pueden ser genéricos.</span><span class="sxs-lookup"><span data-stu-id="c82e1-135">Struct, interface, and delegate types can also be generic.</span></span>
<span data-ttu-id="c82e1-136">Cuando se usa la clase genérica, se deben proporcionar argumentos de tipo para cada uno de los parámetros de tipo:</span><span class="sxs-lookup"><span data-stu-id="c82e1-136">When the generic class is used, type arguments must be provided for each of the type parameters:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="CreatePairObject":::

<span data-ttu-id="c82e1-137">Un tipo genérico con argumentos de tipo proporcionado, como `Pair<int,string>` anteriormente, se conoce como *tipo construido*.</span><span class="sxs-lookup"><span data-stu-id="c82e1-137">A generic type with type arguments provided, like `Pair<int,string>` above, is called a *constructed type*.</span></span>

### <a name="base-classes"></a><span data-ttu-id="c82e1-138">Clases base</span><span class="sxs-lookup"><span data-stu-id="c82e1-138">Base classes</span></span>

<span data-ttu-id="c82e1-139">Una declaración de clase puede especificar una clase base.</span><span class="sxs-lookup"><span data-stu-id="c82e1-139">A class declaration may specify a base class.</span></span> <span data-ttu-id="c82e1-140">Tras el nombre de clase y los parámetros de tipo, agregue un signo de dos puntos y el nombre de la clase base.</span><span class="sxs-lookup"><span data-stu-id="c82e1-140">Follow the class name and type parameters with a colon and the name of the base class.</span></span> <span data-ttu-id="c82e1-141">Omitir una especificación de la clase base es igual que derivarla del tipo `object`.</span><span class="sxs-lookup"><span data-stu-id="c82e1-141">Omitting a base class specification is the same as deriving from type `object`.</span></span> <span data-ttu-id="c82e1-142">En el ejemplo siguiente, la clase base de `Point3D` es `Point`.</span><span class="sxs-lookup"><span data-stu-id="c82e1-142">In the following example, the base class of `Point3D` is `Point`.</span></span> <span data-ttu-id="c82e1-143">En el primer ejemplo, la clase base de `Point` es `object`:</span><span class="sxs-lookup"><span data-stu-id="c82e1-143">From the first example, the base class of `Point` is `object`:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="Create3DPoint":::

<span data-ttu-id="c82e1-144">Una clase hereda a los miembros de su clase base.</span><span class="sxs-lookup"><span data-stu-id="c82e1-144">A class inherits the members of its base class.</span></span> <span data-ttu-id="c82e1-145">La herencia significa que una clase contiene implícitamente casi todos los miembros de su clase base.</span><span class="sxs-lookup"><span data-stu-id="c82e1-145">Inheritance means that a class implicitly contains almost all members of its base class.</span></span> <span data-ttu-id="c82e1-146">Una clase no hereda la instancia, los constructores estáticos ni el finalizador.</span><span class="sxs-lookup"><span data-stu-id="c82e1-146">A class doesn't inherit the instance and static constructors, and the finalizer.</span></span> <span data-ttu-id="c82e1-147">Una clase derivada puede agregar nuevos miembros a aquellos de los que hereda, pero no puede quitar la definición de un miembro heredado.</span><span class="sxs-lookup"><span data-stu-id="c82e1-147">A derived class can add new members to those members it inherits, but it can't remove the definition of an inherited member.</span></span> <span data-ttu-id="c82e1-148">En el ejemplo anterior, `Point3D` hereda los miembros `X` y `Y` de `Point`, y cada instancia de `Point3D` contiene tres miembros: `X`, `Y` y `Z`.</span><span class="sxs-lookup"><span data-stu-id="c82e1-148">In the previous example, `Point3D` inherits the `X` and `Y` members from `Point`, and every `Point3D` instance contains three properties, `X`, `Y`, and `Z`.</span></span>

<span data-ttu-id="c82e1-149">Existe una conversión implícita de un tipo de clase a cualquiera de sus tipos de clase base.</span><span class="sxs-lookup"><span data-stu-id="c82e1-149">An implicit conversion exists from a class type to any of its base class types.</span></span> <span data-ttu-id="c82e1-150">Una variable de un tipo de clase puede hacer referencia a una instancia de esa clase o a una instancia de cualquier clase derivada.</span><span class="sxs-lookup"><span data-stu-id="c82e1-150">A variable of a class type can reference an instance of that class or an instance of any derived class.</span></span> <span data-ttu-id="c82e1-151">Por ejemplo, dadas las declaraciones de clase anteriores, una variable de tipo `Point` puede hacer referencia a una instancia de `Point` o `Point3D`:</span><span class="sxs-lookup"><span data-stu-id="c82e1-151">For example, given the previous class declarations, a variable of type `Point` can reference either a `Point` or a `Point3D`:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="ImplicitCastToBase":::

## <a name="structs"></a><span data-ttu-id="c82e1-152">Estructuras</span><span class="sxs-lookup"><span data-stu-id="c82e1-152">Structs</span></span>

<span data-ttu-id="c82e1-153">Las clases definen tipos que admiten la herencia y el polimorfismo.</span><span class="sxs-lookup"><span data-stu-id="c82e1-153">Classes define types that support inheritance and polymorphism.</span></span> <span data-ttu-id="c82e1-154">Permiten crear comportamientos sofisticados basados en jerarquías de clases derivadas.</span><span class="sxs-lookup"><span data-stu-id="c82e1-154">They enable you to create sophisticated behaviors based on hierarchies of derived classes.</span></span> <span data-ttu-id="c82e1-155">Por el contrario, los tipos [\***struct** _](../language-reference/builtin-types/struct.md) son tipos más sencillos cuyo propósito principal es almacenar valores de datos.</span><span class="sxs-lookup"><span data-stu-id="c82e1-155">By contrast, [\***struct** _](../language-reference/builtin-types/struct.md) types are simpler types whose primary purpose is to store data values.</span></span> <span data-ttu-id="c82e1-156">Dichos tipos struct no pueden declarar un tipo base; se derivan implícitamente de <xref:System.ValueType?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c82e1-156">Structs can't declare a base type; they implicitly derive from <xref:System.ValueType?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c82e1-157">No se pueden derivar otros tipos de `struct` a partir de un tipo de `struct`.</span><span class="sxs-lookup"><span data-stu-id="c82e1-157">You can't derive other `struct` types from a `struct` type.</span></span> <span data-ttu-id="c82e1-158">Están sellados implícitamente.</span><span class="sxs-lookup"><span data-stu-id="c82e1-158">They're implicitly sealed.</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="PointStruct":::

## <a name="interfaces"></a><span data-ttu-id="c82e1-159">Interfaces</span><span class="sxs-lookup"><span data-stu-id="c82e1-159">Interfaces</span></span>

<span data-ttu-id="c82e1-160">Una [_*_interfaz_*_](../programming-guide/interfaces/index.md) define un contrato que se puede implementar mediante clases y estructuras.</span><span class="sxs-lookup"><span data-stu-id="c82e1-160">An [_*_interface_*_](../programming-guide/interfaces/index.md) defines a contract that can be implemented by classes and structs.</span></span> <span data-ttu-id="c82e1-161">Una interfaz puede contener métodos, propiedades, eventos e indexadores.</span><span class="sxs-lookup"><span data-stu-id="c82e1-161">An interface can contain methods, properties, events, and indexers.</span></span> <span data-ttu-id="c82e1-162">Normalmente, una interfaz no proporciona implementaciones de los miembros que define, sino que simplemente especifica los miembros que se deben proporcionar mediante clases o estructuras que implementan la interfaz.</span><span class="sxs-lookup"><span data-stu-id="c82e1-162">An interface typically doesn't provide implementations of the members it defines—it merely specifies the members that must be supplied by classes or structs that implement the interface.</span></span>

<span data-ttu-id="c82e1-163">Las interfaces pueden usar la _*_herencia múltiple_*_.</span><span class="sxs-lookup"><span data-stu-id="c82e1-163">Interfaces may employ _*_multiple inheritance_*_.</span></span> <span data-ttu-id="c82e1-164">En el ejemplo siguiente, la interfaz `IComboBox` hereda de `ITextBox` y `IListBox`.</span><span class="sxs-lookup"><span data-stu-id="c82e1-164">In the following example, the interface `IComboBox` inherits from both `ITextBox` and `IListBox`.</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="FirstInterfaces":::

<span data-ttu-id="c82e1-165">Las clases y los structs pueden implementar varias interfaces.</span><span class="sxs-lookup"><span data-stu-id="c82e1-165">Classes and structs can implement multiple interfaces.</span></span> <span data-ttu-id="c82e1-166">En el ejemplo siguiente, la clase `EditBox` implementa `IControl` y `IDataBound`.</span><span class="sxs-lookup"><span data-stu-id="c82e1-166">In the following example, the class `EditBox` implements both `IControl` and `IDataBound`.</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="ImplementInterfaces":::

<span data-ttu-id="c82e1-167">Cuando una clase o un struct implementan una interfaz determinada, las instancias de esa clase o struct se pueden convertir implícitamente a ese tipo de interfaz.</span><span class="sxs-lookup"><span data-stu-id="c82e1-167">When a class or struct implements a particular interface, instances of that class or struct can be implicitly converted to that interface type.</span></span> <span data-ttu-id="c82e1-168">Por ejemplo</span><span class="sxs-lookup"><span data-stu-id="c82e1-168">For example</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="UseInterfaces":::

## <a name="enums"></a><span data-ttu-id="c82e1-169">Enumeraciones</span><span class="sxs-lookup"><span data-stu-id="c82e1-169">Enums</span></span>

<span data-ttu-id="c82e1-170">Un tipo de [_*_enumeración_*_](../language-reference/builtin-types/enum.md) define un conjunto de valores constantes.</span><span class="sxs-lookup"><span data-stu-id="c82e1-170">An [_*_Enum_*_](../language-reference/builtin-types/enum.md) type defines a set of constant values.</span></span> <span data-ttu-id="c82e1-171">En el elemento `enum` siguiente se declaran constantes que definen diferentes verduras de raíz:</span><span class="sxs-lookup"><span data-stu-id="c82e1-171">The following `enum` declares constants that define different root vegetables:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="EnumDeclaration":::

<span data-ttu-id="c82e1-172">También puede definir un elemento `enum` que se usará de forma combinada como marcas.</span><span class="sxs-lookup"><span data-stu-id="c82e1-172">You can also define an `enum` to be used in combination as flags.</span></span> <span data-ttu-id="c82e1-173">La declaración siguiente declara un conjunto de marcas para las cuatro estaciones.</span><span class="sxs-lookup"><span data-stu-id="c82e1-173">The following declaration declares a set of flags for the four seasons.</span></span> <span data-ttu-id="c82e1-174">Se puede aplicar cualquier combinación de estaciones, incluido un valor `All` que incluya todas las estaciones:</span><span class="sxs-lookup"><span data-stu-id="c82e1-174">Any combination of the seasons may be applied, including an `All` value that includes all seasons:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="FlagsEnumDeclaration":::

<span data-ttu-id="c82e1-175">En el ejemplo siguiente se muestran las declaraciones de ambas enumeraciones anteriores:</span><span class="sxs-lookup"><span data-stu-id="c82e1-175">The following example shows declarations of both the preceding enums:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="UsingEnums":::

## <a name="nullable-types"></a><span data-ttu-id="c82e1-176">Tipos que aceptan valores NULL</span><span class="sxs-lookup"><span data-stu-id="c82e1-176">Nullable types</span></span>

<span data-ttu-id="c82e1-177">Las variables de cualquier tipo se pueden declarar como _*_que no aceptan valores NULL_*_ o _*_que admiten un valor NULL_*_.</span><span class="sxs-lookup"><span data-stu-id="c82e1-177">Variables of any type may be declared as _*_non-nullable_*_ or _*_nullable_*_.</span></span> <span data-ttu-id="c82e1-178">Una variable que acepta valores NULL puede contener un valor `null` adicional que no indica valor alguno.</span><span class="sxs-lookup"><span data-stu-id="c82e1-178">A nullable variable can hold an additional `null` value, indicating no value.</span></span> <span data-ttu-id="c82e1-179">Los tipos de valor que aceptan valores NULL (estructuras o enumeraciones) se representan mediante <xref:System.Nullable%601?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c82e1-179">Nullable Value types (structs or enums) are represented by <xref:System.Nullable%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c82e1-180">Los tipos de referencia que no aceptan valores NULL y los que sí aceptan valores NULL se representan mediante el tipo de referencia subyacente.</span><span class="sxs-lookup"><span data-stu-id="c82e1-180">Non-nullable and Nullable Reference types are both represented by the underlying reference type.</span></span> <span data-ttu-id="c82e1-181">La distinción se representa mediante metadatos leídos por el compilador y algunas bibliotecas.</span><span class="sxs-lookup"><span data-stu-id="c82e1-181">The distinction is represented by metadata read by the compiler and some libraries.</span></span> <span data-ttu-id="c82e1-182">El compilador proporciona advertencias cuando se desreferencian las referencias que aceptan valores NULL sin comprobar primero su valor con `null`.</span><span class="sxs-lookup"><span data-stu-id="c82e1-182">The compiler provides warnings when nullable references are dereferenced without first checking their value against `null`.</span></span> <span data-ttu-id="c82e1-183">El compilador también proporciona advertencias cuando las referencias que no aceptan valores NULL se asignan a un valor que puede ser `null`.</span><span class="sxs-lookup"><span data-stu-id="c82e1-183">The compiler also provides warnings when non-nullable references are assigned a value that may be `null`.</span></span> <span data-ttu-id="c82e1-184">En el ejemplo siguiente se declara un elemento _*_int que admite un valor NULL_*_, y que se inicializa en `null`.</span><span class="sxs-lookup"><span data-stu-id="c82e1-184">The following example declares a _*_nullable int_*_, initializing it to `null`.</span></span> <span data-ttu-id="c82e1-185">A continuación, establece el valor en `5`.</span><span class="sxs-lookup"><span data-stu-id="c82e1-185">Then, it sets the value to `5`.</span></span> <span data-ttu-id="c82e1-186">Muestra el mismo concepto con una _*_cadena que admite un valor NULL_*_.</span><span class="sxs-lookup"><span data-stu-id="c82e1-186">It demonstrates the same concept with a _*_nullable string_*_.</span></span> <span data-ttu-id="c82e1-187">Para más información, consulte [Tipos de valor que admiten un valor NULL](../language-reference/builtin-types/nullable-value-types.md) y [Tipos de referencia que aceptan valores NULL](../nullable-references.md).</span><span class="sxs-lookup"><span data-stu-id="c82e1-187">For more information, see [nullable value types](../language-reference/builtin-types/nullable-value-types.md) and [nullable reference types](../nullable-references.md).</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="DeclareNullable":::

## <a name="tuples"></a><span data-ttu-id="c82e1-188">Tuplas</span><span class="sxs-lookup"><span data-stu-id="c82e1-188">Tuples</span></span>

<span data-ttu-id="c82e1-189">C# admite [_ *_tuplas_*\*](../language-reference/builtin-types/value-tuples.md), lo que proporciona una sintaxis concisa para agrupar varios elementos de datos en una estructura de datos ligera.</span><span class="sxs-lookup"><span data-stu-id="c82e1-189">C# supports [_ *_tuples_*\*](../language-reference/builtin-types/value-tuples.md), which provides concise syntax to group multiple data elements in a lightweight data structure.</span></span> <span data-ttu-id="c82e1-190">Puede crear una instancia de una tupla declarando los tipos y los nombres de los miembros entre `(` y `)`, como se muestra en el ejemplo siguiente:</span><span class="sxs-lookup"><span data-stu-id="c82e1-190">You instantiate a tuple by declaring the types and names of the members between `(` and `)`, as shown in the following example:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="DeclareTuples":::

<span data-ttu-id="c82e1-191">Las tuplas proporcionan una alternativa para la estructura de datos con varios miembros sin usar los bloques de creación que se describen en el siguiente artículo.</span><span class="sxs-lookup"><span data-stu-id="c82e1-191">Tuples provide an alternative for data structure with multiple members, without using the building blocks described in the next article.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="c82e1-192">[Anterior](index.md)
>[Siguiente](program-building-blocks.md)</span><span class="sxs-lookup"><span data-stu-id="c82e1-192">[Previous](index.md)
[Next](program-building-blocks.md)</span></span>
