---
title: 'Clases y objetos en C#: un paseo por el lenguaje C#'
description: "¿Nuevo en C#? Lea esta información general sobre clases, objetos y herencia."
keywords: .NET, csharp, clase, instancia, objeto, herencia, polimorfismo
author: BillWagner
ms.author: wiwagn
ms.date: 08/10/2016
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.assetid: 63a89bde-0f05-4bc4-b0cd-4f693854f0cd
ms.translationtype: HT
ms.sourcegitcommit: 306c608dc7f97594ef6f72ae0f5aaba596c936e1
ms.openlocfilehash: c71aee3dbfb6544973e1527955ca03deb6b569f3
ms.contentlocale: es-es
ms.lasthandoff: 07/28/2017

---
# <a name="classes-and-objects"></a><span data-ttu-id="0eb41-105">Clases y objetos</span><span class="sxs-lookup"><span data-stu-id="0eb41-105">Classes and objects</span></span>

<span data-ttu-id="0eb41-106">Las *clases* son los tipos más fundamentales de C#.</span><span class="sxs-lookup"><span data-stu-id="0eb41-106">*Classes* are the most fundamental of C#’s types.</span></span> <span data-ttu-id="0eb41-107">Una clase es una estructura de datos que combina estados (campos) y acciones (métodos y otros miembros de función) en una sola unidad.</span><span class="sxs-lookup"><span data-stu-id="0eb41-107">A class is a data structure that combines state (fields) and actions (methods and other function members) in a single unit.</span></span> <span data-ttu-id="0eb41-108">Una clase proporciona una definición para *instancias* creadas dinámicamente de la clase, también conocidas como *objetos*.</span><span class="sxs-lookup"><span data-stu-id="0eb41-108">A class provides a definition for dynamically created *instances* of the class, also known as *objects*.</span></span> <span data-ttu-id="0eb41-109">Las clases admiten *herencia* y *polimorfismo*, mecanismos por los que las *clases derivadas* pueden extender y especializar *clases base*.</span><span class="sxs-lookup"><span data-stu-id="0eb41-109">Classes support *inheritance* and *polymorphism*, mechanisms whereby *derived classes* can extend and specialize *base classes*.</span></span>

<span data-ttu-id="0eb41-110">Las clases nuevas se crean mediante declaraciones de clase.</span><span class="sxs-lookup"><span data-stu-id="0eb41-110">New classes are created using class declarations.</span></span> <span data-ttu-id="0eb41-111">Una declaración de clase se inicia con un encabezado que especifica los atributos y modificadores de la clase, el nombre de la clase, la clase base (si se indica) y las interfaces implementadas por la clase.</span><span class="sxs-lookup"><span data-stu-id="0eb41-111">A class declaration starts with a header that specifies the attributes and modifiers of the class, the name of the class, the base class (if given), and the interfaces implemented by the class.</span></span> <span data-ttu-id="0eb41-112">Al encabezado le sigue el cuerpo de la clase, que consta de una lista de declaraciones de miembros escritas entre los delimitadores `{` y `}`.</span><span class="sxs-lookup"><span data-stu-id="0eb41-112">The header is followed by the class body, which consists of a list of member declarations written between the delimiters `{` and `}`.</span></span>

<span data-ttu-id="0eb41-113">La siguiente es una declaración de una clase simple denominada `Point`:</span><span class="sxs-lookup"><span data-stu-id="0eb41-113">The following is a declaration of a simple class named `Point`:</span></span>

<span data-ttu-id="0eb41-114">[!code-csharp[PointClass](../../../samples/snippets/csharp/tour/classes-and-objects/Point.cs#L3-L11)]</span><span class="sxs-lookup"><span data-stu-id="0eb41-114">[!code-csharp[PointClass](../../../samples/snippets/csharp/tour/classes-and-objects/Point.cs#L3-L11)]</span></span>

<span data-ttu-id="0eb41-115">Las instancias de clases se crean mediante el operador `new`, que asigna memoria para una nueva instancia, invoca un constructor para inicializar la instancia y devuelve una referencia a la instancia.</span><span class="sxs-lookup"><span data-stu-id="0eb41-115">Instances of classes are created using the `new` operator, which allocates memory for a new instance, invokes a constructor to initialize the instance, and returns a reference to the instance.</span></span> <span data-ttu-id="0eb41-116">Las instrucciones siguientes crean dos objetos Point y almacenan las referencias en esos objetos en dos variables:</span><span class="sxs-lookup"><span data-stu-id="0eb41-116">The following statements create two Point objects and store references to those objects in two variables:</span></span>

<span data-ttu-id="0eb41-117">[!code-csharp[PointExample](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L9-L10)]</span><span class="sxs-lookup"><span data-stu-id="0eb41-117">[!code-csharp[PointExample](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L9-L10)]</span></span>

<span data-ttu-id="0eb41-118">La memoria ocupada por un objeto se reclama automáticamente cuando el objeto ya no es accesible.</span><span class="sxs-lookup"><span data-stu-id="0eb41-118">The memory occupied by an object is automatically reclaimed when the object is no longer reachable.</span></span> <span data-ttu-id="0eb41-119">No es necesario ni posible desasignar explícitamente objetos en C#.</span><span class="sxs-lookup"><span data-stu-id="0eb41-119">It is neither necessary nor possible to explicitly deallocate objects in C#.</span></span>

## <a name="members"></a><span data-ttu-id="0eb41-120">Miembros</span><span class="sxs-lookup"><span data-stu-id="0eb41-120">Members</span></span>

<span data-ttu-id="0eb41-121">Los miembros de una clase son miembros estáticos o miembros de instancia.</span><span class="sxs-lookup"><span data-stu-id="0eb41-121">The members of a class are either static members or instance members.</span></span> <span data-ttu-id="0eb41-122">Los miembros estáticos pertenecen a clases y los miembros de instancia pertenecen a objetos (instancias de clases).</span><span class="sxs-lookup"><span data-stu-id="0eb41-122">Static members belong to classes, and instance members belong to objects (instances of classes).</span></span>

<span data-ttu-id="0eb41-123">A continuación se proporciona una visión general de los tipos de miembros que puede contener una clase.</span><span class="sxs-lookup"><span data-stu-id="0eb41-123">The following provides an overview of the kinds of members a class can contain.</span></span>

* <span data-ttu-id="0eb41-124">Constantes</span><span class="sxs-lookup"><span data-stu-id="0eb41-124">Constants</span></span>
    - <span data-ttu-id="0eb41-125">Valores constantes asociados a la clase</span><span class="sxs-lookup"><span data-stu-id="0eb41-125">Constant values associated with the class</span></span>
* <span data-ttu-id="0eb41-126">Campos</span><span class="sxs-lookup"><span data-stu-id="0eb41-126">Fields</span></span>
    - <span data-ttu-id="0eb41-127">Variables de la clase</span><span class="sxs-lookup"><span data-stu-id="0eb41-127">Variables of the class</span></span>
* <span data-ttu-id="0eb41-128">Métodos</span><span class="sxs-lookup"><span data-stu-id="0eb41-128">Methods</span></span>
    - <span data-ttu-id="0eb41-129">Cálculos y acciones que pueden realizarse mediante la clase</span><span class="sxs-lookup"><span data-stu-id="0eb41-129">Computations and actions that can be performed by the class</span></span>
* <span data-ttu-id="0eb41-130">Propiedades</span><span class="sxs-lookup"><span data-stu-id="0eb41-130">Properties</span></span>
    - <span data-ttu-id="0eb41-131">Acciones asociadas a la lectura y escritura de propiedades con nombre de la clase</span><span class="sxs-lookup"><span data-stu-id="0eb41-131">Actions associated with reading and writing named properties of the class</span></span>
* <span data-ttu-id="0eb41-132">Indizadores</span><span class="sxs-lookup"><span data-stu-id="0eb41-132">Indexers</span></span>
    - <span data-ttu-id="0eb41-133">Acciones asociadas a la indexación de instancias de la clase como una matriz</span><span class="sxs-lookup"><span data-stu-id="0eb41-133">Actions associated with indexing instances of the class like an array</span></span>
* <span data-ttu-id="0eb41-134">Eventos</span><span class="sxs-lookup"><span data-stu-id="0eb41-134">Events</span></span>
    - <span data-ttu-id="0eb41-135">Notificaciones que puede generar la clase</span><span class="sxs-lookup"><span data-stu-id="0eb41-135">Notifications that can be generated by the class</span></span>
* <span data-ttu-id="0eb41-136">Operadores</span><span class="sxs-lookup"><span data-stu-id="0eb41-136">Operators</span></span>
    - <span data-ttu-id="0eb41-137">Conversiones y operadores de expresión admitidos por la clase</span><span class="sxs-lookup"><span data-stu-id="0eb41-137">Conversions and expression operators supported by the class</span></span>
* <span data-ttu-id="0eb41-138">Constructores</span><span class="sxs-lookup"><span data-stu-id="0eb41-138">Constructors</span></span>
    - <span data-ttu-id="0eb41-139">Acciones necesarias para inicializar instancias de la clase o la clase propiamente dicha</span><span class="sxs-lookup"><span data-stu-id="0eb41-139">Actions required to initialize instances of the class or the class itself</span></span>
* <span data-ttu-id="0eb41-140">Finalizadores</span><span class="sxs-lookup"><span data-stu-id="0eb41-140">Finalizers</span></span>
    - <span data-ttu-id="0eb41-141">Acciones que deben realizarse antes de que las instancias de la clase se descarten de forma permanente</span><span class="sxs-lookup"><span data-stu-id="0eb41-141">Actions to perform before instances of the class are permanently discarded</span></span>
* <span data-ttu-id="0eb41-142">Tipos</span><span class="sxs-lookup"><span data-stu-id="0eb41-142">Types</span></span>
    - <span data-ttu-id="0eb41-143">Tipos anidados declarados por la clase</span><span class="sxs-lookup"><span data-stu-id="0eb41-143">Nested types declared by the class</span></span>

## <a name="accessibility"></a><span data-ttu-id="0eb41-144">Accesibilidad</span><span class="sxs-lookup"><span data-stu-id="0eb41-144">Accessibility</span></span>

<span data-ttu-id="0eb41-145">Cada miembro de una clase tiene asociada una accesibilidad, que controla las regiones del texto del programa que pueden tener acceso al miembro.</span><span class="sxs-lookup"><span data-stu-id="0eb41-145">Each member of a class has an associated accessibility, which controls the regions of program text that are able to access the member.</span></span> <span data-ttu-id="0eb41-146">Existen cinco formas posibles de accesibilidad.</span><span class="sxs-lookup"><span data-stu-id="0eb41-146">There are five possible forms of accessibility.</span></span> <span data-ttu-id="0eb41-147">Se resumen a continuación.</span><span class="sxs-lookup"><span data-stu-id="0eb41-147">These are summarized below.</span></span>

* `public`
    - <span data-ttu-id="0eb41-148">Acceso no limitado</span><span class="sxs-lookup"><span data-stu-id="0eb41-148">Access not limited</span></span>
* `protected`
    - <span data-ttu-id="0eb41-149">Acceso limitado a esta clase o a las clases derivadas de esta clase</span><span class="sxs-lookup"><span data-stu-id="0eb41-149">Access limited to this class or classes derived from this class</span></span>
* `internal`
    - <span data-ttu-id="0eb41-150">Acceso limitado al ensamblado actual (.exe, .dll, etc.)</span><span class="sxs-lookup"><span data-stu-id="0eb41-150">Access limited to the current assembly (.exe, .dll, etc.)</span></span>
* `protected internal`
    - <span data-ttu-id="0eb41-151">Acceso limitado a la clase contenedora o a las clases derivadas de la clase contenedora</span><span class="sxs-lookup"><span data-stu-id="0eb41-151">Access limited to the containing class or classes derived from the containing class</span></span>
* `private`
    - <span data-ttu-id="0eb41-152">Acceso limitado a esta clase</span><span class="sxs-lookup"><span data-stu-id="0eb41-152">Access limited to this class</span></span>

## <a name="type-parameters"></a><span data-ttu-id="0eb41-153">Parámetros de tipo</span><span class="sxs-lookup"><span data-stu-id="0eb41-153">Type parameters</span></span>

<span data-ttu-id="0eb41-154">Una definición de clase puede especificar un conjunto de parámetros de tipo poniendo tras el nombre de clase una lista de nombres de parámetro de tipo entre corchetes angulares.</span><span class="sxs-lookup"><span data-stu-id="0eb41-154">A class definition may specify a set of type parameters by following the class name with angle brackets enclosing a list of type parameter names.</span></span> <span data-ttu-id="0eb41-155">Los parámetros de tipo pueden usarse luego en el cuerpo de las declaraciones de clase para definir a los miembros de la clase.</span><span class="sxs-lookup"><span data-stu-id="0eb41-155">The type parameters can then be used in the body of the class declarations to define the members of the class.</span></span> <span data-ttu-id="0eb41-156">En el ejemplo siguiente, los parámetros de tipo de `Pair` son `TFirst` y `TSecond`:</span><span class="sxs-lookup"><span data-stu-id="0eb41-156">In the following example, the type parameters of `Pair` are `TFirst` and `TSecond`:</span></span>

<span data-ttu-id="0eb41-157">[!code-csharp[Pair](../../../samples/snippets/csharp/tour/classes-and-objects/Pair.cs#L3-L7)]</span><span class="sxs-lookup"><span data-stu-id="0eb41-157">[!code-csharp[Pair](../../../samples/snippets/csharp/tour/classes-and-objects/Pair.cs#L3-L7)]</span></span>

<span data-ttu-id="0eb41-158">Un tipo de clase que se declara para tomar parámetros de tipo se conoce como *tipo de clase genérica*.</span><span class="sxs-lookup"><span data-stu-id="0eb41-158">A class type that is declared to take type parameters is called a *generic class type*.</span></span> <span data-ttu-id="0eb41-159">Los tipos struct, interfaz y delegado también pueden ser genéricos.</span><span class="sxs-lookup"><span data-stu-id="0eb41-159">Struct, interface and delegate types can also be generic.</span></span>
<span data-ttu-id="0eb41-160">Cuando se usa la clase genérica, se deben proporcionar argumentos de tipo para cada uno de los parámetros de tipo:</span><span class="sxs-lookup"><span data-stu-id="0eb41-160">When the generic class is used, type arguments must be provided for each of the type parameters:</span></span>

<span data-ttu-id="0eb41-161">[!code-csharp[PairExample](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L15-L17)]</span><span class="sxs-lookup"><span data-stu-id="0eb41-161">[!code-csharp[PairExample](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L15-L17)]</span></span>

<span data-ttu-id="0eb41-162">Un tipo genérico con argumentos de tipo proporcionado, como `Pair<int,string>` anteriormente, se conoce como *tipo construido*.</span><span class="sxs-lookup"><span data-stu-id="0eb41-162">A generic type with type arguments provided, like `Pair<int,string>` above, is called a *constructed type*.</span></span>

## <a name="base-classes"></a><span data-ttu-id="0eb41-163">Clases base</span><span class="sxs-lookup"><span data-stu-id="0eb41-163">Base classes</span></span>

<span data-ttu-id="0eb41-164">Una declaración de clase puede especificar una clase base colocando después del nombre de clase y los parámetros de tipo dos puntos seguidos del nombre de la clase base.</span><span class="sxs-lookup"><span data-stu-id="0eb41-164">A class declaration may specify a base class by following the class name and type parameters with a colon and the name of the base class.</span></span> <span data-ttu-id="0eb41-165">Omitir una especificación de la clase base es igual que derivarla del tipo `object`.</span><span class="sxs-lookup"><span data-stu-id="0eb41-165">Omitting a base class specification is the same as deriving from type `object`.</span></span> <span data-ttu-id="0eb41-166">En el ejemplo siguiente, la clase base de `Point3D` es `Point` y la clase base de `Point` es `object`:</span><span class="sxs-lookup"><span data-stu-id="0eb41-166">In the following example, the base class of `Point3D` is `Point`, and the base class of `Point` is `object`:</span></span>

<span data-ttu-id="0eb41-167">[!code-csharp[Point3DClass](../../../samples/snippets/csharp/tour/classes-and-objects/Point.cs#L3-L20)]</span><span class="sxs-lookup"><span data-stu-id="0eb41-167">[!code-csharp[Point3DClass](../../../samples/snippets/csharp/tour/classes-and-objects/Point.cs#L3-L20)]</span></span>

<span data-ttu-id="0eb41-168">Una clase hereda a los miembros de su clase base.</span><span class="sxs-lookup"><span data-stu-id="0eb41-168">A class inherits the members of its base class.</span></span> <span data-ttu-id="0eb41-169">La herencia significa que una clase contiene implícitamente todos los miembros de su clase base, excepto la instancia y los constructores estáticos, y los finalizadores de la clase base.</span><span class="sxs-lookup"><span data-stu-id="0eb41-169">Inheritance means that a class implicitly contains all members of its base class, except for the instance and static constructors, and the finalizers of the base class.</span></span> <span data-ttu-id="0eb41-170">Una clase derivada puede agregar nuevos miembros a aquellos de los que hereda, pero no puede quitar la definición de un miembro heredado.</span><span class="sxs-lookup"><span data-stu-id="0eb41-170">A derived class can add new members to those it inherits, but it cannot remove the definition of an inherited member.</span></span> <span data-ttu-id="0eb41-171">En el ejemplo anterior, `Point3D` hereda los campos `x` y `y` de `Point` y cada instancia de `Point3D` contiene tres campos: `x`, `y` y `z`.</span><span class="sxs-lookup"><span data-stu-id="0eb41-171">In the previous example, `Point3D` inherits the `x` and `y` fields from `Point`, and every `Point3D` instance contains three fields, `x`, `y`, and `z`.</span></span>

<span data-ttu-id="0eb41-172">Existe una conversión implícita de un tipo de clase a cualquiera de sus tipos de clase base.</span><span class="sxs-lookup"><span data-stu-id="0eb41-172">An implicit conversion exists from a class type to any of its base class types.</span></span> <span data-ttu-id="0eb41-173">Por lo tanto, una variable de un tipo de clase puede hacer referencia a una instancia de esa clase o a una instancia de cualquier clase derivada.</span><span class="sxs-lookup"><span data-stu-id="0eb41-173">Therefore, a variable of a class type can reference an instance of that class or an instance of any derived class.</span></span> <span data-ttu-id="0eb41-174">Por ejemplo, dadas las declaraciones de clase anteriores, una variable de tipo `Point` puede hacer referencia a una instancia de `Point` o `Point3D`:</span><span class="sxs-lookup"><span data-stu-id="0eb41-174">For example, given the previous class declarations, a variable of type `Point` can reference either a `Point` or a `Point3D`:</span></span>

<span data-ttu-id="0eb41-175">[!code-csharp[Point3DExample](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L22-L23)]</span><span class="sxs-lookup"><span data-stu-id="0eb41-175">[!code-csharp[Point3DExample](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L22-L23)]</span></span>

## <a name="fields"></a><span data-ttu-id="0eb41-176">Campos</span><span class="sxs-lookup"><span data-stu-id="0eb41-176">Fields</span></span>

<span data-ttu-id="0eb41-177">Un *campo* es una variable que está asociada con una clase o a una instancia de una clase.</span><span class="sxs-lookup"><span data-stu-id="0eb41-177">A *field* is a variable that is associated with a class or with an instance of a class.</span></span>

<span data-ttu-id="0eb41-178">Un campo declarado con el modificador "static" define un campo estático.</span><span class="sxs-lookup"><span data-stu-id="0eb41-178">A field declared with the static modifier defines a static field.</span></span> <span data-ttu-id="0eb41-179">Un campo estático identifica exactamente una ubicación de almacenamiento.</span><span class="sxs-lookup"><span data-stu-id="0eb41-179">A static field identifies exactly one storage location.</span></span> <span data-ttu-id="0eb41-180">Independientemente del número de instancias de una clase que se creen, siempre solo hay una copia de un campo estático.</span><span class="sxs-lookup"><span data-stu-id="0eb41-180">No matter how many instances of a class are created, there is only ever one copy of a static field.</span></span>

<span data-ttu-id="0eb41-181">Un campo declarado sin el modificador "static" define un campo de instancia.</span><span class="sxs-lookup"><span data-stu-id="0eb41-181">A field declared without the static modifier defines an instance field.</span></span> <span data-ttu-id="0eb41-182">Cada instancia de una clase contiene una copia independiente de todos los campos de instancia de esa clase.</span><span class="sxs-lookup"><span data-stu-id="0eb41-182">Every instance of a class contains a separate copy of all the instance fields of that class.</span></span>

<span data-ttu-id="0eb41-183">En el ejemplo siguiente, cada instancia de la clase `Color` tiene una copia independiente de los campos de instancia `r`, `g` y `b`, pero solo hay una copia de los campos estáticos `Black`, `White`, `Red`, `Green` y `Blue`:</span><span class="sxs-lookup"><span data-stu-id="0eb41-183">In the following example, each instance of the `Color` class has a separate copy of the `r`, `g`, and `b` instance fields, but there is only one copy of the `Black`, `White`, `Red`, `Green`, and `Blue` static fields:</span></span>

<span data-ttu-id="0eb41-184">[!code-csharp[ColorClass](../../../samples/snippets/csharp/tour/classes-and-objects/Color.cs#L3-L17)]</span><span class="sxs-lookup"><span data-stu-id="0eb41-184">[!code-csharp[ColorClass](../../../samples/snippets/csharp/tour/classes-and-objects/Color.cs#L3-L17)]</span></span>

<span data-ttu-id="0eb41-185">Como se muestra en el ejemplo anterior, los *campos de solo lectura* se puede declarar con un modificador `readonly`.</span><span class="sxs-lookup"><span data-stu-id="0eb41-185">As shown in the previous example, *read-only fields* may be declared with a `readonly` modifier.</span></span> <span data-ttu-id="0eb41-186">La asignación a un campo `readonly` solo se puede producir como parte de la declaración del campo o en un constructor de la misma clase.</span><span class="sxs-lookup"><span data-stu-id="0eb41-186">Assignment to a `readonly` field can only occur as part of the field’s declaration or in a constructor in the same class.</span></span>

## <a name="methods"></a><span data-ttu-id="0eb41-187">Métodos</span><span class="sxs-lookup"><span data-stu-id="0eb41-187">Methods</span></span>

<span data-ttu-id="0eb41-188">Un *método* es un miembro que implementa un cálculo o una acción que puede realizar un objeto o una clase.</span><span class="sxs-lookup"><span data-stu-id="0eb41-188">A *method* is a member that implements a computation or action that can be performed by an object or class.</span></span> <span data-ttu-id="0eb41-189">A los *métodos estáticos* se accede a través de la clase.</span><span class="sxs-lookup"><span data-stu-id="0eb41-189">*Static methods* are accessed through the class.</span></span> <span data-ttu-id="0eb41-190">A los *métodos de instancia* se accede a través de instancias de la clase.</span><span class="sxs-lookup"><span data-stu-id="0eb41-190">*Instance methods* are accessed through instances of the class.</span></span>

<span data-ttu-id="0eb41-191">Los métodos pueden tener una lista de *parámetros*, que representan valores o referencias a variables que se pasan al método, y un *tipo de valor devuelto*, que especifica el tipo del valor calculado y devuelto por el método.</span><span class="sxs-lookup"><span data-stu-id="0eb41-191">Methods may have a list of *parameters*, which represent values or variable references passed to the method, and a *return type*, which specifies the type of the value computed and returned by the method.</span></span> <span data-ttu-id="0eb41-192">El tipo de valor devuelto de un método es `void` si no se devuelve un valor.</span><span class="sxs-lookup"><span data-stu-id="0eb41-192">A method’s return type is `void` if it does not return a value.</span></span>

<span data-ttu-id="0eb41-193">Al igual que los tipos, los métodos también pueden tener un conjunto de parámetros de tipo, para lo cuales se deben especificar argumentos de tipo cuando se llama al método.</span><span class="sxs-lookup"><span data-stu-id="0eb41-193">Like types, methods may also have a set of type parameters, for which type arguments must be specified when the method is called.</span></span> <span data-ttu-id="0eb41-194">A diferencia de los tipos, los argumentos de tipo a menudo se pueden deducir de los argumentos de una llamada al método y no es necesario proporcionarlos explícitamente.</span><span class="sxs-lookup"><span data-stu-id="0eb41-194">Unlike types, the type arguments can often be inferred from the arguments of a method call and need not be explicitly given.</span></span>

<span data-ttu-id="0eb41-195">La *signatura* de un método debe ser única en la clase en la que se declara el método.</span><span class="sxs-lookup"><span data-stu-id="0eb41-195">The *signature* of a method must be unique in the class in which the method is declared.</span></span> <span data-ttu-id="0eb41-196">La signatura de un método se compone del nombre del método, el número de parámetros de tipo y el número, los modificadores y los tipos de sus parámetros.</span><span class="sxs-lookup"><span data-stu-id="0eb41-196">The signature of a method consists of the name of the method, the number of type parameters and the number, modifiers, and types of its parameters.</span></span> <span data-ttu-id="0eb41-197">La signatura de un método no incluye el tipo de valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="0eb41-197">The signature of a method does not include the return type.</span></span>

### <a name="parameters"></a><span data-ttu-id="0eb41-198">Parámetros</span><span class="sxs-lookup"><span data-stu-id="0eb41-198">Parameters</span></span>

<span data-ttu-id="0eb41-199">Los parámetros se usan para pasar valores o referencias a variables a métodos.</span><span class="sxs-lookup"><span data-stu-id="0eb41-199">Parameters are used to pass values or variable references to methods.</span></span> <span data-ttu-id="0eb41-200">Los parámetros de un método obtienen sus valores reales de los *argumentos* que se especifican cuando se invoca el método.</span><span class="sxs-lookup"><span data-stu-id="0eb41-200">The parameters of a method get their actual values from the *arguments* that are specified when the method is invoked.</span></span> <span data-ttu-id="0eb41-201">Hay cuatro tipos de parámetros: parámetros de valor, parámetros de referencia, parámetros de salida y matrices de parámetros.</span><span class="sxs-lookup"><span data-stu-id="0eb41-201">There are four kinds of parameters: value parameters, reference parameters, output parameters, and parameter arrays.</span></span>

<span data-ttu-id="0eb41-202">Un *parámetro de valor* se usa para pasar argumentos de entrada.</span><span class="sxs-lookup"><span data-stu-id="0eb41-202">A *value parameter* is used for passing input arguments.</span></span> <span data-ttu-id="0eb41-203">Un parámetro de valor corresponde a una variable local que obtiene su valor inicial del argumento que se ha pasado para el parámetro.</span><span class="sxs-lookup"><span data-stu-id="0eb41-203">A value parameter corresponds to a local variable that gets its initial value from the argument that was passed for the parameter.</span></span> <span data-ttu-id="0eb41-204">Las modificaciones en un parámetro de valor no afectan el argumento que se pasa para el parámetro.</span><span class="sxs-lookup"><span data-stu-id="0eb41-204">Modifications to a value parameter do not affect the argument that was passed for the parameter.</span></span> 

<span data-ttu-id="0eb41-205">Los parámetros de valor pueden ser opcionales; se especifica un valor predeterminado para que se puedan omitir los argumentos correspondientes.</span><span class="sxs-lookup"><span data-stu-id="0eb41-205">Value parameters can be optional, by specifying a default value so that corresponding arguments can be omitted.</span></span>

<span data-ttu-id="0eb41-206">Un *parámetro de referencia* se usa para pasar argumentos mediante una referencia.</span><span class="sxs-lookup"><span data-stu-id="0eb41-206">A *reference parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="0eb41-207">El argumento pasado para un parámetro de referencia debe ser una variable con un valor definitivo, y durante la ejecución del método, el parámetro de referencia representa la misma ubicación de almacenamiento que la variable del argumento.</span><span class="sxs-lookup"><span data-stu-id="0eb41-207">The argument passed for a reference parameter must be a variable with a definite value, and during execution of the method, the reference parameter represents the same storage location as the argument variable.</span></span> <span data-ttu-id="0eb41-208">Un parámetro de referencia se declara con el modificador `ref`.</span><span class="sxs-lookup"><span data-stu-id="0eb41-208">A reference parameter is declared with the `ref` modifier.</span></span> <span data-ttu-id="0eb41-209">En el ejemplo siguiente se muestra el uso de parámetros `ref`.</span><span class="sxs-lookup"><span data-stu-id="0eb41-209">The following example shows the use of `ref` parameters.</span></span>

<span data-ttu-id="0eb41-210">[!code-csharp[swapExample](../../../samples/snippets/csharp/tour/classes-and-objects/RefExample.cs#L3-L18)]</span><span class="sxs-lookup"><span data-stu-id="0eb41-210">[!code-csharp[swapExample](../../../samples/snippets/csharp/tour/classes-and-objects/RefExample.cs#L3-L18)]</span></span>

<span data-ttu-id="0eb41-211">Un *parámetro de salida* se usa para pasar argumentos mediante una referencia.</span><span class="sxs-lookup"><span data-stu-id="0eb41-211">An *output parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="0eb41-212">Es similar a un parámetro de referencia, excepto que no necesita que asigne un valor explícitamente al argumento proporcionado por el autor de la llamada.</span><span class="sxs-lookup"><span data-stu-id="0eb41-212">It's similar to a reference parameter, except that it doesn't require that you explicitly assign a value to the caller-provided argument.</span></span> <span data-ttu-id="0eb41-213">Un parámetro de salida se declara con el modificador `out`.</span><span class="sxs-lookup"><span data-stu-id="0eb41-213">An output parameter is declared with the `out` modifier.</span></span> <span data-ttu-id="0eb41-214">En el siguiente ejemplo se muestra el uso de los parámetros `out` con la sintaxis que se ha presentado en C# 7.</span><span class="sxs-lookup"><span data-stu-id="0eb41-214">The following example shows the use of `out` parameters using the syntax introduced in C# 7.</span></span>

<span data-ttu-id="0eb41-215">[!code-csharp[OutExample](../../../samples/snippets/csharp/tour/classes-and-objects/OutExample.cs#L3-L17)]</span><span class="sxs-lookup"><span data-stu-id="0eb41-215">[!code-csharp[OutExample](../../../samples/snippets/csharp/tour/classes-and-objects/OutExample.cs#L3-L17)]</span></span>

<span data-ttu-id="0eb41-216">Una *matriz de parámetros* permite que se pasen a un método un número variable de argumentos.</span><span class="sxs-lookup"><span data-stu-id="0eb41-216">A *parameter array* permits a variable number of arguments to be passed to a method.</span></span> <span data-ttu-id="0eb41-217">Una matriz de parámetros se declara con el modificador `params`.</span><span class="sxs-lookup"><span data-stu-id="0eb41-217">A parameter array is declared with the `params` modifier.</span></span> <span data-ttu-id="0eb41-218">Solo el último parámetro de un método puede ser una matriz de parámetros y el tipo de una matriz de parámetros debe ser un tipo de matriz unidimensional.</span><span class="sxs-lookup"><span data-stu-id="0eb41-218">Only the last parameter of a method can be a parameter array, and the type of a parameter array must be a single-dimensional array type.</span></span> <span data-ttu-id="0eb41-219">Los métodos Write y WriteLine de la clase `@System.Console` son buenos ejemplos de uso de la matriz de parámetros.</span><span class="sxs-lookup"><span data-stu-id="0eb41-219">The Write and WriteLine methods of the `@System.Console` class are good examples of parameter array usage.</span></span> <span data-ttu-id="0eb41-220">Se declaran de la manera siguiente.</span><span class="sxs-lookup"><span data-stu-id="0eb41-220">They are declared as follows.</span></span>

<span data-ttu-id="0eb41-221">[!code-csharp[ConsoleExample](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L78-L83)]</span><span class="sxs-lookup"><span data-stu-id="0eb41-221">[!code-csharp[ConsoleExample](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L78-L83)]</span></span>

<span data-ttu-id="0eb41-222">Dentro de un método que usa una matriz de parámetros, la matriz de parámetros se comporta exactamente igual que un parámetro normal de un tipo de matriz.</span><span class="sxs-lookup"><span data-stu-id="0eb41-222">Within a method that uses a parameter array, the parameter array behaves exactly like a regular parameter of an array type.</span></span> <span data-ttu-id="0eb41-223">Sin embargo, en una invocación de un método con una matriz de parámetros, es posible pasar un único argumento del tipo de matriz de parámetros o cualquier número de argumentos del tipo de elemento de la matriz de parámetros.</span><span class="sxs-lookup"><span data-stu-id="0eb41-223">However, in an invocation of a method with a parameter array, it is possible to pass either a single argument of the parameter array type or any number of arguments of the element type of the parameter array.</span></span> <span data-ttu-id="0eb41-224">En este caso, una instancia de matriz se e inicializa automáticamente con los argumentos dados.</span><span class="sxs-lookup"><span data-stu-id="0eb41-224">In the latter case, an array instance is automatically created and initialized with the given arguments.</span></span> <span data-ttu-id="0eb41-225">Este ejemplo</span><span class="sxs-lookup"><span data-stu-id="0eb41-225">This example</span></span>

<span data-ttu-id="0eb41-226">[!code-csharp[StringFormat](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L55-L55)]</span><span class="sxs-lookup"><span data-stu-id="0eb41-226">[!code-csharp[StringFormat](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L55-L55)]</span></span>

<span data-ttu-id="0eb41-227">es equivalente a escribir lo siguiente.</span><span class="sxs-lookup"><span data-stu-id="0eb41-227">is equivalent to writing the following.</span></span>

<span data-ttu-id="0eb41-228">[!code-csharp[StringFormat2](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L30-L35)]</span><span class="sxs-lookup"><span data-stu-id="0eb41-228">[!code-csharp[StringFormat2](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L30-L35)]</span></span>

### <a name="method-body-and-local-variables"></a><span data-ttu-id="0eb41-229">Cuerpo del método y variables locales</span><span class="sxs-lookup"><span data-stu-id="0eb41-229">Method body and local variables</span></span>

<span data-ttu-id="0eb41-230">El cuerpo de un método especifica las instrucciones que se ejecutarán cuando se invoca el método.</span><span class="sxs-lookup"><span data-stu-id="0eb41-230">A method’s body specifies the statements to execute when the method is invoked.</span></span>

<span data-ttu-id="0eb41-231">Un cuerpo del método puede declarar variables que son específicas de la invocación del método.</span><span class="sxs-lookup"><span data-stu-id="0eb41-231">A method body can declare variables that are specific to the invocation of the method.</span></span> <span data-ttu-id="0eb41-232">Estas variables se denominan *variables locales*.</span><span class="sxs-lookup"><span data-stu-id="0eb41-232">Such variables are called *local variables*.</span></span> <span data-ttu-id="0eb41-233">Una declaración de variable local especifica un nombre de tipo, un nombre de variable y, posiblemente, un valor inicial.</span><span class="sxs-lookup"><span data-stu-id="0eb41-233">A local variable declaration specifies a type name, a variable name, and possibly an initial value.</span></span> <span data-ttu-id="0eb41-234">En el ejemplo siguiente se declara una variable local `i` con un valor inicial de cero y una variable local `j` sin ningún valor inicial.</span><span class="sxs-lookup"><span data-stu-id="0eb41-234">The following example declares a local variable `i` with an initial value of zero and a local variable `j` with no initial value.</span></span>

<span data-ttu-id="0eb41-235">[!code-csharp[Squares](../../../samples/snippets/csharp/tour/classes-and-objects/Squares.cs#L3-L17)]</span><span class="sxs-lookup"><span data-stu-id="0eb41-235">[!code-csharp[Squares](../../../samples/snippets/csharp/tour/classes-and-objects/Squares.cs#L3-L17)]</span></span>

<span data-ttu-id="0eb41-236">C# requiere que se *asigne definitivamente* una variable local antes de que se pueda obtener su valor.</span><span class="sxs-lookup"><span data-stu-id="0eb41-236">C# requires a local variable to be *definitely assigned* before its value can be obtained.</span></span> <span data-ttu-id="0eb41-237">Por ejemplo, si la declaración de `i` anterior no incluyera un valor inicial, el compilador notificaría un error con los usos posteriores de `i` porque `i` no se asignaría definitivamente en esos puntos del programa.</span><span class="sxs-lookup"><span data-stu-id="0eb41-237">For example, if the declaration of the previous `i` did not include an initial value, the compiler would report an error for the subsequent usages of `i` because `i` would not be definitely assigned at those points in the program.</span></span>

<span data-ttu-id="0eb41-238">Puede usar una instrucción `return` para devolver el control a su llamador.</span><span class="sxs-lookup"><span data-stu-id="0eb41-238">A method can use `return` statements to return control to its caller.</span></span> <span data-ttu-id="0eb41-239">En un método que devuelve `void`, las instrucciones `return` no pueden especificar una expresión.</span><span class="sxs-lookup"><span data-stu-id="0eb41-239">In a method returning `void`, `return` statements cannot specify an expression.</span></span> <span data-ttu-id="0eb41-240">En un método que devuelve valores distintos de void, las instrucciones `return` deben incluir una expresión que calcula el valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="0eb41-240">In a method returning non-void, `return` statements must include an expression that computes the return value.</span></span>

### <a name="static-and-instance-methods"></a><span data-ttu-id="0eb41-241">Métodos estáticos y de instancia</span><span class="sxs-lookup"><span data-stu-id="0eb41-241">Static and instance methods</span></span>

<span data-ttu-id="0eb41-242">Un método declarado con un modificador static es un *método estático*.</span><span class="sxs-lookup"><span data-stu-id="0eb41-242">A method declared with a static modifier is a *static method*.</span></span> <span data-ttu-id="0eb41-243">Un método estático no opera en una instancia específica y solo puede acceder directamente a miembros estáticos.</span><span class="sxs-lookup"><span data-stu-id="0eb41-243">A static method does not operate on a specific instance and can only directly access static members.</span></span>

<span data-ttu-id="0eb41-244">Un método declarado sin un modificador static es un *método de instancia*.</span><span class="sxs-lookup"><span data-stu-id="0eb41-244">A method declared without a static modifier is an *instance method*.</span></span> <span data-ttu-id="0eb41-245">Un método de instancia opera en una instancia específica y puede acceder a miembros estáticos y de instancia.</span><span class="sxs-lookup"><span data-stu-id="0eb41-245">An instance method operates on a specific instance and can access both static and instance members.</span></span> <span data-ttu-id="0eb41-246">Se puede acceder explícitamente a la instancia en la que se invoca un método de instancia como `this`.</span><span class="sxs-lookup"><span data-stu-id="0eb41-246">The instance on which an instance method was invoked can be explicitly accessed as `this`.</span></span> <span data-ttu-id="0eb41-247">Es un error hacer referencia a `this` en un método estático.</span><span class="sxs-lookup"><span data-stu-id="0eb41-247">It is an error to refer to `this` in a static method.</span></span>

<span data-ttu-id="0eb41-248">La siguiente clase `Entity` tiene miembros estáticos y de instancia.</span><span class="sxs-lookup"><span data-stu-id="0eb41-248">The following `Entity` class has both static and instance members.</span></span>

<span data-ttu-id="0eb41-249">[!code-csharp[Entity](../../../samples/snippets/csharp/tour/classes-and-objects/Entity.cs#L16-L36)]</span><span class="sxs-lookup"><span data-stu-id="0eb41-249">[!code-csharp[Entity](../../../samples/snippets/csharp/tour/classes-and-objects/Entity.cs#L16-L36)]</span></span>

<span data-ttu-id="0eb41-250">Cada instancia `Entity` contiene un número de serie (y probablemente alguna otra información que no se muestra aquí).</span><span class="sxs-lookup"><span data-stu-id="0eb41-250">Each `Entity` instance contains a serial number (and presumably some other information that is not shown here).</span></span> <span data-ttu-id="0eb41-251">El constructor `Entity` (que es como un método de instancia) inicializa la nueva instancia con el siguiente número de serie disponible.</span><span class="sxs-lookup"><span data-stu-id="0eb41-251">The `Entity` constructor (which is like an instance method) initializes the new instance with the next available serial number.</span></span> <span data-ttu-id="0eb41-252">Dado que el constructor es un miembro de instancia, se le permite acceder al campo de instancia `serialNo` y al campo estático `nextSerialNo`.</span><span class="sxs-lookup"><span data-stu-id="0eb41-252">Because the constructor is an instance member, it is permitted to access both the `serialNo` instance field and the `nextSerialNo` static field.</span></span>

<span data-ttu-id="0eb41-253">Los métodos estáticos `GetNextSerialNo` y `SetNextSerialNo` pueden acceder al campo estático `nextSerialNo`, pero sería un error para ellas acceder directamente al campo de instancia `serialNo`.</span><span class="sxs-lookup"><span data-stu-id="0eb41-253">The `GetNextSerialNo` and `SetNextSerialNo` static methods can access the `nextSerialNo` static field, but it would be an error for them to directly access the `serialNo` instance field.</span></span>

<span data-ttu-id="0eb41-254">En el ejemplo siguiente se muestra el uso de la clase Entity.</span><span class="sxs-lookup"><span data-stu-id="0eb41-254">The following example shows the use of the Entity class.</span></span>

<span data-ttu-id="0eb41-255">[!code-csharp[EntityExample](../../../samples/snippets/csharp/tour/classes-and-objects/Entity.cs#L3-L15)]</span><span class="sxs-lookup"><span data-stu-id="0eb41-255">[!code-csharp[EntityExample](../../../samples/snippets/csharp/tour/classes-and-objects/Entity.cs#L3-L15)]</span></span>

<span data-ttu-id="0eb41-256">Tenga en cuenta que los métodos estáticos `SetNextSerialNo` y `GetNextSerialNo` se invocan en la clase, mientras que el método de instancia `GetSerialNo` se invoca en instancias de la clase.</span><span class="sxs-lookup"><span data-stu-id="0eb41-256">Note that the `SetNextSerialNo` and `GetNextSerialNo` static methods are invoked on the class whereas the `GetSerialNo` instance method is invoked on instances of the class.</span></span>

### <a name="virtual-override-and-abstract-methods"></a><span data-ttu-id="0eb41-257">Métodos virtual, de reemplazo y abstracto</span><span class="sxs-lookup"><span data-stu-id="0eb41-257">Virtual, override, and abstract methods</span></span>

<span data-ttu-id="0eb41-258">Cuando una declaración de método de instancia incluye un modificador `virtual`, se dice que el método es un *método virtual*.</span><span class="sxs-lookup"><span data-stu-id="0eb41-258">When an instance method declaration includes a `virtual` modifier, the method is said to be a *virtual method*.</span></span> <span data-ttu-id="0eb41-259">Cuando no existe un modificador virtual, se dice que el método es un *método no virtual*.</span><span class="sxs-lookup"><span data-stu-id="0eb41-259">When no virtual modifier is present, the method is said to be a *nonvirtual method*.</span></span>

<span data-ttu-id="0eb41-260">Cuando se invoca un método virtual, el *tipo en tiempo de ejecución* de la instancia para la que tiene lugar esa invocación determina la implementación del método real que se invocará.</span><span class="sxs-lookup"><span data-stu-id="0eb41-260">When a virtual method is invoked, the *run-time type* of the instance for which that invocation takes place determines the actual method implementation to invoke.</span></span> <span data-ttu-id="0eb41-261">En una invocación de método no virtual, el *tipo en tiempo de compilación* de la instancia es el factor determinante.</span><span class="sxs-lookup"><span data-stu-id="0eb41-261">In a nonvirtual method invocation, the *compile-time type* of the instance is the determining factor.</span></span>

<span data-ttu-id="0eb41-262">Un método virtual puede ser *reemplazado* en una clase derivada.</span><span class="sxs-lookup"><span data-stu-id="0eb41-262">A virtual method can be *overridden* in a derived class.</span></span> <span data-ttu-id="0eb41-263">Cuando una declaración de método de instancia incluye un modificador "override", el método reemplaza un método virtual heredado con la misma signatura.</span><span class="sxs-lookup"><span data-stu-id="0eb41-263">When an instance method declaration includes an override modifier, the method overrides an inherited virtual method with the same signature.</span></span> <span data-ttu-id="0eb41-264">Mientras que una declaración de método virtual introduce un método nuevo, una declaración de método de reemplazo especializa un método virtual heredado existente proporcionando una nueva implementación de ese método.</span><span class="sxs-lookup"><span data-stu-id="0eb41-264">Whereas a virtual method declaration introduces a new method, an override method declaration specializes an existing inherited virtual method by providing a new implementation of that method.</span></span>

<span data-ttu-id="0eb41-265">Un *método abstracto* es un método virtual sin implementación.</span><span class="sxs-lookup"><span data-stu-id="0eb41-265">An *abstract method* is a virtual method with no implementation.</span></span> <span data-ttu-id="0eb41-266">Un método abstracto se declara con el modificador "abstract" y solo se permite en una clase que también se declare abstracta.</span><span class="sxs-lookup"><span data-stu-id="0eb41-266">An abstract method is declared with the abstract modifier and is permitted only in a class that is also declared abstract.</span></span> <span data-ttu-id="0eb41-267">Un método abstracto debe reemplazarse en todas las clases derivadas no abstractas.</span><span class="sxs-lookup"><span data-stu-id="0eb41-267">An abstract method must be overridden in every non-abstract derived class.</span></span>

<span data-ttu-id="0eb41-268">En el ejemplo siguiente se declara una clase abstracta, `Expression`, que representa un nodo de árbol de expresión y tres clases derivadas, `Constant`, `VariableReference` y `Operation`, que implementan nodos de árbol de expresión para constantes, referencias a variables y operaciones aritméticas.</span><span class="sxs-lookup"><span data-stu-id="0eb41-268">The following example declares an abstract class, `Expression`, which represents an expression tree node, and three derived classes, `Constant`, `VariableReference`, and `Operation`, which implement expression tree nodes for constants, variable references, and arithmetic operations.</span></span> <span data-ttu-id="0eb41-269">(Esto es similar a los tipos de árbol de expresión, pero no debe confundirse con ellos).</span><span class="sxs-lookup"><span data-stu-id="0eb41-269">(This is similar to, but not to be confused with the expression tree types).</span></span>

<span data-ttu-id="0eb41-270">[!code-csharp[ExpressionClass](../../../samples/snippets/csharp/tour/classes-and-objects/Expressions.cs#L3-L61)]</span><span class="sxs-lookup"><span data-stu-id="0eb41-270">[!code-csharp[ExpressionClass](../../../samples/snippets/csharp/tour/classes-and-objects/Expressions.cs#L3-L61)]</span></span>

<span data-ttu-id="0eb41-271">Las cuatro clases anteriores se pueden usar para modelar expresiones aritméticas.</span><span class="sxs-lookup"><span data-stu-id="0eb41-271">The previous four classes can be used to model arithmetic expressions.</span></span> <span data-ttu-id="0eb41-272">Por ejemplo, usando instancias de estas clases, la expresión `x + 3` se puede representar de la manera siguiente.</span><span class="sxs-lookup"><span data-stu-id="0eb41-272">For example, using instances of these classes, the expression `x + 3` can be represented as follows.</span></span>

<span data-ttu-id="0eb41-273">[!code-csharp[ExpressionExample](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L40-L43)]</span><span class="sxs-lookup"><span data-stu-id="0eb41-273">[!code-csharp[ExpressionExample](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L40-L43)]</span></span>

<span data-ttu-id="0eb41-274">El método `Evaluate` de una instancia `Expression` se invoca para evaluar la expresión determinada y generar un valor `double`.</span><span class="sxs-lookup"><span data-stu-id="0eb41-274">The `Evaluate` method of an `Expression` instance is invoked to evaluate the given expression and produce a `double` value.</span></span> <span data-ttu-id="0eb41-275">El método toma un argumento `Dictionary` que contiene nombres de variables (como claves de las entradas) y valores (como valores de las entradas).</span><span class="sxs-lookup"><span data-stu-id="0eb41-275">The method takes a `Dictionary` argument that contains variable names (as keys of the entries) and values (as values of the entries).</span></span> <span data-ttu-id="0eb41-276">Como `Evaluate` es un método abstracto, las clases no abstractas que derivan de `Expression` deben invalidar `Evaluate`.</span><span class="sxs-lookup"><span data-stu-id="0eb41-276">Because `Evaluate` is an abstract method, non-abstract classes derived from `Expression` must override `Evaluate`.</span></span>

<span data-ttu-id="0eb41-277">Una implementación de `Constant` de `Evaluate` simplemente devuelve la constante almacenada.</span><span class="sxs-lookup"><span data-stu-id="0eb41-277">A `Constant`'s implementation of `Evaluate` simply returns the stored constant.</span></span> <span data-ttu-id="0eb41-278">Una implementación de `VariableReference` busca el nombre de variable en el diccionario y devuelve el valor resultante.</span><span class="sxs-lookup"><span data-stu-id="0eb41-278">A `VariableReference`'s implementation looks up the variable name in the dictionary and returns the resulting value.</span></span> <span data-ttu-id="0eb41-279">Una implementación de `Operation` evalúa primero los operandos izquierdo y derecho (mediante la invocación recursiva de sus métodos `Evaluate`) y luego realiza la operación aritmética correspondiente.</span><span class="sxs-lookup"><span data-stu-id="0eb41-279">An `Operation`'s implementation first evaluates the left and right operands (by recursively invoking their `Evaluate` methods) and then performs the given arithmetic operation.</span></span>

<span data-ttu-id="0eb41-280">El siguiente programa usa las clases `Expression` para evaluar la expresión `x * (y + 2)` para los distintos valores de `x` y `y`.</span><span class="sxs-lookup"><span data-stu-id="0eb41-280">The following program uses the `Expression` classes to evaluate the expression `x * (y + 2)` for different values of `x` and `y`.</span></span>

<span data-ttu-id="0eb41-281">[!code-csharp[ExpressionUsage](../../../samples/snippets/csharp/tour/classes-and-objects/Expressions.cs#L66-L89)]</span><span class="sxs-lookup"><span data-stu-id="0eb41-281">[!code-csharp[ExpressionUsage](../../../samples/snippets/csharp/tour/classes-and-objects/Expressions.cs#L66-L89)]</span></span>

### <a name="method-overloading"></a><span data-ttu-id="0eb41-282">Sobrecarga de métodos</span><span class="sxs-lookup"><span data-stu-id="0eb41-282">Method overloading</span></span>

<span data-ttu-id="0eb41-283">La *sobrecarga* de métodos permite que varios métodos de la misma clase tengan el mismo nombre mientras tengan signaturas únicas.</span><span class="sxs-lookup"><span data-stu-id="0eb41-283">Method *overloading* permits multiple methods in the same class to have the same name as long as they have unique signatures.</span></span> <span data-ttu-id="0eb41-284">Al compilar una invocación de un método sobrecargado, el compilador usa la *resolución de sobrecarga* para determinar el método concreto que de invocará.</span><span class="sxs-lookup"><span data-stu-id="0eb41-284">When compiling an invocation of an overloaded method, the compiler uses *overload resolution* to determine the specific method to invoke.</span></span> <span data-ttu-id="0eb41-285">La resolución de sobrecarga busca el método que mejor coincida con los argumentos o informa de un error si no se puede encontrar ninguna mejor coincidencia.</span><span class="sxs-lookup"><span data-stu-id="0eb41-285">Overload resolution finds the one method that best matches the arguments or reports an error if no single best match can be found.</span></span> <span data-ttu-id="0eb41-286">En el ejemplo siguiente se muestra la resolución de sobrecarga en vigor.</span><span class="sxs-lookup"><span data-stu-id="0eb41-286">The following example shows overload resolution in effect.</span></span> <span data-ttu-id="0eb41-287">El comentario para cada invocación del método `Main` muestra qué método se invoca realmente.</span><span class="sxs-lookup"><span data-stu-id="0eb41-287">The comment for each invocation in the `Main` method shows which method is actually invoked.</span></span>

<span data-ttu-id="0eb41-288">[!code-csharp[OverloadUsage](../../../samples/snippets/csharp/tour/classes-and-objects/Overloading.cs#L3-L41)]</span><span class="sxs-lookup"><span data-stu-id="0eb41-288">[!code-csharp[OverloadUsage](../../../samples/snippets/csharp/tour/classes-and-objects/Overloading.cs#L3-L41)]</span></span>

<span data-ttu-id="0eb41-289">Tal como se muestra en el ejemplo, un método determinado siempre se puede seleccionar mediante la conversión explícita de los argumentos en los tipos de parámetros exactos o el suministro explícito de los argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="0eb41-289">As shown by the example, a particular method can always be selected by explicitly casting the arguments to the exact parameter types and/or explicitly supplying type arguments.</span></span>

## <a name="other-function-members"></a><span data-ttu-id="0eb41-290">Otros miembros de función</span><span class="sxs-lookup"><span data-stu-id="0eb41-290">Other function members</span></span>

<span data-ttu-id="0eb41-291">Los miembros que contienen código ejecutable se conocen colectivamente como *miembros de función* de una clase.</span><span class="sxs-lookup"><span data-stu-id="0eb41-291">Members that contain executable code are collectively known as the *function members* of a class.</span></span> <span data-ttu-id="0eb41-292">En la sección anterior se han descrito métodos, que son el tipo principal de los miembros de función.</span><span class="sxs-lookup"><span data-stu-id="0eb41-292">The preceding section describes methods, which are the primary kind of function members.</span></span> <span data-ttu-id="0eb41-293">En esta sección se describen los otros tipos de miembros de función admitidos por C#: constructores, propiedades, indexadores, eventos, operadores y finalizadores.</span><span class="sxs-lookup"><span data-stu-id="0eb41-293">This section describes the other kinds of function members supported by C#: constructors, properties, indexers, events, operators, and finalizers.</span></span>

<span data-ttu-id="0eb41-294">A continuación se muestra una clase genérica llamada List<T>, que implementa una lista creciente de objetos.</span><span class="sxs-lookup"><span data-stu-id="0eb41-294">The following shows a generic class called List<T>, which implements a growable list of objects.</span></span> <span data-ttu-id="0eb41-295">La clase contiene varios ejemplos de los tipos más comunes de miembros de función.</span><span class="sxs-lookup"><span data-stu-id="0eb41-295">The class contains several examples of the most common kinds of function members.</span></span>

<span data-ttu-id="0eb41-296">[!code-csharp[ListClass](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L4-L89)]</span><span class="sxs-lookup"><span data-stu-id="0eb41-296">[!code-csharp[ListClass](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L4-L89)]</span></span>

### <a name="constructors"></a><span data-ttu-id="0eb41-297">Constructores</span><span class="sxs-lookup"><span data-stu-id="0eb41-297">Constructors</span></span>

<span data-ttu-id="0eb41-298">C# admite constructores de instancia y estáticos.</span><span class="sxs-lookup"><span data-stu-id="0eb41-298">C# supports both instance and static constructors.</span></span> <span data-ttu-id="0eb41-299">Un *constructor de instancia* es un miembro que implementa las acciones necesarias para inicializar una instancia de una clase.</span><span class="sxs-lookup"><span data-stu-id="0eb41-299">An *instance constructor* is a member that implements the actions required to initialize an instance of a class.</span></span> <span data-ttu-id="0eb41-300">Un *constructor estático* es un miembro que implementa las acciones necesarias para inicializar una clase en sí misma cuando se carga por primera vez.</span><span class="sxs-lookup"><span data-stu-id="0eb41-300">A *static constructor* is a member that implements the actions required to initialize a class itself when it is first loaded.</span></span>

<span data-ttu-id="0eb41-301">Un constructor se declara como un método sin ningún tipo de valor devuelto y el mismo nombre que la clase contenedora.</span><span class="sxs-lookup"><span data-stu-id="0eb41-301">A constructor is declared like a method with no return type and the same name as the containing class.</span></span> <span data-ttu-id="0eb41-302">Si una declaración de constructor incluye un modificador "static", declara un constructor estático.</span><span class="sxs-lookup"><span data-stu-id="0eb41-302">If a constructor declaration includes a static modifier, it declares a static constructor.</span></span> <span data-ttu-id="0eb41-303">De lo contrario, declara un constructor de instancia.</span><span class="sxs-lookup"><span data-stu-id="0eb41-303">Otherwise, it declares an instance constructor.</span></span>

<span data-ttu-id="0eb41-304">Los constructores de instancias se pueden sobrecargar y pueden tener parámetros opcionales.</span><span class="sxs-lookup"><span data-stu-id="0eb41-304">Instance constructors can be overloaded, and can have optional parameters.</span></span> <span data-ttu-id="0eb41-305">Por ejemplo, la clase `List<T>` declara dos constructores de instancia, una sin parámetros y otra que toma un parámetro `int`.</span><span class="sxs-lookup"><span data-stu-id="0eb41-305">For example, the `List<T>` class declares two instance constructors, one with no parameters and one that takes an `int` parameter.</span></span> <span data-ttu-id="0eb41-306">Los constructores de instancia se invocan mediante el operador `new`.</span><span class="sxs-lookup"><span data-stu-id="0eb41-306">Instance constructors are invoked using the `new` operator.</span></span> <span data-ttu-id="0eb41-307">Las siguientes instrucciones asignan dos instancias `List<string>` mediante el constructor de la clase `List` con y sin el argumento opcional.</span><span class="sxs-lookup"><span data-stu-id="0eb41-307">The following statements allocate two `List<string>` instances using the constructor of the `List` class with and without the optional argument.</span></span>

<span data-ttu-id="0eb41-308">[!code-csharp[ListExample1](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L95-L96)]</span><span class="sxs-lookup"><span data-stu-id="0eb41-308">[!code-csharp[ListExample1](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L95-L96)]</span></span>

<span data-ttu-id="0eb41-309">A diferencia de otros miembros, los constructores de instancia no se heredan y una clase no tiene ningún constructor de instancia que no sea el que se declara realmente en la clase.</span><span class="sxs-lookup"><span data-stu-id="0eb41-309">Unlike other members, instance constructors are not inherited, and a class has no instance constructors other than those actually declared in the class.</span></span> <span data-ttu-id="0eb41-310">Si no se proporciona ningún constructor de instancia para una clase, se proporciona automáticamente uno vacío sin ningún parámetro.</span><span class="sxs-lookup"><span data-stu-id="0eb41-310">If no instance constructor is supplied for a class, then an empty one with no parameters is automatically provided.</span></span>

### <a name="properties"></a><span data-ttu-id="0eb41-311">Propiedades</span><span class="sxs-lookup"><span data-stu-id="0eb41-311">Properties</span></span>

<span data-ttu-id="0eb41-312">Las *propiedades* son una extensión natural de los campos.</span><span class="sxs-lookup"><span data-stu-id="0eb41-312">*Properties* are a natural extension of fields.</span></span> <span data-ttu-id="0eb41-313">Ambos son miembros con nombre con tipos asociados y la sintaxis para acceder a los campos y las propiedades es la misma.</span><span class="sxs-lookup"><span data-stu-id="0eb41-313">Both are named members with associated types, and the syntax for accessing fields and properties is the same.</span></span> <span data-ttu-id="0eb41-314">Sin embargo, a diferencia de los campos, las propiedades no denotan ubicaciones de almacenamiento.</span><span class="sxs-lookup"><span data-stu-id="0eb41-314">However, unlike fields, properties do not denote storage locations.</span></span> <span data-ttu-id="0eb41-315">Las propiedades tienen *descriptores de acceso* que especifican las instrucciones que se ejecutan cuando se leen o escriben sus valores.</span><span class="sxs-lookup"><span data-stu-id="0eb41-315">Instead, properties have *accessors* that specify the statements to be executed when their values are read or written.</span></span>

<span data-ttu-id="0eb41-316">Una propiedad se declara como un campo, salvo que la declaración finaliza con un descriptor de acceso get y un descriptor de acceso set escrito entre los delimitadores `{` y `}` en lugar de finalizar en un punto y coma.</span><span class="sxs-lookup"><span data-stu-id="0eb41-316">A property is declared like a field, except that the declaration ends with a get accessor and/or a set accessor written between the delimiters `{` and `}` instead of ending in a semicolon.</span></span> <span data-ttu-id="0eb41-317">Una propiedad que tiene un descriptor de acceso get y un descriptor de acceso set es una *propiedad de lectura y escritura*, una propiedad que tiene solo un descriptor de acceso get es una *propiedad de solo lectura* y una propiedad que tiene solo un descriptor de acceso set es una *propiedad de solo escritura*.</span><span class="sxs-lookup"><span data-stu-id="0eb41-317">A property that has both a get accessor and a set accessor is a *read-write property*, a property that has only a get accessor is a *read-only property*, and a property that has only a set accessor is a *write-only property*.</span></span>

<span data-ttu-id="0eb41-318">Un descriptor de acceso get corresponde a un método sin parámetros con un valor devuelto del tipo de propiedad.</span><span class="sxs-lookup"><span data-stu-id="0eb41-318">A get accessor corresponds to a parameterless method with a return value of the property type.</span></span> <span data-ttu-id="0eb41-319">Excepto como destino de una asignación, cuando se hace referencia a una propiedad en una expresión, el descriptor de acceso get de la propiedad se invoca para calcular el valor de la propiedad.</span><span class="sxs-lookup"><span data-stu-id="0eb41-319">Except as the target of an assignment, when a property is referenced in an expression, the get accessor of the property is invoked to compute the value of the property.</span></span>

<span data-ttu-id="0eb41-320">Un descriptor de acceso set corresponde a un método con un solo parámetro denominado value y ningún tipo de valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="0eb41-320">A set accessor corresponds to a method with a single parameter named value and no return type.</span></span> <span data-ttu-id="0eb41-321">Cuando se hace referencia a una propiedad como el destino de una asignación o como el operando de ++ o--, el descriptor de acceso set se invoca con un argumento que proporciona el nuevo valor.</span><span class="sxs-lookup"><span data-stu-id="0eb41-321">When a property is referenced as the target of an assignment or as the operand of ++ or --, the set accessor is invoked with an argument that provides the new value.</span></span>

<span data-ttu-id="0eb41-322">La clase `List<T>` declara dos propiedades, Count y Capacity, que son de solo lectura y de lectura y escritura, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="0eb41-322">The `List<T>` class declares two properties, Count and Capacity, which are read-only and read-write, respectively.</span></span> <span data-ttu-id="0eb41-323">El siguiente es un ejemplo de uso de estas propiedades.</span><span class="sxs-lookup"><span data-stu-id="0eb41-323">The following is an example of use of these properties.</span></span>

<span data-ttu-id="0eb41-324">[!code-csharp[ListExample2](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L101-L104)]</span><span class="sxs-lookup"><span data-stu-id="0eb41-324">[!code-csharp[ListExample2](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L101-L104)]</span></span>

<span data-ttu-id="0eb41-325">De forma similar a los campos y métodos, C# admite propiedades de instancia y propiedades estáticas.</span><span class="sxs-lookup"><span data-stu-id="0eb41-325">Similar to fields and methods, C# supports both instance properties and static properties.</span></span> <span data-ttu-id="0eb41-326">Las propiedades estáticas se declaran con el modificador "static", y las propiedades de instancia se declaran sin él.</span><span class="sxs-lookup"><span data-stu-id="0eb41-326">Static properties are declared with the static modifier, and instance properties are declared without it.</span></span>

<span data-ttu-id="0eb41-327">Los descriptores de acceso de una propiedad pueden ser virtuales.</span><span class="sxs-lookup"><span data-stu-id="0eb41-327">The accessor(s) of a property can be virtual.</span></span> <span data-ttu-id="0eb41-328">Cuando una declaración de propiedad incluye un modificador `virtual`, `abstract` o `override`, se aplica a los descriptores de acceso de la propiedad.</span><span class="sxs-lookup"><span data-stu-id="0eb41-328">When a property declaration includes a `virtual`, `abstract`, or `override` modifier, it applies to the accessor(s) of the property.</span></span>

### <a name="indexers"></a><span data-ttu-id="0eb41-329">Indizadores</span><span class="sxs-lookup"><span data-stu-id="0eb41-329">Indexers</span></span>

<span data-ttu-id="0eb41-330">Un *indexador* es un miembro que permite indexar de la misma manera que una matriz.</span><span class="sxs-lookup"><span data-stu-id="0eb41-330">An *indexer* is a member that enables objects to be indexed in the same way as an array.</span></span> <span data-ttu-id="0eb41-331">Un indexador se declara como una propiedad, excepto por el hecho que el nombre del miembro va seguido por una lista de parámetros que se escriben entre los delimitadores `[` y `]`.</span><span class="sxs-lookup"><span data-stu-id="0eb41-331">An indexer is declared like a property except that the name of the member is this followed by a parameter list written between the delimiters `[` and `]`.</span></span> <span data-ttu-id="0eb41-332">Los parámetros están disponibles en los descriptores de acceso del indexador.</span><span class="sxs-lookup"><span data-stu-id="0eb41-332">The parameters are available in the accessor(s) of the indexer.</span></span> <span data-ttu-id="0eb41-333">De forma similar a las propiedades, los indexadores pueden ser lectura y escritura, de solo lectura y de solo escritura, y los descriptores de acceso de un indexador pueden ser virtuales.</span><span class="sxs-lookup"><span data-stu-id="0eb41-333">Similar to properties, indexers can be read-write, read-only, and write-only, and the accessor(s) of an indexer can be virtual.</span></span>

<span data-ttu-id="0eb41-334">La clase `List` declara un único indexador de lectura y escritura que toma un parámetro `int`.</span><span class="sxs-lookup"><span data-stu-id="0eb41-334">The `List` class declares a single read-write indexer that takes an `int` parameter.</span></span> <span data-ttu-id="0eb41-335">El indexador permite indexar instancias de `List` con valores `int`.</span><span class="sxs-lookup"><span data-stu-id="0eb41-335">The indexer makes it possible to index `List` instances with `int` values.</span></span> <span data-ttu-id="0eb41-336">Por ejemplo:</span><span class="sxs-lookup"><span data-stu-id="0eb41-336">For example:</span></span>

<span data-ttu-id="0eb41-337">[!code-csharp[ListExample3](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L109-L117)]</span><span class="sxs-lookup"><span data-stu-id="0eb41-337">[!code-csharp[ListExample3](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L109-L117)]</span></span>

<span data-ttu-id="0eb41-338">Los indexadores se pueden sobrecargar, lo que significa que una clase puede declarar varios indexadores siempre y cuando el número o los tipos de sus parámetros sean diferentes.</span><span class="sxs-lookup"><span data-stu-id="0eb41-338">Indexers can be overloaded, meaning that a class can declare multiple indexers as long as the number or types of their parameters differ.</span></span>

### <a name="events"></a><span data-ttu-id="0eb41-339">Eventos</span><span class="sxs-lookup"><span data-stu-id="0eb41-339">Events</span></span>

<span data-ttu-id="0eb41-340">Un *evento* es un miembro que permite que una clase u objeto proporcionen notificaciones.</span><span class="sxs-lookup"><span data-stu-id="0eb41-340">An *event* is a member that enables a class or object to provide notifications.</span></span> <span data-ttu-id="0eb41-341">Un evento se declara como un campo, excepto por el hecho de que la declaración incluye una palabra clave event y el tipo debe ser un tipo delegado.</span><span class="sxs-lookup"><span data-stu-id="0eb41-341">An event is declared like a field except that the declaration includes an event keyword and the type must be a delegate type.</span></span>

<span data-ttu-id="0eb41-342">Dentro de una clase que declara un miembro de evento, el evento se comporta como un campo de un tipo delegado (siempre que el evento no sea abstracto y no declare descriptores de acceso).</span><span class="sxs-lookup"><span data-stu-id="0eb41-342">Within a class that declares an event member, the event behaves just like a field of a delegate type (provided the event is not abstract and does not declare accessors).</span></span> <span data-ttu-id="0eb41-343">El campo almacena una referencia a un delegado que representa los controladores de eventos que se han agregado al evento.</span><span class="sxs-lookup"><span data-stu-id="0eb41-343">The field stores a reference to a delegate that represents the event handlers that have been added to the event.</span></span> <span data-ttu-id="0eb41-344">Si no existen controladores de eventos, el campo es `null`.</span><span class="sxs-lookup"><span data-stu-id="0eb41-344">If no event handlers are present, the field is `null`.</span></span>

<span data-ttu-id="0eb41-345">La clase `List<T>` declara un único miembro de evento llamado `Changed`, lo que indica que se ha agregado un nuevo elemento a la lista.</span><span class="sxs-lookup"><span data-stu-id="0eb41-345">The `List<T>` class declares a single event member called `Changed`, which indicates that a new item has been added to the list.</span></span> <span data-ttu-id="0eb41-346">El método virtual `OnChanged` genera el evento cambiado, y comprueba primero si el evento es `null` (lo que significa que no existen controladores).</span><span class="sxs-lookup"><span data-stu-id="0eb41-346">The Changed event is raised by the `OnChanged` virtual method, which first checks whether the event is `null` (meaning that no handlers are present).</span></span> <span data-ttu-id="0eb41-347">La noción de generar un evento es equivalente exactamente a invocar el delegado representado por el evento; por lo tanto, no hay ninguna construcción especial de lenguaje para generar eventos.</span><span class="sxs-lookup"><span data-stu-id="0eb41-347">The notion of raising an event is precisely equivalent to invoking the delegate represented by the event—thus, there are no special language constructs for raising events.</span></span>

<span data-ttu-id="0eb41-348">Los clientes reaccionan a los eventos mediante *controladores de eventos*.</span><span class="sxs-lookup"><span data-stu-id="0eb41-348">Clients react to events through *event handlers*.</span></span> <span data-ttu-id="0eb41-349">Los controladores de eventos se asocian mediante el operador `+=` y se quitan con el operador `-=`.</span><span class="sxs-lookup"><span data-stu-id="0eb41-349">Event handlers are attached using the `+=` operator and removed using the `-=` operator.</span></span> <span data-ttu-id="0eb41-350">En el ejemplo siguiente se asocia un controlador de eventos con el evento `Changed` de un objeto `List<string>`.</span><span class="sxs-lookup"><span data-stu-id="0eb41-350">The following example attaches an event handler to the `Changed` event of a `List<string>`.</span></span>

<span data-ttu-id="0eb41-351">[!code-csharp[EventExample](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L132-L148)]</span><span class="sxs-lookup"><span data-stu-id="0eb41-351">[!code-csharp[EventExample](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L132-L148)]</span></span>

<span data-ttu-id="0eb41-352">Para escenarios avanzados donde se desea controlar el almacenamiento subyacente de un evento, una declaración de evento puede proporcionar explícitamente los descriptores de acceso `add` y `remove`, que son similares en cierto modo al descriptor de acceso `set` de una propiedad.</span><span class="sxs-lookup"><span data-stu-id="0eb41-352">For advanced scenarios where control of the underlying storage of an event is desired, an event declaration can explicitly provide `add` and `remove` accessors, which are somewhat similar to the `set` accessor of a property.</span></span>

### <a name="operators"></a><span data-ttu-id="0eb41-353">Operadores</span><span class="sxs-lookup"><span data-stu-id="0eb41-353">Operators</span></span>

<span data-ttu-id="0eb41-354">Un *operador* es un miembro que define el significado de aplicar un operador de expresión determinado a las instancias de una clase.</span><span class="sxs-lookup"><span data-stu-id="0eb41-354">An *operator* is a member that defines the meaning of applying a particular expression operator to instances of a class.</span></span> <span data-ttu-id="0eb41-355">Se pueden definir tres tipos de operadores: operadores unarios, operadores binarios y operadores de conversión.</span><span class="sxs-lookup"><span data-stu-id="0eb41-355">Three kinds of operators can be defined: unary operators, binary operators, and conversion operators.</span></span> <span data-ttu-id="0eb41-356">Todos los operadores se deben declarar como `public` y `static`.</span><span class="sxs-lookup"><span data-stu-id="0eb41-356">All operators must be declared as `public` and `static`.</span></span>

<span data-ttu-id="0eb41-357">La clase `List<T>` declara dos operadores, `operator ==` y `operator !=`, y de este modo proporciona un nuevo significado a expresiones que aplican esos operadores a instancias `List`.</span><span class="sxs-lookup"><span data-stu-id="0eb41-357">The `List<T>` class declares two operators, `operator ==` and `operator !=`, and thus gives new meaning to expressions that apply those operators to `List` instances.</span></span> <span data-ttu-id="0eb41-358">En concreto, los operadores definen la igualdad de dos instancias `List<T>` como la comparación de cada uno de los objetos contenidos con sus métodos Equals.</span><span class="sxs-lookup"><span data-stu-id="0eb41-358">Specifically, the operators define equality of two `List<T>` instances as comparing each of the contained objects using their Equals methods.</span></span> <span data-ttu-id="0eb41-359">En el ejemplo siguiente se usa el operador `==` para comparar dos instancias `List<int>`.</span><span class="sxs-lookup"><span data-stu-id="0eb41-359">The following example uses the `==` operator to compare two `List<int>` instances.</span></span>

<span data-ttu-id="0eb41-360">[!code-csharp[OperatorExample](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L121-L129)]</span><span class="sxs-lookup"><span data-stu-id="0eb41-360">[!code-csharp[OperatorExample](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L121-L129)]</span></span>

<span data-ttu-id="0eb41-361">El primer objeto `Console.WriteLine` genera `True` porque las dos listas contienen el mismo número de objetos con los mismos valores en el mismo orden.</span><span class="sxs-lookup"><span data-stu-id="0eb41-361">The first `Console.WriteLine` outputs `True` because the two lists contain the same number of objects with the same values in the same order.</span></span> <span data-ttu-id="0eb41-362">Si `List<T>` no hubiera definido `operator ==`, el primer objeto `Console.WriteLine` habría generado `False` porque `a` y `b` hacen referencia a diferentes instancias de `List<int>`.</span><span class="sxs-lookup"><span data-stu-id="0eb41-362">Had `List<T>` not defined `operator ==`, the first `Console.WriteLine` would have output `False` because `a` and `b` reference different `List<int>` instances.</span></span>

### <a name="finalizers"></a><span data-ttu-id="0eb41-363">Finalizadores</span><span class="sxs-lookup"><span data-stu-id="0eb41-363">Finalizers</span></span>

<span data-ttu-id="0eb41-364">Un *finalizador* es un miembro que implementa las acciones necesarias para finalizar una instancia de una clase.</span><span class="sxs-lookup"><span data-stu-id="0eb41-364">A *finalizer* is a member that implements the actions required to finalize an instance of a class.</span></span> <span data-ttu-id="0eb41-365">Los finalizadores no pueden tener parámetros, no pueden tener modificadores de accesibilidad y no se pueden invocar explícitamente.</span><span class="sxs-lookup"><span data-stu-id="0eb41-365">Finalizers cannot have parameters, they cannot have accessibility modifiers, and they cannot be invoked explicitly.</span></span> <span data-ttu-id="0eb41-366">El finalizador de una instancia se invoca automáticamente durante la recolección de elementos no utilizados.</span><span class="sxs-lookup"><span data-stu-id="0eb41-366">The finalizer for an instance is invoked automatically during garbage collection.</span></span>

<span data-ttu-id="0eb41-367">El recolector de elementos no utilizados tiene una amplia libertad para decidir cuándo debe recolectar objetos y ejecutar finalizadores.</span><span class="sxs-lookup"><span data-stu-id="0eb41-367">The garbage collector is allowed wide latitude in deciding when to collect objects and run finalizers.</span></span> <span data-ttu-id="0eb41-368">En concreto, los intervalos de las llamadas del finalizador no son deterministas y los finalizadores se pueden ejecutar en cualquier subproceso.</span><span class="sxs-lookup"><span data-stu-id="0eb41-368">Specifically, the timing of finalizer invocations is not deterministic, and finalizers may be executed on any thread.</span></span> <span data-ttu-id="0eb41-369">Por estas y otras razones, las clases deben implementar finalizadores solo cuando no haya otras soluciones que sean factibles.</span><span class="sxs-lookup"><span data-stu-id="0eb41-369">For these and other reasons, classes should implement finalizers only when no other solutions are feasible.</span></span>

<span data-ttu-id="0eb41-370">La instrucción `using` proporciona un mejor enfoque para la destrucción de objetos.</span><span class="sxs-lookup"><span data-stu-id="0eb41-370">The `using` statement provides a better approach to object destruction.</span></span>

>[!div class="step-by-step"]
<span data-ttu-id="0eb41-371">[Anterior](statements.md)
[Siguiente](structs.md)</span><span class="sxs-lookup"><span data-stu-id="0eb41-371">[Previous](statements.md)
[Next](structs.md)</span></span>

