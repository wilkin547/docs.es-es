---
title: Bloques de creación de "programas" de C#
description: Obtenga información sobre miembros, expresiones e instrucciones de C#. Los tipos contienen miembros que se escriben. Estos miembros se crean a partir de instrucciones y expresiones.
ms.date: 08/06/2020
ms.openlocfilehash: e4350f2c2b6005fb59dd868f0f7f628bd07b0053
ms.sourcegitcommit: 0802ac583585110022beb6af8ea0b39188b77c43
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 11/26/2020
ms.locfileid: "93342701"
---
# <a name="program-building-blocks"></a><span data-ttu-id="bcb12-105">Bloques de creación de programas</span><span class="sxs-lookup"><span data-stu-id="bcb12-105">Program building blocks</span></span>

<span data-ttu-id="bcb12-106">Los tipos descritos en el artículo anterior se compilan con estos bloques de creación: [\***miembros** _](../programming-guide/classes-and-structs/members.md), [_*_expresiones_*_ e _*_instrucciones_*_](../programming-guide/statements-expressions-operators/index.md).</span><span class="sxs-lookup"><span data-stu-id="bcb12-106">The types described in the previous article are built using these building blocks: [\***members** _](../programming-guide/classes-and-structs/members.md), [_*_expressions_*_, and _*_statements_*_](../programming-guide/statements-expressions-operators/index.md).</span></span>

## <a name="members"></a><span data-ttu-id="bcb12-107">Miembros</span><span class="sxs-lookup"><span data-stu-id="bcb12-107">Members</span></span>

<span data-ttu-id="bcb12-108">Los miembros de una `class` son _*_estáticos_*_ o _*_de instancia_*_.</span><span class="sxs-lookup"><span data-stu-id="bcb12-108">The members of a `class` are either _*_static members_*_ or _*_instance members_*_.</span></span> <span data-ttu-id="bcb12-109">Los miembros estáticos pertenecen a clases y los miembros de instancia pertenecen a objetos (instancias de clases).</span><span class="sxs-lookup"><span data-stu-id="bcb12-109">Static members belong to classes, and instance members belong to objects (instances of classes).</span></span>

<span data-ttu-id="bcb12-110">En la lista siguiente se proporciona una visión general de los tipos de miembros que puede contener una clase.</span><span class="sxs-lookup"><span data-stu-id="bcb12-110">The following list provides an overview of the kinds of members a class can contain.</span></span>

- <span data-ttu-id="bcb12-111">_\*Constantes\*\*: Valores constantes asociados a la clase</span><span class="sxs-lookup"><span data-stu-id="bcb12-111">_\*Constants\*\*: Constant values associated with the class</span></span>
- <span data-ttu-id="bcb12-112">**Campos**:  variables que están asociadas a la clase</span><span class="sxs-lookup"><span data-stu-id="bcb12-112">**Fields**:  Variables that are associated of the class</span></span>
- <span data-ttu-id="bcb12-113">**Métodos**:  acciones que puede realizar la clase.</span><span class="sxs-lookup"><span data-stu-id="bcb12-113">**Methods**:  Actions that can be performed by the class</span></span>
- <span data-ttu-id="bcb12-114">**Propiedades**: Acciones asociadas a la lectura y escritura de propiedades con nombre de la clase</span><span class="sxs-lookup"><span data-stu-id="bcb12-114">**Properties**: Actions associated with reading and writing named properties of the class</span></span>
- <span data-ttu-id="bcb12-115">**Indizadores**: Acciones asociadas a la indexación de instancias de la clase como una matriz</span><span class="sxs-lookup"><span data-stu-id="bcb12-115">**Indexers**: Actions associated with indexing instances of the class like an array</span></span>
- <span data-ttu-id="bcb12-116">**Eventos**: Notificaciones que puede generar la clase</span><span class="sxs-lookup"><span data-stu-id="bcb12-116">**Events**: Notifications that can be generated by the class</span></span>
- <span data-ttu-id="bcb12-117">**Operadores**: Conversiones y operadores de expresión admitidos por la clase</span><span class="sxs-lookup"><span data-stu-id="bcb12-117">**Operators**: Conversions and expression operators supported by the class</span></span>
- <span data-ttu-id="bcb12-118">**Constructores**: Acciones necesarias para inicializar instancias de la clase o la clase propiamente dicha</span><span class="sxs-lookup"><span data-stu-id="bcb12-118">**Constructors**: Actions required to initialize instances of the class or the class itself</span></span>
- <span data-ttu-id="bcb12-119">**Finalizadores**: acciones que deben realizarse antes de que las instancias de la clase se descarten de forma permanente</span><span class="sxs-lookup"><span data-stu-id="bcb12-119">**Finalizers**: Actions performed before instances of the class are permanently discarded</span></span>
- <span data-ttu-id="bcb12-120">**Tipos**: Tipos anidados declarados por la clase</span><span class="sxs-lookup"><span data-stu-id="bcb12-120">**Types**: Nested types declared by the class</span></span>

## <a name="accessibility"></a><span data-ttu-id="bcb12-121">Accesibilidad</span><span class="sxs-lookup"><span data-stu-id="bcb12-121">Accessibility</span></span>

<span data-ttu-id="bcb12-122">Cada miembro de una clase tiene asociada una accesibilidad, que controla las regiones del texto del programa que pueden acceder al miembro.</span><span class="sxs-lookup"><span data-stu-id="bcb12-122">Each member of a class has an associated accessibility, which controls the regions of program text that can access the member.</span></span> <span data-ttu-id="bcb12-123">Existen seis formas de accesibilidad posibles.</span><span class="sxs-lookup"><span data-stu-id="bcb12-123">There are six possible forms of accessibility.</span></span> <span data-ttu-id="bcb12-124">A continuación se resumen los modificadores de acceso.</span><span class="sxs-lookup"><span data-stu-id="bcb12-124">The access modifiers are summarized below.</span></span>

- <span data-ttu-id="bcb12-125">`public`: El acceso no está limitado.</span><span class="sxs-lookup"><span data-stu-id="bcb12-125">`public`: Access isn't limited.</span></span>
- <span data-ttu-id="bcb12-126">`private`: El acceso está limitado a esta clase.</span><span class="sxs-lookup"><span data-stu-id="bcb12-126">`private`: Access is limited to this class.</span></span>
- <span data-ttu-id="bcb12-127">`protected`: El acceso está limitado a esta clase o a las clases derivadas de esta clase.</span><span class="sxs-lookup"><span data-stu-id="bcb12-127">`protected`: Access is limited to this class or classes derived from this class.</span></span>
- <span data-ttu-id="bcb12-128">`internal`: El acceso está limitado al ensamblado actual (`.exe` o `.dll`).</span><span class="sxs-lookup"><span data-stu-id="bcb12-128">`internal`: Access is limited to the current assembly (`.exe` or `.dll`).</span></span>
- <span data-ttu-id="bcb12-129">`protected internal`: El acceso está limitado a esta clase, las clases derivadas de la misma o las clases que forman parte del mismo ensamblado.</span><span class="sxs-lookup"><span data-stu-id="bcb12-129">`protected internal`: Access is limited to this class, classes derived from this class, or classes within the same assembly.</span></span>
- <span data-ttu-id="bcb12-130">`private protected`: El acceso está limitado a esta clase o a las clases derivadas de este tipo que forman parte del mismo ensamblado.</span><span class="sxs-lookup"><span data-stu-id="bcb12-130">`private protected`: Access is limited to this class or classes derived from this type within the same assembly.</span></span>

## <a name="fields"></a><span data-ttu-id="bcb12-131">Campos</span><span class="sxs-lookup"><span data-stu-id="bcb12-131">Fields</span></span>

<span data-ttu-id="bcb12-132">Un *campo* es una variable que está asociada con una clase o a una instancia de una clase.</span><span class="sxs-lookup"><span data-stu-id="bcb12-132">A *field* is a variable that is associated with a class or with an instance of a class.</span></span>

<span data-ttu-id="bcb12-133">Un campo declarado con el modificador "static" define un campo estático.</span><span class="sxs-lookup"><span data-stu-id="bcb12-133">A field declared with the static modifier defines a static field.</span></span> <span data-ttu-id="bcb12-134">Un campo estático identifica exactamente una ubicación de almacenamiento.</span><span class="sxs-lookup"><span data-stu-id="bcb12-134">A static field identifies exactly one storage location.</span></span> <span data-ttu-id="bcb12-135">Independientemente del número de instancias de una clase que se creen, solo hay una única copia de un campo estático.</span><span class="sxs-lookup"><span data-stu-id="bcb12-135">No matter how many instances of a class are created, there's only ever one copy of a static field.</span></span>

<span data-ttu-id="bcb12-136">Un campo declarado sin el modificador "static" define un campo de instancia.</span><span class="sxs-lookup"><span data-stu-id="bcb12-136">A field declared without the static modifier defines an instance field.</span></span> <span data-ttu-id="bcb12-137">Cada instancia de una clase contiene una copia independiente de todos los campos de instancia de esa clase.</span><span class="sxs-lookup"><span data-stu-id="bcb12-137">Every instance of a class contains a separate copy of all the instance fields of that class.</span></span>

<span data-ttu-id="bcb12-138">En el ejemplo siguiente, cada instancia de la clase `Color` tiene una copia independiente de los campos de instancia `R`, `G` y `B`, pero solo hay una copia de los campos estáticos `Black`, `White`, `Red`, `Green` y `Blue`:</span><span class="sxs-lookup"><span data-stu-id="bcb12-138">In the following example, each instance of the `Color` class has a separate copy of the `R`, `G`, and `B` instance fields, but there's only one copy of the `Black`, `White`, `Red`, `Green`, and `Blue` static fields:</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ColorClassDefinition":::

<span data-ttu-id="bcb12-139">Como se muestra en el ejemplo anterior, los *campos de solo lectura* se puede declarar con un modificador `readonly`.</span><span class="sxs-lookup"><span data-stu-id="bcb12-139">As shown in the previous example, *read-only fields* may be declared with a `readonly` modifier.</span></span> <span data-ttu-id="bcb12-140">La asignación a un campo de solo lectura únicamente se puede producir como parte de la declaración del campo o en un constructor de la misma clase.</span><span class="sxs-lookup"><span data-stu-id="bcb12-140">Assignment to a read-only field can only occur as part of the field’s declaration or in a constructor in the same class.</span></span>

## <a name="methods"></a><span data-ttu-id="bcb12-141">Métodos</span><span class="sxs-lookup"><span data-stu-id="bcb12-141">Methods</span></span>

<span data-ttu-id="bcb12-142">Un *método* es un miembro que implementa un cálculo o una acción que puede realizar un objeto o una clase.</span><span class="sxs-lookup"><span data-stu-id="bcb12-142">A *method* is a member that implements a computation or action that can be performed by an object or class.</span></span> <span data-ttu-id="bcb12-143">A los *métodos estáticos* se accede a través de la clase.</span><span class="sxs-lookup"><span data-stu-id="bcb12-143">*Static methods* are accessed through the class.</span></span> <span data-ttu-id="bcb12-144">A los *métodos de instancia* se accede a través de instancias de la clase.</span><span class="sxs-lookup"><span data-stu-id="bcb12-144">*Instance methods* are accessed through instances of the class.</span></span>

<span data-ttu-id="bcb12-145">Los métodos pueden tener una lista de *parámetros*, los cuales representan valores o referencias a variables que se pasan al método.</span><span class="sxs-lookup"><span data-stu-id="bcb12-145">Methods may have a list of *parameters*, which represent values or variable references passed to the method.</span></span> <span data-ttu-id="bcb12-146">Los métodos tienen un *tipo de valor devuelto*, el cual especifica el tipo del valor calculado y devuelto por el método.</span><span class="sxs-lookup"><span data-stu-id="bcb12-146">Methods have a *return type*, which specifies the type of the value computed and returned by the method.</span></span> <span data-ttu-id="bcb12-147">El tipo de valor devuelto de un método es `void` si no devuelve un valor.</span><span class="sxs-lookup"><span data-stu-id="bcb12-147">A method’s return type is `void` if it doesn't return a value.</span></span>

<span data-ttu-id="bcb12-148">Al igual que los tipos, los métodos también pueden tener un conjunto de parámetros de tipo, para lo cuales se deben especificar argumentos de tipo cuando se llama al método.</span><span class="sxs-lookup"><span data-stu-id="bcb12-148">Like types, methods may also have a set of type parameters, for which type arguments must be specified when the method is called.</span></span> <span data-ttu-id="bcb12-149">A diferencia de los tipos, los argumentos de tipo a menudo se pueden deducir de los argumentos de una llamada al método y no es necesario proporcionarlos explícitamente.</span><span class="sxs-lookup"><span data-stu-id="bcb12-149">Unlike types, the type arguments can often be inferred from the arguments of a method call and need not be explicitly given.</span></span>

<span data-ttu-id="bcb12-150">La *signatura* de un método debe ser única en la clase en la que se declara el método.</span><span class="sxs-lookup"><span data-stu-id="bcb12-150">The *signature* of a method must be unique in the class in which the method is declared.</span></span> <span data-ttu-id="bcb12-151">La signatura de un método se compone del nombre del método, el número de parámetros de tipo y el número, los modificadores y los tipos de sus parámetros.</span><span class="sxs-lookup"><span data-stu-id="bcb12-151">The signature of a method consists of the name of the method, the number of type parameters, and the number, modifiers, and types of its parameters.</span></span> <span data-ttu-id="bcb12-152">La signatura de un método no incluye el tipo de valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="bcb12-152">The signature of a method doesn't include the return type.</span></span>

<span data-ttu-id="bcb12-153">Cuando el cuerpo del método es una expresión única, el método se puede definir con un formato de expresión compacta, tal y como se muestra en el ejemplo siguiente:</span><span class="sxs-lookup"><span data-stu-id="bcb12-153">When a method body is a single expression, the method can be defined using a compact expression format, as shown in the following example:</span></span>

```csharp
public override string ToString() => "This is an object";
```

### <a name="parameters"></a><span data-ttu-id="bcb12-154">Parámetros</span><span class="sxs-lookup"><span data-stu-id="bcb12-154">Parameters</span></span>

<span data-ttu-id="bcb12-155">Los parámetros se usan para pasar valores o referencias a variables a métodos.</span><span class="sxs-lookup"><span data-stu-id="bcb12-155">Parameters are used to pass values or variable references to methods.</span></span> <span data-ttu-id="bcb12-156">Los parámetros de un método obtienen sus valores reales de los *argumentos* que se especifican cuando se invoca el método.</span><span class="sxs-lookup"><span data-stu-id="bcb12-156">The parameters of a method get their actual values from the *arguments* that are specified when the method is invoked.</span></span> <span data-ttu-id="bcb12-157">Hay cuatro tipos de parámetros: parámetros de valor, parámetros de referencia, parámetros de salida y matrices de parámetros.</span><span class="sxs-lookup"><span data-stu-id="bcb12-157">There are four kinds of parameters: value parameters, reference parameters, output parameters, and parameter arrays.</span></span>

<span data-ttu-id="bcb12-158">Un *parámetro de valor* se usa para pasar argumentos de entrada.</span><span class="sxs-lookup"><span data-stu-id="bcb12-158">A *value parameter* is used for passing input arguments.</span></span> <span data-ttu-id="bcb12-159">Un parámetro de valor corresponde a una variable local que obtiene su valor inicial del argumento que se ha pasado para el parámetro.</span><span class="sxs-lookup"><span data-stu-id="bcb12-159">A value parameter corresponds to a local variable that gets its initial value from the argument that was passed for the parameter.</span></span> <span data-ttu-id="bcb12-160">Las modificaciones de un parámetro de valor no afectan el argumento que se ha pasado para el parámetro.</span><span class="sxs-lookup"><span data-stu-id="bcb12-160">Modifications to a value parameter don't affect the argument that was passed for the parameter.</span></span>

<span data-ttu-id="bcb12-161">Los parámetros de valor pueden ser opcionales; se especifica un valor predeterminado para que se puedan omitir los argumentos correspondientes.</span><span class="sxs-lookup"><span data-stu-id="bcb12-161">Value parameters can be optional, by specifying a default value so that corresponding arguments can be omitted.</span></span>

<span data-ttu-id="bcb12-162">Un *parámetro de referencia* se usa para pasar argumentos mediante una referencia.</span><span class="sxs-lookup"><span data-stu-id="bcb12-162">A *reference parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="bcb12-163">El argumento pasado para un parámetro de referencia debe ser una variable con un valor definido.</span><span class="sxs-lookup"><span data-stu-id="bcb12-163">The argument passed for a reference parameter must be a variable with a definite value.</span></span> <span data-ttu-id="bcb12-164">Durante la ejecución del método, el parámetro de referencia representa la misma ubicación de almacenamiento que la variable del argumento.</span><span class="sxs-lookup"><span data-stu-id="bcb12-164">During execution of the method, the reference parameter represents the same storage location as the argument variable.</span></span> <span data-ttu-id="bcb12-165">Un parámetro de referencia se declara con el modificador `ref`.</span><span class="sxs-lookup"><span data-stu-id="bcb12-165">A reference parameter is declared with the `ref` modifier.</span></span> <span data-ttu-id="bcb12-166">En el ejemplo siguiente se muestra el uso de parámetros `ref`.</span><span class="sxs-lookup"><span data-stu-id="bcb12-166">The following example shows the use of `ref` parameters.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="RefExample":::

<span data-ttu-id="bcb12-167">Un *parámetro de salida* se usa para pasar argumentos mediante una referencia.</span><span class="sxs-lookup"><span data-stu-id="bcb12-167">An *output parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="bcb12-168">Es similar a un parámetro de referencia, excepto que no necesita que asigne un valor explícitamente al argumento proporcionado por el autor de la llamada.</span><span class="sxs-lookup"><span data-stu-id="bcb12-168">It's similar to a reference parameter, except that it doesn't require that you explicitly assign a value to the caller-provided argument.</span></span> <span data-ttu-id="bcb12-169">Un parámetro de salida se declara con el modificador `out`.</span><span class="sxs-lookup"><span data-stu-id="bcb12-169">An output parameter is declared with the `out` modifier.</span></span> <span data-ttu-id="bcb12-170">En el siguiente ejemplo se muestra el uso de los parámetros `out` con la sintaxis que se ha presentado en C# 7.</span><span class="sxs-lookup"><span data-stu-id="bcb12-170">The following example shows the use of `out` parameters using the syntax introduced in C# 7.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="OutExample":::

<span data-ttu-id="bcb12-171">Una *matriz de parámetros* permite que se pasen a un método un número variable de argumentos.</span><span class="sxs-lookup"><span data-stu-id="bcb12-171">A *parameter array* permits a variable number of arguments to be passed to a method.</span></span> <span data-ttu-id="bcb12-172">Una matriz de parámetros se declara con el modificador `params`.</span><span class="sxs-lookup"><span data-stu-id="bcb12-172">A parameter array is declared with the `params` modifier.</span></span> <span data-ttu-id="bcb12-173">Solo el último parámetro de un método puede ser una matriz de parámetros y el tipo de una matriz de parámetros debe ser un tipo de matriz unidimensional.</span><span class="sxs-lookup"><span data-stu-id="bcb12-173">Only the last parameter of a method can be a parameter array, and the type of a parameter array must be a single-dimensional array type.</span></span> <span data-ttu-id="bcb12-174">Los métodos `Write` y `WriteLine` de la clase <xref:System.Console?displayProperty=nameWithType> son buenos ejemplos de uso de la matriz de parámetros.</span><span class="sxs-lookup"><span data-stu-id="bcb12-174">The `Write` and `WriteLine` methods of the <xref:System.Console?displayProperty=nameWithType> class are good examples of parameter array usage.</span></span> <span data-ttu-id="bcb12-175">Se declaran de la manera siguiente.</span><span class="sxs-lookup"><span data-stu-id="bcb12-175">They're declared as follows.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ConsoleExtract":::

<span data-ttu-id="bcb12-176">Dentro de un método que usa una matriz de parámetros, la matriz de parámetros se comporta exactamente igual que un parámetro normal de un tipo de matriz.</span><span class="sxs-lookup"><span data-stu-id="bcb12-176">Within a method that uses a parameter array, the parameter array behaves exactly like a regular parameter of an array type.</span></span> <span data-ttu-id="bcb12-177">Pero en una invocación de un método con una matriz de parámetros, es posible pasar un único argumento del tipo de matriz de parámetros o cualquier número de argumentos del tipo de elemento de la matriz de parámetros.</span><span class="sxs-lookup"><span data-stu-id="bcb12-177">However, in an invocation of a method with a parameter array, it's possible to pass either a single argument of the parameter array type or any number of arguments of the element type of the parameter array.</span></span> <span data-ttu-id="bcb12-178">En este caso, una instancia de matriz se e inicializa automáticamente con los argumentos dados.</span><span class="sxs-lookup"><span data-stu-id="bcb12-178">In the latter case, an array instance is automatically created and initialized with the given arguments.</span></span> <span data-ttu-id="bcb12-179">Este ejemplo</span><span class="sxs-lookup"><span data-stu-id="bcb12-179">This example</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UseParamsArgs":::

<span data-ttu-id="bcb12-180">es equivalente a escribir lo siguiente.</span><span class="sxs-lookup"><span data-stu-id="bcb12-180">is equivalent to writing the following.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="CompilerParams":::

### <a name="method-body-and-local-variables"></a><span data-ttu-id="bcb12-181">Cuerpo del método y variables locales</span><span class="sxs-lookup"><span data-stu-id="bcb12-181">Method body and local variables</span></span>

<span data-ttu-id="bcb12-182">El cuerpo de un método especifica las instrucciones que se ejecutarán cuando se invoca el método.</span><span class="sxs-lookup"><span data-stu-id="bcb12-182">A method’s body specifies the statements to execute when the method is invoked.</span></span>

<span data-ttu-id="bcb12-183">Un cuerpo del método puede declarar variables que son específicas de la invocación del método.</span><span class="sxs-lookup"><span data-stu-id="bcb12-183">A method body can declare variables that are specific to the invocation of the method.</span></span> <span data-ttu-id="bcb12-184">Estas variables se denominan *variables locales*.</span><span class="sxs-lookup"><span data-stu-id="bcb12-184">Such variables are called *local variables*.</span></span> <span data-ttu-id="bcb12-185">Una declaración de variable local especifica un nombre de tipo, un nombre de variable y, posiblemente, un valor inicial.</span><span class="sxs-lookup"><span data-stu-id="bcb12-185">A local variable declaration specifies a type name, a variable name, and possibly an initial value.</span></span> <span data-ttu-id="bcb12-186">En el ejemplo siguiente se declara una variable local `i` con un valor inicial de cero y una variable local `j` sin ningún valor inicial.</span><span class="sxs-lookup"><span data-stu-id="bcb12-186">The following example declares a local variable `i` with an initial value of zero and a local variable `j` with no initial value.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="SquaresClass":::

<span data-ttu-id="bcb12-187">C# requiere que se *asigne definitivamente* una variable local antes de que se pueda obtener su valor.</span><span class="sxs-lookup"><span data-stu-id="bcb12-187">C# requires a local variable to be *definitely assigned* before its value can be obtained.</span></span> <span data-ttu-id="bcb12-188">Por ejemplo, si la declaración de `i` anterior no incluyera un valor inicial, el compilador notificaría un error con los usos posteriores de `i` porque `i` no se asignaría definitivamente en esos puntos del programa.</span><span class="sxs-lookup"><span data-stu-id="bcb12-188">For example, if the declaration of the previous `i` didn't include an initial value, the compiler would report an error for the later usages of `i` because `i` wouldn't be definitely assigned at those points in the program.</span></span>

<span data-ttu-id="bcb12-189">Puede usar una instrucción `return` para devolver el control a su llamador.</span><span class="sxs-lookup"><span data-stu-id="bcb12-189">A method can use `return` statements to return control to its caller.</span></span> <span data-ttu-id="bcb12-190">En un método que devuelve `void`, las instrucciones `return` no pueden especificar una expresión.</span><span class="sxs-lookup"><span data-stu-id="bcb12-190">In a method returning `void`, `return` statements can't specify an expression.</span></span> <span data-ttu-id="bcb12-191">En un método que devuelve valores distintos de void, las instrucciones `return` deben incluir una expresión que calcula el valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="bcb12-191">In a method returning non-void, `return` statements must include an expression that computes the return value.</span></span>

### <a name="static-and-instance-methods"></a><span data-ttu-id="bcb12-192">Métodos estáticos y de instancia</span><span class="sxs-lookup"><span data-stu-id="bcb12-192">Static and instance methods</span></span>

<span data-ttu-id="bcb12-193">Un método declarado con un modificador `static` es un *método estático*.</span><span class="sxs-lookup"><span data-stu-id="bcb12-193">A method declared with a `static` modifier is a *static method*.</span></span> <span data-ttu-id="bcb12-194">Un método estático no opera en una instancia específica y solo puede acceder directamente a miembros estáticos.</span><span class="sxs-lookup"><span data-stu-id="bcb12-194">A static method doesn't operate on a specific instance and can only directly access static members.</span></span>

<span data-ttu-id="bcb12-195">Un método declarado sin un modificador `static` es un *método de instancia*.</span><span class="sxs-lookup"><span data-stu-id="bcb12-195">A method declared without a `static` modifier is an *instance method*.</span></span> <span data-ttu-id="bcb12-196">Un método de instancia opera en una instancia específica y puede acceder a miembros estáticos y de instancia.</span><span class="sxs-lookup"><span data-stu-id="bcb12-196">An instance method operates on a specific instance and can access both static and instance members.</span></span> <span data-ttu-id="bcb12-197">Se puede acceder explícitamente a la instancia en la que se invoca un método de instancia como `this`.</span><span class="sxs-lookup"><span data-stu-id="bcb12-197">The instance on which an instance method was invoked can be explicitly accessed as `this`.</span></span> <span data-ttu-id="bcb12-198">Es un error hacer referencia a `this` en un método estático.</span><span class="sxs-lookup"><span data-stu-id="bcb12-198">It's an error to refer to `this` in a static method.</span></span>

<span data-ttu-id="bcb12-199">La siguiente clase `Entity` tiene miembros estáticos y de instancia.</span><span class="sxs-lookup"><span data-stu-id="bcb12-199">The following `Entity` class has both static and instance members.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="EntityClass":::

<span data-ttu-id="bcb12-200">Cada instancia de `Entity` contiene un número de serie (y, probablemente, otra información que no se muestra aquí).</span><span class="sxs-lookup"><span data-stu-id="bcb12-200">Each `Entity` instance contains a serial number (and presumably some other information that isn't shown here).</span></span> <span data-ttu-id="bcb12-201">El constructor `Entity` (que es como un método de instancia) inicializa la nueva instancia con el siguiente número de serie disponible.</span><span class="sxs-lookup"><span data-stu-id="bcb12-201">The `Entity` constructor (which is like an instance method) initializes the new instance with the next available serial number.</span></span> <span data-ttu-id="bcb12-202">Como el constructor es un miembro de instancia, se le permite acceder al campo de instancia `_serialNo` y al campo estático `s_nextSerialNo`.</span><span class="sxs-lookup"><span data-stu-id="bcb12-202">Because the constructor is an instance member, it's permitted to access both the `_serialNo` instance field and the `s_nextSerialNo` static field.</span></span>

<span data-ttu-id="bcb12-203">Los métodos estáticos `GetNextSerialNo` y `SetNextSerialNo` pueden acceder al campo estático `s_nextSerialNo`, pero sería un error para ellas acceder directamente al campo de instancia `_serialNo`.</span><span class="sxs-lookup"><span data-stu-id="bcb12-203">The `GetNextSerialNo` and `SetNextSerialNo` static methods can access the `s_nextSerialNo` static field, but it would be an error for them to directly access the `_serialNo` instance field.</span></span>

<span data-ttu-id="bcb12-204">En el ejemplo siguiente se muestra el uso de la clase `Entity`.</span><span class="sxs-lookup"><span data-stu-id="bcb12-204">The following example shows the use of the `Entity` class.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UsingEntity":::

<span data-ttu-id="bcb12-205">Los métodos estáticos `SetNextSerialNo` y `GetNextSerialNo` se invocan en la clase, mientras que el método de instancia `GetSerialNo` se invoca en instancias de la clase.</span><span class="sxs-lookup"><span data-stu-id="bcb12-205">The `SetNextSerialNo` and `GetNextSerialNo` static methods are invoked on the class whereas the `GetSerialNo` instance method is invoked on instances of the class.</span></span>

### <a name="virtual-override-and-abstract-methods"></a><span data-ttu-id="bcb12-206">Métodos virtual, de reemplazo y abstracto</span><span class="sxs-lookup"><span data-stu-id="bcb12-206">Virtual, override, and abstract methods</span></span>

<span data-ttu-id="bcb12-207">Cuando una declaración de método de instancia incluye un modificador `virtual`, se dice que el método es un *método virtual*.</span><span class="sxs-lookup"><span data-stu-id="bcb12-207">When an instance method declaration includes a `virtual` modifier, the method is said to be a *virtual method*.</span></span> <span data-ttu-id="bcb12-208">Cuando no existe un modificador virtual, se dice que el método es un *método no virtual*.</span><span class="sxs-lookup"><span data-stu-id="bcb12-208">When no virtual modifier is present, the method is said to be a *nonvirtual method*.</span></span>

<span data-ttu-id="bcb12-209">Cuando se invoca un método virtual, el *tipo en tiempo de ejecución* de la instancia para la que tiene lugar esa invocación determina la implementación del método real que se invocará.</span><span class="sxs-lookup"><span data-stu-id="bcb12-209">When a virtual method is invoked, the *run-time type* of the instance for which that invocation takes place determines the actual method implementation to invoke.</span></span> <span data-ttu-id="bcb12-210">En una invocación de método no virtual, el *tipo en tiempo de compilación* de la instancia es el factor determinante.</span><span class="sxs-lookup"><span data-stu-id="bcb12-210">In a nonvirtual method invocation, the *compile-time type* of the instance is the determining factor.</span></span>

<span data-ttu-id="bcb12-211">Un método virtual puede ser *reemplazado* en una clase derivada.</span><span class="sxs-lookup"><span data-stu-id="bcb12-211">A virtual method can be *overridden* in a derived class.</span></span> <span data-ttu-id="bcb12-212">Cuando una declaración de método de instancia incluye un modificador "override", el método reemplaza un método virtual heredado con la misma signatura.</span><span class="sxs-lookup"><span data-stu-id="bcb12-212">When an instance method declaration includes an override modifier, the method overrides an inherited virtual method with the same signature.</span></span> <span data-ttu-id="bcb12-213">Una declaración de método virtual presenta un nuevo método.</span><span class="sxs-lookup"><span data-stu-id="bcb12-213">A virtual method declaration introduces a new method.</span></span> <span data-ttu-id="bcb12-214">Una declaración de método de reemplazo especializa un método virtual heredado existente proporcionando una nueva implementación de ese método.</span><span class="sxs-lookup"><span data-stu-id="bcb12-214">An override method declaration specializes an existing inherited virtual method by providing a new implementation of that method.</span></span>

<span data-ttu-id="bcb12-215">Un *método abstracto* es un método virtual sin implementación.</span><span class="sxs-lookup"><span data-stu-id="bcb12-215">An *abstract method* is a virtual method with no implementation.</span></span> <span data-ttu-id="bcb12-216">Un método abstracto se declara con el modificador `abstract` y solo se permite en una clase abstracta.</span><span class="sxs-lookup"><span data-stu-id="bcb12-216">An abstract method is declared with the `abstract` modifier and is permitted only in an abstract class.</span></span> <span data-ttu-id="bcb12-217">Un método abstracto debe reemplazarse en todas las clases derivadas no abstractas.</span><span class="sxs-lookup"><span data-stu-id="bcb12-217">An abstract method must be overridden in every non-abstract derived class.</span></span>

<span data-ttu-id="bcb12-218">En el ejemplo siguiente se declara una clase abstracta, `Expression`, que representa un nodo de árbol de expresión y tres clases derivadas, `Constant`, `VariableReference` y `Operation`, que implementan nodos de árbol de expresión para constantes, referencias a variables y operaciones aritméticas.</span><span class="sxs-lookup"><span data-stu-id="bcb12-218">The following example declares an abstract class, `Expression`, which represents an expression tree node, and three derived classes, `Constant`, `VariableReference`, and `Operation`, which implement expression tree nodes for constants, variable references, and arithmetic operations.</span></span> <span data-ttu-id="bcb12-219">Este ejemplo es similar a los tipos de árbol de expresión, pero no está relacionada con ellos.</span><span class="sxs-lookup"><span data-stu-id="bcb12-219">(This example is similar to, but not related to the expression tree types).</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="WorkingWithExpressions":::

<span data-ttu-id="bcb12-220">Las cuatro clases anteriores se pueden usar para modelar expresiones aritméticas.</span><span class="sxs-lookup"><span data-stu-id="bcb12-220">The previous four classes can be used to model arithmetic expressions.</span></span> <span data-ttu-id="bcb12-221">Por ejemplo, usando instancias de estas clases, la expresión `x + 3` se puede representar de la manera siguiente.</span><span class="sxs-lookup"><span data-stu-id="bcb12-221">For example, using instances of these classes, the expression `x + 3` can be represented as follows.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UseExpressions":::

<span data-ttu-id="bcb12-222">El método `Evaluate` de una instancia `Expression` se invoca para evaluar la expresión determinada y generar un valor `double`.</span><span class="sxs-lookup"><span data-stu-id="bcb12-222">The `Evaluate` method of an `Expression` instance is invoked to evaluate the given expression and produce a `double` value.</span></span> <span data-ttu-id="bcb12-223">El método toma un argumento `Dictionary` que contiene nombres de variables (como claves de las entradas) y valores (como valores de las entradas).</span><span class="sxs-lookup"><span data-stu-id="bcb12-223">The method takes a `Dictionary` argument that contains variable names (as keys of the entries) and values (as values of the entries).</span></span> <span data-ttu-id="bcb12-224">Como `Evaluate` es un método abstracto, las clases no abstractas que derivan de `Expression` deben invalidar `Evaluate`.</span><span class="sxs-lookup"><span data-stu-id="bcb12-224">Because `Evaluate` is an abstract method, non-abstract classes derived from `Expression` must override `Evaluate`.</span></span>

<span data-ttu-id="bcb12-225">Una implementación de `Constant` de `Evaluate` simplemente devuelve la constante almacenada.</span><span class="sxs-lookup"><span data-stu-id="bcb12-225">A `Constant`'s implementation of `Evaluate` simply returns the stored constant.</span></span> <span data-ttu-id="bcb12-226">Una implementación de `VariableReference` busca el nombre de variable en el diccionario y devuelve el valor resultante.</span><span class="sxs-lookup"><span data-stu-id="bcb12-226">A `VariableReference`'s implementation looks up the variable name in the dictionary and returns the resulting value.</span></span> <span data-ttu-id="bcb12-227">Una implementación de `Operation` evalúa primero los operandos izquierdo y derecho (mediante la invocación recursiva de sus métodos `Evaluate`) y luego realiza la operación aritmética correspondiente.</span><span class="sxs-lookup"><span data-stu-id="bcb12-227">An `Operation`'s implementation first evaluates the left and right operands (by recursively invoking their `Evaluate` methods) and then performs the given arithmetic operation.</span></span>

<span data-ttu-id="bcb12-228">El siguiente programa usa las clases `Expression` para evaluar la expresión `x * (y + 2)` para los distintos valores de `x` y `y`.</span><span class="sxs-lookup"><span data-stu-id="bcb12-228">The following program uses the `Expression` classes to evaluate the expression `x * (y + 2)` for different values of `x` and `y`.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UsingExpressions":::

### <a name="method-overloading"></a><span data-ttu-id="bcb12-229">Sobrecarga de métodos</span><span class="sxs-lookup"><span data-stu-id="bcb12-229">Method overloading</span></span>

<span data-ttu-id="bcb12-230">La *sobrecarga* de métodos permite que varios métodos de la misma clase tengan el mismo nombre mientras tengan signaturas únicas.</span><span class="sxs-lookup"><span data-stu-id="bcb12-230">Method *overloading* permits multiple methods in the same class to have the same name as long as they have unique signatures.</span></span> <span data-ttu-id="bcb12-231">Al compilar una invocación de un método sobrecargado, el compilador usa la *resolución de sobrecarga* para determinar el método concreto que de invocará.</span><span class="sxs-lookup"><span data-stu-id="bcb12-231">When compiling an invocation of an overloaded method, the compiler uses *overload resolution* to determine the specific method to invoke.</span></span> <span data-ttu-id="bcb12-232">La resolución de sobrecarga busca el método que mejor coincida con los argumentos.</span><span class="sxs-lookup"><span data-stu-id="bcb12-232">Overload resolution finds the one method that best matches the arguments.</span></span> <span data-ttu-id="bcb12-233">Si no se puede encontrar la mejor coincidencia, se genera un error.</span><span class="sxs-lookup"><span data-stu-id="bcb12-233">If no single best match can be found, an error is reported.</span></span> <span data-ttu-id="bcb12-234">En el ejemplo siguiente se muestra la resolución de sobrecarga en vigor.</span><span class="sxs-lookup"><span data-stu-id="bcb12-234">The following example shows overload resolution in effect.</span></span> <span data-ttu-id="bcb12-235">El comentario para cada invocación del método `UsageExample` muestra qué método se invoca.</span><span class="sxs-lookup"><span data-stu-id="bcb12-235">The comment for each invocation in the `UsageExample` method shows which method is invoked.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="Overloading":::

<span data-ttu-id="bcb12-236">Tal como se muestra en el ejemplo, un método determinado siempre se puede seleccionar mediante la conversión explícita de los argumentos en los tipos de parámetros exactos o los argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="bcb12-236">As shown by the example, a particular method can always be selected by explicitly casting the arguments to the exact parameter types and type arguments.</span></span>

## <a name="other-function-members"></a><span data-ttu-id="bcb12-237">Otros miembros de función</span><span class="sxs-lookup"><span data-stu-id="bcb12-237">Other function members</span></span>

<span data-ttu-id="bcb12-238">Los miembros que contienen código ejecutable se conocen colectivamente como *miembros de función* de una clase.</span><span class="sxs-lookup"><span data-stu-id="bcb12-238">Members that contain executable code are collectively known as the *function members* of a class.</span></span> <span data-ttu-id="bcb12-239">En la sección anterior se describen los métodos, que son los tipos principales de los miembros de función.</span><span class="sxs-lookup"><span data-stu-id="bcb12-239">The preceding section describes methods, which are the primary types of function members.</span></span> <span data-ttu-id="bcb12-240">En esta sección se describen los otros tipos de miembros de función admitidos por C#: constructores, propiedades, indexadores, eventos, operadores y finalizadores.</span><span class="sxs-lookup"><span data-stu-id="bcb12-240">This section describes the other kinds of function members supported by C#: constructors, properties, indexers, events, operators, and finalizers.</span></span>

<span data-ttu-id="bcb12-241">En el ejemplo siguiente se muestra una clase genérica llamada `MyList<T>`, que implementa una lista creciente de objetos.</span><span class="sxs-lookup"><span data-stu-id="bcb12-241">The following example shows a generic class called `MyList<T>`, which implements a growable list of objects.</span></span> <span data-ttu-id="bcb12-242">La clase contiene varios ejemplos de los tipos más comunes de miembros de función.</span><span class="sxs-lookup"><span data-stu-id="bcb12-242">The class contains several examples of the most common kinds of function members.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ListExample":::

### <a name="constructors"></a><span data-ttu-id="bcb12-243">Constructores</span><span class="sxs-lookup"><span data-stu-id="bcb12-243">Constructors</span></span>

<span data-ttu-id="bcb12-244">C# admite constructores de instancia y estáticos.</span><span class="sxs-lookup"><span data-stu-id="bcb12-244">C# supports both instance and static constructors.</span></span> <span data-ttu-id="bcb12-245">Un *constructor de instancia* es un miembro que implementa las acciones necesarias para inicializar una instancia de una clase.</span><span class="sxs-lookup"><span data-stu-id="bcb12-245">An *instance constructor* is a member that implements the actions required to initialize an instance of a class.</span></span> <span data-ttu-id="bcb12-246">Un *constructor estático* es un miembro que implementa las acciones necesarias para inicializar una clase en sí misma cuando se carga por primera vez.</span><span class="sxs-lookup"><span data-stu-id="bcb12-246">A *static constructor* is a member that implements the actions required to initialize a class itself when it's first loaded.</span></span>

<span data-ttu-id="bcb12-247">Un constructor se declara como un método sin ningún tipo de valor devuelto y el mismo nombre que la clase contenedora.</span><span class="sxs-lookup"><span data-stu-id="bcb12-247">A constructor is declared like a method with no return type and the same name as the containing class.</span></span> <span data-ttu-id="bcb12-248">Si una declaración de constructor incluye un modificador `static`, declara un constructor estático.</span><span class="sxs-lookup"><span data-stu-id="bcb12-248">If a constructor declaration includes a `static` modifier, it declares a static constructor.</span></span> <span data-ttu-id="bcb12-249">De lo contrario, declara un constructor de instancia.</span><span class="sxs-lookup"><span data-stu-id="bcb12-249">Otherwise, it declares an instance constructor.</span></span>

<span data-ttu-id="bcb12-250">Los constructores de instancia pueden sobrecargarse y tener parámetros opcionales.</span><span class="sxs-lookup"><span data-stu-id="bcb12-250">Instance constructors can be overloaded and can have optional parameters.</span></span> <span data-ttu-id="bcb12-251">Por ejemplo, la clase `MyList<T>` declara un constructor de instancia con único parámetro `int` opcional.</span><span class="sxs-lookup"><span data-stu-id="bcb12-251">For example, the `MyList<T>` class declares one instance constructor with a single optional `int` parameter.</span></span> <span data-ttu-id="bcb12-252">Los constructores de instancia se invocan mediante el operador `new`.</span><span class="sxs-lookup"><span data-stu-id="bcb12-252">Instance constructors are invoked using the `new` operator.</span></span> <span data-ttu-id="bcb12-253">Las siguientes instrucciones asignan dos instancias `MyList<string>` mediante el constructor de la clase `MyList` con y sin el argumento opcional.</span><span class="sxs-lookup"><span data-stu-id="bcb12-253">The following statements allocate two `MyList<string>` instances using the constructor of the `MyList` class with and without the optional argument.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="CreateLists":::

<span data-ttu-id="bcb12-254">A diferencia de otros miembros, los constructores de instancias no se heredan.</span><span class="sxs-lookup"><span data-stu-id="bcb12-254">Unlike other members, instance constructors aren't inherited.</span></span> <span data-ttu-id="bcb12-255">Una clase no tiene constructores de instancia que no sean los que se declaren realmente en la misma.</span><span class="sxs-lookup"><span data-stu-id="bcb12-255">A class has no instance constructors other than those constructors actually declared in the class.</span></span> <span data-ttu-id="bcb12-256">Si no se proporciona ningún constructor de instancia para una clase, se proporciona automáticamente uno vacío sin ningún parámetro.</span><span class="sxs-lookup"><span data-stu-id="bcb12-256">If no instance constructor is supplied for a class, then an empty one with no parameters is automatically provided.</span></span>

### <a name="properties"></a><span data-ttu-id="bcb12-257">Propiedades</span><span class="sxs-lookup"><span data-stu-id="bcb12-257">Properties</span></span>

<span data-ttu-id="bcb12-258">Las *propiedades* son una extensión natural de los campos.</span><span class="sxs-lookup"><span data-stu-id="bcb12-258">*Properties* are a natural extension of fields.</span></span> <span data-ttu-id="bcb12-259">Ambos son miembros con nombre con tipos asociados y la sintaxis para acceder a los campos y las propiedades es la misma.</span><span class="sxs-lookup"><span data-stu-id="bcb12-259">Both are named members with associated types, and the syntax for accessing fields and properties is the same.</span></span> <span data-ttu-id="bcb12-260">Pero a diferencia de los campos, las propiedades no denotan ubicaciones de almacenamiento.</span><span class="sxs-lookup"><span data-stu-id="bcb12-260">However, unlike fields, properties don't denote storage locations.</span></span> <span data-ttu-id="bcb12-261">Las propiedades tienen *descriptores de acceso* que especifican las instrucciones ejecutadas cuando se leen o escriben sus valores.</span><span class="sxs-lookup"><span data-stu-id="bcb12-261">Instead, properties have *accessors* that specify the statements executed when their values are read or written.</span></span>

<span data-ttu-id="bcb12-262">Una propiedad se declara como un campo, salvo que la declaración finaliza con un descriptor de acceso get o un descriptor de acceso set escrito entre los delimitadores `{` y `}` en lugar de finalizar en un punto y coma.</span><span class="sxs-lookup"><span data-stu-id="bcb12-262">A property is declared like a field, except that the declaration ends with a get accessor or a set accessor written between the delimiters `{` and `}` instead of ending in a semicolon.</span></span> <span data-ttu-id="bcb12-263">Una propiedad que tiene un descriptor de acceso get y un descriptor de acceso set es una *propiedad de lectura y escritura*, una propiedad que tiene solo un descriptor de acceso get es una *propiedad de solo lectura* y una propiedad que tiene solo un descriptor de acceso set es una *propiedad de solo escritura*.</span><span class="sxs-lookup"><span data-stu-id="bcb12-263">A property that has both a get accessor and a set accessor is a *read-write property*, a property that has only a get accessor is a *read-only property*, and a property that has only a set accessor is a *write-only property*.</span></span>

<span data-ttu-id="bcb12-264">Un descriptor de acceso get corresponde a un método sin parámetros con un valor devuelto del tipo de propiedad.</span><span class="sxs-lookup"><span data-stu-id="bcb12-264">A get accessor corresponds to a parameterless method with a return value of the property type.</span></span> <span data-ttu-id="bcb12-265">Un descriptor de acceso set corresponde a un método con un solo parámetro denominado value y ningún tipo de valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="bcb12-265">A set accessor corresponds to a method with a single parameter named value and no return type.</span></span> <span data-ttu-id="bcb12-266">El descriptor de acceso get calcula el valor de la propiedad.</span><span class="sxs-lookup"><span data-stu-id="bcb12-266">The get accessor computes the value of the property.</span></span> <span data-ttu-id="bcb12-267">El descriptor de acceso set proporciona un nuevo valor para la propiedad.</span><span class="sxs-lookup"><span data-stu-id="bcb12-267">The set accessor provides a new value for the property.</span></span> <span data-ttu-id="bcb12-268">Cuando la propiedad es el destino de una asignación, o el operando de `++` o `--`, se invoca al descriptor de acceso set.</span><span class="sxs-lookup"><span data-stu-id="bcb12-268">When the property is the target of an assignment, or the operand of `++` or `--`, the set accessor is invoked.</span></span> <span data-ttu-id="bcb12-269">En otros casos en los que se hace referencia a la propiedad, se invoca al descriptor de acceso get.</span><span class="sxs-lookup"><span data-stu-id="bcb12-269">In other cases where the property is referenced, the get accessor is invoked.</span></span>

<span data-ttu-id="bcb12-270">La clase `MyList<T>` declara dos propiedades, `Count` y `Capacity`, que son de solo lectura y de lectura y escritura, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="bcb12-270">The `MyList<T>` class declares two properties, `Count` and `Capacity`, which are read-only and read-write, respectively.</span></span> <span data-ttu-id="bcb12-271">El código siguiente es un ejemplo de uso de estas propiedades:</span><span class="sxs-lookup"><span data-stu-id="bcb12-271">The following code is an example of use of these properties:</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="AccessProperties":::

<span data-ttu-id="bcb12-272">De forma similar a los campos y métodos, C# admite propiedades de instancia y propiedades estáticas.</span><span class="sxs-lookup"><span data-stu-id="bcb12-272">Similar to fields and methods, C# supports both instance properties and static properties.</span></span> <span data-ttu-id="bcb12-273">Las propiedades estáticas se declaran con el modificador "static", y las propiedades de instancia se declaran sin él.</span><span class="sxs-lookup"><span data-stu-id="bcb12-273">Static properties are declared with the static modifier, and instance properties are declared without it.</span></span>

<span data-ttu-id="bcb12-274">Los descriptores de acceso de una propiedad pueden ser virtuales.</span><span class="sxs-lookup"><span data-stu-id="bcb12-274">The accessor(s) of a property can be virtual.</span></span> <span data-ttu-id="bcb12-275">Cuando una declaración de propiedad incluye un modificador `virtual`, `abstract` o `override`, se aplica a los descriptores de acceso de la propiedad.</span><span class="sxs-lookup"><span data-stu-id="bcb12-275">When a property declaration includes a `virtual`, `abstract`, or `override` modifier, it applies to the accessor(s) of the property.</span></span>

### <a name="indexers"></a><span data-ttu-id="bcb12-276">Indexadores</span><span class="sxs-lookup"><span data-stu-id="bcb12-276">Indexers</span></span>

<span data-ttu-id="bcb12-277">Un *indexador* es un miembro que permite indexar de la misma manera que una matriz.</span><span class="sxs-lookup"><span data-stu-id="bcb12-277">An *indexer* is a member that enables objects to be indexed in the same way as an array.</span></span> <span data-ttu-id="bcb12-278">Un indexador se declara como una propiedad, excepto por el hecho que el nombre del miembro es `this`, seguido por una lista de parámetros que se escriben entre los delimitadores `[` y `]`.</span><span class="sxs-lookup"><span data-stu-id="bcb12-278">An indexer is declared like a property except that the name of the member is `this` followed by a parameter list written between the delimiters `[` and `]`.</span></span> <span data-ttu-id="bcb12-279">Los parámetros están disponibles en los descriptores de acceso del indexador.</span><span class="sxs-lookup"><span data-stu-id="bcb12-279">The parameters are available in the accessor(s) of the indexer.</span></span> <span data-ttu-id="bcb12-280">De forma similar a las propiedades, los indexadores pueden ser lectura y escritura, de solo lectura y de solo escritura, y los descriptores de acceso de un indexador pueden ser virtuales.</span><span class="sxs-lookup"><span data-stu-id="bcb12-280">Similar to properties, indexers can be read-write, read-only, and write-only, and the accessor(s) of an indexer can be virtual.</span></span>

<span data-ttu-id="bcb12-281">La clase `MyList<T>` declara un único indexador de lectura y escritura que toma un parámetro `int`.</span><span class="sxs-lookup"><span data-stu-id="bcb12-281">The `MyList<T>` class declares a single read-write indexer that takes an `int` parameter.</span></span> <span data-ttu-id="bcb12-282">El indexador permite indexar instancias de `MyList<T>` con valores `int`.</span><span class="sxs-lookup"><span data-stu-id="bcb12-282">The indexer makes it possible to index `MyList<T>` instances with `int` values.</span></span> <span data-ttu-id="bcb12-283">Por ejemplo:</span><span class="sxs-lookup"><span data-stu-id="bcb12-283">For example:</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ListAccess":::

<span data-ttu-id="bcb12-284">Los indizadores se pueden sobrecargar.</span><span class="sxs-lookup"><span data-stu-id="bcb12-284">Indexers can be overloaded.</span></span> <span data-ttu-id="bcb12-285">Una clase puede declarar varios indexadores siempre y cuando el número o los tipos de sus parámetros sean diferentes.</span><span class="sxs-lookup"><span data-stu-id="bcb12-285">A class can declare multiple indexers as long as the number or types of their parameters differ.</span></span>

### <a name="events"></a><span data-ttu-id="bcb12-286">Eventos</span><span class="sxs-lookup"><span data-stu-id="bcb12-286">Events</span></span>

<span data-ttu-id="bcb12-287">Un *evento* es un miembro que permite que una clase u objeto proporcionen notificaciones.</span><span class="sxs-lookup"><span data-stu-id="bcb12-287">An *event* is a member that enables a class or object to provide notifications.</span></span> <span data-ttu-id="bcb12-288">Un evento se declara como un campo, excepto por el hecho de que la declaración incluye una palabra clave `event`, y el tipo debe ser un tipo delegado.</span><span class="sxs-lookup"><span data-stu-id="bcb12-288">An event is declared like a field except that the declaration includes an `event` keyword and the type must be a delegate type.</span></span>

<span data-ttu-id="bcb12-289">Dentro de una clase que declara un miembro de evento, el evento se comporta como un campo de un tipo delegado (siempre que el evento no sea abstracto y no declare descriptores de acceso).</span><span class="sxs-lookup"><span data-stu-id="bcb12-289">Within a class that declares an event member, the event behaves just like a field of a delegate type (provided the event isn't abstract and doesn't declare accessors).</span></span> <span data-ttu-id="bcb12-290">El campo almacena una referencia a un delegado que representa los controladores de eventos que se han agregado al evento.</span><span class="sxs-lookup"><span data-stu-id="bcb12-290">The field stores a reference to a delegate that represents the event handlers that have been added to the event.</span></span> <span data-ttu-id="bcb12-291">Si no existen controladores de eventos, el campo es `null`.</span><span class="sxs-lookup"><span data-stu-id="bcb12-291">If no event handlers are present, the field is `null`.</span></span>

<span data-ttu-id="bcb12-292">La clase `MyList<T>` declara un único miembro de evento llamado `Changed`, lo que indica que se ha agregado un nuevo elemento a la lista.</span><span class="sxs-lookup"><span data-stu-id="bcb12-292">The `MyList<T>` class declares a single event member called `Changed`, which indicates that a new item has been added to the list.</span></span> <span data-ttu-id="bcb12-293">El método virtual `OnChanged` genera el evento cambiado, y comprueba primero si el evento es `null` (lo que significa que no existen controladores).</span><span class="sxs-lookup"><span data-stu-id="bcb12-293">The Changed event is raised by the `OnChanged` virtual method, which first checks whether the event is `null` (meaning that no handlers are present).</span></span> <span data-ttu-id="bcb12-294">La noción de generar un evento es equivalente exactamente a invocar el delegado representado por el evento.</span><span class="sxs-lookup"><span data-stu-id="bcb12-294">The notion of raising an event is precisely equivalent to invoking the delegate represented by the event.</span></span> <span data-ttu-id="bcb12-295">No hay ninguna construcción especial de lenguaje para generar eventos.</span><span class="sxs-lookup"><span data-stu-id="bcb12-295">There are no special language constructs for raising events.</span></span>

<span data-ttu-id="bcb12-296">Los clientes reaccionan a los eventos mediante *controladores de eventos*.</span><span class="sxs-lookup"><span data-stu-id="bcb12-296">Clients react to events through *event handlers*.</span></span> <span data-ttu-id="bcb12-297">Los controladores de eventos se asocian mediante el operador `+=` y se quitan con el operador `-=`.</span><span class="sxs-lookup"><span data-stu-id="bcb12-297">Event handlers are attached using the `+=` operator and removed using the `-=` operator.</span></span> <span data-ttu-id="bcb12-298">En el ejemplo siguiente se asocia un controlador de eventos con el evento `Changed` de un objeto `MyList<string>`.</span><span class="sxs-lookup"><span data-stu-id="bcb12-298">The following example attaches an event handler to the `Changed` event of a `MyList<string>`.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="RespondToEvents":::

<span data-ttu-id="bcb12-299">Para escenarios avanzados donde se quiere controlar el almacenamiento subyacente de un evento, una declaración de evento puede proporcionar de forma explícita los descriptores de acceso `add` y `remove`, que son similares al descriptor de acceso `set` de una propiedad.</span><span class="sxs-lookup"><span data-stu-id="bcb12-299">For advanced scenarios where control of the underlying storage of an event is desired, an event declaration can explicitly provide `add` and `remove` accessors, which are similar to the `set` accessor of a property.</span></span>

### <a name="operators"></a><span data-ttu-id="bcb12-300">Operadores</span><span class="sxs-lookup"><span data-stu-id="bcb12-300">Operators</span></span>

<span data-ttu-id="bcb12-301">Un *operador* es un miembro que define el significado de aplicar un operador de expresión determinado a las instancias de una clase.</span><span class="sxs-lookup"><span data-stu-id="bcb12-301">An *operator* is a member that defines the meaning of applying a particular expression operator to instances of a class.</span></span> <span data-ttu-id="bcb12-302">Se pueden definir tres tipos de operadores: operadores unarios, operadores binarios y operadores de conversión.</span><span class="sxs-lookup"><span data-stu-id="bcb12-302">Three kinds of operators can be defined: unary operators, binary operators, and conversion operators.</span></span> <span data-ttu-id="bcb12-303">Todos los operadores se deben declarar como `public` y `static`.</span><span class="sxs-lookup"><span data-stu-id="bcb12-303">All operators must be declared as `public` and `static`.</span></span>

<span data-ttu-id="bcb12-304">La clase `MyList<T>` declara dos operadores, `operator ==` y `operator !=`.</span><span class="sxs-lookup"><span data-stu-id="bcb12-304">The `MyList<T>` class declares two operators, `operator ==` and `operator !=`.</span></span> <span data-ttu-id="bcb12-305">Los operadores de reemplazo proporcionan un nuevo significado a expresiones que aplican esos operadores a instancias `MyList`.</span><span class="sxs-lookup"><span data-stu-id="bcb12-305">These overridden operators give new meaning to expressions that apply those operators to `MyList` instances.</span></span> <span data-ttu-id="bcb12-306">En concreto, los operadores definen la igualdad de dos instancias `MyList<T>` como la comparación de cada uno de los objetos contenidos con sus métodos `Equals`.</span><span class="sxs-lookup"><span data-stu-id="bcb12-306">Specifically, the operators define equality of two `MyList<T>` instances as comparing each of the contained objects using their `Equals` methods.</span></span> <span data-ttu-id="bcb12-307">En el ejemplo siguiente se usa el operador `==` para comparar dos instancias `MyList<int>`.</span><span class="sxs-lookup"><span data-stu-id="bcb12-307">The following example uses the `==` operator to compare two `MyList<int>` instances.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ListAddition":::

<span data-ttu-id="bcb12-308">El primer objeto `Console.WriteLine` genera `True` porque las dos listas contienen el mismo número de objetos con los mismos valores en el mismo orden.</span><span class="sxs-lookup"><span data-stu-id="bcb12-308">The first `Console.WriteLine` outputs `True` because the two lists contain the same number of objects with the same values in the same order.</span></span> <span data-ttu-id="bcb12-309">Si `MyList<T>` no hubiera definido `operator ==`, el primer objeto `Console.WriteLine` habría generado `False` porque `a` y `b` hacen referencia a diferentes instancias de `MyList<int>`.</span><span class="sxs-lookup"><span data-stu-id="bcb12-309">Had `MyList<T>` not defined `operator ==`, the first `Console.WriteLine` would have output `False` because `a` and `b` reference different `MyList<int>` instances.</span></span>

### <a name="finalizers"></a><span data-ttu-id="bcb12-310">Finalizadores</span><span class="sxs-lookup"><span data-stu-id="bcb12-310">Finalizers</span></span>

<span data-ttu-id="bcb12-311">Un *finalizador* es un miembro que implementa las acciones necesarias para finalizar una instancia de una clase.</span><span class="sxs-lookup"><span data-stu-id="bcb12-311">A *finalizer* is a member that implements the actions required to finalize an instance of a class.</span></span> <span data-ttu-id="bcb12-312">Normalmente, se necesita un finalizador para liberar los recursos no administrados.</span><span class="sxs-lookup"><span data-stu-id="bcb12-312">Typically, a finalizer is needed to release unmanaged resources.</span></span> <span data-ttu-id="bcb12-313">Los finalizadores no pueden tener parámetros, no pueden tener modificadores de accesibilidad y no se pueden invocar de forma explícita.</span><span class="sxs-lookup"><span data-stu-id="bcb12-313">Finalizers can't have parameters, they can't have accessibility modifiers, and they can't be invoked explicitly.</span></span> <span data-ttu-id="bcb12-314">El finalizador de una instancia se invoca automáticamente durante la recolección de elementos no utilizados.</span><span class="sxs-lookup"><span data-stu-id="bcb12-314">The finalizer for an instance is invoked automatically during garbage collection.</span></span> <span data-ttu-id="bcb12-315">Para obtener más información, consulte el artículo sobre los [finalizadores](../programming-guide/classes-and-structs/destructors.md).</span><span class="sxs-lookup"><span data-stu-id="bcb12-315">For more details, see the article on [finalizers](../programming-guide/classes-and-structs/destructors.md).</span></span>

<span data-ttu-id="bcb12-316">El recolector de elementos no utilizados tiene una amplia libertad para decidir cuándo debe recolectar objetos y ejecutar finalizadores.</span><span class="sxs-lookup"><span data-stu-id="bcb12-316">The garbage collector is allowed wide latitude in deciding when to collect objects and run finalizers.</span></span> <span data-ttu-id="bcb12-317">En concreto, los intervalos de las invocaciones de finalizador no son deterministas y los finalizadores se pueden ejecutar en cualquier subproceso.</span><span class="sxs-lookup"><span data-stu-id="bcb12-317">Specifically, the timing of finalizer invocations isn't deterministic, and finalizers may be executed on any thread.</span></span> <span data-ttu-id="bcb12-318">Por estas y otras razones, las clases deben implementar finalizadores solo cuando no haya otras soluciones que sean factibles.</span><span class="sxs-lookup"><span data-stu-id="bcb12-318">For these and other reasons, classes should implement finalizers only when no other solutions are feasible.</span></span>

<span data-ttu-id="bcb12-319">La instrucción `using` proporciona un mejor enfoque para la destrucción de objetos.</span><span class="sxs-lookup"><span data-stu-id="bcb12-319">The `using` statement provides a better approach to object destruction.</span></span>

## <a name="expressions"></a><span data-ttu-id="bcb12-320">Expresiones</span><span class="sxs-lookup"><span data-stu-id="bcb12-320">Expressions</span></span>

<span data-ttu-id="bcb12-321">Las *expresiones* se construyen con *operandos* y *operadores*.</span><span class="sxs-lookup"><span data-stu-id="bcb12-321">*Expressions* are constructed from *operands* and *operators*.</span></span> <span data-ttu-id="bcb12-322">Los operadores de una expresión indican qué operaciones se aplican a los operandos.</span><span class="sxs-lookup"><span data-stu-id="bcb12-322">The operators of an expression indicate which operations to apply to the operands.</span></span> <span data-ttu-id="bcb12-323">Ejemplos de operadores incluyen `+`, `-`, `*`, `/` y `new`.</span><span class="sxs-lookup"><span data-stu-id="bcb12-323">Examples of operators include `+`, `-`, `*`, `/`, and `new`.</span></span> <span data-ttu-id="bcb12-324">Algunos ejemplos de operandos son literales, campos, variables locales y expresiones.</span><span class="sxs-lookup"><span data-stu-id="bcb12-324">Examples of operands include literals, fields, local variables, and expressions.</span></span>

<span data-ttu-id="bcb12-325">Cuando una expresión contiene varios operadores, su *precedencia* controla el orden en el que se evalúan los operadores individuales.</span><span class="sxs-lookup"><span data-stu-id="bcb12-325">When an expression contains multiple operators, the *precedence* of the operators controls the order in which the individual operators are evaluated.</span></span> <span data-ttu-id="bcb12-326">Por ejemplo, la expresión `x + y * z` se evalúa como `x + (y * z)` porque el operador `*` tiene mayor precedencia que el operador `+`.</span><span class="sxs-lookup"><span data-stu-id="bcb12-326">For example, the expression `x + y * z` is evaluated as `x + (y * z)` because the `*` operator has higher precedence than the `+` operator.</span></span>

<span data-ttu-id="bcb12-327">Cuando un operando se encuentra entre dos operadores con la misma precedencia, la *asociatividad* de los operadores controla el orden en que se realizan las operaciones:</span><span class="sxs-lookup"><span data-stu-id="bcb12-327">When an operand occurs between two operators with the same precedence, the *associativity* of the operators controls the order in which the operations are performed:</span></span>

* <span data-ttu-id="bcb12-328">Excepto los operadores de asignación y los operadores de fusión de NULL, todos los operadores binarios son *asociativos a la izquierda*, lo que significa que las operaciones se realizan de izquierda a derecha.</span><span class="sxs-lookup"><span data-stu-id="bcb12-328">Except for the assignment and null-coalescing operators, all binary operators are *left-associative*, meaning that operations are performed from left to right.</span></span> <span data-ttu-id="bcb12-329">Por ejemplo, `x + y + z` se evalúa como `(x + y) + z`.</span><span class="sxs-lookup"><span data-stu-id="bcb12-329">For example, `x + y + z` is evaluated as `(x + y) + z`.</span></span>
* <span data-ttu-id="bcb12-330">Los operadores de asignación, los operadores de fusión de NULL `??` y `??=` y el operador condicional `?:` son *asociativos a la derecha*, lo que significa que las operaciones se realizan de derecha a izquierda.</span><span class="sxs-lookup"><span data-stu-id="bcb12-330">The assignment operators, the null-coalescing `??` and `??=` operators, and the conditional operator `?:` are *right-associative*, meaning that operations are performed from right to left.</span></span> <span data-ttu-id="bcb12-331">Por ejemplo, `x = y = z` se evalúa como `x = (y = z)`.</span><span class="sxs-lookup"><span data-stu-id="bcb12-331">For example, `x = y = z` is evaluated as `x = (y = z)`.</span></span>

<span data-ttu-id="bcb12-332">La precedencia y la asociatividad pueden controlarse mediante paréntesis.</span><span class="sxs-lookup"><span data-stu-id="bcb12-332">Precedence and associativity can be controlled using parentheses.</span></span> <span data-ttu-id="bcb12-333">Por ejemplo, `x + y * z` primero multiplica `y` por `z` y luego suma el resultado a `x`, pero `(x + y) * z` primero suma `x` y `y` y luego multiplica el resultado por `z`.</span><span class="sxs-lookup"><span data-stu-id="bcb12-333">For example, `x + y * z` first multiplies `y` by `z` and then adds the result to `x`, but `(x + y) * z` first adds `x` and `y` and then multiplies the result by `z`.</span></span>

<span data-ttu-id="bcb12-334">La mayoría de los operadores se pueden [*sobrecargar*](../language-reference/operators/operator-overloading.md).</span><span class="sxs-lookup"><span data-stu-id="bcb12-334">Most operators can be [*overloaded*](../language-reference/operators/operator-overloading.md).</span></span> <span data-ttu-id="bcb12-335">La sobrecarga de operador permite la especificación de implementaciones de operadores definidas por el usuario para operaciones donde uno o ambos operandos son de un tipo de struct o una clase definidos por el usuario.</span><span class="sxs-lookup"><span data-stu-id="bcb12-335">Operator overloading permits user-defined operator implementations to be specified for operations where one or both of the operands are of a user-defined class or struct type.</span></span>

<span data-ttu-id="bcb12-336">C# ofrece una serie de operadores para realizar operaciones [aritméticas](../language-reference/operators/arithmetic-operators.md), [lógicas](../language-reference/operators/boolean-logical-operators.md), [de desplazamiento y bit a bit](../language-reference/operators/bitwise-and-shift-operators.md), además de comparaciones de [igualdad](../language-reference/operators/equality-operators.md) y de [orden](../language-reference/operators/comparison-operators.md).</span><span class="sxs-lookup"><span data-stu-id="bcb12-336">C# provides a number of operators to perform [arithmetic](../language-reference/operators/arithmetic-operators.md), [logical](../language-reference/operators/boolean-logical-operators.md), [bitwise and shift](../language-reference/operators/bitwise-and-shift-operators.md) operations and [equality](../language-reference/operators/equality-operators.md) and [order](../language-reference/operators/comparison-operators.md) comparisons.</span></span>

<span data-ttu-id="bcb12-337">Para obtener la lista completa de los operadores de C# ordenados por nivel de prioridad, vea [Operadores de C#](../language-reference/operators/index.md).</span><span class="sxs-lookup"><span data-stu-id="bcb12-337">For the complete list of C# operators ordered by precedence level, see [C# operators](../language-reference/operators/index.md).</span></span>

## <a name="statements"></a><span data-ttu-id="bcb12-338">Instrucciones</span><span class="sxs-lookup"><span data-stu-id="bcb12-338">Statements</span></span>

<span data-ttu-id="bcb12-339">Las acciones de un programa se expresan mediante *instrucciones*.</span><span class="sxs-lookup"><span data-stu-id="bcb12-339">The actions of a program are expressed using *statements*.</span></span> <span data-ttu-id="bcb12-340">C# admite varios tipos de instrucciones diferentes, varias de las cuales se definen en términos de instrucciones insertadas.</span><span class="sxs-lookup"><span data-stu-id="bcb12-340">C# supports several different kinds of statements, a number of which are defined in terms of embedded statements.</span></span>

- <span data-ttu-id="bcb12-341">Un *bloque* permite que se escriban varias instrucciones en contextos donde se permite una única instrucción.</span><span class="sxs-lookup"><span data-stu-id="bcb12-341">A *block* permits multiple statements to be written in contexts where a single statement is allowed.</span></span> <span data-ttu-id="bcb12-342">Un bloque se compone de una lista de instrucciones escritas entre los delimitadores `{` y `}`.</span><span class="sxs-lookup"><span data-stu-id="bcb12-342">A block consists of a list of statements written between the delimiters `{` and `}`.</span></span>
- <span data-ttu-id="bcb12-343">Las *instrucciones de declaración* se usan para declarar variables locales y constantes.</span><span class="sxs-lookup"><span data-stu-id="bcb12-343">*Declaration statements* are used to declare local variables and constants.</span></span>
- <span data-ttu-id="bcb12-344">Las *instrucciones de expresión* se usan para evaluar expresiones.</span><span class="sxs-lookup"><span data-stu-id="bcb12-344">*Expression statements* are used to evaluate expressions.</span></span> <span data-ttu-id="bcb12-345">Las expresiones que pueden usarse como instrucciones incluyen invocaciones de método, asignaciones de objetos mediante el operador `new`, asignaciones mediante `=` y los operadores de asignación compuestos, operaciones de incremento y decremento mediante los operadores `++` y `--` y expresiones `await`.</span><span class="sxs-lookup"><span data-stu-id="bcb12-345">Expressions that can be used as statements include method invocations, object allocations using the `new` operator, assignments using `=` and the compound assignment operators, increment and decrement operations using the `++` and `--` operators and `await` expressions.</span></span>
- <span data-ttu-id="bcb12-346">Las *instrucciones de selección* se usan para seleccionar una de varias instrucciones posibles para su ejecución en función del valor de alguna expresión.</span><span class="sxs-lookup"><span data-stu-id="bcb12-346">*Selection statements* are used to select one of a number of possible statements for execution based on the value of some expression.</span></span> <span data-ttu-id="bcb12-347">Este grupo contiene las instrucciones `if` y `switch`.</span><span class="sxs-lookup"><span data-stu-id="bcb12-347">This group contains the `if` and `switch` statements.</span></span>
- <span data-ttu-id="bcb12-348">Las *instrucciones de iteración* se usan para ejecutar una instrucción insertada de forma repetida.</span><span class="sxs-lookup"><span data-stu-id="bcb12-348">*Iteration statements* are used to execute repeatedly an embedded statement.</span></span> <span data-ttu-id="bcb12-349">Este grupo contiene las instrucciones `while`, `do`, `for` y `foreach`.</span><span class="sxs-lookup"><span data-stu-id="bcb12-349">This group contains the `while`, `do`, `for`, and `foreach` statements.</span></span>
- <span data-ttu-id="bcb12-350">Las *instrucciones de salto* se usan para transferir el control.</span><span class="sxs-lookup"><span data-stu-id="bcb12-350">*Jump statements* are used to transfer control.</span></span> <span data-ttu-id="bcb12-351">Este grupo contiene las instrucciones `break`, `continue`, `goto`, `throw`, `return` y `yield`.</span><span class="sxs-lookup"><span data-stu-id="bcb12-351">This group contains the `break`, `continue`, `goto`, `throw`, `return`, and `yield` statements.</span></span>
- <span data-ttu-id="bcb12-352">La instrucción `try`... `catch` se usa para detectar excepciones que se producen durante la ejecución de un bloque, y la instrucción `try`... `finally` se usa para especificar el código de finalización que siempre se ejecuta, tanto si se ha producido una excepción como si no.</span><span class="sxs-lookup"><span data-stu-id="bcb12-352">The `try`...`catch` statement is used to catch exceptions that occur during execution of a block, and the `try`...`finally` statement is used to specify finalization code that is always executed, whether an exception occurred or not.</span></span>
- <span data-ttu-id="bcb12-353">Las instrucciones `checked` y `unchecked` sirven para controlar el contexto de comprobación de desbordamiento para conversiones y operaciones aritméticas de tipo integral.</span><span class="sxs-lookup"><span data-stu-id="bcb12-353">The `checked` and `unchecked` statements are used to control the overflow-checking context for integral-type arithmetic operations and conversions.</span></span>
- <span data-ttu-id="bcb12-354">La instrucción `lock` se usa para obtener el bloqueo de exclusión mutua para un objeto determinado, ejecutar una instrucción y, luego, liberar el bloqueo.</span><span class="sxs-lookup"><span data-stu-id="bcb12-354">The `lock` statement is used to obtain the mutual-exclusion lock for a given object, execute a statement, and then release the lock.</span></span>
- <span data-ttu-id="bcb12-355">La instrucción `using` se usa para obtener un recurso, ejecutar una instrucción y, luego, eliminar dicho recurso.</span><span class="sxs-lookup"><span data-stu-id="bcb12-355">The `using` statement is used to obtain a resource, execute a statement, and then dispose of that resource.</span></span>

<span data-ttu-id="bcb12-356">A continuación se enumeran los tipos de instrucciones que se pueden usar:</span><span class="sxs-lookup"><span data-stu-id="bcb12-356">The following lists the kinds of statements that can be used:</span></span>

* <span data-ttu-id="bcb12-357">Declaración de variable local</span><span class="sxs-lookup"><span data-stu-id="bcb12-357">Local variable declaration.</span></span>
* <span data-ttu-id="bcb12-358">Declaración de constante local</span><span class="sxs-lookup"><span data-stu-id="bcb12-358">Local constant declaration.</span></span>
* <span data-ttu-id="bcb12-359">Instrucción de expresión</span><span class="sxs-lookup"><span data-stu-id="bcb12-359">Expression statement.</span></span>
* <span data-ttu-id="bcb12-360">Instrucción `if`</span><span class="sxs-lookup"><span data-stu-id="bcb12-360">`if` statement.</span></span>
* <span data-ttu-id="bcb12-361">Instrucción `switch`</span><span class="sxs-lookup"><span data-stu-id="bcb12-361">`switch` statement.</span></span>
* <span data-ttu-id="bcb12-362">Instrucción `while`</span><span class="sxs-lookup"><span data-stu-id="bcb12-362">`while` statement.</span></span>
* <span data-ttu-id="bcb12-363">Instrucción `do`</span><span class="sxs-lookup"><span data-stu-id="bcb12-363">`do` statement.</span></span>
* <span data-ttu-id="bcb12-364">Instrucción `for`</span><span class="sxs-lookup"><span data-stu-id="bcb12-364">`for` statement.</span></span>
* <span data-ttu-id="bcb12-365">Instrucción `foreach`</span><span class="sxs-lookup"><span data-stu-id="bcb12-365">`foreach` statement.</span></span>
* <span data-ttu-id="bcb12-366">Instrucción `break`</span><span class="sxs-lookup"><span data-stu-id="bcb12-366">`break` statement.</span></span>
* <span data-ttu-id="bcb12-367">Instrucción `continue`</span><span class="sxs-lookup"><span data-stu-id="bcb12-367">`continue` statement.</span></span>
* <span data-ttu-id="bcb12-368">Instrucción `goto`</span><span class="sxs-lookup"><span data-stu-id="bcb12-368">`goto` statement.</span></span>
* <span data-ttu-id="bcb12-369">Instrucción `return`</span><span class="sxs-lookup"><span data-stu-id="bcb12-369">`return` statement.</span></span>
* <span data-ttu-id="bcb12-370">Instrucción `yield`</span><span class="sxs-lookup"><span data-stu-id="bcb12-370">`yield` statement.</span></span>
* <span data-ttu-id="bcb12-371">Instrucciones `throw` y `try`</span><span class="sxs-lookup"><span data-stu-id="bcb12-371">`throw` statements and `try` statements.</span></span>
* <span data-ttu-id="bcb12-372">Instrucciones `checked` y `unchecked`</span><span class="sxs-lookup"><span data-stu-id="bcb12-372">`checked` and `unchecked` statements.</span></span>
* <span data-ttu-id="bcb12-373">Instrucción `lock`</span><span class="sxs-lookup"><span data-stu-id="bcb12-373">`lock` statement.</span></span>
* <span data-ttu-id="bcb12-374">Instrucción `using`</span><span class="sxs-lookup"><span data-stu-id="bcb12-374">`using` statement.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="bcb12-375">[Anterior](types.md)
>[Siguiente](features.md)</span><span class="sxs-lookup"><span data-stu-id="bcb12-375">[Previous](types.md)
[Next](features.md)</span></span>
