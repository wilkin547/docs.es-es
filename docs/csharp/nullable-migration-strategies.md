---
title: Actualización del código base para usar tipos de referencia que aceptan valores NULL
description: Elija la mejor estrategia de actualización de su código base para usar tipos de referencia que aceptan valores NULL.
ms.technology: csharp-null-safety
ms.date: 07/31/2019
ms.openlocfilehash: ab0970247c7e3f3c20d7fdb40ef035c4ba1d8b01
ms.sourcegitcommit: 30e9e11dfd90112b8eec6406186ba3533f21eba1
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 11/21/2020
ms.locfileid: "97866827"
---
# <a name="update-libraries-to-use-nullable-reference-types-and-communicate-nullable-rules-to-callers"></a><span data-ttu-id="2ab87-103">Actualización de las bibliotecas para usar tipos de referencia que aceptan valores NULL y comunicar reglas que aceptan valores NULL a los llamadores</span><span class="sxs-lookup"><span data-stu-id="2ab87-103">Update libraries to use nullable reference types and communicate nullable rules to callers</span></span>

<span data-ttu-id="2ab87-104">La adición de [tipos de referencia que aceptan valores NULL](nullable-references.md) significa que puede declarar si se permite o espera un valor de `null` para cada variable.</span><span class="sxs-lookup"><span data-stu-id="2ab87-104">The addition of [nullable reference types](nullable-references.md) means you can declare whether or not a `null` value is allowed or expected for every variable.</span></span> <span data-ttu-id="2ab87-105">Además, puede aplicar varios atributos, `AllowNull`, `DisallowNull`, `MaybeNull`, `NotNull`, `NotNullWhen`, `MaybeNullWhen` y `NotNullIfNotNull`, para describir por completo los estados NULL de los valores devueltos y de argumento.</span><span class="sxs-lookup"><span data-stu-id="2ab87-105">In addition, you can apply a number of attributes: `AllowNull`, `DisallowNull`, `MaybeNull`, `NotNull`, `NotNullWhen`, `MaybeNullWhen`, and `NotNullIfNotNull` to completely describe the null states of argument and return values.</span></span> <span data-ttu-id="2ab87-106">Esto proporciona una gran experiencia de escritura de código.</span><span class="sxs-lookup"><span data-stu-id="2ab87-106">That provides a great experience as you write code.</span></span> <span data-ttu-id="2ab87-107">Por ejemplo, obtiene advertencias si una variable que no acepta valores NULL está establecida en `null`.</span><span class="sxs-lookup"><span data-stu-id="2ab87-107">You get warnings if a non-nullable variable might be set to `null`.</span></span> <span data-ttu-id="2ab87-108">También recibe advertencias si no se comprueban los valores NULL de una variable que acepta valores NULL antes de desreferenciarla.</span><span class="sxs-lookup"><span data-stu-id="2ab87-108">You get warnings if a nullable variable isn't null-checked before you dereference it.</span></span> <span data-ttu-id="2ab87-109">La actualización de las bibliotecas puede llevar un tiempo, pero merece la pena.</span><span class="sxs-lookup"><span data-stu-id="2ab87-109">Updating your libraries can take time, but the payoffs are worth it.</span></span> <span data-ttu-id="2ab87-110">Cuanta más información proporcione al compilador sobre *cuándo* está permitido o prohibido un valor `null`, mejores advertencias obtendrán los usuarios de la API.</span><span class="sxs-lookup"><span data-stu-id="2ab87-110">The more information you provide to the compiler about *when* a `null` value is allowed or prohibited, the better warnings users of your API will get.</span></span> <span data-ttu-id="2ab87-111">Para empezar, se usará un ejemplo conocido.</span><span class="sxs-lookup"><span data-stu-id="2ab87-111">Let's start with a familiar example.</span></span> <span data-ttu-id="2ab87-112">Imagine que la biblioteca tiene la siguiente API para recuperar una cadena de recursos:</span><span class="sxs-lookup"><span data-stu-id="2ab87-112">Imagine your library has the following API to retrieve a resource string:</span></span>

```csharp
bool TryGetMessage(string key, out string message)
```

<span data-ttu-id="2ab87-113">En el ejemplo anterior se sigue el conocido patrón de `Try*` en .NET.</span><span class="sxs-lookup"><span data-stu-id="2ab87-113">The preceding example follows the familiar `Try*` pattern in .NET.</span></span> <span data-ttu-id="2ab87-114">Hay dos argumentos de referencia para esta API: los parámetros `key` y `message`.</span><span class="sxs-lookup"><span data-stu-id="2ab87-114">There are two reference arguments for this API: the `key` and the `message` parameter.</span></span> <span data-ttu-id="2ab87-115">Esta API tiene las siguientes reglas relacionadas con la obtención del valor NULL de estos argumentos:</span><span class="sxs-lookup"><span data-stu-id="2ab87-115">This API has the following rules relating to the nullness of these arguments:</span></span>

- <span data-ttu-id="2ab87-116">Los autores de la llamada no deben pasar `null` como argumento para `key`.</span><span class="sxs-lookup"><span data-stu-id="2ab87-116">Callers shouldn't pass `null` as the argument for `key`.</span></span>
- <span data-ttu-id="2ab87-117">Los autores de la llamada pueden pasar una variable cuyo valor sea `null` como argumento de `message`.</span><span class="sxs-lookup"><span data-stu-id="2ab87-117">Callers can pass a variable whose value is `null` as the argument for `message`.</span></span>
- <span data-ttu-id="2ab87-118">Si el método `TryGetMessage` devuelve `true`, el valor de `message` no es NULL.</span><span class="sxs-lookup"><span data-stu-id="2ab87-118">If the `TryGetMessage` method returns `true`, the value of `message` isn't null.</span></span> <span data-ttu-id="2ab87-119">Si el valor devuelto es `false,`, el valor de `message` (y su estado NULL) es NULL.</span><span class="sxs-lookup"><span data-stu-id="2ab87-119">If the return value is `false,` the value of `message` (and its null state) is null.</span></span>

<span data-ttu-id="2ab87-120">La regla para `key` se puede expresar completamente mediante el tipo de variable; `key` debe ser un tipo de referencia que no acepte valores NULL.</span><span class="sxs-lookup"><span data-stu-id="2ab87-120">The rule for `key` can be completely expressed by the variable type: `key` should be a non-nullable reference type.</span></span> <span data-ttu-id="2ab87-121">El parámetro `message` es más complejo.</span><span class="sxs-lookup"><span data-stu-id="2ab87-121">The `message` parameter is more complex.</span></span> <span data-ttu-id="2ab87-122">Permite `null` como argumento, pero garantiza que, si se ejecuta correctamente, el argumento `out` no sea NULL.</span><span class="sxs-lookup"><span data-stu-id="2ab87-122">It allows `null` as the argument, but guarantees that, on success, that `out` argument isn't null.</span></span> <span data-ttu-id="2ab87-123">En estos escenarios, necesita un vocabulario más completo para describir las expectativas.</span><span class="sxs-lookup"><span data-stu-id="2ab87-123">For these scenarios, you need a richer vocabulary to describe the expectations.</span></span>

<span data-ttu-id="2ab87-124">La actualización de la biblioteca para las referencias que aceptan valores NULL requiere más trabajo que agregar `?` en algunas de las variables y los nombres de tipo.</span><span class="sxs-lookup"><span data-stu-id="2ab87-124">Updating your library for nullable references requires more than sprinkling `?` on some of the variables and type names.</span></span> <span data-ttu-id="2ab87-125">En el ejemplo anterior se muestra que debe examinar las API y tener en cuenta las expectativas para cada argumento de entrada.</span><span class="sxs-lookup"><span data-stu-id="2ab87-125">The preceding example shows that you need to examine your APIs and consider your expectations for each input argument.</span></span> <span data-ttu-id="2ab87-126">Considere las garantías para el valor devuelto y cualquier argumento `out` o `ref` en la devolución del método.</span><span class="sxs-lookup"><span data-stu-id="2ab87-126">Consider the guarantees for the return value, and any `out` or `ref` arguments upon the method's return.</span></span> <span data-ttu-id="2ab87-127">Después, comunique dichas reglas al compilador y este proporcionará advertencias cuando los llamadores no las cumplan.</span><span class="sxs-lookup"><span data-stu-id="2ab87-127">Then communicate those rules to the compiler, and the compiler will provide warnings when callers don't abide by those rules.</span></span>

<span data-ttu-id="2ab87-128">Este trabajo lleva tiempo.</span><span class="sxs-lookup"><span data-stu-id="2ab87-128">This work takes time.</span></span> <span data-ttu-id="2ab87-129">Empecemos con las estrategias para hacer que su biblioteca o aplicación sea compatible con valores NULL, a la vez que equilibra otros requisitos.</span><span class="sxs-lookup"><span data-stu-id="2ab87-129">Let's start with strategies to make your library or application nullable-aware, while balancing other requirements.</span></span> <span data-ttu-id="2ab87-130">Verá cómo equilibrar el desarrollo continuo habilitando tipos de referencia que admiten valores NULL.</span><span class="sxs-lookup"><span data-stu-id="2ab87-130">You'll see how to balance ongoing development enabling nullable reference types.</span></span> <span data-ttu-id="2ab87-131">Conocerá los desafíos de las definiciones de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="2ab87-131">You'll learn challenges for generic type definitions.</span></span> <span data-ttu-id="2ab87-132">Y aprenderá a aplicar atributos para describir condiciones previas y posteriores en las API individuales.</span><span class="sxs-lookup"><span data-stu-id="2ab87-132">You'll learn to apply attributes to describe pre- and post-conditions on individual APIs.</span></span>

## <a name="choose-a-strategy-for-nullable-reference-types"></a><span data-ttu-id="2ab87-133">Elección de una estrategia para admitir tipos de referencia que aceptan valores NULL</span><span class="sxs-lookup"><span data-stu-id="2ab87-133">Choose a strategy for nullable reference types</span></span>

<span data-ttu-id="2ab87-134">Primero debe elegir si los tipos de referencia que aceptan valores NULL deben estar habilitados o desactivados de forma predeterminada.</span><span class="sxs-lookup"><span data-stu-id="2ab87-134">The first choice is whether nullable reference types should be on or off by default.</span></span> <span data-ttu-id="2ab87-135">Tiene dos estrategias:</span><span class="sxs-lookup"><span data-stu-id="2ab87-135">You have two strategies:</span></span>

- <span data-ttu-id="2ab87-136">Habilitar los tipos de referencia que aceptan valores NULL para todo el proyecto y deshabilitarlos en el código que no está listo.</span><span class="sxs-lookup"><span data-stu-id="2ab87-136">Enable nullable reference types for the entire project, and disable it in code that's not ready.</span></span>
- <span data-ttu-id="2ab87-137">Habilitar solo los tipos de referencia que aceptan valores NULL para el código que se ha anotado para estos tipos de referencia.</span><span class="sxs-lookup"><span data-stu-id="2ab87-137">Only enable nullable reference types for code that's been annotated for nullable reference types.</span></span>

<span data-ttu-id="2ab87-138">La primera estrategia funciona mejor si va a agregar otras características a la biblioteca a medida que la actualiza para admitir tipos de referencia que aceptan valores NULL.</span><span class="sxs-lookup"><span data-stu-id="2ab87-138">The first strategy works best when you're adding other features to the library as you update it for nullable reference types.</span></span> <span data-ttu-id="2ab87-139">Todo el desarrollo nuevo es compatible con valores NULL.</span><span class="sxs-lookup"><span data-stu-id="2ab87-139">All new development is nullable aware.</span></span> <span data-ttu-id="2ab87-140">Al actualizar el código existente, se habilitan los tipos de referencia que aceptan valores NULL en esas clases.</span><span class="sxs-lookup"><span data-stu-id="2ab87-140">As you update existing code, you enable nullable reference types in those classes.</span></span>

<span data-ttu-id="2ab87-141">Para seguir esta primera estrategia, realice los pasos siguientes:</span><span class="sxs-lookup"><span data-stu-id="2ab87-141">Following this first strategy, you do the following steps:</span></span>

1. <span data-ttu-id="2ab87-142">Habilite los tipos de referencia que aceptan valores NULL para todo el proyecto agregando el elemento `<Nullable>enable</Nullable>` a los archivos *csproj*.</span><span class="sxs-lookup"><span data-stu-id="2ab87-142">Enable nullable reference types for the entire project by adding the `<Nullable>enable</Nullable>` element to your *csproj* files.</span></span>
1. <span data-ttu-id="2ab87-143">Agregue la pragma `#nullable disable` a cada archivo de código fuente del proyecto.</span><span class="sxs-lookup"><span data-stu-id="2ab87-143">Add the `#nullable disable` pragma to every source file in your project.</span></span>
1. <span data-ttu-id="2ab87-144">A la hora de trabajar en cada archivo, quite la pragma y resuelva las advertencias.</span><span class="sxs-lookup"><span data-stu-id="2ab87-144">As you work on each file, remove the pragma and address any warnings.</span></span>

<span data-ttu-id="2ab87-145">Esta primera estrategia requiere más trabajo previo para agregar la pragma a cada archivo.</span><span class="sxs-lookup"><span data-stu-id="2ab87-145">This first strategy has more up-front work to add the pragma to every file.</span></span> <span data-ttu-id="2ab87-146">La ventaja es que todos los archivos de código nuevos que se agreguen al proyecto estarán habilitados para aceptar valores NULL.</span><span class="sxs-lookup"><span data-stu-id="2ab87-146">The advantage is that every new code file added to the project will be nullable enabled.</span></span> <span data-ttu-id="2ab87-147">Cualquier trabajo nuevo admitirá valores NULL; solo se debe actualizar el código existente.</span><span class="sxs-lookup"><span data-stu-id="2ab87-147">Any new work will be nullable aware; only existing code must be updated.</span></span>

<span data-ttu-id="2ab87-148">La segunda estrategia funciona mejor si la biblioteca es estable y el objetivo principal del desarrollo es adoptar tipos de referencia que aceptan valores NULL.</span><span class="sxs-lookup"><span data-stu-id="2ab87-148">The second strategy works better if the library is stable, and the main focus of the development is to adopt nullable reference types.</span></span> <span data-ttu-id="2ab87-149">Los tipos de referencia que aceptan valores NULL se habilitan al anotar las API.</span><span class="sxs-lookup"><span data-stu-id="2ab87-149">You turn on nullable reference types as you annotate APIs.</span></span> <span data-ttu-id="2ab87-150">Cuando haya terminado, habilite los tipos de referencia que aceptan valores NULL para todo el proyecto.</span><span class="sxs-lookup"><span data-stu-id="2ab87-150">When you've finished, you enable nullable reference types for the entire project.</span></span>

<span data-ttu-id="2ab87-151">Para seguir esta segunda estrategia, realice los pasos siguientes:</span><span class="sxs-lookup"><span data-stu-id="2ab87-151">Following this second strategy you do the following steps:</span></span>

1. <span data-ttu-id="2ab87-152">Agregue la pragma `#nullable enable` al archivo que quiere que admita valores NULL.</span><span class="sxs-lookup"><span data-stu-id="2ab87-152">Add the `#nullable enable` pragma to the file you want to make nullable aware.</span></span>
1. <span data-ttu-id="2ab87-153">Resuelva las advertencias.</span><span class="sxs-lookup"><span data-stu-id="2ab87-153">Address any warnings.</span></span>
1. <span data-ttu-id="2ab87-154">Continúe con estos dos primeros pasos hasta que la biblioteca entera sea compatible con valores NULL.</span><span class="sxs-lookup"><span data-stu-id="2ab87-154">Continue these first two steps until you've made the entire library nullable aware.</span></span>
1. <span data-ttu-id="2ab87-155">Agregue el elemento `<Nullable>enable</Nullable>` a los archivos *csproj* para habilitar los tipos que aceptan valores NULL para todo el proyecto.</span><span class="sxs-lookup"><span data-stu-id="2ab87-155">Enable nullable types for the entire project by adding the `<Nullable>enable</Nullable>` element to your *csproj* files.</span></span>
1. <span data-ttu-id="2ab87-156">Quite las pragmas `#nullable enable`, puesto que ya no son necesarias.</span><span class="sxs-lookup"><span data-stu-id="2ab87-156">Remove the `#nullable enable` pragmas, as they're no longer needed.</span></span>

<span data-ttu-id="2ab87-157">Esta segunda estrategia requiere menos trabajo previo.</span><span class="sxs-lookup"><span data-stu-id="2ab87-157">This second strategy has less work up-front.</span></span> <span data-ttu-id="2ab87-158">La desventaja es que la primera tarea al crear un nuevo archivo consiste en agregar la pragma y hacer que admita valores NULL.</span><span class="sxs-lookup"><span data-stu-id="2ab87-158">The tradeoff is that the first task when you create a new file is to add the pragma and make it nullable aware.</span></span> <span data-ttu-id="2ab87-159">Si alguno de los desarrolladores de su equipo se olvida de hacerlo, ese nuevo código se sumará al trabajo pendiente para hacer que todo el código admita valores NULL.</span><span class="sxs-lookup"><span data-stu-id="2ab87-159">If any developers on your team forget, that new code is now in the backlog of work to make all code nullable aware.</span></span>

<span data-ttu-id="2ab87-160">La elección de una estrategia u otra dependerá de la cantidad de desarrollo activo que haya en el proyecto.</span><span class="sxs-lookup"><span data-stu-id="2ab87-160">Which of these strategies you pick depends on how much active development is taking place in your project.</span></span> <span data-ttu-id="2ab87-161">Cuanto más desarrollado esté y más estable sea su proyecto, más adecuada será la segunda estrategia.</span><span class="sxs-lookup"><span data-stu-id="2ab87-161">The more mature and stable your project, the better the second strategy.</span></span> <span data-ttu-id="2ab87-162">Cuantas más características se estén desarrollando, más apropiada será la primera estrategia.</span><span class="sxs-lookup"><span data-stu-id="2ab87-162">The more features being developed, the better the first strategy.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="2ab87-163">El contexto global que admite un valor NULL no se aplica a los archivos de código generado.</span><span class="sxs-lookup"><span data-stu-id="2ab87-163">The global nullable context does not apply for generated code files.</span></span> <span data-ttu-id="2ab87-164">En cualquier estrategia, el contexto que admite un valor NULL está *deshabilitado* para cualquier archivo de código fuente marcado como generado.</span><span class="sxs-lookup"><span data-stu-id="2ab87-164">Under either strategy, the nullable context is *disabled* for any source file marked as generated.</span></span> <span data-ttu-id="2ab87-165">Esto significa que las API de los archivos generados no se anotan.</span><span class="sxs-lookup"><span data-stu-id="2ab87-165">This means any APIs in generated files are not annotated.</span></span> <span data-ttu-id="2ab87-166">Hay cuatro maneras de marcar un archivo como generado:</span><span class="sxs-lookup"><span data-stu-id="2ab87-166">There are four ways a file is marked as generated:</span></span>
>
> 1. <span data-ttu-id="2ab87-167">En el archivo .editorconfig, especifique `generated_code = true` en una sección que se aplique a ese archivo.</span><span class="sxs-lookup"><span data-stu-id="2ab87-167">In the .editorconfig, specify `generated_code = true` in a section that applies to that file.</span></span>
> 1. <span data-ttu-id="2ab87-168">Coloque `<auto-generated>` o `<auto-generated/>` en un comentario en la parte superior del archivo.</span><span class="sxs-lookup"><span data-stu-id="2ab87-168">Put `<auto-generated>` or `<auto-generated/>` in a comment at the top of the file.</span></span> <span data-ttu-id="2ab87-169">Puede estar en cualquier línea de ese comentario, pero el bloque de comentario debe ser el primer elemento del archivo.</span><span class="sxs-lookup"><span data-stu-id="2ab87-169">It can be on any line in that comment, but the comment block must be the first element in the file.</span></span>
> 1. <span data-ttu-id="2ab87-170">Inicie el nombre de archivo con *TemporaryGeneratedFile_*</span><span class="sxs-lookup"><span data-stu-id="2ab87-170">Start the file name with *TemporaryGeneratedFile_*</span></span>
> 1. <span data-ttu-id="2ab87-171">Finalice el nombre de archivo con *.designer.cs*, *.generated.cs*, *.g.cs* o *.g.i.cs*.</span><span class="sxs-lookup"><span data-stu-id="2ab87-171">End the file name with *.designer.cs*, *.generated.cs*, *.g.cs*, or *.g.i.cs*.</span></span>
>
> <span data-ttu-id="2ab87-172">Los generadores pueden optar por usar la directiva de preprocesador [`#nullable`](language-reference/preprocessor-directives/preprocessor-nullable.md).</span><span class="sxs-lookup"><span data-stu-id="2ab87-172">Generators can opt-in using the [`#nullable`](language-reference/preprocessor-directives/preprocessor-nullable.md) preprocessor directive.</span></span>

## <a name="should-nullable-warnings-introduce-breaking-changes"></a><span data-ttu-id="2ab87-173">¿Deberían introducir cambios importantes las advertencias que aceptan valores NULL?</span><span class="sxs-lookup"><span data-stu-id="2ab87-173">Should nullable warnings introduce breaking changes?</span></span>

<span data-ttu-id="2ab87-174">Antes de habilitar los tipos de referencia que aceptan valores NULL, se considera que las variables *desconocen los valores NULL*.</span><span class="sxs-lookup"><span data-stu-id="2ab87-174">Before you enable nullable reference types, variables are considered *nullable oblivious*.</span></span> <span data-ttu-id="2ab87-175">Una vez habilitados los tipos de referencia que aceptan valores NULL, todas esas variables *no aceptan valores NULL*.</span><span class="sxs-lookup"><span data-stu-id="2ab87-175">Once you enable nullable reference types, all those variables are *non-nullable*.</span></span> <span data-ttu-id="2ab87-176">El compilador generará advertencias si dichas variables se inicializan en valores que sean NULL.</span><span class="sxs-lookup"><span data-stu-id="2ab87-176">The compiler will issue warnings if those variables aren't initialized to non-null values.</span></span>

<span data-ttu-id="2ab87-177">Otra posible causa de que se generen advertencias es la devolución de valores cuando los valores no se han inicializado.</span><span class="sxs-lookup"><span data-stu-id="2ab87-177">Another likely source of warnings is return values when the value hasn't been initialized.</span></span>

<span data-ttu-id="2ab87-178">El primer paso para abordar las advertencias del compilador es usar anotaciones `?` en los tipos de parámetros y de valores devueltos para indicar si los argumentos o los valores devueltos pueden ser NULL.</span><span class="sxs-lookup"><span data-stu-id="2ab87-178">The first step in addressing the compiler warnings is to use `?` annotations on parameter and return types to indicate when arguments or return values may be null.</span></span> <span data-ttu-id="2ab87-179">Cuando las variables de referencia no deben ser NULL, la declaración original es correcta.</span><span class="sxs-lookup"><span data-stu-id="2ab87-179">When reference variables must not be null, the original declaration is correct.</span></span> <span data-ttu-id="2ab87-180">A medida que realiza esta tarea, su objetivo no es solo resolver las advertencias;</span><span class="sxs-lookup"><span data-stu-id="2ab87-180">As you do this task, your goal isn't just to fix warnings.</span></span> <span data-ttu-id="2ab87-181">el objetivo más importante es hacer que el compilador entienda su intención de admitir posibles valores NULL.</span><span class="sxs-lookup"><span data-stu-id="2ab87-181">The more important goal is to make the compiler understand your intent for potential null values.</span></span> <span data-ttu-id="2ab87-182">Cuando examine las advertencias, llegará a la siguiente decisión importante que debe tomar para la biblioteca.</span><span class="sxs-lookup"><span data-stu-id="2ab87-182">As you examine the warnings, you reach your next major decision for your library.</span></span> <span data-ttu-id="2ab87-183">¿Quiere modificar las firmas de API para comunicar con mayor claridad su intención de diseño?</span><span class="sxs-lookup"><span data-stu-id="2ab87-183">Do you want to consider modifying API signatures to more clearly communicate your design intent?</span></span> <span data-ttu-id="2ab87-184">Una mejor firma de API para el método `TryGetMessage` examinado anteriormente podría ser la siguiente:</span><span class="sxs-lookup"><span data-stu-id="2ab87-184">A better API signature for the `TryGetMessage` method examined earlier could be:</span></span>

```csharp
string? TryGetMessage(string key);
```

<span data-ttu-id="2ab87-185">El valor devuelto indica si la acción se ha realizado correctamente o no y contiene el valor si se ha encontrado.</span><span class="sxs-lookup"><span data-stu-id="2ab87-185">The return value indicates success or failure, and carries the value if the value was found.</span></span> <span data-ttu-id="2ab87-186">En muchos casos, cambiar las firmas de API puede mejorar el modo en que comunican los valores NULL.</span><span class="sxs-lookup"><span data-stu-id="2ab87-186">In many cases, changing API signatures can improve how they communicate null values.</span></span>

<span data-ttu-id="2ab87-187">Pero en el caso de las bibliotecas públicas o con grandes bases de usuarios, puede que prefiera no introducir ningún cambio en las firmas de API.</span><span class="sxs-lookup"><span data-stu-id="2ab87-187">However, for public libraries, or libraries with large user bases, you may prefer not introducing any API signature changes.</span></span> <span data-ttu-id="2ab87-188">En esos casos, y en otros patrones comunes, puede aplicar atributos para definir con más claridad cuándo puede ser `null` un argumento o un valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="2ab87-188">For those cases, and other common patterns, you can apply attributes to more clearly define when an argument or return value may be `null`.</span></span> <span data-ttu-id="2ab87-189">Tanto si cambia la superficie de la API como si no, probablemente verá que las anotaciones de tipo por sí solas no son suficientes para describir valores `null` para argumentos o valores devueltos.</span><span class="sxs-lookup"><span data-stu-id="2ab87-189">Whether or not you consider changing the surface of your API, you'll likely find that type annotations alone aren't sufficient for describing `null` values for arguments or return values.</span></span> <span data-ttu-id="2ab87-190">En esos casos, puede aplicar atributos para describir una API de forma más clara.</span><span class="sxs-lookup"><span data-stu-id="2ab87-190">In those instances, you can apply attributes to more clearly describe an API.</span></span>

## <a name="attributes-extend-type-annotations"></a><span data-ttu-id="2ab87-191">Atributos para complementar a las anotaciones de tipo</span><span class="sxs-lookup"><span data-stu-id="2ab87-191">Attributes extend type annotations</span></span>

<span data-ttu-id="2ab87-192">Se han agregado varios atributos para expresar información adicional sobre el estado NULL de las variables.</span><span class="sxs-lookup"><span data-stu-id="2ab87-192">Several attributes have been added to express additional information about the null state of variables.</span></span> <span data-ttu-id="2ab87-193">Todo el código escrito antes de que C# 8 introdujera los tipos de referencia que aceptan valores NULL *desconocía los valores NULL*.</span><span class="sxs-lookup"><span data-stu-id="2ab87-193">All code you wrote before C# 8 introduced nullable reference types was *null oblivious*.</span></span> <span data-ttu-id="2ab87-194">Esto significa que es posible que cualquier variable de tipo de referencia sea NULL, pero no se necesitan comprobaciones de valores NULL.</span><span class="sxs-lookup"><span data-stu-id="2ab87-194">That means any reference type variable may be null, but null checks aren't required.</span></span> <span data-ttu-id="2ab87-195">Una vez que el código *admite valores NULL*, esas reglas cambian.</span><span class="sxs-lookup"><span data-stu-id="2ab87-195">Once your code is *nullable aware*, those rules change.</span></span> <span data-ttu-id="2ab87-196">Los tipos de referencia nunca deben ser del valor `null`, y los que admitan valores NULL se deben comprobar con `null` antes de desreferenciarlos.</span><span class="sxs-lookup"><span data-stu-id="2ab87-196">Reference types should never be the `null` value, and nullable reference types must be checked against `null` before being dereferenced.</span></span>

<span data-ttu-id="2ab87-197">Es probable que las reglas de las API sean más complicadas, como se ha visto en el escenario de la API `TryGetValue`.</span><span class="sxs-lookup"><span data-stu-id="2ab87-197">The rules for your APIs are likely more complicated, as you saw with the `TryGetValue` API scenario.</span></span> <span data-ttu-id="2ab87-198">Muchas de las API tienen reglas más complejas para cuando las variables pueden ser `null` o no.</span><span class="sxs-lookup"><span data-stu-id="2ab87-198">Many of your APIs have more complex rules for when variables can or can't be `null`.</span></span> <span data-ttu-id="2ab87-199">En estos casos, usará atributos para expresar dichas reglas.</span><span class="sxs-lookup"><span data-stu-id="2ab87-199">In these cases, you'll use attributes to express those rules.</span></span> <span data-ttu-id="2ab87-200">Los atributos que describen la semántica de la API se encuentran en el artículo sobre los [atributos que afectan al análisis del estado NULL](./language-reference/attributes/nullable-analysis.md).</span><span class="sxs-lookup"><span data-stu-id="2ab87-200">The attributes that describe the semantics of your API are found in the article on [Attributes that impact nullable analysis](./language-reference/attributes/nullable-analysis.md).</span></span>

## <a name="generic-definitions-and-nullability"></a><span data-ttu-id="2ab87-201">Definiciones genéricas y nulabilidad</span><span class="sxs-lookup"><span data-stu-id="2ab87-201">Generic definitions and nullability</span></span>

<span data-ttu-id="2ab87-202">Para comunicar correctamente el estado NULL de los tipos y métodos genéricos es necesario prestar especial atención.</span><span class="sxs-lookup"><span data-stu-id="2ab87-202">Correctly communicating the null state of generic types and generic methods requires special care.</span></span> <span data-ttu-id="2ab87-203">Esta atención extra se debe a que un tipo de valor que acepta valores NULL y un tipo de referencia que acepta valores NULL son muy diferentes.</span><span class="sxs-lookup"><span data-stu-id="2ab87-203">The extra care stems from the fact that a nullable value type and a nullable reference type are fundamentally different.</span></span> <span data-ttu-id="2ab87-204">Un `int?` es un sinónimo de `Nullable<int>`, mientras que `string?` es lo mismo que `string` con un atributo agregado por el compilador.</span><span class="sxs-lookup"><span data-stu-id="2ab87-204">An `int?` is a synonym for `Nullable<int>`, whereas `string?` is `string` with an attribute added by the compiler.</span></span> <span data-ttu-id="2ab87-205">El resultado es que el compilador no puede generar código correcto para `T?` sin saber si `T` es un objeto `class` o `struct`.</span><span class="sxs-lookup"><span data-stu-id="2ab87-205">The result is that the compiler can't generate correct code for `T?` without knowing if `T` is a `class` or a `struct`.</span></span>

<span data-ttu-id="2ab87-206">Esto no significa que no pueda usar un tipo que acepta valores NULL (ya sea un tipo de valor o un tipo de referencia) como argumento de tipo para un tipo genérico cerrado.</span><span class="sxs-lookup"><span data-stu-id="2ab87-206">This fact doesn't mean you can't use a nullable type (either value type or reference type) as the type argument for a closed generic type.</span></span> <span data-ttu-id="2ab87-207">Tanto `List<string?>` como `List<int?>` son instancias válidas de `List<T>`.</span><span class="sxs-lookup"><span data-stu-id="2ab87-207">Both `List<string?>` and `List<int?>` are valid instantiations of `List<T>`.</span></span>

<span data-ttu-id="2ab87-208">Lo que significa es que no se puede usar `T?` en una declaración de método o clase genérica sin restricciones.</span><span class="sxs-lookup"><span data-stu-id="2ab87-208">What it does mean is that you can't use `T?` in a generic class or method declaration without constraints.</span></span> <span data-ttu-id="2ab87-209">Por ejemplo, <xref:System.Linq.Enumerable.FirstOrDefault%60%601(System.Collections.Generic.IEnumerable%7B%60%600%7D)?displayProperty=nameWithType> no se cambiará para devolver `T?`.</span><span class="sxs-lookup"><span data-stu-id="2ab87-209">For example, <xref:System.Linq.Enumerable.FirstOrDefault%60%601(System.Collections.Generic.IEnumerable%7B%60%600%7D)?displayProperty=nameWithType> won't be changed to return `T?`.</span></span> <span data-ttu-id="2ab87-210">Puede superar esta limitación agregando las restricciones `struct` o `class`.</span><span class="sxs-lookup"><span data-stu-id="2ab87-210">You can overcome this limitation by adding either the `struct` or `class` constraint.</span></span> <span data-ttu-id="2ab87-211">Con cualquiera de estas restricciones, el compilador sabe cómo generar código para `T` y `T?`.</span><span class="sxs-lookup"><span data-stu-id="2ab87-211">With either of those constraints, the compiler knows how to generate code for both `T` and `T?`.</span></span>

<span data-ttu-id="2ab87-212">Es posible que quiera restringir los tipos usados para un argumento de tipo genérico a tipos que no aceptan valores NULL.</span><span class="sxs-lookup"><span data-stu-id="2ab87-212">You may want to restrict the types used for a generic type argument to be non-nullable types.</span></span> <span data-ttu-id="2ab87-213">Para ello, agregue la restricción `notnull` a ese argumento de tipo.</span><span class="sxs-lookup"><span data-stu-id="2ab87-213">You can do that by adding the `notnull` constraint on that type argument.</span></span> <span data-ttu-id="2ab87-214">Cuando se aplica esta restricción, el argumento de tipo no debe ser un tipo que acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="2ab87-214">When that constraint is applied, the type argument must not be a nullable type.</span></span>

## <a name="late-initialized-properties-data-transfer-objects-and-nullability"></a><span data-ttu-id="2ab87-215">Propiedades inicializadas con posterioridad, objetos de transferencia de datos y nulabilidad</span><span class="sxs-lookup"><span data-stu-id="2ab87-215">Late-initialized properties, Data Transfer Objects, and nullability</span></span>

<span data-ttu-id="2ab87-216">Para indicar la nulabilidad de las propiedades inicializadas con posterioridad, es decir, establecidas después de la construcción, puede que deba prestar especial atención para asegurarse de que la clase sigue expresando correctamente la intención de diseño original.</span><span class="sxs-lookup"><span data-stu-id="2ab87-216">Indicating the nullability of properties that are late-initialized, meaning set after construction, may require special consideration to ensure that your class continues to correctly express the original design intent.</span></span>

<span data-ttu-id="2ab87-217">A menudo se crean instancias de tipos que contienen propiedades inicializadas con posterioridad, como objetos de transferencia de datos (DTO), mediante una biblioteca externa, por ejemplo, un ORM (asignador relacional de objetos) de base de datos, un deserializador u otro componente que rellena automáticamente las propiedades a partir de otro origen.</span><span class="sxs-lookup"><span data-stu-id="2ab87-217">Types that contain late-initialized properties, such as Data Transfer Objects (DTOs), are often instantiated by an external library, like a database ORM (Object Relational Mapper), a deserializer, or some other component that automatically populates properties from another source.</span></span>

<span data-ttu-id="2ab87-218">Fíjese en la siguiente clase de DTO, la cual representa a un estudiante, antes de habilitar los tipos de referencia que aceptan valores NULL:</span><span class="sxs-lookup"><span data-stu-id="2ab87-218">Consider the following DTO class, prior to enabling nullable reference types, that represents a student:</span></span>

```csharp
class Student
{
    [Required]
    public string FirstName { get; set; }

    [Required]
    public string LastName { get; set; }

    public string VehicleRegistration { get; set; }
}
```

<span data-ttu-id="2ab87-219">La intención de diseño (indicada en este caso por el atributo `Required`) sugiere que, en este sistema, las propiedades `FirstName` y `LastName` son **obligatorias** y, por tanto, no son NULL.</span><span class="sxs-lookup"><span data-stu-id="2ab87-219">The design intent (indicated in this case by the `Required` attribute) suggests that in this system, the `FirstName` and `LastName` properties are **mandatory**, and therefore not null.</span></span>

<span data-ttu-id="2ab87-220">La propiedad `VehicleRegistration` **no es obligatoria**, por lo que puede ser NULL.</span><span class="sxs-lookup"><span data-stu-id="2ab87-220">The `VehicleRegistration` property is **not mandatory**, so may be null.</span></span>

<span data-ttu-id="2ab87-221">Cuando se habilitan tipos de referencia que aceptan valores NULL, se debe indicar qué propiedades de DTO podrían admitir valores NULL, de acuerdo con la intención original:</span><span class="sxs-lookup"><span data-stu-id="2ab87-221">When you enable nullable reference types, you want to indicate which properties on your DTO may be nullable, consistent with your original intent:</span></span>

```csharp
class Student
{
    [Required]
    public string FirstName { get; set; }

    [Required]
    public string LastName { get; set; }

    public string? VehicleRegistration { get; set; }
}
```

<span data-ttu-id="2ab87-222">Para este DTO, la única propiedad que puede ser NULL es ``VehicleRegistration``.</span><span class="sxs-lookup"><span data-stu-id="2ab87-222">For this DTO, the only property that may be null is ``VehicleRegistration``.</span></span>

<span data-ttu-id="2ab87-223">A pesar de esto, el compilador genera advertencias `CS8618` para `FirstName` y `LastName` para indicar que las propiedades que no aceptan valores NULL no están inicializadas.</span><span class="sxs-lookup"><span data-stu-id="2ab87-223">However, the compiler raises `CS8618` warnings for both `FirstName` and `LastName`, indicating the non-nullable properties are uninitialized.</span></span>

<span data-ttu-id="2ab87-224">Hay tres opciones disponibles para resolver las advertencias del compilador de una manera que mantiene la intención original.</span><span class="sxs-lookup"><span data-stu-id="2ab87-224">There are three options available to you that resolve the compiler warnings in a way that maintains the original intent.</span></span> <span data-ttu-id="2ab87-225">Cualquiera de estas opciones es válida y debe elegir la que mejor se adapte a sus requisitos de diseño y su estilo de codificación.</span><span class="sxs-lookup"><span data-stu-id="2ab87-225">Any of these options are valid; you should choose the one that best suits your coding style and design requirements.</span></span>

### <a name="initialize-in-the-constructor"></a><span data-ttu-id="2ab87-226">Inicializar en el constructor</span><span class="sxs-lookup"><span data-stu-id="2ab87-226">Initialize in the constructor</span></span>

<span data-ttu-id="2ab87-227">La forma ideal de resolver las advertencias de propiedades no inicializadas es inicializar las propiedades en el constructor:</span><span class="sxs-lookup"><span data-stu-id="2ab87-227">The ideal way to resolve the uninitialized warnings is to initialize the properties in the constructor:</span></span>

```csharp
class Student
{
    public Student(string firstName, string lastName)
    {
        FirstName = firstName;
        LastName = lastName;
    }

    [Required]
    public string FirstName { get; set; }

    [Required]
    public string LastName { get; set; }

    public string? VehicleRegistration { get; set; }
}
```

<span data-ttu-id="2ab87-228">Este enfoque únicamente funciona si la biblioteca que se usa para crear instancias de la clase admite el paso de parámetros en el constructor.</span><span class="sxs-lookup"><span data-stu-id="2ab87-228">This approach only works if the library that you use to instantiate the class supports passing parameters in the constructor.</span></span>

<span data-ttu-id="2ab87-229">Una biblioteca puede admitir el paso de *algunas* propiedades en el constructor, pero no todas.</span><span class="sxs-lookup"><span data-stu-id="2ab87-229">A library may support passing *some* properties in the constructor, but not all.</span></span> <span data-ttu-id="2ab87-230">Por ejemplo, EF Core admite el [enlace del constructor](/ef/core/modeling/constructors) para las propiedades de columna normales, pero no para las propiedades de navegación.</span><span class="sxs-lookup"><span data-stu-id="2ab87-230">For example, EF Core supports [constructor binding](/ef/core/modeling/constructors) for normal column properties, but not navigation properties.</span></span>

<span data-ttu-id="2ab87-231">Consulte la documentación de la biblioteca que crea instancias de la clase para comprender en qué medida admite el enlace del constructor.</span><span class="sxs-lookup"><span data-stu-id="2ab87-231">Check the documentation on the library that instantiates your class, to understand the extent to which it supports constructor binding.</span></span>

### <a name="property-with-nullable-backing-field"></a><span data-ttu-id="2ab87-232">Propiedad con campo de respaldo que acepta valores NULL</span><span class="sxs-lookup"><span data-stu-id="2ab87-232">Property with nullable backing field</span></span>

<span data-ttu-id="2ab87-233">Si el enlace del constructor no funcionara en su caso, una manera de solucionar este problema sería tener una propiedad que no acepta valores NULL con un campo de respaldo que acepta valores NULL:</span><span class="sxs-lookup"><span data-stu-id="2ab87-233">If constructor binding won't work for you, one way to deal with this problem is to have a non-nullable property with a nullable backing field:</span></span>

```csharp
private string? _firstName;

[Required]
public string FirstName
{
    set => _firstName = value;
    get => _firstName
           ?? throw new InvalidOperationException("Uninitialized " + nameof(FirstName))
}
```

<span data-ttu-id="2ab87-234">En este escenario, si se accede a la propiedad `FirstName` antes de que se haya inicializado, el código produce una excepción `InvalidOperationException`, porque el contrato de API se ha usado incorrectamente.</span><span class="sxs-lookup"><span data-stu-id="2ab87-234">In this scenario, if the `FirstName` property is accessed before it has been initialized, then the code throws an `InvalidOperationException`, because the API contract has been used incorrectly.</span></span>

<span data-ttu-id="2ab87-235">Tenga en cuenta que algunas bibliotecas pueden tener requisitos especiales a la hora de usar los campos de respaldo.</span><span class="sxs-lookup"><span data-stu-id="2ab87-235">Consider that some libraries may have special considerations when using backing fields.</span></span> <span data-ttu-id="2ab87-236">Por ejemplo, puede ser necesario configurar EF Core para usar los [campos de respaldo](/ef/core/modeling/backing-field) correctamente.</span><span class="sxs-lookup"><span data-stu-id="2ab87-236">For example, EF Core may need to be configured to use [backing fields](/ef/core/modeling/backing-field) correctly.</span></span>

### <a name="initialize-the-property-to-null"></a><span data-ttu-id="2ab87-237">Inicialización de la propiedad con un valor NULL</span><span class="sxs-lookup"><span data-stu-id="2ab87-237">Initialize the property to null</span></span>

<span data-ttu-id="2ab87-238">Como alternativa al uso de un campo de respaldo que acepta valores NULL, o si la biblioteca que crea instancias de la clase no es compatible con ese enfoque, puede inicializar la propiedad como `null` directamente con la ayuda del operador que permite valores NULL (`!`):</span><span class="sxs-lookup"><span data-stu-id="2ab87-238">As a terser alternative to using a nullable backing field, or if the library that instantiates your class isn't compatible with that approach, you can initialize the property to `null` directly, with the help of the null-forgiving operator (`!`):</span></span>

```csharp
[Required]
public string FirstName { get; set; } = null!;

[Required]
public string LastName { get; set; } = null!;

public string? VehicleRegistration { get; set; }
```

<span data-ttu-id="2ab87-239">Nunca observará un valor NULL real en tiempo de ejecución, a menos que se produzca un error de programación al acceder a la propiedad antes de que se haya inicializado correctamente.</span><span class="sxs-lookup"><span data-stu-id="2ab87-239">You'll never observe an actual null value at runtime except as a result of a programming bug, by accessing the property before it has been properly initialized.</span></span>

## <a name="see-also"></a><span data-ttu-id="2ab87-240">Consulte también</span><span class="sxs-lookup"><span data-stu-id="2ab87-240">See also</span></span>

- [<span data-ttu-id="2ab87-241">Migración de un código base existente a referencias que aceptan valores NULL</span><span class="sxs-lookup"><span data-stu-id="2ab87-241">Migrate an existing codebase to nullable references</span></span>](tutorials/upgrade-to-nullable-references.md)
- [<span data-ttu-id="2ab87-242">Uso de tipos de referencia que aceptan valores NULL en EF Core</span><span class="sxs-lookup"><span data-stu-id="2ab87-242">Working with Nullable Reference Types in EF Core</span></span>](/ef/core/miscellaneous/nullable-reference-types)
