---
title: 'Tipos básicos: Guía de C#'
description: Obtenga información sobre los tipos principales (valores numéricos, cadenas y objeto) en todos los programas de C#
ms.date: 10/10/2016
ms.technology: csharp-fundamentals
ms.assetid: 95c686ba-ae4f-440e-8e94-0dbd6e04d11f
ms.openlocfilehash: 1c3cdefe6aba300536386fe4bb66d788814bcd9d
ms.sourcegitcommit: 9c589b25b005b9a7f87327646020eb85c3b6306f
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 03/06/2021
ms.locfileid: "102258187"
---
# <a name="types-variables-and-values"></a><span data-ttu-id="6a50d-103">Tipos, variables y valores</span><span class="sxs-lookup"><span data-stu-id="6a50d-103">Types, variables, and values</span></span>

<span data-ttu-id="6a50d-104">C# es un lenguaje fuertemente tipado.</span><span class="sxs-lookup"><span data-stu-id="6a50d-104">C# is a strongly typed language.</span></span> <span data-ttu-id="6a50d-105">Todas las variables y constantes tienen un tipo, al igual que todas las expresiones que se evalúan como un valor.</span><span class="sxs-lookup"><span data-stu-id="6a50d-105">Every variable and constant has a type, as does every expression that evaluates to a value.</span></span> <span data-ttu-id="6a50d-106">Cada una de las firmas de método especifica un tipo para cada parámetro de entrada y para el valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="6a50d-106">Every method signature specifies a type for each input parameter and for the return value.</span></span> <span data-ttu-id="6a50d-107">La biblioteca de clases .NET define un conjunto de tipos numéricos integrados, así como tipos más complejos que representan una amplia variedad de construcciones lógicas, como el sistema de archivos, conexiones de red, colecciones y matrices de objetos, y fechas.</span><span class="sxs-lookup"><span data-stu-id="6a50d-107">The .NET class library defines a set of built-in numeric types as well as more complex types that represent a wide variety of logical constructs, such as the file system, network connections, collections and arrays of objects, and dates.</span></span> <span data-ttu-id="6a50d-108">Los programas de C# típicos usan tipos de la biblioteca de clases, así como tipos definidos por el usuario que modelan los conceptos que son específicos del dominio del problema del programa.</span><span class="sxs-lookup"><span data-stu-id="6a50d-108">A typical C# program uses types from the class library as well as user-defined types that model the concepts that are specific to the program's problem domain.</span></span>  
  
<span data-ttu-id="6a50d-109">Entre la información almacenada en un tipo se puede incluir lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="6a50d-109">The information stored in a type can include the following:</span></span>  
  
- <span data-ttu-id="6a50d-110">El espacio de almacenamiento que requiere una variable del tipo.</span><span class="sxs-lookup"><span data-stu-id="6a50d-110">The storage space that a variable of the type requires.</span></span>  
  
- <span data-ttu-id="6a50d-111">Los valores máximo y mínimo que puede representar.</span><span class="sxs-lookup"><span data-stu-id="6a50d-111">The maximum and minimum values that it can represent.</span></span>  
  
- <span data-ttu-id="6a50d-112">Los miembros (métodos, campos, eventos, etc.) que contiene.</span><span class="sxs-lookup"><span data-stu-id="6a50d-112">The members (methods, fields, events, and so on) that it contains.</span></span>  
  
- <span data-ttu-id="6a50d-113">El tipo base del que hereda.</span><span class="sxs-lookup"><span data-stu-id="6a50d-113">The base type it inherits from.</span></span>

- <span data-ttu-id="6a50d-114">Interfaces que implementa.</span><span class="sxs-lookup"><span data-stu-id="6a50d-114">The interface(s) it implements.</span></span>

- <span data-ttu-id="6a50d-115">La ubicación donde se asignará la memoria para variables en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="6a50d-115">The location where the memory for variables will be allocated at run time.</span></span>  
  
- <span data-ttu-id="6a50d-116">Los tipos de operaciones permitidas.</span><span class="sxs-lookup"><span data-stu-id="6a50d-116">The kinds of operations that are permitted.</span></span>  
  
<span data-ttu-id="6a50d-117">El compilador usa información de tipo para garantizar que todas las operaciones que se realizan en el código cuentan *con seguridad de tipos*.</span><span class="sxs-lookup"><span data-stu-id="6a50d-117">The compiler uses type information to make sure that all operations that are performed in your code are *type safe*.</span></span> <span data-ttu-id="6a50d-118">Por ejemplo, si declara una variable de tipo [int](language-reference/builtin-types/integral-numeric-types.md), el compilador le permite usar la variable en operaciones de suma y resta.</span><span class="sxs-lookup"><span data-stu-id="6a50d-118">For example, if you declare a variable of type [int](language-reference/builtin-types/integral-numeric-types.md), the compiler allows you to use the variable in addition and subtraction operations.</span></span> <span data-ttu-id="6a50d-119">Si intenta realizar esas mismas operaciones en una variable de tipo [bool](language-reference/builtin-types/bool.md), el compilador genera un error, como se muestra en el siguiente ejemplo:</span><span class="sxs-lookup"><span data-stu-id="6a50d-119">If you try to perform those same operations on a variable of type [bool](language-reference/builtin-types/bool.md), the compiler generates an error, as shown in the following example:</span></span>  
  
[!code-csharp[Type Safety](../../samples/snippets/csharp/concepts/basic-types/type-safety.cs)]  
  
> [!NOTE]  
> <span data-ttu-id="6a50d-120">Los desarrolladores de C y C++ deben tener en cuenta que, en C#, [bool](language-reference/builtin-types/bool.md) no se puede convertir en [int](language-reference/builtin-types/integral-numeric-types.md).</span><span class="sxs-lookup"><span data-stu-id="6a50d-120">C and C++ developers, notice that in C#, [bool](language-reference/builtin-types/bool.md) is not convertible to [int](language-reference/builtin-types/integral-numeric-types.md).</span></span>  
  
<span data-ttu-id="6a50d-121">El compilador inserta la información de tipo en el archivo ejecutable como metadatos.</span><span class="sxs-lookup"><span data-stu-id="6a50d-121">The compiler embeds the type information into the executable file as metadata.</span></span> <span data-ttu-id="6a50d-122">Common Language Runtime (CLR) usa esos metadatos en tiempo de ejecución para garantizar aún más la seguridad de tipos cuando asigna y reclama memoria.</span><span class="sxs-lookup"><span data-stu-id="6a50d-122">The common language runtime (CLR) uses that metadata at run time to further guarantee type safety when it allocates and reclaims memory.</span></span>  

## <a name="specifying-types-in-variable-declarations"></a><span data-ttu-id="6a50d-123">Especificar tipos en declaraciones de variable</span><span class="sxs-lookup"><span data-stu-id="6a50d-123">Specifying types in variable declarations</span></span>

<span data-ttu-id="6a50d-124">Cuando declare una variable o constante en un programa, debe especificar su tipo o usar la palabra clave [var](language-reference/keywords/var.md) para que el compilador infiera el tipo.</span><span class="sxs-lookup"><span data-stu-id="6a50d-124">When you declare a variable or constant in a program, you must either specify its type or use the [var](language-reference/keywords/var.md) keyword to let the compiler infer the type.</span></span> <span data-ttu-id="6a50d-125">En el ejemplo siguiente se muestran algunas declaraciones de variable que utilizan tanto tipos numéricos integrados como tipos complejos definidos por el usuario:</span><span class="sxs-lookup"><span data-stu-id="6a50d-125">The following example shows some variable declarations that use both built-in numeric types and complex user-defined types:</span></span>  
  
[!code-csharp[Variable Declaration](../../samples/snippets/csharp/concepts/basic-types/variable-declaration.cs)]  
  
<span data-ttu-id="6a50d-126">Los tipos de parámetros de método y valores devueltos se especifican en la firma del método.</span><span class="sxs-lookup"><span data-stu-id="6a50d-126">The types of method parameters and return values are specified in the method signature.</span></span> <span data-ttu-id="6a50d-127">En la siguiente firma se muestra un método que requiere una variable [int](language-reference/builtin-types/integral-numeric-types.md) como argumento de entrada y devuelve una cadena:</span><span class="sxs-lookup"><span data-stu-id="6a50d-127">The following signature shows a method that requires an [int](language-reference/builtin-types/integral-numeric-types.md) as an input argument and returns a string:</span></span>  
  
[!code-csharp[Method Signature](../../samples/snippets/csharp/concepts/basic-types/method-signature.cs)]  
  
<span data-ttu-id="6a50d-128">Tras declarar una variable, no se puede volver a declarar con un nuevo tipo y no se le puede asignar un valor que no sea compatible con su tipo declarado.</span><span class="sxs-lookup"><span data-stu-id="6a50d-128">After a variable is declared, it cannot be re-declared with a new type, and it cannot be assigned a value that is not compatible with its declared type.</span></span> <span data-ttu-id="6a50d-129">Por ejemplo, no puede declarar un valor [int](language-reference/builtin-types/integral-numeric-types.md) y, luego, asignarle un valor booleano de `true`.</span><span class="sxs-lookup"><span data-stu-id="6a50d-129">For example, you cannot declare an [int](language-reference/builtin-types/integral-numeric-types.md) and then assign it a Boolean value of `true`.</span></span> <span data-ttu-id="6a50d-130">En cambio, los valores se pueden convertir en otros tipos, por ejemplo, cuando se asignan a variables nuevas o se pasan como argumentos de método.</span><span class="sxs-lookup"><span data-stu-id="6a50d-130">However, values can be converted to other types, for example when they are assigned to new variables or passed as method arguments.</span></span> <span data-ttu-id="6a50d-131">El compilador realiza automáticamente una *conversión de tipo* que no da lugar a una pérdida de datos.</span><span class="sxs-lookup"><span data-stu-id="6a50d-131">A *type conversion* that does not cause data loss is performed automatically by the compiler.</span></span> <span data-ttu-id="6a50d-132">Una conversión que pueda dar lugar a la pérdida de datos requiere un valor *cast* en el código fuente.</span><span class="sxs-lookup"><span data-stu-id="6a50d-132">A conversion that might cause data loss requires a *cast* in the source code.</span></span>

<span data-ttu-id="6a50d-133">Para obtener más información, consulte [Conversiones de tipos](programming-guide/types/casting-and-type-conversions.md).</span><span class="sxs-lookup"><span data-stu-id="6a50d-133">For more information, see [Casting and type conversions](programming-guide/types/casting-and-type-conversions.md).</span></span>

## <a name="built-in-types"></a><span data-ttu-id="6a50d-134">Tipos integrados</span><span class="sxs-lookup"><span data-stu-id="6a50d-134">Built-in types</span></span>

<span data-ttu-id="6a50d-135">C# proporciona un conjunto estándar de tipos numéricos integrados para representar números enteros, valores de punto flotante, expresiones booleanas, caracteres de texto, valores decimales y otros tipos de datos.</span><span class="sxs-lookup"><span data-stu-id="6a50d-135">C# provides a standard set of built-in numeric types to represent integers, floating point values, Boolean expressions, text characters, decimal values, and other types of data.</span></span> <span data-ttu-id="6a50d-136">También hay tipos **string** y **object** integrados.</span><span class="sxs-lookup"><span data-stu-id="6a50d-136">There are also built-in **string** and **object** types.</span></span> <span data-ttu-id="6a50d-137">Están disponibles para su uso en cualquier programa de C#.</span><span class="sxs-lookup"><span data-stu-id="6a50d-137">These are available for you to use in any C# program.</span></span> <span data-ttu-id="6a50d-138">Para obtener una lista completa de los tipos integrados, vea [Tipos integrados](language-reference/builtin-types/built-in-types.md).</span><span class="sxs-lookup"><span data-stu-id="6a50d-138">For the complete list of the built-in types, see [Built-in types](language-reference/builtin-types/built-in-types.md).</span></span>
  
## <a name="custom-types"></a><span data-ttu-id="6a50d-139">Tipos personalizados</span><span class="sxs-lookup"><span data-stu-id="6a50d-139">Custom types</span></span>

<span data-ttu-id="6a50d-140">Las construcciones [struct](language-reference/builtin-types/struct.md), [class](language-reference/keywords/class.md), [record](language-reference/builtin-types/record.md), [interface](language-reference/keywords/interface.md) y [enum](language-reference/builtin-types/enum.md) se utilizan para crear sus propios tipos personalizados.</span><span class="sxs-lookup"><span data-stu-id="6a50d-140">You use the [struct](language-reference/builtin-types/struct.md), [class](language-reference/keywords/class.md), [record](language-reference/builtin-types/record.md), [interface](language-reference/keywords/interface.md), and [enum](language-reference/builtin-types/enum.md) constructs to create your own custom types.</span></span> <span data-ttu-id="6a50d-141">La biblioteca de clases .NET es en sí misma una colección de tipos personalizados proporcionados por Microsoft que puede usar en sus propias aplicaciones.</span><span class="sxs-lookup"><span data-stu-id="6a50d-141">The .NET class library itself is a collection of custom types provided by Microsoft that you can use in your own applications.</span></span> <span data-ttu-id="6a50d-142">De forma predeterminada, los tipos usados con más frecuencia en la biblioteca de clases están disponibles en cualquier programa de C#.</span><span class="sxs-lookup"><span data-stu-id="6a50d-142">By default, the most frequently used types in the class library are available in any C# program.</span></span> <span data-ttu-id="6a50d-143">Otros están disponibles solo cuando agrega explícitamente una referencia de proyecto al ensamblado en el que se definen.</span><span class="sxs-lookup"><span data-stu-id="6a50d-143">Others become available only when you explicitly add a project reference to the assembly in which they are defined.</span></span> <span data-ttu-id="6a50d-144">Una vez que el compilador tenga una referencia al ensamblado, puede declarar variables (y constantes) de los tipos declarados en dicho ensamblado en el código fuente.</span><span class="sxs-lookup"><span data-stu-id="6a50d-144">After the compiler has a reference to the assembly, you can declare variables (and constants) of the types declared in that assembly in source code.</span></span>
  
## <a name="generic-types"></a><span data-ttu-id="6a50d-145">Tipos genéricos</span><span class="sxs-lookup"><span data-stu-id="6a50d-145">Generic types</span></span>

<span data-ttu-id="6a50d-146">Los tipos se pueden declarar con uno o varios *parámetros de tipo* que actúan como un marcador de posición para el tipo real (el *tipo concreto*) que proporcionará el código de cliente cuando cree una instancia del tipo.</span><span class="sxs-lookup"><span data-stu-id="6a50d-146">A type can be declared with one or more *type parameters* that serve as a placeholder for the actual type (the *concrete type*) that client code will provide when it creates an instance of the type.</span></span> <span data-ttu-id="6a50d-147">Estos tipos se denominan *tipos genéricos*.</span><span class="sxs-lookup"><span data-stu-id="6a50d-147">Such types are called *generic types*.</span></span> <span data-ttu-id="6a50d-148">Por ejemplo, <xref:System.Collections.Generic.List%601> tiene un parámetro de tipo al que, por convención, se le denomina *T*. Cuando crea una instancia del tipo, especifica el tipo de los objetos que contendrá la lista, por ejemplo, la cadena:</span><span class="sxs-lookup"><span data-stu-id="6a50d-148">For example, <xref:System.Collections.Generic.List%601> has one type parameter that by convention is given the name *T*. When you create an instance of the type, you specify the type of the objects that the list will contain, for example, string:</span></span>  
  
[!code-csharp[Generic types](../../samples/snippets/csharp/concepts/basic-types/generic-type.cs)]
  
<span data-ttu-id="6a50d-149">El uso del parámetro de tipo permite reutilizar la misma clase para incluir cualquier tipo de elemento, sin necesidad de convertir cada elemento en [object](language-reference/builtin-types/reference-types.md#the-object-type).</span><span class="sxs-lookup"><span data-stu-id="6a50d-149">The use of the type parameter makes it possible to reuse the same class to hold any type of element, without having to convert each element to [object](language-reference/builtin-types/reference-types.md#the-object-type).</span></span> <span data-ttu-id="6a50d-150">Las clases de colección genéricas se denominan *colecciones fuertemente tipadas* porque el compilador conoce el tipo específico de los elementos de la colección y puede generar un error en tiempo de compilación si, por ejemplo, intenta agregar un valor entero al objeto `strings` del ejemplo anterior.</span><span class="sxs-lookup"><span data-stu-id="6a50d-150">Generic collection classes are called *strongly typed collections* because the compiler knows the specific type of the collection's elements and can raise an error at compile-time if, for example, you try to add an integer to the `strings` object in the previous example.</span></span> <span data-ttu-id="6a50d-151">Para más información, vea [Genéricos](programming-guide/generics/index.md).</span><span class="sxs-lookup"><span data-stu-id="6a50d-151">For more information, see [Generics](programming-guide/generics/index.md).</span></span>

## <a name="implicit-types-anonymous-types-and-tuple-types"></a><span data-ttu-id="6a50d-152">Tipos implícitos, tipos anónimos y tipos de tupla</span><span class="sxs-lookup"><span data-stu-id="6a50d-152">Implicit types, anonymous types, and tuple types</span></span>

<span data-ttu-id="6a50d-153">Como se ha mencionado anteriormente, puede asignar implícitamente un tipo a una variable local (pero no miembros de clase) mediante la palabra clave [var](language-reference/keywords/var.md).</span><span class="sxs-lookup"><span data-stu-id="6a50d-153">As stated previously, you can implicitly type a local variable (but not class members) by using the [var](language-reference/keywords/var.md) keyword.</span></span> <span data-ttu-id="6a50d-154">La variable sigue recibiendo un tipo en tiempo de compilación, pero este lo proporciona el compilador.</span><span class="sxs-lookup"><span data-stu-id="6a50d-154">The variable still receives a type at compile time, but the type is provided by the compiler.</span></span> <span data-ttu-id="6a50d-155">Para obtener más información, consulte [Variables locales con asignación implícita de tipos](programming-guide/classes-and-structs/implicitly-typed-local-variables.md).</span><span class="sxs-lookup"><span data-stu-id="6a50d-155">For more information, see [Implicitly typed local variables](programming-guide/classes-and-structs/implicitly-typed-local-variables.md).</span></span>  
  
<span data-ttu-id="6a50d-156">En algunos casos, resulta conveniente crear un tipo con nombre para conjuntos sencillos de valores relacionados que no quiera almacenar ni pasar fuera de los límites del método.</span><span class="sxs-lookup"><span data-stu-id="6a50d-156">In some cases, it is inconvenient to create a named type for simple sets of related values that you do not intend to store or pass outside method boundaries.</span></span> <span data-ttu-id="6a50d-157">Puede crear *tipos anónimos* para este fin.</span><span class="sxs-lookup"><span data-stu-id="6a50d-157">You can create *anonymous types* for this purpose.</span></span> <span data-ttu-id="6a50d-158">Para obtener más información, consulte [Tipos anónimos (Guía de programación de C#)](programming-guide/classes-and-structs/anonymous-types.md).</span><span class="sxs-lookup"><span data-stu-id="6a50d-158">For more information, see [Anonymous types](programming-guide/classes-and-structs/anonymous-types.md).</span></span>

<span data-ttu-id="6a50d-159">Es habitual querer devolver más de un valor de un método.</span><span class="sxs-lookup"><span data-stu-id="6a50d-159">It's common to want to return more than one value from a method.</span></span> <span data-ttu-id="6a50d-160">Puede crear *tipos de tupla* que devuelven varios valores en una única llamada de método.</span><span class="sxs-lookup"><span data-stu-id="6a50d-160">You can create *tuple types* that return multiple values in a single method call.</span></span> <span data-ttu-id="6a50d-161">Para obtener más información, consulte [Tipos de tupla](language-reference/builtin-types/value-tuples.md).</span><span class="sxs-lookup"><span data-stu-id="6a50d-161">For more information, see [Tuple types](language-reference/builtin-types/value-tuples.md).</span></span>

## <a name="the-common-type-system"></a><span data-ttu-id="6a50d-162">Common Type System</span><span class="sxs-lookup"><span data-stu-id="6a50d-162">The Common type system</span></span>

<span data-ttu-id="6a50d-163">Es importante entender dos aspectos fundamentales sobre el sistema de tipos en .NET:</span><span class="sxs-lookup"><span data-stu-id="6a50d-163">It is important to understand two fundamental points about the type system in .NET:</span></span>  
  
- <span data-ttu-id="6a50d-164">Es compatible con el principio de herencia.</span><span class="sxs-lookup"><span data-stu-id="6a50d-164">It supports the principle of inheritance.</span></span> <span data-ttu-id="6a50d-165">Los tipos pueden derivarse de otros tipos, denominados *tipos base*.</span><span class="sxs-lookup"><span data-stu-id="6a50d-165">Types can derive from other types, called *base types*.</span></span> <span data-ttu-id="6a50d-166">El tipo derivado hereda (con algunas restricciones), los métodos, las propiedades y otros miembros del tipo base.</span><span class="sxs-lookup"><span data-stu-id="6a50d-166">The derived type inherits (with some restrictions) the methods, properties, and other members of the base type.</span></span> <span data-ttu-id="6a50d-167">A su vez, el tipo base puede derivarse de algún otro tipo, en cuyo caso el tipo derivado hereda los miembros de ambos tipos base en su jerarquía de herencia.</span><span class="sxs-lookup"><span data-stu-id="6a50d-167">The base type can in turn derive from some other type, in which case the derived type inherits the members of both base types in its inheritance hierarchy.</span></span> <span data-ttu-id="6a50d-168">Todos los tipos, incluidos los tipos numéricos integrados como <xref:System.Int32> (palabra clave de C#: `int`), se derivan en última instancia de un único tipo base, que es <xref:System.Object> (palabra clave de C#: `object`).</span><span class="sxs-lookup"><span data-stu-id="6a50d-168">All types, including built-in numeric types such as <xref:System.Int32> (C# keyword: `int`), derive ultimately from a single base type, which is <xref:System.Object> (C# keyword: `object`).</span></span> <span data-ttu-id="6a50d-169">Esta jerarquía de tipos unificada se denomina [Common Type System](../standard/common-type-system.md) (CTS).</span><span class="sxs-lookup"><span data-stu-id="6a50d-169">This unified type hierarchy is called the [Common type system](../standard/common-type-system.md) (CTS).</span></span> <span data-ttu-id="6a50d-170">Para obtener más información sobre la herencia en C#, consulte [Herencia](programming-guide/classes-and-structs/inheritance.md).</span><span class="sxs-lookup"><span data-stu-id="6a50d-170">For more information about inheritance in C#, see [Inheritance](programming-guide/classes-and-structs/inheritance.md).</span></span>  
  
- <span data-ttu-id="6a50d-171">En CTS, cada tipo se define como un *tipo de valor* o un *tipo de referencia*.</span><span class="sxs-lookup"><span data-stu-id="6a50d-171">Each type in the CTS is defined as either a *value type* or a *reference type*.</span></span> <span data-ttu-id="6a50d-172">Esto incluye todos los tipos personalizados de la biblioteca de clases .NET y también sus propios tipos definidos por el usuario.</span><span class="sxs-lookup"><span data-stu-id="6a50d-172">This includes all custom types in the .NET class library and also your own user-defined types.</span></span> <span data-ttu-id="6a50d-173">Los tipos que se definen mediante la palabra clave `struct` o `enum` son tipos de valor.</span><span class="sxs-lookup"><span data-stu-id="6a50d-173">Types that you define by using the `struct` or `enum` keyword are value types.</span></span> <span data-ttu-id="6a50d-174">Para más información sobre los tipos de valor, vea [Tipos de valor](language-reference/builtin-types/value-types.md).</span><span class="sxs-lookup"><span data-stu-id="6a50d-174">For more information about value types, see [Value types](language-reference/builtin-types/value-types.md).</span></span> <span data-ttu-id="6a50d-175">Los tipos que se definen mediante el uso de la palabra clave [class](language-reference/keywords/class.md) son tipos de referencia.</span><span class="sxs-lookup"><span data-stu-id="6a50d-175">Types that you define by using the [class](language-reference/keywords/class.md) keyword are reference types.</span></span> <span data-ttu-id="6a50d-176">Para obtener más información sobre los tipos de referencia, consulte [Classes](programming-guide/classes-and-structs/classes.md) (Clases).</span><span class="sxs-lookup"><span data-stu-id="6a50d-176">For more information about reference types, see [Classes](programming-guide/classes-and-structs/classes.md).</span></span> <span data-ttu-id="6a50d-177">Los tipos de referencia y los tipos de valor tienen distintas reglas de tiempo de compilación y distintos comportamientos de tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="6a50d-177">Reference types and value types have different compile-time rules, and different run-time behavior.</span></span>

## <a name="see-also"></a><span data-ttu-id="6a50d-178">Vea también</span><span class="sxs-lookup"><span data-stu-id="6a50d-178">See also</span></span>

- [<span data-ttu-id="6a50d-179">Tipos de estructura</span><span class="sxs-lookup"><span data-stu-id="6a50d-179">Structure types</span></span>](language-reference/builtin-types/struct.md)
- [<span data-ttu-id="6a50d-180">Tipos de enumeración</span><span class="sxs-lookup"><span data-stu-id="6a50d-180">Enumeration types</span></span>](language-reference/builtin-types/enum.md)
- [<span data-ttu-id="6a50d-181">Clases</span><span class="sxs-lookup"><span data-stu-id="6a50d-181">Classes</span></span>](programming-guide/classes-and-structs/classes.md)
