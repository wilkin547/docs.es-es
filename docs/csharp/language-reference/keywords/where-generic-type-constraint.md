---
description: 'where (restricción de tipo genérico): Referencia de C#'
title: 'where (restricción de tipo genérico): Referencia de C#'
ms.date: 04/15/2020
f1_keywords:
- whereconstraint
- whereconstraint_CSharpKeyword
- classconstraint_CSharpKeyword
- structconstraint_CSharpKeyword
- enumconstraint_CSharpKeyword
helpviewer_keywords:
- where (generic type constraint) [C#]
ms.openlocfilehash: 83fb5b562d9e1e4caaef179ca2911adb60fc01fa
ms.sourcegitcommit: c7f0beaa2bd66ebca86362ca17d673f7e8256ca6
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 03/23/2021
ms.locfileid: "104872631"
---
# <a name="where-generic-type-constraint-c-reference"></a><span data-ttu-id="ebb46-103">where (restricción de tipo genérico) (Referencia de C#)</span><span class="sxs-lookup"><span data-stu-id="ebb46-103">where (generic type constraint) (C# Reference)</span></span>

<span data-ttu-id="ebb46-104">La cláusula `where` en una definición genérica especifica restricciones en los tipos que se usan como argumentos para los parámetros de tipo en un tipo genérico, método, delegado o función local.</span><span class="sxs-lookup"><span data-stu-id="ebb46-104">The `where` clause in a generic definition specifies constraints on the types that are used as arguments for type parameters in a generic type, method, delegate, or local function.</span></span> <span data-ttu-id="ebb46-105">Las restricciones pueden especificar interfaces o clases base, o bien requerir que un tipo genérico sea una referencia, un valor o un tipo no administrado.</span><span class="sxs-lookup"><span data-stu-id="ebb46-105">Constraints can specify interfaces, base classes, or require a generic type to be a reference, value, or unmanaged type.</span></span> <span data-ttu-id="ebb46-106">Declaran las funcionalidades que debe tener el argumento de tipo.</span><span class="sxs-lookup"><span data-stu-id="ebb46-106">They declare capabilities that the type argument must have.</span></span>

<span data-ttu-id="ebb46-107">Por ejemplo, se puede declarar una clase genérica, `AGenericClass`, de modo que el parámetro de tipo `T` implemente la interfaz <xref:System.IComparable%601>:</span><span class="sxs-lookup"><span data-stu-id="ebb46-107">For example, you can declare a generic class, `AGenericClass`, such that the type parameter `T` implements the <xref:System.IComparable%601> interface:</span></span>

[!code-csharp[using an interface constraint](snippets/GenericWhereConstraints.cs#1)]

> [!NOTE]
> <span data-ttu-id="ebb46-108">Para obtener más información sobre la cláusula where en una expresión de consulta, vea [where (Cláusula)](where-clause.md).</span><span class="sxs-lookup"><span data-stu-id="ebb46-108">For more information on the where clause in a query expression, see [where clause](where-clause.md).</span></span>

<span data-ttu-id="ebb46-109">La cláusula `where` también puede incluir una restricción de clase base.</span><span class="sxs-lookup"><span data-stu-id="ebb46-109">The `where` clause can also include a base class constraint.</span></span> <span data-ttu-id="ebb46-110">La restricción de clase base indica que un tipo que se va a usar como argumento de tipo para ese tipo genérico tiene la clase especificada como clase base, o bien es la clase base.</span><span class="sxs-lookup"><span data-stu-id="ebb46-110">The base class constraint states that a type to be used as a type argument for that generic type has the specified class as a base class, or is that base class.</span></span> <span data-ttu-id="ebb46-111">Si se usa la restricción de clase base, debe aparecer antes que cualquier otra restricción de ese parámetro de tipo.</span><span class="sxs-lookup"><span data-stu-id="ebb46-111">If the base class constraint is used, it must appear before any other constraints on that type parameter.</span></span> <span data-ttu-id="ebb46-112">Algunos tipos no están permitidos como restricción de clase base: <xref:System.Object>, <xref:System.Array> y <xref:System.ValueType>.</span><span class="sxs-lookup"><span data-stu-id="ebb46-112">Some types are disallowed as a base class constraint: <xref:System.Object>, <xref:System.Array>, and <xref:System.ValueType>.</span></span> <span data-ttu-id="ebb46-113">Antes de C# 7.3, tampoco se permitían <xref:System.Enum>, <xref:System.Delegate> ni <xref:System.MulticastDelegate> como restricciones de clase base.</span><span class="sxs-lookup"><span data-stu-id="ebb46-113">Before C# 7.3, <xref:System.Enum>, <xref:System.Delegate>, and <xref:System.MulticastDelegate> were also disallowed as base class constraints.</span></span> <span data-ttu-id="ebb46-114">En el ejemplo siguiente se muestran los tipos que ahora se pueden especificar como clase base:</span><span class="sxs-lookup"><span data-stu-id="ebb46-114">The following example shows the types that can now be specified as a base class:</span></span>

[!code-csharp[using an interface constraint](snippets/GenericWhereConstraints.cs#2)]

<span data-ttu-id="ebb46-115">En un contexto que admite un valor NULL en C# 8.0 y versiones posteriores, se aplica la nulabilidad del tipo de clase base.</span><span class="sxs-lookup"><span data-stu-id="ebb46-115">In a nullable context in C# 8.0 and later, the nullability of the base class type is enforced.</span></span> <span data-ttu-id="ebb46-116">Si la clase base no acepta valores NULL (por ejemplo, `Base`), el argumento de tipo no debe aceptar valores NULL.</span><span class="sxs-lookup"><span data-stu-id="ebb46-116">If the base class is non-nullable (for example `Base`), the type argument must be non-nullable.</span></span> <span data-ttu-id="ebb46-117">Si la clase base admite un valor NULL (por ejemplo, `Base?`), el argumento de tipo puede ser un tipo de referencia que acepte o no valores NULL.</span><span class="sxs-lookup"><span data-stu-id="ebb46-117">If the base class is nullable (for example `Base?`), the type argument may be either a nullable or non-nullable reference type.</span></span> <span data-ttu-id="ebb46-118">El compilador emite una advertencia si el argumento de tipo es un tipo de referencia que admite un valor NULL cuando la clase base no acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="ebb46-118">The compiler issues a warning if the type argument is a nullable reference type when the base class is non-nullable.</span></span>

<span data-ttu-id="ebb46-119">La cláusula `where` puede especificar que el tipo es `class` o `struct`.</span><span class="sxs-lookup"><span data-stu-id="ebb46-119">The `where` clause can specify that the type is a `class` or a `struct`.</span></span> <span data-ttu-id="ebb46-120">La restricción `struct` elimina la necesidad de especificar una restricción de clase base de `System.ValueType`.</span><span class="sxs-lookup"><span data-stu-id="ebb46-120">The `struct` constraint removes the need to specify a base class constraint of `System.ValueType`.</span></span> <span data-ttu-id="ebb46-121">El tipo `System.ValueType` no se puede usar como restricción de clase base.</span><span class="sxs-lookup"><span data-stu-id="ebb46-121">The `System.ValueType` type may not be used as a base class constraint.</span></span> <span data-ttu-id="ebb46-122">En el ejemplo siguiente se muestran las restricciones `class` y `struct`:</span><span class="sxs-lookup"><span data-stu-id="ebb46-122">The following example shows both the `class` and `struct` constraints:</span></span>

[!code-csharp[using the class and struct constraints](snippets/GenericWhereConstraints.cs#3)]

<span data-ttu-id="ebb46-123">En un contexto que admite un valor NULL en C# 8.0 y versiones posteriores, la restricción `class` requiere que un tipo sea un tipo de referencia que no acepte valores NULL.</span><span class="sxs-lookup"><span data-stu-id="ebb46-123">In a nullable context in C# 8.0 and later, the `class` constraint requires a type to be a non-nullable reference type.</span></span> <span data-ttu-id="ebb46-124">Para permitir tipos de referencia que admitan un valor NULL, use la restricción `class?`, que permite tipos de referencia que aceptan y que no aceptan valores NULL.</span><span class="sxs-lookup"><span data-stu-id="ebb46-124">To allow nullable reference types, use the `class?` constraint, which allows both nullable and non-nullable reference types.</span></span>

<span data-ttu-id="ebb46-125">La cláusula `where` puede incluir la restricción `notnull`.</span><span class="sxs-lookup"><span data-stu-id="ebb46-125">The `where` clause may include the `notnull` constraint.</span></span> <span data-ttu-id="ebb46-126">La restricción `notnull` limita el parámetro de tipo a tipos que no aceptan valores NULL.</span><span class="sxs-lookup"><span data-stu-id="ebb46-126">The `notnull` constraint limits the type parameter to non-nullable types.</span></span> <span data-ttu-id="ebb46-127">Ese tipo puede ser un [tipo de valor](../builtin-types/value-types.md) o un tipo de referencia que no acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="ebb46-127">That type may be a [value type](../builtin-types/value-types.md) or a non-nullable reference type.</span></span> <span data-ttu-id="ebb46-128">La restricción `notnull` está disponible a partir C# 8.0 para el código compilado en un contexto [`nullable enable`](../../nullable-references.md#nullable-contexts).</span><span class="sxs-lookup"><span data-stu-id="ebb46-128">The `notnull` constraint is available starting in C# 8.0 for code compiled in a [`nullable enable` context](../../nullable-references.md#nullable-contexts).</span></span> <span data-ttu-id="ebb46-129">A diferencia de otras restricciones, si un argumento de tipo infringe la restricción `notnull`, el compilador genera una advertencia en lugar de un error.</span><span class="sxs-lookup"><span data-stu-id="ebb46-129">Unlike other constraints, if a type argument violates the `notnull` constraint, the compiler generates a warning instead of an error.</span></span> <span data-ttu-id="ebb46-130">Las advertencias solo se generan en un contexto `nullable enable`.</span><span class="sxs-lookup"><span data-stu-id="ebb46-130">Warnings are only generated in a `nullable enable` context.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="ebb46-131">Las declaraciones genéricas que incluyen la restricción `notnull` se pueden usar en un contexto donde se desconoce que se aceptan valores NULL, pero el compilador no aplica la restricción.</span><span class="sxs-lookup"><span data-stu-id="ebb46-131">Generic declarations that include the `notnull` constraint can be used in a nullable oblivious context, but compiler does not enforce the constraint.</span></span>

[!code-csharp[using the nonnull constraint](snippets/GenericWhereConstraints.cs#NotNull)]

<span data-ttu-id="ebb46-132">La cláusula `where` también podría incluir una restricción `unmanaged`.</span><span class="sxs-lookup"><span data-stu-id="ebb46-132">The `where` clause may also include an `unmanaged` constraint.</span></span> <span data-ttu-id="ebb46-133">La restricción `unmanaged` limita el parámetro de tipo a los tipos conocidos como [tipos no administrados](../builtin-types/unmanaged-types.md).</span><span class="sxs-lookup"><span data-stu-id="ebb46-133">The `unmanaged` constraint limits the type parameter to types known as [unmanaged types](../builtin-types/unmanaged-types.md).</span></span> <span data-ttu-id="ebb46-134">La restricción `unmanaged` hace que sea más fácil escribir código de interoperabilidad de bajo nivel en C#.</span><span class="sxs-lookup"><span data-stu-id="ebb46-134">The `unmanaged` constraint makes it easier to write low-level interop code in C#.</span></span> <span data-ttu-id="ebb46-135">Esta restricción habilita las rutinas reutilizables en todos los tipos no administrados.</span><span class="sxs-lookup"><span data-stu-id="ebb46-135">This constraint enables reusable routines across all unmanaged types.</span></span> <span data-ttu-id="ebb46-136">La restricción `unmanaged` no se puede combinar con las restricciones `class` o `struct`.</span><span class="sxs-lookup"><span data-stu-id="ebb46-136">The `unmanaged` constraint can't be combined with the `class` or `struct` constraint.</span></span> <span data-ttu-id="ebb46-137">La restricción `unmanaged` exige que el tipo sea `struct`:</span><span class="sxs-lookup"><span data-stu-id="ebb46-137">The `unmanaged` constraint enforces that the type must be a `struct`:</span></span>

[!code-csharp[using the unmanaged constraint](snippets/GenericWhereConstraints.cs#4)]

<span data-ttu-id="ebb46-138">La cláusula `where` también podría incluir una restricción de constructor, `new()`.</span><span class="sxs-lookup"><span data-stu-id="ebb46-138">The `where` clause may also include a constructor constraint, `new()`.</span></span> <span data-ttu-id="ebb46-139">Esta restricción hace posible crear una instancia de un parámetro de tipo con el operador `new`.</span><span class="sxs-lookup"><span data-stu-id="ebb46-139">That constraint makes it possible to create an instance of a type parameter using the `new` operator.</span></span> <span data-ttu-id="ebb46-140">La [restricción new()](new-constraint.md) permite que el compilador sepa que cualquier argumento de tipo especificado debe tener accesible un constructor sin parámetros.</span><span class="sxs-lookup"><span data-stu-id="ebb46-140">The [new() Constraint](new-constraint.md) lets the compiler know that any type argument supplied must have an accessible parameterless constructor.</span></span> <span data-ttu-id="ebb46-141">Por ejemplo:</span><span class="sxs-lookup"><span data-stu-id="ebb46-141">For example:</span></span>

[!code-csharp[using the new constraint](snippets/GenericWhereConstraints.cs#5)]

<span data-ttu-id="ebb46-142">La restricción `new()` aparece en último lugar en la cláusula `where`.</span><span class="sxs-lookup"><span data-stu-id="ebb46-142">The `new()` constraint appears last in the `where` clause.</span></span> <span data-ttu-id="ebb46-143">La restricción `new()` no se puede combinar con las restricciones `struct` o `unmanaged`.</span><span class="sxs-lookup"><span data-stu-id="ebb46-143">The `new()` constraint can't be combined with the `struct` or `unmanaged` constraints.</span></span> <span data-ttu-id="ebb46-144">Todos los tipos que cumplan esas restricciones deben tener un constructor sin parámetros accesible, lo que hace que la restricción `new()` sea redundante.</span><span class="sxs-lookup"><span data-stu-id="ebb46-144">All types satisfying those constraints must have an accessible parameterless constructor, making the `new()` constraint redundant.</span></span>

<span data-ttu-id="ebb46-145">Con varios parámetros de tipo, use una cláusula `where` para cada parámetro de tipo, por ejemplo:</span><span class="sxs-lookup"><span data-stu-id="ebb46-145">With multiple type parameters, use one `where` clause for each type parameter, for example:</span></span>

[!code-csharp[using multiple where constraints](snippets/GenericWhereConstraints.cs#6)]

<span data-ttu-id="ebb46-146">También puede asociar restricciones a parámetros de tipo de métodos genéricos, como se muestra en el ejemplo siguiente:</span><span class="sxs-lookup"><span data-stu-id="ebb46-146">You can also attach constraints to type parameters of generic methods, as shown in the following example:</span></span>

[!code-csharp[where constraints with generic methods](snippets/GenericWhereConstraints.cs#7)]

<span data-ttu-id="ebb46-147">Observe que la sintaxis para describir las restricciones de parámetro de tipo en delegados es igual que la de métodos:</span><span class="sxs-lookup"><span data-stu-id="ebb46-147">Notice that the syntax to describe type parameter constraints on delegates is the same as that of methods:</span></span>

[!code-csharp[where constraints with generic methods](snippets/GenericWhereConstraints.cs#8)]

<span data-ttu-id="ebb46-148">Para obtener información sobre los delegados genéricos, vea [Delegados genéricos](../../programming-guide/generics/generic-delegates.md).</span><span class="sxs-lookup"><span data-stu-id="ebb46-148">For information on generic delegates, see [Generic Delegates](../../programming-guide/generics/generic-delegates.md).</span></span>

<span data-ttu-id="ebb46-149">Para obtener más información sobre la sintaxis y el uso de restricciones, vea [Restricciones de tipos de parámetros](../../programming-guide/generics/constraints-on-type-parameters.md).</span><span class="sxs-lookup"><span data-stu-id="ebb46-149">For details on the syntax and use of constraints, see [Constraints on Type Parameters](../../programming-guide/generics/constraints-on-type-parameters.md).</span></span>

## <a name="c-language-specification"></a><span data-ttu-id="ebb46-150">Especificación del lenguaje C#</span><span class="sxs-lookup"><span data-stu-id="ebb46-150">C# language specification</span></span>

 [!INCLUDE[CSharplangspec](~/includes/csharplangspec-md.md)]

## <a name="see-also"></a><span data-ttu-id="ebb46-151">Consulte también</span><span class="sxs-lookup"><span data-stu-id="ebb46-151">See also</span></span>

- [<span data-ttu-id="ebb46-152">Referencia de C#</span><span class="sxs-lookup"><span data-stu-id="ebb46-152">C# Reference</span></span>](../index.md)
- [<span data-ttu-id="ebb46-153">Guía de programación de C#</span><span class="sxs-lookup"><span data-stu-id="ebb46-153">C# Programming Guide</span></span>](../../programming-guide/index.md)
- [<span data-ttu-id="ebb46-154">Introducción a los genéricos</span><span class="sxs-lookup"><span data-stu-id="ebb46-154">Introduction to Generics</span></span>](../../programming-guide/generics/index.md)
- [<span data-ttu-id="ebb46-155">new (restricción)</span><span class="sxs-lookup"><span data-stu-id="ebb46-155">new Constraint</span></span>](./new-constraint.md)
- [<span data-ttu-id="ebb46-156">Restricciones de tipos de parámetros</span><span class="sxs-lookup"><span data-stu-id="ebb46-156">Constraints on Type Parameters</span></span>](../../programming-guide/generics/constraints-on-type-parameters.md)
