---
title: Registros (referencia de C#)
description: Obtenga información sobre el tipo de registro en C#.
ms.date: 02/25/2021
f1_keywords:
- record_CSharpKeyword
helpviewer_keywords:
- record keyword [C#]
- record type [C#]
ms.openlocfilehash: 57474caf0f1106380e52da7fcb7608b62a0f23e5
ms.sourcegitcommit: c7f0beaa2bd66ebca86362ca17d673f7e8256ca6
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 03/23/2021
ms.locfileid: "104872657"
---
# <a name="records-c-reference"></a><span data-ttu-id="a2485-103">Registros (referencia de C#)</span><span class="sxs-lookup"><span data-stu-id="a2485-103">Records (C# reference)</span></span>

<span data-ttu-id="a2485-104">A partir de C# 9, se usa la palabra clave `record` para definir un [tipo de referencia](reference-types.md) que proporciona funcionalidad integrada para encapsular los datos.</span><span class="sxs-lookup"><span data-stu-id="a2485-104">Beginning with C# 9, you use the `record` keyword to define a [reference type](reference-types.md) that provides built-in functionality for encapsulating data.</span></span> <span data-ttu-id="a2485-105">Puede crear tipos de registros con propiedades inmutables mediante parámetros posicionales o sintaxis de propiedades estándar:</span><span class="sxs-lookup"><span data-stu-id="a2485-105">You can create record types with immutable properties by using positional parameters or standard property syntax:</span></span>

:::code language="csharp" source="snippets/shared/RecordType.cs" id="PositionalRecord":::
:::code language="csharp" source="snippets/shared/RecordType.cs" id="ImmutableRecord":::

<span data-ttu-id="a2485-106">También puede crear tipos de registros con propiedades y campos mutables:</span><span class="sxs-lookup"><span data-stu-id="a2485-106">You can also create record types with mutable properties and fields:</span></span>

:::code language="csharp" source="snippets/shared/RecordType.cs" id="MutableRecord":::

<span data-ttu-id="a2485-107">Aunque los registros pueden ser mutables, están destinados principalmente a admitir modelos de datos inmutables.</span><span class="sxs-lookup"><span data-stu-id="a2485-107">While records can be mutable, they are primarily intended for supporting immutable data models.</span></span> <span data-ttu-id="a2485-108">El tipo de registro ofrece las siguientes características:</span><span class="sxs-lookup"><span data-stu-id="a2485-108">The record type offers the following features:</span></span>

* [<span data-ttu-id="a2485-109">Sintaxis concisa para crear un tipo de referencia con propiedades inmutables</span><span class="sxs-lookup"><span data-stu-id="a2485-109">Concise syntax for creating a reference type with immutable properties</span></span>](#positional-syntax-for-property-definition)
* <span data-ttu-id="a2485-110">Comportamiento integrado útil para un tipo de referencia centrado en datos:</span><span class="sxs-lookup"><span data-stu-id="a2485-110">Built-in behavior useful for a data-centric reference type:</span></span>
  * [<span data-ttu-id="a2485-111">Igualdad de valores</span><span class="sxs-lookup"><span data-stu-id="a2485-111">Value equality</span></span>](#value-equality)
  * [<span data-ttu-id="a2485-112">Sintaxis concisa para la mutación no destructiva</span><span class="sxs-lookup"><span data-stu-id="a2485-112">Concise syntax for nondestructive mutation</span></span>](#nondestructive-mutation)
  * [<span data-ttu-id="a2485-113">Formato integrado para la presentación</span><span class="sxs-lookup"><span data-stu-id="a2485-113">Built-in formatting for display</span></span>](#built-in-formatting-for-display)
* [<span data-ttu-id="a2485-114">Compatibilidad con las jerarquías de herencia</span><span class="sxs-lookup"><span data-stu-id="a2485-114">Support for inheritance hierarchies</span></span>](#inheritance)

<span data-ttu-id="a2485-115">También puede utilizar [tipos de estructura](struct.md) para diseñar tipos centrados en datos que proporcionen igualdad de valores y un comportamiento escaso o inexistente.</span><span class="sxs-lookup"><span data-stu-id="a2485-115">You can also use [structure types](struct.md) to design data-centric types that provide value equality and little or no behavior.</span></span> <span data-ttu-id="a2485-116">Pero, en el caso de los modelos de datos relativamente grandes, los tipos de estructura tienen algunas desventajas:</span><span class="sxs-lookup"><span data-stu-id="a2485-116">But for relatively large data models, structure types have some disadvantages:</span></span>

* <span data-ttu-id="a2485-117">No admiten la herencia.</span><span class="sxs-lookup"><span data-stu-id="a2485-117">They don't support inheritance.</span></span>
* <span data-ttu-id="a2485-118">Son menos eficaces a la hora de determinar la igualdad de valores.</span><span class="sxs-lookup"><span data-stu-id="a2485-118">They're less efficient at determining value equality.</span></span> <span data-ttu-id="a2485-119">En el caso de los tipos de valor, el método <xref:System.ValueType.Equals%2A?displayProperty=nameWithType> usa la reflexión para buscar todos los campos.</span><span class="sxs-lookup"><span data-stu-id="a2485-119">For value types, the <xref:System.ValueType.Equals%2A?displayProperty=nameWithType> method uses reflection to find all fields.</span></span> <span data-ttu-id="a2485-120">En el caso de los registros, el compilador genera el método `Equals`.</span><span class="sxs-lookup"><span data-stu-id="a2485-120">For records, the compiler generates the `Equals` method.</span></span> <span data-ttu-id="a2485-121">En la práctica, la implementación de la igualdad de valores en los registros es bastante más rápida.</span><span class="sxs-lookup"><span data-stu-id="a2485-121">In practice, the implementation of value equality in records is measurably faster.</span></span>
* <span data-ttu-id="a2485-122">Usan más memoria en algunos escenarios, ya que cada instancia tiene una copia completa de todos los datos.</span><span class="sxs-lookup"><span data-stu-id="a2485-122">They use more memory in some scenarios, since every instance has a complete copy of all of the data.</span></span> <span data-ttu-id="a2485-123">Los tipos de registro son [tipos de referencia](reference-types.md), por lo que una instancia de registro solo contiene una referencia a los datos.</span><span class="sxs-lookup"><span data-stu-id="a2485-123">Record types are [reference types](reference-types.md), so a record instance contains only a reference to the data.</span></span>

## <a name="positional-syntax-for-property-definition"></a><span data-ttu-id="a2485-124">Sintaxis posicional para la definición de propiedad</span><span class="sxs-lookup"><span data-stu-id="a2485-124">Positional syntax for property definition</span></span>

<span data-ttu-id="a2485-125">Puede usar parámetros posicionales para declarar propiedades de un registro e inicializar los valores de propiedad al crear una instancia:</span><span class="sxs-lookup"><span data-stu-id="a2485-125">You can use positional parameters to declare properties of a record and to initialize the property values when you create an instance:</span></span>

:::code language="csharp" source="snippets/shared/RecordType.cs" id="InstantiatePositional":::

<span data-ttu-id="a2485-126">Cuando se usa la sintaxis posicional para la definición de propiedad, el compilador crea lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="a2485-126">When you use the positional syntax for property definition, the compiler creates:</span></span>

* <span data-ttu-id="a2485-127">Una propiedad pública implementada automáticamente de solo inicialización para cada parámetro posicional proporcionado en la declaración de registro.</span><span class="sxs-lookup"><span data-stu-id="a2485-127">A public init-only auto-implemented property for each positional parameter provided in the record declaration.</span></span> <span data-ttu-id="a2485-128">Una propiedad de [solo inicialización](../../whats-new/csharp-9.md#init-only-setters) solo se puede establecer en el constructor o mediante un inicializador de propiedad.</span><span class="sxs-lookup"><span data-stu-id="a2485-128">An [init-only](../../whats-new/csharp-9.md#init-only-setters) property can only be set in the constructor or by using a property initializer.</span></span>
* <span data-ttu-id="a2485-129">Un constructor primario cuyos parámetros coinciden con los parámetros posicionales en la declaración del registro.</span><span class="sxs-lookup"><span data-stu-id="a2485-129">A primary constructor whose parameters match the positional parameters on the record declaration.</span></span>
* <span data-ttu-id="a2485-130">Un método `Deconstruct` con un parámetro `out` para cada parámetro posicional proporcionado en la declaración de registro.</span><span class="sxs-lookup"><span data-stu-id="a2485-130">A `Deconstruct` method with an `out` parameter for each positional parameter provided in the record declaration.</span></span> <span data-ttu-id="a2485-131">Este método solo se proporciona si hay dos o más parámetros posicionales.</span><span class="sxs-lookup"><span data-stu-id="a2485-131">This method is provided only if there are two or more positional parameters.</span></span> <span data-ttu-id="a2485-132">El método deconstruye las propiedades definidas mediante la sintaxis posicional; omite las propiedades que se definen mediante la sintaxis de propiedades estándar.</span><span class="sxs-lookup"><span data-stu-id="a2485-132">The method deconstructs properties defined by using positional syntax; it ignores properties that are defined by using standard property syntax.</span></span>

<span data-ttu-id="a2485-133">Si la definición de propiedad implementada automáticamente generada no es la que desea, puede definir su propia propiedad con el mismo nombre.</span><span class="sxs-lookup"><span data-stu-id="a2485-133">If the generated auto-implemented property definition isn't what you want, you can define your own property of the same name.</span></span> <span data-ttu-id="a2485-134">Si lo hace, el constructor y el deconstructor generados usarán su definición de propiedad.</span><span class="sxs-lookup"><span data-stu-id="a2485-134">If you do that, the generated constructor and deconstructor will use your property definition.</span></span> <span data-ttu-id="a2485-135">Por ejemplo, en el ejemplo siguiente se crea la propiedad posicional `FirstName` `internal` en lugar de `public`.</span><span class="sxs-lookup"><span data-stu-id="a2485-135">For instance, the following example makes the `FirstName` positional property `internal` instead of `public`.</span></span>

:::code language="csharp" source="snippets/shared/RecordType.cs" id="PositionalWithManualProperty":::

<span data-ttu-id="a2485-136">Un tipo de registro no tiene que declarar ninguna propiedad posicional.</span><span class="sxs-lookup"><span data-stu-id="a2485-136">A record type doesn't have to declare any positional properties.</span></span> <span data-ttu-id="a2485-137">Puede declarar un registro sin propiedades posicionales y también campos y propiedades adicionales, como en el ejemplo siguiente:</span><span class="sxs-lookup"><span data-stu-id="a2485-137">You can declare a record without any positional properties, and you can declare additional fields and properties, as in the following example:</span></span>

:::code language="csharp" source="snippets/shared/RecordType.cs" id="MixedSyntax":::

<span data-ttu-id="a2485-138">Si define propiedades mediante la sintaxis de propiedades estándar, pero omite el modificador de acceso, las propiedades son `public` implícitamente.</span><span class="sxs-lookup"><span data-stu-id="a2485-138">If you define properties by using standard property syntax but omit the access modifier, the properties are implicitly `public`.</span></span>
<!-- Todo -- Explain issues surrounding use of attributes on positional properties. -->

## <a name="immutability"></a><span data-ttu-id="a2485-139">Inmutabilidad</span><span class="sxs-lookup"><span data-stu-id="a2485-139">Immutability</span></span>

<span data-ttu-id="a2485-140">Un tipo de registro no es necesariamente inmutable.</span><span class="sxs-lookup"><span data-stu-id="a2485-140">A record type is not necessarily immutable.</span></span> <span data-ttu-id="a2485-141">Puede declarar propiedades con descriptores de acceso `set` y campos que no sean `readonly`.</span><span class="sxs-lookup"><span data-stu-id="a2485-141">You can declare properties with `set` accessors and fields that aren't `readonly`.</span></span> <span data-ttu-id="a2485-142">Sin embargo, aunque los registros pueden ser mutables, facilitan la creación de modelos de datos inmutables.</span><span class="sxs-lookup"><span data-stu-id="a2485-142">But while records can be mutable, they make it easier to create immutable data models.</span></span>

<span data-ttu-id="a2485-143">La inmutabilidad puede resultar útil si necesita que un tipo centrado en datos sea seguro para subprocesos o si depende de que un código hash quede igual en una tabla hash.</span><span class="sxs-lookup"><span data-stu-id="a2485-143">Immutability can be useful when you need a data-centric type to be thread-safe or you're depending on a hash code remaining the same in a hash table.</span></span> <span data-ttu-id="a2485-144">Sin embargo, la inmutabilidad no es adecuada para todos los escenarios de datos.</span><span class="sxs-lookup"><span data-stu-id="a2485-144">Immutability isn't appropriate for all data scenarios, however.</span></span> <span data-ttu-id="a2485-145">Por ejemplo, [Entity Framework Core](/ef/core/) no admite la actualización con tipos de entidad inmutables.</span><span class="sxs-lookup"><span data-stu-id="a2485-145">[Entity Framework Core](/ef/core/), for example, doesn't support updating with immutable entity types.</span></span>

<span data-ttu-id="a2485-146">Las propiedades de solo inicialización, tanto si se crean a partir de parámetros posicionales como al especificar descriptores de acceso `init`, tienen una *inmutabilidad superficial*.</span><span class="sxs-lookup"><span data-stu-id="a2485-146">Init-only properties, whether created from positional parameters or by specifying `init` accessors, have *shallow immutability*.</span></span> <span data-ttu-id="a2485-147">Después de la inicialización, no se puede cambiar el valor de las propiedades de tipo de valor ni la referencia de las propiedades de tipo de referencia.</span><span class="sxs-lookup"><span data-stu-id="a2485-147">After initialization, you can't change the value of value-type properties or the reference of reference-type properties.</span></span> <span data-ttu-id="a2485-148">Sin embargo, se pueden cambiar los datos a los que hace referencia una propiedad de tipo de referencia.</span><span class="sxs-lookup"><span data-stu-id="a2485-148">However, the data that a reference-type property refers to can be changed.</span></span> <span data-ttu-id="a2485-149">En el ejemplo siguiente se muestra que el contenido de una propiedad inmutable de tipo de referencia (una matriz en este caso) es mutable:</span><span class="sxs-lookup"><span data-stu-id="a2485-149">The following example shows that the content of a reference-type immutable property (an array in this case) is mutable:</span></span>

:::code language="csharp" source="snippets/shared/RecordType.cs" id="ShallowImmutability":::

<span data-ttu-id="a2485-150">Las características exclusivas de los tipos de registro se implementan mediante métodos sintetizados por el compilador, y ninguno de estos métodos pone en peligro la inmutabilidad mediante la modificación del estado del objeto.</span><span class="sxs-lookup"><span data-stu-id="a2485-150">The features unique to record types are implemented by compiler-synthesized methods, and none of these methods compromises immutability by modifying object state.</span></span>

## <a name="value-equality"></a><span data-ttu-id="a2485-151">Igualdad de valores</span><span class="sxs-lookup"><span data-stu-id="a2485-151">Value equality</span></span>

<span data-ttu-id="a2485-152">La igualdad de valores significa que dos variables de un tipo de registro son iguales si los tipos coinciden y todos los valores de propiedad y campo coinciden.</span><span class="sxs-lookup"><span data-stu-id="a2485-152">Value equality means that two variables of a record type are equal if the types match and all property and field values match.</span></span> <span data-ttu-id="a2485-153">Para otros tipos de referencia, la igualdad significa identidad.</span><span class="sxs-lookup"><span data-stu-id="a2485-153">For other reference types, equality means identity.</span></span> <span data-ttu-id="a2485-154">Es decir, dos variables de un tipo de referencia son iguales si hacen referencia al mismo objeto.</span><span class="sxs-lookup"><span data-stu-id="a2485-154">That is, two variables of a reference type are equal if they refer to the same object.</span></span>

<span data-ttu-id="a2485-155">Se requiere la igualdad de referencia en algunos modelos de datos.</span><span class="sxs-lookup"><span data-stu-id="a2485-155">Reference equality is required for some data models.</span></span> <span data-ttu-id="a2485-156">Por ejemplo, [Entity Framework Core](/ef/core/) depende de la igualdad de referencia para garantizar que solo usa una instancia de un tipo de entidad para lo que es conceptualmente una entidad.</span><span class="sxs-lookup"><span data-stu-id="a2485-156">For example, [Entity Framework Core](/ef/core/) depends on reference equality to ensure that it uses only one instance of an entity type for what is conceptually one entity.</span></span> <span data-ttu-id="a2485-157">Por esta razón, los tipos de registro no son adecuados para su uso como tipos de entidad en Entity Framework Core.</span><span class="sxs-lookup"><span data-stu-id="a2485-157">For this reason, record types aren't appropriate for use as entity types in Entity Framework Core.</span></span>

<span data-ttu-id="a2485-158">En el ejemplo siguiente se muestra la igualdad de valores de tipos de registro:</span><span class="sxs-lookup"><span data-stu-id="a2485-158">The following example illustrates value equality of record types:</span></span>

:::code language="csharp" source="snippets/shared/RecordType.cs" id="Equality":::

<span data-ttu-id="a2485-159">Para implementar la igualdad de valores, el compilador sintetiza los métodos siguientes:</span><span class="sxs-lookup"><span data-stu-id="a2485-159">To implement value equality, the compiler synthesizes the following methods:</span></span>

* <span data-ttu-id="a2485-160">Una invalidación de <xref:System.Object.Equals(System.Object)?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a2485-160">An override of <xref:System.Object.Equals(System.Object)?displayProperty=nameWithType>.</span></span>

  <span data-ttu-id="a2485-161">Este método se utiliza como base para el método estático <xref:System.Object.Equals(System.Object,System.Object)?displayProperty=nameWithType> cuando ambos parámetros no son NULL.</span><span class="sxs-lookup"><span data-stu-id="a2485-161">This method is used as the basis for the <xref:System.Object.Equals(System.Object,System.Object)?displayProperty=nameWithType> static method when both parameters are non-null.</span></span>

* <span data-ttu-id="a2485-162">Un método `Equals` virtual cuyo parámetro es el tipo de registro.</span><span class="sxs-lookup"><span data-stu-id="a2485-162">A virtual `Equals` method whose parameter is the record type.</span></span> <span data-ttu-id="a2485-163">Este método implementa <xref:System.IEquatable%601>.</span><span class="sxs-lookup"><span data-stu-id="a2485-163">This method implements <xref:System.IEquatable%601>.</span></span>

* <span data-ttu-id="a2485-164">Una invalidación de <xref:System.Object.GetHashCode?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a2485-164">An override of <xref:System.Object.GetHashCode?displayProperty=nameWithType>.</span></span>

* <span data-ttu-id="a2485-165">Invalidaciones de los operadores `==` y `!=`.</span><span class="sxs-lookup"><span data-stu-id="a2485-165">Overrides of operators `==` and `!=`.</span></span>

<span data-ttu-id="a2485-166">En los tipos `class`, podría invalidar manualmente los métodos y los operadores de igualdad para lograr la igualdad de valores, pero el desarrollo y las pruebas de ese código serían lentos y propensos a errores.</span><span class="sxs-lookup"><span data-stu-id="a2485-166">In `class` types, you could manually override equality methods and operators to achieve value equality, but developing and testing that code would be time-consuming and error-prone.</span></span> <span data-ttu-id="a2485-167">Al tener esta funcionalidad integrada, se evitan los errores que resultarían de olvidarse de actualizar el código de invalidación personalizado cuando se agreguen o cambien propiedades o campos.</span><span class="sxs-lookup"><span data-stu-id="a2485-167">Having this functionality built-in prevents bugs that would result from forgetting to update custom override code when properties or fields are added or changed.</span></span>

<span data-ttu-id="a2485-168">Puede escribir sus propias implementaciones para reemplazar cualquiera de estos métodos sintetizados.</span><span class="sxs-lookup"><span data-stu-id="a2485-168">You can write your own implementations to replace any of these synthesized methods.</span></span> <span data-ttu-id="a2485-169">Si un tipo de registro tiene un método que coincide con la signatura de cualquier método sintetizado, el compilador no sintetiza ese método.</span><span class="sxs-lookup"><span data-stu-id="a2485-169">If a record type has a method that matches the signature of any synthesized method, the compiler doesn't synthesize that method.</span></span>

<span data-ttu-id="a2485-170">Si proporciona su propia implementación de `Equals` en un tipo de registro, proporcione también una implementación de `GetHashCode`.</span><span class="sxs-lookup"><span data-stu-id="a2485-170">If you provide your own implementation of `Equals` in a record type, provide an implementation of `GetHashCode` also.</span></span>

## <a name="nondestructive-mutation"></a><span data-ttu-id="a2485-171">Mutación no destructiva</span><span class="sxs-lookup"><span data-stu-id="a2485-171">Nondestructive mutation</span></span>

<span data-ttu-id="a2485-172">Si necesita mutar propiedades inmutables de una instancia de registro, puede usar una expresión `with` para lograr una *mutación no destructiva*.</span><span class="sxs-lookup"><span data-stu-id="a2485-172">If you need to mutate immutable properties of a record instance, you can use a `with` expression to achieve *nondestructive mutation*.</span></span> <span data-ttu-id="a2485-173">Una expresión `with` crea una instancia de registro que es una copia de una instancia de registro existente, con las propiedades y los campos especificados modificados.</span><span class="sxs-lookup"><span data-stu-id="a2485-173">A `with` expression makes a new record instance that is a copy of an existing record instance, with specified properties and fields modified.</span></span> <span data-ttu-id="a2485-174">Use la sintaxis del [inicializador de objeto](../../programming-guide/classes-and-structs/object-and-collection-initializers.md) para especificar los valores que se van a cambiar, como se muestra en el ejemplo siguiente:</span><span class="sxs-lookup"><span data-stu-id="a2485-174">You use [object initializer](../../programming-guide/classes-and-structs/object-and-collection-initializers.md) syntax to specify the values to be changed, as shown in the following example:</span></span>

:::code language="csharp" source="snippets/shared/RecordType.cs" id="WithExpressions":::

<span data-ttu-id="a2485-175">La expresión `with` puede establecer propiedades posicionales o propiedades creadas con la sintaxis de propiedades estándar.</span><span class="sxs-lookup"><span data-stu-id="a2485-175">The `with` expression can set positional properties or properties created by using standard property syntax.</span></span> <span data-ttu-id="a2485-176">Las propiedades no posicionales deben tener un descriptor de acceso `init` o `set` para cambiar en una expresión `with`.</span><span class="sxs-lookup"><span data-stu-id="a2485-176">Non-positional properties must have an `init` or `set` accessor to be changed in a `with` expression.</span></span>

<span data-ttu-id="a2485-177">El resultado de una expresión `with` es una *copia superficial*, lo que significa que, para una propiedad de referencia, solo se copia la referencia a una instancia.</span><span class="sxs-lookup"><span data-stu-id="a2485-177">The result of a `with` expression is a *shallow copy*, which means that for a reference property, only the reference to an instance is copied.</span></span> <span data-ttu-id="a2485-178">Tanto el registro original como la copia terminan con una referencia a la misma instancia.</span><span class="sxs-lookup"><span data-stu-id="a2485-178">Both the original record and the copy end up with a reference to the same instance.</span></span>

<span data-ttu-id="a2485-179">Para implementar esta característica, el compilador sintetiza un método de clon y un constructor de copias.</span><span class="sxs-lookup"><span data-stu-id="a2485-179">To implement this feature, the compiler synthesizes a clone method and a copy constructor.</span></span> <span data-ttu-id="a2485-180">El constructor adopta una instancia del registro que se va a copiar y llama al método de clon.</span><span class="sxs-lookup"><span data-stu-id="a2485-180">The constructor takes an instance of the record to be copied and calls the clone method.</span></span> <span data-ttu-id="a2485-181">Cuando se usa una expresión `with`, el compilador crea código que llama al constructor de copia y, a continuación, establece las propiedades que se especifican en la expresión `with`.</span><span class="sxs-lookup"><span data-stu-id="a2485-181">When you use a `with` expression, the compiler creates code that calls the copy constructor and then sets the properties that are specified in the `with` expression.</span></span>

<span data-ttu-id="a2485-182">Si necesita un comportamiento de copia diferente, puede escribir su propio constructor de copia.</span><span class="sxs-lookup"><span data-stu-id="a2485-182">If you need different copying behavior, you can write your own copy constructor.</span></span> <span data-ttu-id="a2485-183">Si lo hace, el compilador no sintetizará un método.</span><span class="sxs-lookup"><span data-stu-id="a2485-183">If you do that, the compiler won't synthesize one.</span></span> <span data-ttu-id="a2485-184">Cree su constructor `private` si el registro es `sealed`; de lo contrario, conviértalo en `protected`.</span><span class="sxs-lookup"><span data-stu-id="a2485-184">Make your constructor `private` if the record is `sealed`, otherwise make it `protected`.</span></span>

<span data-ttu-id="a2485-185">No puede invalidar el método de clon y no puede crear un miembro denominado `Clone`.</span><span class="sxs-lookup"><span data-stu-id="a2485-185">You can't override the clone method, and you can't create a member named `Clone`.</span></span> <span data-ttu-id="a2485-186">El nombre real del método de clon lo genera el compilador.</span><span class="sxs-lookup"><span data-stu-id="a2485-186">The actual name of the clone method is compiler-generated.</span></span>

## <a name="built-in-formatting-for-display"></a><span data-ttu-id="a2485-187">Formato integrado para la presentación</span><span class="sxs-lookup"><span data-stu-id="a2485-187">Built-in formatting for display</span></span>

<span data-ttu-id="a2485-188">Los tipos de registros tienen un método <xref:System.Object.ToString%2A> generado por el compilador que muestra los nombres y los valores de las propiedades y los campos públicos.</span><span class="sxs-lookup"><span data-stu-id="a2485-188">Record types have a compiler-generated <xref:System.Object.ToString%2A> method that displays the names and values of public properties and fields.</span></span> <span data-ttu-id="a2485-189">El método `ToString` devuelve una cadena con el formato siguiente:</span><span class="sxs-lookup"><span data-stu-id="a2485-189">The `ToString` method returns a string of the following format:</span></span>

> <span data-ttu-id="a2485-190">\<record type name> { \<property name> = \<value>, \<property name> = \<value>, ...}</span><span class="sxs-lookup"><span data-stu-id="a2485-190">\<record type name> { \<property name> = \<value>, \<property name> = \<value>, ...}</span></span>

<span data-ttu-id="a2485-191">En el caso de los tipos de referencia, se muestra el nombre del tipo del objeto al que hace referencia la propiedad en lugar del valor de propiedad.</span><span class="sxs-lookup"><span data-stu-id="a2485-191">For reference types, the type name of the object that the property refers to is displayed instead of the property value.</span></span> <span data-ttu-id="a2485-192">En el ejemplo siguiente, la matriz es un tipo de referencia, por lo que se muestra `System.String[]` en lugar de los valores de los elementos de matriz reales:</span><span class="sxs-lookup"><span data-stu-id="a2485-192">In the following example, the array is a reference type, so `System.String[]` is displayed instead of the actual array element values:</span></span>

```
Person { FirstName = Nancy, LastName = Davolio, ChildNames = System.String[] }
```

<span data-ttu-id="a2485-193">Para implementar esta característica, el compilador sintetiza un método `PrintMembers` virtual y una invalidación <xref:System.Object.ToString%2A>.</span><span class="sxs-lookup"><span data-stu-id="a2485-193">To implement this feature, the compiler synthesizes a virtual `PrintMembers` method and a <xref:System.Object.ToString%2A> override.</span></span>
<span data-ttu-id="a2485-194">La invalidación `ToString` crea un objeto <xref:System.Text.StringBuilder> con el nombre de tipo seguido de un corchete de apertura.</span><span class="sxs-lookup"><span data-stu-id="a2485-194">The `ToString` override creates a <xref:System.Text.StringBuilder> object with the type name followed by an opening bracket.</span></span> <span data-ttu-id="a2485-195">Llama a `PrintMembers` para agregar nombres y valores de propiedad y, a continuación, agrega el corchete de cierre.</span><span class="sxs-lookup"><span data-stu-id="a2485-195">It calls `PrintMembers` to add property names and values, then adds the closing bracket.</span></span> <span data-ttu-id="a2485-196">En el ejemplo siguiente se muestra código similar al que contiene la invalidación sintetizada:</span><span class="sxs-lookup"><span data-stu-id="a2485-196">The following example shows code similar to what the synthesized override contains:</span></span>

:::code language="csharp" source="snippets/shared/RecordType.cs" id="ToStringOverrideDefault":::

<span data-ttu-id="a2485-197">Puede proporcionar su propia implementación de `PrintMembers` o la invalidación `ToString`.</span><span class="sxs-lookup"><span data-stu-id="a2485-197">You can provide your own implementation of `PrintMembers` or the `ToString` override.</span></span> <span data-ttu-id="a2485-198">En la sección [Formato `PrintMembers` en registros derivados](#printmembers-formatting-in-derived-records) que se encuentra más adelante en este artículo se proporcionan ejemplos.</span><span class="sxs-lookup"><span data-stu-id="a2485-198">Examples are provided in the [`PrintMembers` formatting in derived records](#printmembers-formatting-in-derived-records) section later in this article.</span></span>

## <a name="inheritance"></a><span data-ttu-id="a2485-199">Herencia</span><span class="sxs-lookup"><span data-stu-id="a2485-199">Inheritance</span></span>

<span data-ttu-id="a2485-200">Un registro puede heredar de otro registro.</span><span class="sxs-lookup"><span data-stu-id="a2485-200">A record can inherit from another record.</span></span> <span data-ttu-id="a2485-201">Sin embargo, un registro no puede heredar de una clase, y una clase no puede heredar de un registro.</span><span class="sxs-lookup"><span data-stu-id="a2485-201">However, a record can't inherit from a class, and a class can't inherit from a record.</span></span>

### <a name="positional-parameters-in-derived-record-types"></a><span data-ttu-id="a2485-202">Parámetros posicionales en tipos de registro derivados</span><span class="sxs-lookup"><span data-stu-id="a2485-202">Positional parameters in derived record types</span></span>

<span data-ttu-id="a2485-203">El registro derivado declara parámetros para todos los parámetros del constructor primario del registro base.</span><span class="sxs-lookup"><span data-stu-id="a2485-203">The derived record declares positional parameters for all the parameters in the base record primary constructor.</span></span> <span data-ttu-id="a2485-204">El registro base declara e inicializa esas propiedades.</span><span class="sxs-lookup"><span data-stu-id="a2485-204">The base record declares and initializes those properties.</span></span> <span data-ttu-id="a2485-205">El registro derivado no las oculta, sino que solo crea e inicializa propiedades para los parámetros que no se han declarado en su registro base.</span><span class="sxs-lookup"><span data-stu-id="a2485-205">The derived record doesn't hide them, but only creates and initializes properties for parameters that aren't declared in its base record.</span></span>

<span data-ttu-id="a2485-206">En el ejemplo siguiente se muestra la herencia con la sintaxis de la propiedad posicional:</span><span class="sxs-lookup"><span data-stu-id="a2485-206">The following example illustrates inheritance with positional property syntax:</span></span>

:::code language="csharp" source="snippets/shared/RecordType.cs" id="PositionalInheritance":::

### <a name="equality-in-inheritance-hierarchies"></a><span data-ttu-id="a2485-207">Igualdad en las jerarquías de herencia</span><span class="sxs-lookup"><span data-stu-id="a2485-207">Equality in inheritance hierarchies</span></span>

<span data-ttu-id="a2485-208">Para que dos variables de registro sean iguales, el tipo en tiempo de ejecución debe ser el mismo.</span><span class="sxs-lookup"><span data-stu-id="a2485-208">For two record variables to be equal, the run-time type must be equal.</span></span> <span data-ttu-id="a2485-209">Los tipos de las variables contenedoras podrían ser diferentes.</span><span class="sxs-lookup"><span data-stu-id="a2485-209">The types of the containing variables might be different.</span></span> <span data-ttu-id="a2485-210">Esto se muestra en el siguiente código de ejemplo:</span><span class="sxs-lookup"><span data-stu-id="a2485-210">This is illustrated in the following code example:</span></span>

:::code language="csharp" source="snippets/shared/RecordType.cs" id="InheritanceEquality":::

<span data-ttu-id="a2485-211">En el ejemplo, todas las instancias tienen las mismas propiedades y los mismos valores de propiedad.</span><span class="sxs-lookup"><span data-stu-id="a2485-211">In the example, all instances have the same properties and the same property values.</span></span> <span data-ttu-id="a2485-212">Pero `student == teacher` devuelve `False`, aunque ambas son variables de tipo `Person`, y `student == student2` devuelve `True`, aunque una es una variable `Person` y otra es una variable `Student`.</span><span class="sxs-lookup"><span data-stu-id="a2485-212">But `student == teacher` returns `False` although both are `Person`-type variables, and `student == student2` returns `True` although one is a `Person` variable and one is a `Student` variable.</span></span>

<span data-ttu-id="a2485-213">Para implementar este comportamiento, el compilador sintetiza una propiedad `EqualityContract` que devuelve un objeto <xref:System.Type> que coincide con el tipo del registro.</span><span class="sxs-lookup"><span data-stu-id="a2485-213">To implement this behavior, the compiler synthesizes an `EqualityContract` property that returns a <xref:System.Type> object that matches the type of the record.</span></span> <span data-ttu-id="a2485-214">Esto permite a los métodos de igualdad comparar el tipo en tiempo de ejecución de los objetos cuando están comprobando la igualdad.</span><span class="sxs-lookup"><span data-stu-id="a2485-214">This enables the equality methods to compare the runtime type of objects when they are checking for equality.</span></span> <span data-ttu-id="a2485-215">Si el tipo base de un registro es `object`, esta propiedad es `virtual`.</span><span class="sxs-lookup"><span data-stu-id="a2485-215">If the base type of a record is `object`, this property is `virtual`.</span></span> <span data-ttu-id="a2485-216">Si el tipo base es otro tipo de registro, la propiedad es una invalidación.</span><span class="sxs-lookup"><span data-stu-id="a2485-216">If the base type is another record type, this property is an override.</span></span> <span data-ttu-id="a2485-217">Si el tipo de registro es `sealed`, esta propiedad es `sealed`.</span><span class="sxs-lookup"><span data-stu-id="a2485-217">If the record type is `sealed`, this property is `sealed`.</span></span>

<span data-ttu-id="a2485-218">Al comparar dos instancias de un tipo derivado, los métodos de igualdad sintetizados comprueban la igualdad de todas las propiedades de los tipos base y derivados.</span><span class="sxs-lookup"><span data-stu-id="a2485-218">When comparing two instances of a derived type, the synthesized equality methods check all properties of the base and derived types for equality.</span></span> <span data-ttu-id="a2485-219">El método `GetHashCode` sintetizado usa el método `GetHashCode` de todas las propiedades y los campos declarados en el tipo base y el tipo de registro derivado.</span><span class="sxs-lookup"><span data-stu-id="a2485-219">The synthesized `GetHashCode` method uses the `GetHashCode` method from all properties and fields declared in the base type and the derived record type.</span></span>

### <a name="with-expressions-in-derived-records"></a><span data-ttu-id="a2485-220">Expresiones `with` en registros derivados</span><span class="sxs-lookup"><span data-stu-id="a2485-220">`with` expressions in derived records</span></span>

<span data-ttu-id="a2485-221">Dado que el método de clon sintetizado utiliza un [tipo de valor devuelto covariante](~/_csharplang/proposals/csharp-9.0/covariant-returns.md), el resultado de una expresión `with` tiene el mismo tipo en tiempo de ejecución que el operando de la expresión.</span><span class="sxs-lookup"><span data-stu-id="a2485-221">Because the synthesized clone method uses a [covariant return type](~/_csharplang/proposals/csharp-9.0/covariant-returns.md), the result of a `with` expression has the same run-time type as the expression's operand.</span></span> <span data-ttu-id="a2485-222">Se copian todas las propiedades del tipo en tiempo de ejecución, pero solo se pueden establecer las propiedades del tipo en tiempo de compilación, como se muestra en el ejemplo siguiente:</span><span class="sxs-lookup"><span data-stu-id="a2485-222">All properties of the run-time type get copied, but you can only set properties of the compile-time type, as the following example shows:</span></span>

:::code language="csharp" source="snippets/shared/RecordType.cs" id="WithExpressionInheritance":::

### <a name="printmembers-formatting-in-derived-records"></a><span data-ttu-id="a2485-223">Formato `PrintMembers` en registros derivados</span><span class="sxs-lookup"><span data-stu-id="a2485-223">`PrintMembers` formatting in derived records</span></span>

<span data-ttu-id="a2485-224">El método sintetizado `PrintMembers` de un tipo de registro derivado llama a la implementación base.</span><span class="sxs-lookup"><span data-stu-id="a2485-224">The synthesized `PrintMembers` method of a derived record type calls the base implementation.</span></span> <span data-ttu-id="a2485-225">El resultado es que todas las propiedades y los campos públicos de los tipos derivados y base se incluyen en la salida `ToString`, como se muestra en el ejemplo siguiente:</span><span class="sxs-lookup"><span data-stu-id="a2485-225">The result is that all public properties and fields of both derived and base types are included in the `ToString` output, as shown in the following example:</span></span>

:::code language="csharp" source="snippets/shared/RecordType.cs" id="ToStringInheritance":::

<span data-ttu-id="a2485-226">Puede proporcionar su propia implementación del método `PrintMembers`.</span><span class="sxs-lookup"><span data-stu-id="a2485-226">You can provide your own implementation of the `PrintMembers` method.</span></span> <span data-ttu-id="a2485-227">Si lo hace, use la siguiente firma:</span><span class="sxs-lookup"><span data-stu-id="a2485-227">If you do that, use the following signature:</span></span>

* <span data-ttu-id="a2485-228">Para un registro `sealed` que deriva de `object` (no declara un registro base): `private bool PrintMembers(StringBuilder builder)`.</span><span class="sxs-lookup"><span data-stu-id="a2485-228">For a `sealed` record that derives from `object` (doesn't declare a base record): `private bool PrintMembers(StringBuilder builder)`;</span></span>
* <span data-ttu-id="a2485-229">Para un registro `sealed` que deriva de otro registro: `protected sealed override bool PrintMembers(StringBuilder builder)`.</span><span class="sxs-lookup"><span data-stu-id="a2485-229">For a `sealed` record that derives from another record: `protected sealed override bool PrintMembers(StringBuilder builder)`;</span></span>
* <span data-ttu-id="a2485-230">Para un registro que no es `sealed` y que deriva del objeto: `protected virtual bool PrintMembers(StringBuilder builder);`.</span><span class="sxs-lookup"><span data-stu-id="a2485-230">For a record that isn't `sealed` and derives from object: `protected virtual bool PrintMembers(StringBuilder builder);`</span></span>
* <span data-ttu-id="a2485-231">Para un registro que no es `sealed` y que deriva de otro registro: `protected override bool PrintMembers(StringBuilder builder);`.</span><span class="sxs-lookup"><span data-stu-id="a2485-231">For a record that isn't `sealed` and derives from another record: `protected override bool PrintMembers(StringBuilder builder);`</span></span>

<span data-ttu-id="a2485-232">Este es un ejemplo de código que reemplaza los métodos sintetizados `PrintMembers`, uno para un tipo de registro que deriva de un objeto y otro para un tipo de registro que deriva de otro registro:</span><span class="sxs-lookup"><span data-stu-id="a2485-232">Here is an example of code that replaces the synthesized `PrintMembers` methods, one for a record type that derives from object, and one for a record type that derives from another record:</span></span>

:::code language="csharp" source="snippets/shared/RecordType.cs" id="PrintMembersImplementation":::

### <a name="deconstructor-behavior-in-derived-records"></a><span data-ttu-id="a2485-233">Comportamiento del deconstructor en registros derivados</span><span class="sxs-lookup"><span data-stu-id="a2485-233">Deconstructor behavior in derived records</span></span>

<span data-ttu-id="a2485-234">El método `Deconstruct` de un registro derivado devuelve los valores de todas las propiedades posicionales del tipo en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="a2485-234">The `Deconstruct` method of a derived record returns the values of all positional properties of the compile-time type.</span></span> <span data-ttu-id="a2485-235">Si el tipo de variable es un registro base, solo se deconstruyen las propiedades del registro base a menos que el objeto se convierta en el tipo derivado.</span><span class="sxs-lookup"><span data-stu-id="a2485-235">If the variable type is a base record, only the base record properties are deconstructed unless the object is cast to the derived type.</span></span> <span data-ttu-id="a2485-236">En el ejemplo siguiente se muestra cómo llamar a un deconstructor en un registro derivado.</span><span class="sxs-lookup"><span data-stu-id="a2485-236">The following example demonstrates calling a deconstructor on a derived record.</span></span>

:::code language="csharp" source="snippets/shared/RecordType.cs" id="DeconstructorInheritance":::

## <a name="generic-constraints"></a><span data-ttu-id="a2485-237">Restricciones genéricas</span><span class="sxs-lookup"><span data-stu-id="a2485-237">Generic constraints</span></span>

<span data-ttu-id="a2485-238">No hay ninguna restricción genérica que requiera que un tipo sea un registro.</span><span class="sxs-lookup"><span data-stu-id="a2485-238">There is no generic constraint that requires a type to be a record.</span></span> <span data-ttu-id="a2485-239">Los registros cumplen la restricción `class`.</span><span class="sxs-lookup"><span data-stu-id="a2485-239">Records satisfy the `class` constraint.</span></span> <span data-ttu-id="a2485-240">Para realizar una restricción en una jerarquía específica de tipos de registro, coloque la restricción en el registro base como lo haría con una clase base.</span><span class="sxs-lookup"><span data-stu-id="a2485-240">To make a constraint on a specific hierarchy of record types, put the constraint on the base record as you would a base class.</span></span> <span data-ttu-id="a2485-241">Para obtener más información, vea [Restricciones de tipos de parámetros](../../programming-guide/generics/constraints-on-type-parameters.md).</span><span class="sxs-lookup"><span data-stu-id="a2485-241">For more information, see [Constraints on type parameters](../../programming-guide/generics/constraints-on-type-parameters.md).</span></span>

## <a name="c-language-specification"></a><span data-ttu-id="a2485-242">especificación del lenguaje C#</span><span class="sxs-lookup"><span data-stu-id="a2485-242">C# language specification</span></span>

<span data-ttu-id="a2485-243">Para más información, vea la sección [Clases](~/_csharplang/spec/classes.md) de la [especificación del lenguaje C#](~/_csharplang/spec/introduction.md).</span><span class="sxs-lookup"><span data-stu-id="a2485-243">For more information, see the [Classes](~/_csharplang/spec/classes.md) section of the [C# language specification](~/_csharplang/spec/introduction.md).</span></span>

<span data-ttu-id="a2485-244">Para obtener más información sobre de las características presentadas en C# 9 y versiones posteriores, vea las siguientes notas de propuesta de características:</span><span class="sxs-lookup"><span data-stu-id="a2485-244">For more information about features introduced in C# 9 and later, see the following feature proposal notes:</span></span>

- [<span data-ttu-id="a2485-245">Registros</span><span class="sxs-lookup"><span data-stu-id="a2485-245">Records</span></span>](~/_csharplang/proposals/csharp-9.0/records.md)
- [<span data-ttu-id="a2485-246">Establecedores de solo inicialización</span><span class="sxs-lookup"><span data-stu-id="a2485-246">Init-only setters</span></span>](~/_csharplang/proposals/csharp-9.0/init.md)
- [<span data-ttu-id="a2485-247">Valores devueltos de covariante</span><span class="sxs-lookup"><span data-stu-id="a2485-247">Covariant returns</span></span>](~/_csharplang/proposals/csharp-9.0/covariant-returns.md)

## <a name="see-also"></a><span data-ttu-id="a2485-248">Vea también</span><span class="sxs-lookup"><span data-stu-id="a2485-248">See also</span></span>

- [<span data-ttu-id="a2485-249">Referencia de C#</span><span class="sxs-lookup"><span data-stu-id="a2485-249">C# reference</span></span>](../index.md)
- [<span data-ttu-id="a2485-250">Instrucciones de diseño: elección entre clase y estructura</span><span class="sxs-lookup"><span data-stu-id="a2485-250">Design guidelines - Choosing between class and struct</span></span>](../../../standard/design-guidelines/choosing-between-class-and-struct.md)
- [<span data-ttu-id="a2485-251">Instrucciones de diseño: diseño de estructuras</span><span class="sxs-lookup"><span data-stu-id="a2485-251">Design guidelines - Struct design</span></span>](../../../standard/design-guidelines/struct.md)
- [<span data-ttu-id="a2485-252">Clases y estructuras</span><span class="sxs-lookup"><span data-stu-id="a2485-252">Classes and structs</span></span>](../../programming-guide/classes-and-structs/index.md)
- [<span data-ttu-id="a2485-253">Expresión `with`</span><span class="sxs-lookup"><span data-stu-id="a2485-253">`with` expression</span></span>](../operators/with-expression.md)
