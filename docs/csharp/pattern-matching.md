---
title: "Coincidencia de patrones: Guía de C#"
description: "Información sobre las expresiones de coincidencia de patrones en C#"
keywords: .NET, .NET Core, C#
ms.date: 01/24/2017
ms.author: wiwagn
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.assetid: 1e575c32-2e2b-4425-9dca-7d118f3ed15b
ms.openlocfilehash: 0c77c3c3da9983d20cdd86db18f60f83b86b07ea
ms.sourcegitcommit: 281070dee88db86ec3bb4634d5f558d1a4e159dd
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 11/11/2017
---
# <a name="pattern-matching"></a><span data-ttu-id="70e4b-104">Coincidencia de modelos</span><span class="sxs-lookup"><span data-stu-id="70e4b-104">Pattern Matching</span></span> #

<span data-ttu-id="70e4b-105">Los patrones comprueban que un valor tenga una determinada *forma* y pueden *extraer* información del valor cuando tiene la forma coincidente.</span><span class="sxs-lookup"><span data-stu-id="70e4b-105">Patterns test that a value has a certain *shape*, and can *extract* information from the value when it has the matching shape.</span></span> <span data-ttu-id="70e4b-106">La coincidencia de patrones proporciona una sintaxis más concisa para los algoritmos que se usan actualmente.</span><span class="sxs-lookup"><span data-stu-id="70e4b-106">Pattern matching provides more concise syntax for algorithms you already use today.</span></span> <span data-ttu-id="70e4b-107">Ya se crean algoritmos de coincidencia de patrones mediante la sintaxis existente.</span><span class="sxs-lookup"><span data-stu-id="70e4b-107">You already create pattern matching algorithms using existing syntax.</span></span> <span data-ttu-id="70e4b-108">Se escriben instrucciones `if` o `switch` que comprueban valores.</span><span class="sxs-lookup"><span data-stu-id="70e4b-108">You write `if` or `switch` statements that test values.</span></span> <span data-ttu-id="70e4b-109">Luego, si esas instrucciones coinciden, se extrae y se usa la información de ese valor.</span><span class="sxs-lookup"><span data-stu-id="70e4b-109">Then, when those statements match, you extract and use information from that value.</span></span> <span data-ttu-id="70e4b-110">Los nuevos elementos de sintaxis son extensiones de instrucciones con las que ya está familiarizado: `is` y `switch`.</span><span class="sxs-lookup"><span data-stu-id="70e4b-110">The new syntax elements are extensions to statements you are already familiar with: `is` and `switch`.</span></span> <span data-ttu-id="70e4b-111">Estas nuevas extensiones combinan la comprobación de un valor y la extracción de esa información.</span><span class="sxs-lookup"><span data-stu-id="70e4b-111">These new extensions combine testing a value and extracting that information.</span></span>

<span data-ttu-id="70e4b-112">En este tema se tratará la nueva sintaxis para mostrar cómo permite escribir un código conciso y legible.</span><span class="sxs-lookup"><span data-stu-id="70e4b-112">In this topic, we'll look at the new syntax to show you how it enables readable, concise code.</span></span> <span data-ttu-id="70e4b-113">La coincidencia de patrones permite expresiones donde se separan el código y los datos, a diferencia de los diseños orientados a objetos, donde los datos y los métodos que los manipulan están estrechamente unidos.</span><span class="sxs-lookup"><span data-stu-id="70e4b-113">Pattern matching enables idioms where data and the code are separated, unlike object oriented designs where data and the methods that manipulate them are tightly coupled.</span></span>

<span data-ttu-id="70e4b-114">Para mostrar estas nuevas expresiones, vamos a trabajar con estructuras que representan formas geométricas mediante instrucciones de coincidencia de patrones.</span><span class="sxs-lookup"><span data-stu-id="70e4b-114">To illustrate these new idioms, let's work with structures that represent geometric shapes using pattern matching statements.</span></span> <span data-ttu-id="70e4b-115">Probablemente esté familiarizado con la creación de jerarquías de clases y de [métodos virtuales y métodos invalidados](methods.md#inherited) para personalizar el comportamiento de los objetos según el tipo de tiempo de ejecución del objeto.</span><span class="sxs-lookup"><span data-stu-id="70e4b-115">You are probably familiar with building class hierarchies and creating [virtual methods and overridden methods](methods.md#inherited) to customize object behavior based on the runtime type of the object.</span></span>

<span data-ttu-id="70e4b-116">Esas técnicas no son posibles en el caso de los datos que no están estructurados en una jerarquía de clases.</span><span class="sxs-lookup"><span data-stu-id="70e4b-116">Those techniques aren't possible for data that isn't structured in a class hierarchy.</span></span> <span data-ttu-id="70e4b-117">Cuando los datos y los métodos están separados, se necesitan otras herramientas.</span><span class="sxs-lookup"><span data-stu-id="70e4b-117">When data and methods are separate, you need other tools.</span></span> <span data-ttu-id="70e4b-118">Las nuevas construcciones de *coincidencia de patrones* permiten una sintaxis más limpia para examinar los datos y manipular el flujo de control basándose en cualquier condición de esos datos.</span><span class="sxs-lookup"><span data-stu-id="70e4b-118">The new *pattern matching* constructs enable cleaner syntax to examine data and manipulate control flow based on any condition of that data.</span></span> <span data-ttu-id="70e4b-119">Ya escribe instrucciones `if` y `switch` que comprueban el valor de una variable.</span><span class="sxs-lookup"><span data-stu-id="70e4b-119">You already write `if` statements and `switch` that test a variable's value.</span></span> <span data-ttu-id="70e4b-120">Escribe instrucciones `is` que comprueban el tipo de una variable.</span><span class="sxs-lookup"><span data-stu-id="70e4b-120">You write `is` statements that test a variable's type.</span></span> <span data-ttu-id="70e4b-121">La *coincidencia de patrones* agrega nuevas capacidades a esas instrucciones.</span><span class="sxs-lookup"><span data-stu-id="70e4b-121">*Pattern matching* adds new capabilities to those statements.</span></span>

<span data-ttu-id="70e4b-122">En este tema se creará un método que calcula el área de distintas formas geométricas.</span><span class="sxs-lookup"><span data-stu-id="70e4b-122">In this topic, you'll build a method  that computes the area of different geometric shapes.</span></span> <span data-ttu-id="70e4b-123">Pero se hará sin recurrir a técnicas orientadas a objetos y sin crear una jerarquía de clases para las diferentes formas.</span><span class="sxs-lookup"><span data-stu-id="70e4b-123">But, you'll do it without resorting to object oriented techniques and building a class hierarchy for the different shapes.</span></span>
<span data-ttu-id="70e4b-124">En lugar de esto se usará la *coincidencia de patrones*.</span><span class="sxs-lookup"><span data-stu-id="70e4b-124">You'll use *pattern matching* instead.</span></span> <span data-ttu-id="70e4b-125">Para hacer más hincapié en que no se va a usar la herencia, cada forma será un elemento `struct` en lugar de una clase.</span><span class="sxs-lookup"><span data-stu-id="70e4b-125">To further emphasize that we're not using inheritance, you'll make each shape a `struct` instead of a class.</span></span> <span data-ttu-id="70e4b-126">Observe que los distintos tipos `struct` no pueden especificar un tipo base común definido por el usuario, por lo que la herencia no es un diseño posible.</span><span class="sxs-lookup"><span data-stu-id="70e4b-126">Note that different `struct` types cannot specify a common user defined base type, so inheritance is not a possible design.</span></span>
<span data-ttu-id="70e4b-127">Conforme avance en este ejemplo, compare este código con cómo se estructuraría como una jerarquía de objetos.</span><span class="sxs-lookup"><span data-stu-id="70e4b-127">As you go through this sample, contrast this code with how it would be structured as an object hierarchy.</span></span> <span data-ttu-id="70e4b-128">Cuando los datos que se deben consultar y manipular no son una jerarquía de clases, la coincidencia de patrones permite diseños muy elegantes.</span><span class="sxs-lookup"><span data-stu-id="70e4b-128">When the data you must query and manipulate is not a class hierarchy, pattern matching enables very elegant designs.</span></span>

<span data-ttu-id="70e4b-129">En lugar de empezar con una definición de forma abstracta y agregar diferentes clases de formas concretas, se comenzará con simples definiciones solo de datos para cada una de las formas geométricas:</span><span class="sxs-lookup"><span data-stu-id="70e4b-129">Rather than starting with an abstract shape definition and adding different specific shape classes, let's start instead with simple data only definitions for each of the geometric shapes:</span></span>

[!code-csharp[ShapeDefinitions](../../samples/csharp/PatternMatching/Shapes.cs#01_ShapeDefinitions "Shape definitions")]

<span data-ttu-id="70e4b-130">A partir de estas estructuras se va a escribir un método que calcula el área de alguna forma.</span><span class="sxs-lookup"><span data-stu-id="70e4b-130">From these structures, let's write a method that computes the area of some shape.</span></span>

## <a name="the-is-type-pattern-expression"></a><span data-ttu-id="70e4b-131">Expresión de patrón de tipo `is`</span><span class="sxs-lookup"><span data-stu-id="70e4b-131">The `is` type pattern expression</span></span>

<span data-ttu-id="70e4b-132">Antes de C# 7, había que comprobar cada tipo en una serie de instrucciones `if` e `is`:</span><span class="sxs-lookup"><span data-stu-id="70e4b-132">Before C# 7, you'd need to test each type in a series of `if` and `is` statements:</span></span>

[!code-csharp[ClassicIsExpression](../../samples/csharp/PatternMatching/GeometricUtilities.cs#02_ClassicIsExpression "Classic type pattern using is")]

<span data-ttu-id="70e4b-133">El código anterior es una expresión clásica de la *coincidencia de tipos*: se prueba una variable para determinar su tipo y se realiza una acción diferente basada en ese tipo.</span><span class="sxs-lookup"><span data-stu-id="70e4b-133">That code above is a classic expression of the *type pattern*: You're testing a variable to determine its type and taking a different action based on that type.</span></span>

<span data-ttu-id="70e4b-134">Este código se simplifica con extensiones de la expresión `is` para asignar una variable si la prueba se realiza correctamente:</span><span class="sxs-lookup"><span data-stu-id="70e4b-134">This code becomes simpler using extensions to the `is` expression to assign a variable if the test succeeds:</span></span>

[!code-csharp[IsPatternExpression](../../samples/csharp/PatternMatching/GeometricUtilities.cs#03_IsPatternExpression "is pattern expression")]

<span data-ttu-id="70e4b-135">En esta versión actualizada, la expresión `is` prueba la variable y la asigna a una nueva variable del tipo correcto.</span><span class="sxs-lookup"><span data-stu-id="70e4b-135">In this updated version, the `is` expression both tests the variable and assigns it to a new variable of the proper type.</span></span> <span data-ttu-id="70e4b-136">Observe también que esta versión incluye el tipo `Rectangle`, que es un elemento `struct`.</span><span class="sxs-lookup"><span data-stu-id="70e4b-136">Also, notice that this version includes the `Rectangle` type, which is a `struct`.</span></span> <span data-ttu-id="70e4b-137">La nueva expresión `is` funciona con tipos de valor y con tipos de referencia.</span><span class="sxs-lookup"><span data-stu-id="70e4b-137">The new `is` expression works with value types as well as reference types.</span></span>

<span data-ttu-id="70e4b-138">Las reglas del lenguaje para las expresiones de coincidencia de patrones ayudan a evitar el uso indebido de los resultados de una expresión de coincidencia.</span><span class="sxs-lookup"><span data-stu-id="70e4b-138">Language rules for pattern matching expressions help you avoid misusing the results of a match expression.</span></span> <span data-ttu-id="70e4b-139">En el ejemplo anterior, las variables `s`, `c` y `r` solo están en el ámbito y se asignan definitivamente cuando las expresiones de coincidencia de patrones respectivas tienen resultados `true`.</span><span class="sxs-lookup"><span data-stu-id="70e4b-139">In the example above, the variables `s`, `c`, and `r` are only in scope and definitely assigned when the respective pattern match expressions have `true` results.</span></span> <span data-ttu-id="70e4b-140">Si intenta usar una de las variables en otra ubicación, el código genera errores del compilador.</span><span class="sxs-lookup"><span data-stu-id="70e4b-140">If you try to use either variable in another location, your code generates compiler errors.</span></span>

<span data-ttu-id="70e4b-141">Vamos a examinar detenidamente esas dos reglas, a partir del ámbito.</span><span class="sxs-lookup"><span data-stu-id="70e4b-141">Let's examine both of those rules in detail, beginning with scope.</span></span> <span data-ttu-id="70e4b-142">La variable `c` está en el ámbito únicamente en la rama `else` de la primera instrucción `if`.</span><span class="sxs-lookup"><span data-stu-id="70e4b-142">The variable `c` is in scope only in the `else` branch of the first `if` statement.</span></span> <span data-ttu-id="70e4b-143">La variable `s` está en el ámbito en el método `ComputeArea`.</span><span class="sxs-lookup"><span data-stu-id="70e4b-143">The variable `s` is in scope in the method `ComputeArea`.</span></span> <span data-ttu-id="70e4b-144">Eso se debe a que cada rama de una instrucción `if` establece un ámbito independiente para las variables.</span><span class="sxs-lookup"><span data-stu-id="70e4b-144">That's because each branch of an `if` statement establishes a separate scope for variables.</span></span> <span data-ttu-id="70e4b-145">Pero la propia instrucción `if` no.</span><span class="sxs-lookup"><span data-stu-id="70e4b-145">However, the `if` statement itself does not.</span></span> <span data-ttu-id="70e4b-146">Eso significa que las variables declaradas en la instrucción `if` están en el mismo ámbito que la instrucción `if` (el método en este caso). Este comportamiento no es específico de la coincidencia de patrones, sino que es el definido para los ámbitos de variable y las instrucciones `if` y `else`.</span><span class="sxs-lookup"><span data-stu-id="70e4b-146">That means variables declared in the `if` statement are in the same scope as the `if` statement (the method in this case.) This behavior is not specific to pattern matching, but is the defined behavior for variable scopes and `if` and `else` statements.</span></span>

<span data-ttu-id="70e4b-147">Las variables `c` y `s` se asignan cuando las respectivas instrucciones `if` son true debido al mecanismo when true asignado definitivamente.</span><span class="sxs-lookup"><span data-stu-id="70e4b-147">The variables `c` and `s` are assigned when the respective `if` statements are true because of the definitely assigned when true mechanism.</span></span>

> [!TIP]
> <span data-ttu-id="70e4b-148">En los ejemplos de este tema se usa la construcción recomendada, donde una expresión de coincidencia de patrones `is` asigna definitivamente la variable de coincidencia en la rama `true` de la instrucción `if`.</span><span class="sxs-lookup"><span data-stu-id="70e4b-148">The samples in this topic use the recommended construct where a pattern match `is` expression definitely assigns the match variable in the `true` branch of the `if` statement.</span></span>
> <span data-ttu-id="70e4b-149">Se podría invertir la lógica al decir `if (!(shape is Square s))` y la variable `s` se asignaría definitivamente solo en la rama `false`.</span><span class="sxs-lookup"><span data-stu-id="70e4b-149">You could reverse the logic by saying `if (!(shape is Square s))` and the variable `s` would be definitely assigned only in the `false` branch.</span></span> <span data-ttu-id="70e4b-150">Aunque esto es C# válido, no se recomienda, porque es más confuso para seguir la lógica.</span><span class="sxs-lookup"><span data-stu-id="70e4b-150">While this is valid C#, it is not recommended because it is more confusing to follow the logic.</span></span>

<span data-ttu-id="70e4b-151">Estas reglas significan que es poco probable que se acceda accidentalmente al resultado de una expresión de coincidencia de patrones cuando no ha habido coincidencia de ese patrón.</span><span class="sxs-lookup"><span data-stu-id="70e4b-151">These rules mean that you are unlikely to accidentally access the result of a pattern match expression when that pattern was not met.</span></span>

## <a name="using-pattern-matching-switch-statements"></a><span data-ttu-id="70e4b-152">Uso de instrucciones de coincidencia de patrones `switch`</span><span class="sxs-lookup"><span data-stu-id="70e4b-152">Using pattern matching `switch` statements</span></span>

<span data-ttu-id="70e4b-153">Con el tiempo, es posible que tenga que admitir otros tipos de formas.</span><span class="sxs-lookup"><span data-stu-id="70e4b-153">As time goes on, you may need to support other shape types.</span></span> <span data-ttu-id="70e4b-154">A medida que crece el número de condiciones que se está probando, puede resultar pesado el uso de expresiones de coincidencia de patrones `is`.</span><span class="sxs-lookup"><span data-stu-id="70e4b-154">As the number of conditions you are testing grows, you'll find that using the `is` pattern matching expressions can become cumbersome.</span></span> <span data-ttu-id="70e4b-155">Además de necesitar instrucciones `if` en cada tipo que se quiere comprobar, las expresiones `is` solo se pueden probar si la entrada coincide con un único tipo.</span><span class="sxs-lookup"><span data-stu-id="70e4b-155">In addition to requiring `if` statements on each type you want to check, the `is` expressions are limited to testing if the input matches a single type.</span></span> <span data-ttu-id="70e4b-156">En este caso, las expresiones de coincidencia de patrones `switch` son una mejor opción.</span><span class="sxs-lookup"><span data-stu-id="70e4b-156">In this case, you'll find that the `switch` pattern matching expressions becomes a better choice.</span></span> 

<span data-ttu-id="70e4b-157">La instrucción tradicional `switch` era una expresión de patrón: admitía el patrón de constante.</span><span class="sxs-lookup"><span data-stu-id="70e4b-157">The traditional `switch` statement was a pattern expression: it supported the constant pattern.</span></span>
<span data-ttu-id="70e4b-158">Se podía comparar una variable con cualquier constante usada en una instrucción `case`:</span><span class="sxs-lookup"><span data-stu-id="70e4b-158">You could compare a variable to any constant used in a `case` statement:</span></span>

[!code-csharp[ClassicSwitch](../../samples/csharp/PatternMatching/GeometricUtilities.cs#04_ClassicSwitch "Classic switch statement")]

<span data-ttu-id="70e4b-159">El único patrón admitido por la instrucción `switch` era el patrón de constante.</span><span class="sxs-lookup"><span data-stu-id="70e4b-159">The only pattern supported by the `switch` statement was the constant pattern.</span></span> <span data-ttu-id="70e4b-160">Se limitaba aún más a tipos numéricos y al tipo `string`.</span><span class="sxs-lookup"><span data-stu-id="70e4b-160">It was further limited to numeric types and the `string` type.</span></span>
<span data-ttu-id="70e4b-161">Esas restricciones se han eliminado y ahora se puede escribir una instrucción `switch` con el patrón de tipos:</span><span class="sxs-lookup"><span data-stu-id="70e4b-161">Those restrictions have been removed, and you can now write a `switch` statement using the type pattern:</span></span>

[!code-csharp[Switch Type Pattern](../../samples/csharp/PatternMatching/GeometricUtilities.cs#05_SwitchTypePattern "Compute with `switch` expression")]

<span data-ttu-id="70e4b-162">La instrucción de coincidencia de patrones `switch` usa una sintaxis familiar para los desarrolladores que han empleado la instrucción de estilo C tradicional `switch`.</span><span class="sxs-lookup"><span data-stu-id="70e4b-162">The pattern matching `switch` statement uses familiar syntax to developers who have used the traditional C-style `switch` statement.</span></span> <span data-ttu-id="70e4b-163">Cada `case` se evalúa y se ejecuta el código debajo de la condición que coincide con la variable de entrada.</span><span class="sxs-lookup"><span data-stu-id="70e4b-163">Each `case` is evaluated and the code beneath the condition that matches the input variable is executed.</span></span> <span data-ttu-id="70e4b-164">La ejecución de código no puede "pasar explícitamente" de una expresión case a la siguiente; la sintaxis de la instrucción `case` exige que cada `case` termine con `break`, `return` o `goto`.</span><span class="sxs-lookup"><span data-stu-id="70e4b-164">Code execution cannot "fall through" from one case expression to the next; the syntax of the `case` statement requires that each `case` end with a `break`, `return`, or `goto`.</span></span>

> [!NOTE]
> <span data-ttu-id="70e4b-165">Las instrucciones `goto` para saltar a otra etiqueta solo son válidas para el patrón de constante, la instrucción switch clásica.</span><span class="sxs-lookup"><span data-stu-id="70e4b-165">The `goto` statements to jump to another label are valid only for the constant pattern, the classic switch statement.</span></span>

<span data-ttu-id="70e4b-166">Hay nuevas e importantes reglas que rigen la instrucción `switch`.</span><span class="sxs-lookup"><span data-stu-id="70e4b-166">There are important new rules governing the `switch` statement.</span></span> <span data-ttu-id="70e4b-167">Las restricciones respecto al tipo de la variable en la expresión `switch` se han eliminado.</span><span class="sxs-lookup"><span data-stu-id="70e4b-167">The restrictions on the type of the variable in the `switch` expression have been removed.</span></span>
<span data-ttu-id="70e4b-168">Se puede usar cualquier tipo, como `object` en este ejemplo.</span><span class="sxs-lookup"><span data-stu-id="70e4b-168">Any type, such as `object` in this example, may be used.</span></span> <span data-ttu-id="70e4b-169">Las expresiones case ya no se limitan a valores constantes.</span><span class="sxs-lookup"><span data-stu-id="70e4b-169">The case expressions are no longer limited to constant values.</span></span> <span data-ttu-id="70e4b-170">La eliminación de esa limitación significa que la reordenación de secciones `switch` puede cambiar el comportamiento de un programa.</span><span class="sxs-lookup"><span data-stu-id="70e4b-170">Removing that limitation means that reordering `switch` sections may change a program's behavior.</span></span>

<span data-ttu-id="70e4b-171">Cuando se limitaba a valores constantes, más de una etiqueta `case` podía coincidir con el valor de la expresión `switch`.</span><span class="sxs-lookup"><span data-stu-id="70e4b-171">When limited to constant values, no more than one `case` label could match the value of the `switch` expression.</span></span> <span data-ttu-id="70e4b-172">Eso sumado a la regla de que cada sección `switch` no debe pasar explícitamente a la sección siguiente, el resultado era que las secciones `switch` se podían reorganizar en cualquier orden sin afectar al comportamiento.</span><span class="sxs-lookup"><span data-stu-id="70e4b-172">Combine that with the rule that every `switch` section must not fall through to the next section, and it followed that the `switch` sections could be rearranged in any order without affecting behavior.</span></span>
<span data-ttu-id="70e4b-173">Ahora, con expresiones `switch` más generalizadas, el orden de cada sección importa.</span><span class="sxs-lookup"><span data-stu-id="70e4b-173">Now, with more generalized `switch` expressions, the order of each section matters.</span></span> <span data-ttu-id="70e4b-174">Las expresiones `switch` se evalúan en orden textual.</span><span class="sxs-lookup"><span data-stu-id="70e4b-174">The `switch` expressions are evaluated in textual order.</span></span> <span data-ttu-id="70e4b-175">La ejecución se transfiere a la primera etiqueta `switch` que coincide con la expresión `switch`.</span><span class="sxs-lookup"><span data-stu-id="70e4b-175">Execution transfers to the first `switch` label that matches the `switch` expression.</span></span>  
<span data-ttu-id="70e4b-176">Observe que el caso `default` solo se ejecuta si ninguna otra etiqueta case coincide.</span><span class="sxs-lookup"><span data-stu-id="70e4b-176">Note that the `default` case will only be executed if no other case labels match.</span></span> <span data-ttu-id="70e4b-177">El caso `default` se evalúa en último lugar, independientemente de su orden textual.</span><span class="sxs-lookup"><span data-stu-id="70e4b-177">The `default` case is evaluated last, regardless of its textual order.</span></span> <span data-ttu-id="70e4b-178">Si no hay ningún caso `default` y ninguna de las instrucciones `case` coincide, la ejecución continúa en la instrucción siguiente a la instrucción `switch`.</span><span class="sxs-lookup"><span data-stu-id="70e4b-178">If there is no `default` case, and none of the other `case` statements match, execution continues at the statement following the `switch` statement.</span></span> <span data-ttu-id="70e4b-179">No se ejecuta el código de ninguna de las etiquetas `case`.</span><span class="sxs-lookup"><span data-stu-id="70e4b-179">None of the `case` labels code is executed.</span></span>

## <a name="when-clauses-in-case-expressions"></a><span data-ttu-id="70e4b-180">Cláusulas `when` en expresiones `case`</span><span class="sxs-lookup"><span data-stu-id="70e4b-180">`when` clauses in `case` expressions</span></span>

<span data-ttu-id="70e4b-181">Puede crear casos especiales para las formas que tengan área 0 mediante una cláusula `when` en la etiqueta `case`.</span><span class="sxs-lookup"><span data-stu-id="70e4b-181">You can make special cases for those shapes that have 0 area by using a `when` clause on the `case` label.</span></span> <span data-ttu-id="70e4b-182">Un cuadrado con una longitud de lado de 0 o un círculo con un radio de 0 tiene un área 0.</span><span class="sxs-lookup"><span data-stu-id="70e4b-182">A square with a side length of 0, or a circle with a radius of 0 has a 0 area.</span></span> <span data-ttu-id="70e4b-183">Esa condición se especifica mediante una cláusula `when` en la etiqueta `case`:</span><span class="sxs-lookup"><span data-stu-id="70e4b-183">You specify that condition using a `when` clause on the `case` label:</span></span>  

[!code-csharp[ComputeDegenerateShapes](../../samples/csharp/PatternMatching/GeometricUtilities.cs#07_ComputeDegenerateShapes "Compute shapes with 0 area")]

<span data-ttu-id="70e4b-184">Este cambio muestra algunos puntos importantes sobre la nueva sintaxis.</span><span class="sxs-lookup"><span data-stu-id="70e4b-184">This change demonstrates a few important points about the new syntax.</span></span> <span data-ttu-id="70e4b-185">En primer lugar, se pueden aplicar varias etiquetas `case` a una sección `switch`.</span><span class="sxs-lookup"><span data-stu-id="70e4b-185">First, multiple `case` labels can be applied to one `switch` section.</span></span> <span data-ttu-id="70e4b-186">El bloque de instrucciones se ejecuta cuando cualquiera de esas etiquetas es `true`.</span><span class="sxs-lookup"><span data-stu-id="70e4b-186">The statement block is executed when any of those labels is `true`.</span></span> <span data-ttu-id="70e4b-187">En esta instancia, si la expresión `switch` es un círculo o un cuadrado con área 0, el método devuelve la constante 0.</span><span class="sxs-lookup"><span data-stu-id="70e4b-187">In this instance, if the `switch` expression is either a circle or a square with 0 area, the method returns the constant 0.</span></span>

<span data-ttu-id="70e4b-188">Este ejemplo presenta dos variables distintas en las dos etiquetas `case` del primer bloque `switch`.</span><span class="sxs-lookup"><span data-stu-id="70e4b-188">This example introduces two different variables in the two `case` labels for the first `switch` block.</span></span> <span data-ttu-id="70e4b-189">Observe que las instrucciones de este bloque `switch` no usan las variables `c` (para el círculo) ni `s` (para el cuadrado).</span><span class="sxs-lookup"><span data-stu-id="70e4b-189">Notice that the statements in this `switch` block do not use either the variables `c` (for the circle) or `s` (for the square).</span></span>
<span data-ttu-id="70e4b-190">Ninguna de esas variables se ha asignado definitivamente en este bloque `switch`.</span><span class="sxs-lookup"><span data-stu-id="70e4b-190">Neither of those variables is definitely assigned in this `switch` block.</span></span>
<span data-ttu-id="70e4b-191">Si alguno de estos casos coincide, claramente se ha asignado una de las variables.</span><span class="sxs-lookup"><span data-stu-id="70e4b-191">If either of these cases match, clearly one of the variables has been assigned.</span></span>
<span data-ttu-id="70e4b-192">Pero no es posible saber *cuál* se ha asignado en tiempo de compilación, ya que cualquiera de los casos podría coincidir en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="70e4b-192">However, it is impossible to tell *which* has been assigned at compile-time, because either case could match at runtime.</span></span> <span data-ttu-id="70e4b-193">Por ese motivo, la mayoría de las veces en que se usan varias etiquetas `case` para el mismo bloque, no se presenta una nueva variable en la instrucción `case` o solo se usa la variable en la cláusula `when`.</span><span class="sxs-lookup"><span data-stu-id="70e4b-193">For that reason, most times when you use multiple `case` labels for the same block, you won't introduce a new variable in the `case` statement, or you will only use the variable in the `when` clause.</span></span>

<span data-ttu-id="70e4b-194">Una vez agregadas esas formas con área 0, se van a agregar un par de tipos de formas más: un rectángulo y un triángulo:</span><span class="sxs-lookup"><span data-stu-id="70e4b-194">Having added those shapes with 0 area, let's add a couple more shape types: a rectangle and a triangle:</span></span>

[!code-csharp[AddRectangleAndTriangle](../../samples/csharp/PatternMatching/GeometricUtilities.cs#09_AddRectangleAndTriangle "Add rectangle and triangle")]

 <span data-ttu-id="70e4b-195">Este conjunto de cambios agrega etiquetas `case` para el caso degenerado y etiquetas y bloques para cada una de las nuevas formas.</span><span class="sxs-lookup"><span data-stu-id="70e4b-195">This set of changes adds `case` labels for the degenerate case, and labels and blocks for each of the new shapes.</span></span> 

<span data-ttu-id="70e4b-196">Por último, puede agregar un caso `null` para garantizar que el argumento no sea `null`:</span><span class="sxs-lookup"><span data-stu-id="70e4b-196">Finally, you can add a `null` case to ensure the argument is not `null`:</span></span>

[!code-csharp[NullCase](../../samples/csharp/PatternMatching/GeometricUtilities.cs#10_NullCase "Add null case")]

<span data-ttu-id="70e4b-197">El comportamiento especial del patrón `null` es interesante porque la constante `null` del patrón no tiene un tipo, pero se puede convertir a cualquier tipo de referencia o tipo que acepte valores NULL.</span><span class="sxs-lookup"><span data-stu-id="70e4b-197">The special behavior for the `null` pattern is interesting because the constant `null` in the pattern does not have a type but can be converted to any reference type or nullable type.</span></span> <span data-ttu-id="70e4b-198">En lugar de convertir `null` en cualquier tipo, el lenguaje define que un valor `null` no coincidirá con ningún patrón de tipo, independientemente del tipo de tiempo de compilación de la variable.</span><span class="sxs-lookup"><span data-stu-id="70e4b-198">Rather than convert a `null` to any type, the language defines that a `null` value will not match any type pattern, regardless of the compile-time type of the variable.</span></span> <span data-ttu-id="70e4b-199">Este comportamiento hace que el nuevo patrón de tipo basado en `switch` sea coherente con la instrucción `is`: las instrucciones `is` siempre devuelven `false` cuando el valor que se está comprobando es `null`.</span><span class="sxs-lookup"><span data-stu-id="70e4b-199">This behavior makes the new `switch` based type pattern consistent with the `is` statement: `is` statements always return `false` when the value being checked is `null`.</span></span> <span data-ttu-id="70e4b-200">También es más sencillo: una vez que haya comprobado el tipo, no necesita una comprobación de NULL adicional.</span><span class="sxs-lookup"><span data-stu-id="70e4b-200">It's also simpler: once you have checked the type, you don't need an additional null check.</span></span> <span data-ttu-id="70e4b-201">Puede comprobar esto en que no existen comprobaciones de NULL en ninguno de los bloques de casos de los ejemplos anteriores: no son necesarias, ya que la coincidencia del patrón de tipo garantiza un valor distinto de NULL.</span><span class="sxs-lookup"><span data-stu-id="70e4b-201">You can see that from the fact that there are no null checks in any of the case blocks of the samples above: they are not necessary, since matching the type pattern guarantees a non-null value.</span></span>

## <a name="var-declarations-in-case-expressions"></a><span data-ttu-id="70e4b-202">`var`las declaraciones de `case` expresiones</span><span class="sxs-lookup"><span data-stu-id="70e4b-202">`var` declarations in `case` expressions</span></span>

<span data-ttu-id="70e4b-203">La introducción de `var` como una de las expresiones de coincidencia presenta nuevas reglas para la búsqueda de coincidencias de patrón.</span><span class="sxs-lookup"><span data-stu-id="70e4b-203">The introduction of `var` as one of the match expressions introduces new rules to the pattern match.</span></span>

<span data-ttu-id="70e4b-204">La primera regla es que el `var` declaración sigue las reglas de inferencia de tipo normal: el tipo se deduce que el tipo estático de la expresión switch.</span><span class="sxs-lookup"><span data-stu-id="70e4b-204">The first rule is that the `var` declaration follows the normal type inference rules: The type is inferred to be the static type of the switch expression.</span></span> <span data-ttu-id="70e4b-205">De esa regla, el tipo siempre coincide con.</span><span class="sxs-lookup"><span data-stu-id="70e4b-205">From that rule, the type always matches.</span></span>

<span data-ttu-id="70e4b-206">La segunda regla es que un `var` declaración no tiene la comprobación de valores null que incluyen otras expresiones de patrón de tipo.</span><span class="sxs-lookup"><span data-stu-id="70e4b-206">The second rule is that a `var` declaration does not have the null check that other type pattern expressions include.</span></span> <span data-ttu-id="70e4b-207">Esto significa que la variable puede ser null y una comprobación de valores null en ese caso es necesaria.</span><span class="sxs-lookup"><span data-stu-id="70e4b-207">That means the variable may be null, and a null check is necessary in that case.</span></span>

<span data-ttu-id="70e4b-208">Esas dos reglas significan que en muchos casos, un `var` declaración en un `case` expresión coincide con las mismas condiciones que un `default` expresión.</span><span class="sxs-lookup"><span data-stu-id="70e4b-208">Those two rules mean that in many instances, a `var` declaration in a `case` expression matches the same conditions as a `default` expression.</span></span>
<span data-ttu-id="70e4b-209">Dado que es preferible a un caso de no predeterminado el `default` caso, el `default` caso nunca se ejecutará.</span><span class="sxs-lookup"><span data-stu-id="70e4b-209">Because any non-default case is preferred to the `default` case, the `default` case will never execute.</span></span>

> [!NOTE]
> <span data-ttu-id="70e4b-210">El compilador no emite una advertencia en los casos donde un `default` caso se ha escrito, pero nunca se ejecutará.</span><span class="sxs-lookup"><span data-stu-id="70e4b-210">The compiler does not emit a warning in those cases where a `default` case has been written but will never execute.</span></span> <span data-ttu-id="70e4b-211">Esto es coherente con la actual `switch` comportamiento de la instrucción donde se han enumerado todos los casos posibles.</span><span class="sxs-lookup"><span data-stu-id="70e4b-211">This is consistent with current `switch` statement behavior where all possible cases have been listed.</span></span>

<span data-ttu-id="70e4b-212">La tercera regla presenta utiliza donde un `var` caso puede resultar útil.</span><span class="sxs-lookup"><span data-stu-id="70e4b-212">The third rule introduces uses where a `var` case may be useful.</span></span> <span data-ttu-id="70e4b-213">Imagine que va a realizar a una coincidencia de patrones donde la entrada es una cadena y que está buscando valores de comando conocidos.</span><span class="sxs-lookup"><span data-stu-id="70e4b-213">Imagine that you are doing a pattern match where the input is a string and you are searching for known command values.</span></span> <span data-ttu-id="70e4b-214">Podría escribir algo parecido:</span><span class="sxs-lookup"><span data-stu-id="70e4b-214">You might write something like:</span></span>

[!code-csharp[VarCaseExpression](../../samples/csharp/PatternMatching/Program.cs#VarCaseExpression "use a var case expression to filter white space")]

<span data-ttu-id="70e4b-215">El `var` caso coincidencias `null`, la cadena vacía, o cualquier cadena que contiene solo espacios en blanco.</span><span class="sxs-lookup"><span data-stu-id="70e4b-215">The `var` case matches `null`, the empty string, or any string that contains only whitespace.</span></span> <span data-ttu-id="70e4b-216">Tenga en cuenta que el código anterior usa el `?.` operador para asegurarse de que produce por accidente un <xref:System.NullReferenceException>.</span><span class="sxs-lookup"><span data-stu-id="70e4b-216">Notice that the preceding code uses the `?.` operator to ensure that it does not accidentally throw a <xref:System.NullReferenceException>.</span></span> <span data-ttu-id="70e4b-217">El `default` caso controla cualquier otro valor de cadena que no se entiende este analizador de comando.</span><span class="sxs-lookup"><span data-stu-id="70e4b-217">The `default` case handles any other string values that are not understood by this command parser.</span></span>

<span data-ttu-id="70e4b-218">Este es un ejemplo donde puede que desee tener en cuenta un `var` caso expresión que es distinta de una `default` expresión.</span><span class="sxs-lookup"><span data-stu-id="70e4b-218">This is one example where you may want to consider a `var` case expression that is distinct from a `default` expression.</span></span>

## <a name="conclusions"></a><span data-ttu-id="70e4b-219">Conclusiones</span><span class="sxs-lookup"><span data-stu-id="70e4b-219">Conclusions</span></span>

<span data-ttu-id="70e4b-220">Las *construcciones de coincidencia de patrones* permiten administrar fácilmente el flujo de control entre distintas variables y tipos que no están relacionados mediante una jerarquía de herencia.</span><span class="sxs-lookup"><span data-stu-id="70e4b-220">*Pattern Matching constructs* enable you to easily manage control flow among different variables and types that are not related by an inheritance hierarchy.</span></span> <span data-ttu-id="70e4b-221">También se puede controlar la lógica para usar cualquier condición que se pruebe en la variable.</span><span class="sxs-lookup"><span data-stu-id="70e4b-221">You can also control logic to use any condition you test on the variable.</span></span> <span data-ttu-id="70e4b-222">Permite patrones y expresiones que se van a necesitar más a menudo a medida que se crean aplicaciones más distribuidas, donde los datos y los métodos que los manipulan están separados.</span><span class="sxs-lookup"><span data-stu-id="70e4b-222">It enables patterns and idioms that you'll need more often as you build more distributed applications, where data and the methods that manipulate that data are separate.</span></span> <span data-ttu-id="70e4b-223">Observará que las estructuras de forma usadas en este ejemplo no contienen métodos, solo propiedades de solo lectura.</span><span class="sxs-lookup"><span data-stu-id="70e4b-223">You'll notice that the shape structs used in this sample do not contain any methods, just read-only properties.</span></span>
<span data-ttu-id="70e4b-224">La coincidencia de patrones funciona con cualquier tipo de datos.</span><span class="sxs-lookup"><span data-stu-id="70e4b-224">Pattern Matching works with any data type.</span></span> <span data-ttu-id="70e4b-225">Se escriben expresiones que examinan el objeto y se toman decisiones de flujo de control basadas en esas condiciones.</span><span class="sxs-lookup"><span data-stu-id="70e4b-225">You write expressions that examine the object, and make control flow decisions based on those conditions.</span></span>

<span data-ttu-id="70e4b-226">Compare el código de este ejemplo con el diseño que se obtendría al crear una jerarquía de clases para un elemento `Shape` abstracto y formas derivadas concretas cada una con su propia implementación de un método virtual para calcular el área.</span><span class="sxs-lookup"><span data-stu-id="70e4b-226">Compare the code from this sample with the design that would follow from creating a class hierarchy for an abstract `Shape` and specific derived shapes each with their own implementation of a virtual method to calculate the area.</span></span> <span data-ttu-id="70e4b-227">A menudo encontrará que las expresiones de coincidencia de patrones pueden ser una herramienta muy útil al trabajar con datos y querer separar las preocupaciones sobre almacenamiento de datos de las preocupaciones sobre comportamiento.</span><span class="sxs-lookup"><span data-stu-id="70e4b-227">You'll often find that pattern matching expressions can be a very useful tool when you are working with data and want to separate the data storage concerns from the behavior concerns.</span></span>

