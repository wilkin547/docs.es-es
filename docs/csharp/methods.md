---
title: 'Métodos: Guía de C#'
description: Información general sobre métodos, parámetros de método y valores devueltos de método
ms.technology: csharp-fundamentals
ms.date: 05/21/2018
ms.assetid: 577a8527-1081-4b36-9b9e-0685b6553c6e
ms.openlocfilehash: 09a287b3d74e1b8dbdaf4a53cb207dfe1fad8a0c
ms.sourcegitcommit: 7476c20d2f911a834a00b8a7f5e8926bae6804d9
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 08/11/2020
ms.locfileid: "88063359"
---
# <a name="methods"></a><span data-ttu-id="9a7b3-103">Métodos</span><span class="sxs-lookup"><span data-stu-id="9a7b3-103">Methods</span></span>

<span data-ttu-id="9a7b3-104">Un método es un bloque de código que contiene una serie de instrucciones.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-104">A method is a code block that contains a series of statements.</span></span> <span data-ttu-id="9a7b3-105">Un programa hace que se ejecuten las instrucciones al llamar al método y especificando los argumentos de método necesarios.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-105">A program causes the statements to be executed by calling the method and specifying any required method arguments.</span></span> <span data-ttu-id="9a7b3-106">En C#, todas las instrucciones ejecutadas se realizan en el contexto de un método.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-106">In C#, every executed instruction is performed in the context of a method.</span></span> <span data-ttu-id="9a7b3-107">El método `Main` es el punto de entrada para cada aplicación de C# y se llama mediante Common Language Runtime (CLR) cuando se inicia el programa.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-107">The `Main` method is the entry point for every C# application and it is called by the common language runtime (CLR) when the program is started.</span></span>

> [!NOTE]
> <span data-ttu-id="9a7b3-108">En este tema se analizan los métodos denominados.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-108">This topic discusses named methods.</span></span> <span data-ttu-id="9a7b3-109">Para obtener información sobre las funciones anónimas, vea [Funciones anónimas](programming-guide/statements-expressions-operators/anonymous-functions.md).</span><span class="sxs-lookup"><span data-stu-id="9a7b3-109">For information about anonymous functions, see [Anonymous Functions](programming-guide/statements-expressions-operators/anonymous-functions.md).</span></span>

<a name="signatures"></a>

## <a name="method-signatures"></a><span data-ttu-id="9a7b3-110">Firmas de método</span><span class="sxs-lookup"><span data-stu-id="9a7b3-110">Method signatures</span></span>

<span data-ttu-id="9a7b3-111">Los métodos se declaran en una `class` o `struct` al especificar:</span><span class="sxs-lookup"><span data-stu-id="9a7b3-111">Methods are declared in a `class` or `struct` by specifying:</span></span>

- <span data-ttu-id="9a7b3-112">Un nivel de acceso opcional, como, por ejemplo, `public` o `private`.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-112">An optional access level, such as `public` or `private`.</span></span> <span data-ttu-id="9a7b3-113">De manera predeterminada, es `private`.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-113">The default is `private`.</span></span>
- <span data-ttu-id="9a7b3-114">Modificadores opcionales, como, por ejemplo, `abstract` o `sealed`.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-114">Optional modifiers such as `abstract` or `sealed`.</span></span>
- <span data-ttu-id="9a7b3-115">El valor devuelto o, si el método no tiene ninguno, `void`.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-115">The return value, or `void` if the method has none.</span></span>
- <span data-ttu-id="9a7b3-116">El nombre del método.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-116">The method name.</span></span>
- <span data-ttu-id="9a7b3-117">Los parámetros del método.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-117">Any method parameters.</span></span> <span data-ttu-id="9a7b3-118">Los parámetros de método se encierran entre paréntesis y se separan por comas.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-118">Method parameters are enclosed in parentheses and are separated by commas.</span></span> <span data-ttu-id="9a7b3-119">Los paréntesis vacíos indican que el método no requiere parámetros.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-119">Empty parentheses indicate that the method requires no parameters.</span></span>

<span data-ttu-id="9a7b3-120">Todas estas partes forman la firma del método.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-120">These parts together form the method signature.</span></span>

> [!NOTE]
> <span data-ttu-id="9a7b3-121">Un tipo de valor devuelto de un método no forma parte de la firma del método con el objetivo de sobrecargar el método.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-121">A return type of a method is not part of the signature of the method for the purposes of method overloading.</span></span> <span data-ttu-id="9a7b3-122">Sin embargo, forma parte de la firma del método al determinar la compatibilidad entre un delegado y el método que señala.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-122">However, it is part of the signature of the method when determining the compatibility between a delegate and the method that it points to.</span></span>

<span data-ttu-id="9a7b3-123">En el siguiente ejemplo se define una clase denominada `Motorcycle` que contiene cinco métodos:</span><span class="sxs-lookup"><span data-stu-id="9a7b3-123">The following example defines a class named `Motorcycle` that contains five methods:</span></span>

[!code-csharp[csSnippets.Methods#40](../../samples/snippets/csharp/concepts/methods/methods40.cs#40)]

<span data-ttu-id="9a7b3-124">Tenga en cuenta que la clase `Motorcycle` incluye un método sobrecargado, `Drive`.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-124">Note that the `Motorcycle` class includes an overloaded method, `Drive`.</span></span> <span data-ttu-id="9a7b3-125">Dos métodos tienen el mismo nombre, pero se deben diferenciar en sus tipos de parámetros.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-125">Two methods have the same name, but must be differentiated by their parameter types.</span></span>

<a name="invocation"></a>

## <a name="method-invocation"></a><span data-ttu-id="9a7b3-126">Invocación de método</span><span class="sxs-lookup"><span data-stu-id="9a7b3-126">Method invocation</span></span>

<span data-ttu-id="9a7b3-127">Los métodos pueden ser de *instancia* o *estáticos*.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-127">Methods can be either *instance* or *static*.</span></span> <span data-ttu-id="9a7b3-128">Para invocar un método de instancia es necesario crear una instancia de un objeto y llamar al método del objeto; el método de una instancia actúa en dicha instancia y sus datos.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-128">Invoking an instance method requires that you instantiate an object and call the method on that object; an instance method operates on that instance and its data.</span></span> <span data-ttu-id="9a7b3-129">Si quiere invocar un método estático, haga referencia al nombre del tipo al que pertenece el método; los métodos estáticos no actúan en datos de instancia.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-129">You invoke a static method by referencing the name of the type to which the method belongs; static methods do not operate on instance data.</span></span> <span data-ttu-id="9a7b3-130">Al intentar llamar a un método estático mediante una instancia de objeto se genera un error del compilador.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-130">Attempting to call a static method through an object instance generates a compiler error.</span></span>

<span data-ttu-id="9a7b3-131">Llamar a un método es como acceder a un campo.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-131">Calling a method is like accessing a field.</span></span> <span data-ttu-id="9a7b3-132">Después del nombre de objeto (si se llama a un método de instancia) o el nombre de tipo (si llama a un método `static`), agregue un punto, el nombre del método y paréntesis.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-132">After the object name (if you are calling an instance method) or the type name (if you are calling a `static` method), add a period, the name of the method, and parentheses.</span></span> <span data-ttu-id="9a7b3-133">Los argumentos se enumeran entre paréntesis y están separados por comas.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-133">Arguments are listed within the parentheses, and are separated by commas.</span></span>

<span data-ttu-id="9a7b3-134">La definición del método especifica los nombres y tipos de todos los parámetros necesarios.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-134">The method definition specifies the names and types of any parameters that are required.</span></span> <span data-ttu-id="9a7b3-135">Cuando un autor de llamada invoca el método, proporciona valores concretos denominados argumentos para cada parámetro.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-135">When a caller invokes the method, it provides concrete values, called arguments, for each parameter.</span></span> <span data-ttu-id="9a7b3-136">Los argumentos deben ser compatibles con el tipo de parámetro, pero el nombre de argumento, si se usa alguno en el código de llamada, no tiene que ser el mismo que el del parámetro con nombre definido en el método.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-136">The arguments must be compatible with the parameter type, but the argument name, if one is used in the calling code, does not have to be the same as the parameter named defined in the method.</span></span> <span data-ttu-id="9a7b3-137">En el ejemplo siguiente, el método `Square` incluye un parámetro único de tipo `int` denominado *i*.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-137">In the following example, the `Square` method includes a single parameter of type `int` named *i*.</span></span> <span data-ttu-id="9a7b3-138">La primera llamada de método pasa al método `Square` una variable de tipo `int` denominada *num*; la segunda, una constante numérica; y la tercera, una expresión.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-138">The first method call passes the `Square` method a variable of type `int` named *num*; the second, a numeric constant; and the third, an expression.</span></span>

[!code-csharp[csSnippets.Methods#74](../../samples/snippets/csharp/concepts/methods/params74.cs#74)]

<span data-ttu-id="9a7b3-139">La forma más común de invocación de método usa argumentos posicionales; proporciona argumentos en el mismo orden que los parámetros de método.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-139">The most common form of method invocation used positional arguments; it supplies arguments in the same order as method parameters.</span></span> <span data-ttu-id="9a7b3-140">Los métodos de la clase `Motorcycle` se pueden llamar como en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-140">The methods of the `Motorcycle` class can therefore be called as in the following example.</span></span> <span data-ttu-id="9a7b3-141">Por ejemplo, la llamada al método `Drive` incluye dos argumentos que se corresponden con los dos parámetros de la sintaxis del método.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-141">The call to the `Drive` method, for example, includes two arguments that correspond to the two parameters in the method's syntax.</span></span> <span data-ttu-id="9a7b3-142">El primero se convierte en el valor del parámetro `miles` y el segundo en el valor del parámetro `speed`.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-142">The first becomes the value of the `miles` parameter, the second the value of the `speed` parameter.</span></span>

[!code-csharp[csSnippets.Methods#41](../../samples/snippets/csharp/concepts/methods/methods40.cs#41)]

<span data-ttu-id="9a7b3-143">También se pueden usar *argumentos con nombre* en lugar de argumentos posicionales al invocar un método.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-143">You can also used *named arguments* instead of positional arguments when invoking a method.</span></span> <span data-ttu-id="9a7b3-144">Cuando se usan argumentos con nombre, el nombre del parámetro se especifica seguido de dos puntos (":") y el argumento.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-144">When using named arguments, you specify the parameter name followed by a colon (":") and the argument.</span></span> <span data-ttu-id="9a7b3-145">Los argumentos del método pueden aparecer en cualquier orden, siempre que todos los argumentos necesarios están presentes.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-145">Arguments to the method can appear in any order, as long as all required arguments are present.</span></span> <span data-ttu-id="9a7b3-146">En el ejemplo siguiente se usan argumentos con nombre para invocar el método `TestMotorcycle.Drive`.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-146">The following example uses named arguments to invoke the `TestMotorcycle.Drive` method.</span></span> <span data-ttu-id="9a7b3-147">En este ejemplo, los argumentos con nombre se pasan en orden inverso desde la lista de parámetros del método.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-147">In this example, the named arguments are passed in the opposite order from the method's parameter list.</span></span>

[!code-csharp[csSnippets.Methods#45](../../samples/snippets/csharp/concepts/methods/named1.cs#45)]

<span data-ttu-id="9a7b3-148">Un método se puede invocar con argumentos posicionales y argumentos con nombre.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-148">You can invoke a method using both positional arguments and named arguments.</span></span> <span data-ttu-id="9a7b3-149">Pero un argumento posicional no puede seguir a un argumento con nombre.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-149">However, a positional argument cannot follow a named argument.</span></span> <span data-ttu-id="9a7b3-150">En el ejemplo siguiente se invoca el método `TestMotorcycle.Drive` del ejemplo anterior con un argumento posicional y un argumento con nombre.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-150">The following example invokes the `TestMotorcycle.Drive` method from the previous example using one positional argument and one named argument.</span></span>

[!code-csharp[csSnippets.Methods#46](../../samples/snippets/csharp/concepts/methods/named2.cs#46)]

<a name="inherited"></a>

## <a name="inherited-and-overridden-methods"></a><span data-ttu-id="9a7b3-151">Métodos heredados e invalidados</span><span class="sxs-lookup"><span data-stu-id="9a7b3-151">Inherited and overridden methods</span></span>

<span data-ttu-id="9a7b3-152">Además de los miembros que se definen explícitamente en un tipo, un tipo hereda miembros definidos en sus clases base.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-152">In addition to the members that are explicitly defined in a type, a type inherits members defined in its base classes.</span></span> <span data-ttu-id="9a7b3-153">Dado que todos los tipos en el sistema de tipo administrado heredan directa o indirectamente de la clase <xref:System.Object>, todos los tipos heredan sus miembros, como <xref:System.Object.Equals(System.Object)>, <xref:System.Object.GetType> y <xref:System.Object.ToString>.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-153">Since all types in the managed type system inherit directly or indirectly from the <xref:System.Object> class, all types inherit its members, such as <xref:System.Object.Equals(System.Object)>, <xref:System.Object.GetType>, and <xref:System.Object.ToString>.</span></span> <span data-ttu-id="9a7b3-154">En el ejemplo siguiente se define una clase `Person`, se crean instancias de dos objetos `Person` y se llama al método `Person.Equals` para determinar si los dos objetos son iguales.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-154">The following example defines a `Person` class, instantiates two `Person` objects, and calls the `Person.Equals` method to determine whether the two objects are equal.</span></span> <span data-ttu-id="9a7b3-155">Pero el método `Equals` no está definido en la clase `Person`; se hereda de <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-155">The `Equals` method, however, is not defined in the `Person` class; it is inherited from <xref:System.Object>.</span></span>

[!code-csharp[csSnippets.Methods#104](../../samples/snippets/csharp/concepts/methods/inherited1.cs#104)]

<span data-ttu-id="9a7b3-156">Los tipos pueden invalidar miembros heredados usando la palabra clave `override` y proporcionando una implementación para el método invalidado.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-156">Types can override inherited members by using the `override` keyword and providing an implementation for the overridden method.</span></span> <span data-ttu-id="9a7b3-157">La firma del método debe ser igual a la del método invalidado.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-157">The method signature must be the same as that of the overridden method.</span></span> <span data-ttu-id="9a7b3-158">El ejemplo siguiente es similar al anterior, salvo que invalida el método <xref:System.Object.Equals(System.Object)>.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-158">The following example is like the previous one, except that it overrides the <xref:System.Object.Equals(System.Object)> method.</span></span> <span data-ttu-id="9a7b3-159">(También invalida el método <xref:System.Object.GetHashCode>, ya que los dos métodos están diseñados para proporcionar resultados coherentes).</span><span class="sxs-lookup"><span data-stu-id="9a7b3-159">(It also overrides the <xref:System.Object.GetHashCode> method, since the two methods are intended to provide consistent results.)</span></span>

[!code-csharp[csSnippets.Methods#105](../../samples/snippets/csharp/concepts/methods/overridden1.cs#105)]

<a name="passing"></a>

## <a name="passing-parameters"></a><span data-ttu-id="9a7b3-160">Pasar parámetros</span><span class="sxs-lookup"><span data-stu-id="9a7b3-160">Passing parameters</span></span>

<span data-ttu-id="9a7b3-161">Todos los tipos de C# son *tipos de valor* o *tipos de referencia*.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-161">Types in C# are either *value types* or *reference types*.</span></span> <span data-ttu-id="9a7b3-162">Para obtener una lista de tipos de valor integrados, vea [Tipos](./tour-of-csharp/types.md).</span><span class="sxs-lookup"><span data-stu-id="9a7b3-162">For a list of built-in value types, see [Types](./tour-of-csharp/types.md).</span></span> <span data-ttu-id="9a7b3-163">De forma predeterminada, los tipos de valor y los tipos de referencia se pasan a un método por valor.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-163">By default, both value types and reference types are passed to a method by value.</span></span>

<a name="byval"></a>

### <a name="passing-parameters-by-value"></a><span data-ttu-id="9a7b3-164">Pasar parámetros por valor</span><span class="sxs-lookup"><span data-stu-id="9a7b3-164">Passing parameters by value</span></span>

<span data-ttu-id="9a7b3-165">Cuando un tipo de valor se pasa a un método por valor, se pasa una copia del objeto y no el propio objeto.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-165">When a value type is passed to a method by value, a copy of the object instead of the object itself is passed to the method.</span></span> <span data-ttu-id="9a7b3-166">Por lo tanto, los cambios realizados en el objeto en el método llamado no tienen ningún efecto en el objeto original cuando el control vuelve al autor de la llamada.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-166">Therefore, changes to the object in the called method have no effect on the original object when control returns to the caller.</span></span>

<span data-ttu-id="9a7b3-167">En el ejemplo siguiente se pasa un tipo de valor a un método por valor, y el método llamado intenta cambiar el valor del tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-167">The following example passes a value type to a method by value, and the called method attempts to change the value type's value.</span></span> <span data-ttu-id="9a7b3-168">Define una variable de tipo `int`, que es un tipo de valor, inicializa su valor en 20 y lo pasa a un método denominado `ModifyValue` que cambia el valor de la variable a 30.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-168">It defines a variable of type `int`, which is a value type, initializes its value to 20, and passes it to a method named `ModifyValue` that changes the variable's value to 30.</span></span> <span data-ttu-id="9a7b3-169">Pero cuando el método vuelve, el valor de la variable no cambia.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-169">When the method returns, however, the variable's value remains unchanged.</span></span>

[!code-csharp[csSnippets.Methods#10](../../samples/snippets/csharp/concepts/methods/byvalue10.cs#10)]

<span data-ttu-id="9a7b3-170">Cuando un objeto de un tipo de referencia se pasa a un método por valor, se pasa por valor una referencia al objeto.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-170">When an object of a reference type is passed to a method by value, a reference to the object is passed by value.</span></span> <span data-ttu-id="9a7b3-171">Es decir, el método no recibe el objeto concreto, sino un argumento que indica la ubicación del objeto.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-171">That is, the method receives not the object itself, but an argument that indicates the location of the object.</span></span> <span data-ttu-id="9a7b3-172">Si cambia un miembro del objeto mediante esta referencia, el cambio se reflejará en el objeto cuando el control vuelva al método de llamada.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-172">If you change a member of the object by using this reference, the change is reflected in the object when control returns to the calling method.</span></span> <span data-ttu-id="9a7b3-173">Pero el reemplazo del objeto pasado al método no tendrá ningún efecto en el objeto original cuando el control vuelva al autor de la llamada.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-173">However, replacing the object passed to the method has no effect on the original object when control returns to the caller.</span></span>

<span data-ttu-id="9a7b3-174">En el ejemplo siguiente se define una clase (que es un tipo de referencia) denominada `SampleRefType`.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-174">The following example defines a class (which is a reference type) named `SampleRefType`.</span></span> <span data-ttu-id="9a7b3-175">Crea una instancia de un objeto `SampleRefType`, asigna 44 a su campo `value` y pasa el objeto al método `ModifyObject`.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-175">It instantiates a `SampleRefType` object, assigns 44 to its `value` field, and passes the object to the `ModifyObject` method.</span></span> <span data-ttu-id="9a7b3-176">Fundamentalmente, este ejemplo hace lo mismo que el ejemplo anterior: pasa un argumento por valor a un método.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-176">This example does essentially the same thing as the previous example -- it passes an argument by value to a method.</span></span> <span data-ttu-id="9a7b3-177">Pero, debido a que se usa un tipo de referencia, el resultado es diferente.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-177">But because a reference type is used, the result is different.</span></span> <span data-ttu-id="9a7b3-178">La modificación que se lleva a cabo en `ModifyObject` para el campo `obj.value` cambia también el campo `value` del argumento, `rt`, en el método `Main` a 33, tal y como muestra el resultado del ejemplo.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-178">The modification that is made in `ModifyObject` to the `obj.value` field also changes the `value` field of the argument, `rt`, in the `Main` method to 33, as the output from the example shows.</span></span>

[!code-csharp[csSnippets.Methods#42](../../samples/snippets/csharp/concepts/methods/byvalue42.cs#42)]

<a name="byref"></a>

### <a name="passing-parameters-by-reference"></a><span data-ttu-id="9a7b3-179">Pasar parámetros por referencia</span><span class="sxs-lookup"><span data-stu-id="9a7b3-179">Passing parameters by reference</span></span>

<span data-ttu-id="9a7b3-180">Pase un parámetro por referencia cuando quiera cambiar el valor de un argumento en un método y reflejar ese cambio cuando el control vuelva al método de llamada.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-180">You pass a parameter by reference when you want to change the value of an argument in a method and want to reflect that change when control returns to the calling method.</span></span> <span data-ttu-id="9a7b3-181">Para pasar un parámetro por referencia, use la palabra clave [`ref`](language-reference/keywords/ref.md) o [`out`](language-reference/keywords/out-parameter-modifier.md).</span><span class="sxs-lookup"><span data-stu-id="9a7b3-181">To pass a parameter by reference, you use the [`ref`](language-reference/keywords/ref.md) or [`out`](language-reference/keywords/out-parameter-modifier.md) keyword.</span></span> <span data-ttu-id="9a7b3-182">También puede pasar un valor por referencia para evitar la copia, pero impedir modificaciones igualmente usando la palabra clave [`in`](language-reference/keywords/in-parameter-modifier.md).</span><span class="sxs-lookup"><span data-stu-id="9a7b3-182">You can also pass a value by reference to avoid copying but still prevent modifications using the [`in`](language-reference/keywords/in-parameter-modifier.md) keyword.</span></span>

<span data-ttu-id="9a7b3-183">El ejemplo siguiente es idéntico al anterior, salvo que el valor se pasa por referencia al método `ModifyValue`.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-183">The following example is identical to the previous one, except the value is passed by reference to the `ModifyValue` method.</span></span> <span data-ttu-id="9a7b3-184">Cuando se modifica el valor del parámetro en el método `ModifyValue`, el cambio del valor se refleja cuando el control vuelve al autor de la llamada.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-184">When the value of the parameter is modified in the `ModifyValue` method, the change in value is reflected when control returns to the caller.</span></span>

[!code-csharp[csSnippets.Methods#106](../../samples/snippets/csharp/concepts/methods/byref106.cs#106)]

<span data-ttu-id="9a7b3-185">Un patrón común que se usa en parámetros ref implica intercambiar los valores de variables.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-185">A common pattern that uses by ref parameters involves swapping the values of variables.</span></span> <span data-ttu-id="9a7b3-186">Se pasan dos variables a un método por referencia y el método intercambia su contenido.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-186">You pass two variables to a method by reference, and the method swaps their contents.</span></span> <span data-ttu-id="9a7b3-187">En el ejemplo siguiente se intercambian valores enteros.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-187">The following example swaps integer values.</span></span>

[!code-csharp[csSnippets.Methods#106](../../samples/snippets/csharp/concepts/methods/swap107.cs#107)]

<span data-ttu-id="9a7b3-188">Pasar un parámetro de tipo de referencia le permite cambiar el valor de la propia referencia, en lugar del valor de sus campos o elementos individuales.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-188">Passing a reference-type parameter allows you to change the value of the reference itself, rather than the value of its individual elements or fields.</span></span>

<a name="paramarray"></a>

### <a name="parameter-arrays"></a><span data-ttu-id="9a7b3-189">Matrices de parámetros</span><span class="sxs-lookup"><span data-stu-id="9a7b3-189">Parameter arrays</span></span>

<span data-ttu-id="9a7b3-190">A veces, el requisito de especificar el número exacto de argumentos al método es restrictivo.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-190">Sometimes, the requirement that you specify the exact number of arguments to your method is restrictive.</span></span> <span data-ttu-id="9a7b3-191">El uso de la palabra clave `params` para indicar que un parámetro es una matriz de parámetros permite llamar al método con un número variable de argumentos.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-191">By using the `params` keyword to indicate that a parameter is a parameter array, you allow your method to be called with a variable number of arguments.</span></span> <span data-ttu-id="9a7b3-192">El parámetro etiquetado con la palabra clave `params` debe ser un tipo de matriz y ser el último parámetro en la lista de parámetros del método.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-192">The parameter tagged with the `params` keyword must be an array type, and it must be the last parameter in the method's parameter list.</span></span>

<span data-ttu-id="9a7b3-193">Un autor de llamada puede luego invocar el método de una de las tres maneras siguientes:</span><span class="sxs-lookup"><span data-stu-id="9a7b3-193">A caller can then invoke the method in either of three ways:</span></span>

- <span data-ttu-id="9a7b3-194">Si se pasa una matriz del tipo adecuado que contenga el número de elementos que se quiera.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-194">By passing an array of the appropriate type that contains the desired number of elements.</span></span>
- <span data-ttu-id="9a7b3-195">Si se pasa una lista separada por comas de los argumentos individuales del tipo adecuado para el método.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-195">By passing a comma-separated list of individual arguments of the appropriate type to the method.</span></span>
- <span data-ttu-id="9a7b3-196">Si no se proporciona un argumento a la matriz de parámetros.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-196">By not providing an argument to the parameter array.</span></span>

<span data-ttu-id="9a7b3-197">En el ejemplo siguiente se define un método denominado `GetVowels` que devuelve todas las vocales de una matriz de parámetros.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-197">The following example defines a method named `GetVowels` that returns all the vowels from a parameter array.</span></span> <span data-ttu-id="9a7b3-198">El método `Main` muestra las tres formas de invocar el método.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-198">The `Main` method illustrates all three ways of invoking the method.</span></span> <span data-ttu-id="9a7b3-199">Los autores de llamadas no deben proporcionar argumentos para los parámetros que incluyen el modificador `params`.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-199">Callers are not required to supply any arguments for parameters that include the `params` modifier.</span></span> <span data-ttu-id="9a7b3-200">En ese caso, el parámetro es `null`.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-200">In that case, the parameter is `null`.</span></span>

[!code-csharp[csSnippets.Methods#75](~/samples/snippets/csharp/concepts/methods/params75.cs#75)]

<a name="optional"></a>

## <a name="optional-parameters-and-arguments"></a><span data-ttu-id="9a7b3-201">Argumentos y parámetros opcionales</span><span class="sxs-lookup"><span data-stu-id="9a7b3-201">Optional parameters and arguments</span></span>

<span data-ttu-id="9a7b3-202">La definición de un método puede especificar que sus parámetros son necesarios o que son opcionales.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-202">A method definition can specify that its parameters are required or that they are optional.</span></span> <span data-ttu-id="9a7b3-203">Los parámetros son necesarios de forma predeterminada.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-203">By default, parameters are required.</span></span> <span data-ttu-id="9a7b3-204">Para especificar parámetros opcionales se incluye el valor predeterminado del parámetro en la definición del método.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-204">Optional parameters are specified by including the parameter's default value in the method definition.</span></span> <span data-ttu-id="9a7b3-205">Cuando se llama al método, si no se proporciona ningún argumento para un parámetro opcional, se usa el valor predeterminado.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-205">When the method is called, if no argument is supplied for an optional parameter, the default value is used instead.</span></span>

<span data-ttu-id="9a7b3-206">El valor predeterminado del parámetro debe asignarse con uno de los siguientes tipos de expresiones:</span><span class="sxs-lookup"><span data-stu-id="9a7b3-206">The parameter's default value must be assigned by one of the following kinds of expressions:</span></span>

- <span data-ttu-id="9a7b3-207">Una constante, como una cadena literal o un número.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-207">A constant, such as a literal string or number.</span></span>
- <span data-ttu-id="9a7b3-208">Una expresión con el formato `new ValType()`, donde `ValType` es un tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-208">An expression of the form `new ValType()`, where `ValType` is a value type.</span></span> <span data-ttu-id="9a7b3-209">Tenga en cuenta que esta acción invoca el constructor sin parámetros implícito del tipo de valor, que no es un miembro real del tipo.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-209">Note that this invokes the value type's implicit parameterless constructor, which is not an actual member of the type.</span></span>
- <span data-ttu-id="9a7b3-210">Una expresión con el formato `default(ValType)`, donde `ValType` es un tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-210">An expression of the form `default(ValType)`, where `ValType` is a value type.</span></span>

<span data-ttu-id="9a7b3-211">Si un método incluye parámetros necesarios y opcionales, los parámetros opcionales se definen al final de la lista de parámetros, después de todos los parámetros necesarios.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-211">If a method includes both required and optional parameters, optional parameters are defined at the end of the parameter list, after all required parameters.</span></span>

<span data-ttu-id="9a7b3-212">En el ejemplo siguiente se define un método, `ExampleMethod`, que tiene un parámetro necesario y dos opcionales.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-212">The following example defines a method, `ExampleMethod`, that has one required and two optional parameters.</span></span>

[!code-csharp[csSnippets.Methods#21](../../samples/snippets/csharp/concepts/methods/optional1.cs#21)]

<span data-ttu-id="9a7b3-213">Si se invoca un método con varios argumentos opcionales mediante argumentos posicionales, el autor de la llamada debe proporcionar un argumento para todos los parámetros opcionales, del primero al último, a los que se proporcione un argumento.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-213">If a method with multiple optional arguments is invoked using positional arguments, the caller must supply an argument for all optional parameters from the first one to the last one for which an argument is supplied.</span></span> <span data-ttu-id="9a7b3-214">Por ejemplo, en el caso del método `ExampleMethod`, si el autor de la llamada proporciona un argumento para el parámetro `description`, también debe proporcionar uno para el parámetro `optionalInt`.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-214">In the case of the  `ExampleMethod` method, for example, if the caller supplies an argument for the `description` parameter, it must also supply one for the `optionalInt` parameter.</span></span> <span data-ttu-id="9a7b3-215">`opt.ExampleMethod(2, 2, "Addition of 2 and 2");` es una llamada de método válida; `opt.ExampleMethod(2, , "Addition of 2 and 0");` genera un error del compilador, "Falta un argumento".</span><span class="sxs-lookup"><span data-stu-id="9a7b3-215">`opt.ExampleMethod(2, 2, "Addition of 2 and 2");` is a valid method call; `opt.ExampleMethod(2, , "Addition of 2 and 0");` generates an "Argument missing" compiler error.</span></span>

<span data-ttu-id="9a7b3-216">Si se llama a un método mediante argumentos con nombre o una combinación de argumentos posicionales y con nombre, el autor de la llamada puede omitir los argumentos que siguen al último argumento posicional en la llamada al método.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-216">If a method is called using named arguments or a combination of positional and named arguments, the caller can omit any arguments that follow the last positional argument in the method call.</span></span>

<span data-ttu-id="9a7b3-217">En el ejemplo siguiente se llama tres veces al método `ExampleMethod`.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-217">The following example calls the `ExampleMethod` method three times.</span></span>  <span data-ttu-id="9a7b3-218">Las dos primeras llamadas al método usan argumentos posicionales.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-218">The first two method calls use positional arguments.</span></span> <span data-ttu-id="9a7b3-219">La primera omite los dos argumentos opcionales, mientras que la segunda omite el último argumento.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-219">The first omits both optional arguments, while the second omits the last argument.</span></span> <span data-ttu-id="9a7b3-220">La tercera llamada al método proporciona un argumento posicional para el parámetro necesario, pero usa un argumento con nombre para proporcionar un valor al parámetro `description` mientras omite el argumento `optionalInt`.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-220">The third method call supplies a positional argument for the required parameter, but uses a named argument to supply a value to the `description` parameter while omitting the `optionalInt` argument.</span></span>

[!code-csharp[csSnippets.Methods#22](../../samples/snippets/csharp/concepts/methods/optional1.cs#22)]

<span data-ttu-id="9a7b3-221">El uso de parámetros opcionales incide en la *resolución de sobrecarga* o en la manera en que el compilador de C# determina qué sobrecarga en particular debe invocar una llamada al método, como sigue:</span><span class="sxs-lookup"><span data-stu-id="9a7b3-221">The use of optional parameters affects *overload resolution*, or the way in which the C# compiler determines which particular overload should be invoked by a method call, as follows:</span></span>

- <span data-ttu-id="9a7b3-222">Un método, indexador o constructor es un candidato para la ejecución si cada uno de sus parámetros es opcional o corresponde, por nombre o por posición, a un solo argumento de la instrucción de llamada y el argumento se puede convertir al tipo del parámetro.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-222">A method, indexer, or constructor is a candidate for execution if each of its parameters either is optional or corresponds, by name or by position, to a single argument in the calling statement, and that argument can be converted to the type of the parameter.</span></span>
- <span data-ttu-id="9a7b3-223">Si se encuentra más de un candidato, se aplican las reglas de resolución de sobrecarga de las conversiones preferidas a los argumentos que se especifican explícitamente.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-223">If more than one candidate is found, overload resolution rules for preferred conversions are applied to the arguments that are explicitly specified.</span></span> <span data-ttu-id="9a7b3-224">Los argumentos omitidos en parámetros opcionales se ignoran.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-224">Omitted arguments for optional parameters are ignored.</span></span>
- <span data-ttu-id="9a7b3-225">Si dos candidatos se consideran igualmente correctos, la preferencia pasa a un candidato que no tenga parámetros opcionales cuyos argumentos se hayan omitido en la llamada.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-225">If two candidates are judged to be equally good, preference goes to a candidate that does not have optional parameters for which arguments were omitted in the call.</span></span> <span data-ttu-id="9a7b3-226">Se trata de una consecuencia de una preferencia general en la resolución de sobrecarga para los candidatos con menos parámetros.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-226">This is a consequence of a general preference in overload resolution for candidates that have fewer parameters.</span></span>

<a name="return"></a>

## <a name="return-values"></a><span data-ttu-id="9a7b3-227">Valores devueltos</span><span class="sxs-lookup"><span data-stu-id="9a7b3-227">Return values</span></span>

<span data-ttu-id="9a7b3-228">Los métodos pueden devolver un valor al autor de llamada.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-228">Methods can return a value to the caller.</span></span> <span data-ttu-id="9a7b3-229">Si el tipo de valor devuelto (el tipo que aparece antes del nombre de método) no es `void`, el método puede devolver el valor mediante la palabra clave `return`.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-229">If the return type (the type listed before the method name) is not `void`, the method can return the value by using the `return` keyword.</span></span> <span data-ttu-id="9a7b3-230">Una instrucción con la palabra clave `return` seguida de una variable, una constante o una expresión que coincide con el tipo de valor devuelto devolverá este valor al autor de la llamada al método.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-230">A statement with the `return` keyword followed by a variable, constant, or expression that matches the return type will return that value to the method caller.</span></span> <span data-ttu-id="9a7b3-231">Los métodos con un tipo de valor devuelto no nulo son necesarios para usar la palabra clave `return` para devolver un valor.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-231">Methods with a non-void return type are required to use the `return` keyword to return a value.</span></span> <span data-ttu-id="9a7b3-232">La palabra clave `return` también detiene la ejecución del método.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-232">The `return` keyword also stops the execution of the method.</span></span>

<span data-ttu-id="9a7b3-233">Si el tipo de valor devuelto es `void`, una instrucción `return` sin un valor también es útil para detener la ejecución del método.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-233">If the return type is `void`, a `return` statement without a value is still useful to stop the execution of the method.</span></span> <span data-ttu-id="9a7b3-234">Sin la palabra clave `return` , el método dejará de ejecutarse cuando alcance el final del bloque de código.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-234">Without the `return` keyword, the method will stop executing when it reaches the end of the code block.</span></span>

<span data-ttu-id="9a7b3-235">Por ejemplo, estos dos métodos utilizan la palabra clave `return` para devolver enteros:</span><span class="sxs-lookup"><span data-stu-id="9a7b3-235">For example, these two methods use the `return` keyword to return integers:</span></span>

[!code-csharp[csSnippets.Methods#44](../../samples/snippets/csharp/concepts/methods/return44.cs#44)]

<span data-ttu-id="9a7b3-236">Para utilizar un valor devuelto de un método, el método de llamada puede usar la llamada de método en cualquier lugar; un valor del mismo tipo sería suficiente.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-236">To use a value returned from a method, the calling method can use the method call itself anywhere a value of the same type would be sufficient.</span></span> <span data-ttu-id="9a7b3-237">También puede asignar el valor devuelto a una variable.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-237">You can also assign the return value to a variable.</span></span> <span data-ttu-id="9a7b3-238">Por ejemplo, los dos siguientes ejemplos de código logran el mismo objetivo:</span><span class="sxs-lookup"><span data-stu-id="9a7b3-238">For example, the following two code examples accomplish the same goal:</span></span>

[!code-csharp[csSnippets.Methods#45](../../samples/snippets/csharp/concepts/methods/return44.cs#45)]

[!code-csharp[csSnippets.Methods#46](../../samples/snippets/csharp/concepts/methods/return44.cs#46)]

<span data-ttu-id="9a7b3-239">Usar una variable local, en este caso, `result`, para almacenar un valor es opcional.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-239">Using a local variable, in this case, `result`, to store a value is optional.</span></span> <span data-ttu-id="9a7b3-240">La legibilidad del código puede ser útil, o puede ser necesaria si debe almacenar el valor original del argumento para todo el ámbito del método.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-240">It may help the readability of the code, or it may be necessary if you need to store the original value of the argument for the entire scope of the method.</span></span>

<span data-ttu-id="9a7b3-241">A veces, quiere que el método devuelva más que un solo valor.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-241">Sometimes, you want your method to return more than a single value.</span></span> <span data-ttu-id="9a7b3-242">A partir de C# 7.0, puede hacer esto fácilmente mediante *tipos de tupla* y *literales de tupla*.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-242">Starting with C# 7.0, you can do this easily by using *tuple types* and *tuple literals*.</span></span> <span data-ttu-id="9a7b3-243">El tipo de tupla define los tipos de datos de los elementos de la tupla.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-243">The tuple type defines the data types of the tuple's elements.</span></span> <span data-ttu-id="9a7b3-244">Los literales de tupla proporcionan los valores reales de la tupla devuelta.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-244">Tuple literals provide the actual values of the returned tuple.</span></span> <span data-ttu-id="9a7b3-245">En el ejemplo siguiente, `(string, string, string, int)` define el tipo de tupla que devuelve el método `GetPersonalInfo`.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-245">In the following example, `(string, string, string, int)` defines the tuple type that is returned by the `GetPersonalInfo` method.</span></span> <span data-ttu-id="9a7b3-246">La expresión `(per.FirstName, per.MiddleName, per.LastName, per.Age)` es el literal de tupla; el método devuelve el nombre, los apellidos y la edad de un objeto `PersonInfo`.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-246">The expression `(per.FirstName, per.MiddleName, per.LastName, per.Age)` is the tuple literal; the method returns the first, middle, and last name, along with the age, of a `PersonInfo` object.</span></span>

```csharp
public (string, string, string, int) GetPersonalInfo(string id)
{
    PersonInfo per = PersonInfo.RetrieveInfoById(id);
    return (per.FirstName, per.MiddleName, per.LastName, per.Age);
}
```

<span data-ttu-id="9a7b3-247">Luego, el autor de la llamada puede usar la tupla devuelta con código como el siguiente:</span><span class="sxs-lookup"><span data-stu-id="9a7b3-247">The caller can then consume the returned tuple with code like the following:</span></span>

```csharp
var person = GetPersonalInfo("111111111")
Console.WriteLine("{person.Item1} {person.Item3}: age = {person.Item4}");
```

<span data-ttu-id="9a7b3-248">También se pueden asignar nombres a los elementos de tupla en la definición de tipo de tupla.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-248">Names can also be assigned to the tuple elements in the tuple type definition.</span></span> <span data-ttu-id="9a7b3-249">En el ejemplo siguiente se muestra una versión alternativa del método `GetPersonalInfo` que usa elementos con nombre:</span><span class="sxs-lookup"><span data-stu-id="9a7b3-249">The following example shows an alternate version of the `GetPersonalInfo` method that uses named elements:</span></span>

```csharp
public (string FName, string MName, string LName, int Age) GetPersonalInfo(string id)
{
    PersonInfo per = PersonInfo.RetrieveInfoById(id);
    return (per.FirstName, per.MiddleName, per.LastName, per.Age);
}
```

<span data-ttu-id="9a7b3-250">La llamada anterior al método `GetPersonInfo` se puede modificar luego de la manera siguiente:</span><span class="sxs-lookup"><span data-stu-id="9a7b3-250">The previous call to the `GetPersonInfo` method can then be modified as follows:</span></span>

```csharp
var person = GetPersonalInfo("111111111");
Console.WriteLine("{person.FName} {person.LName}: age = {person.Age}");
```

<span data-ttu-id="9a7b3-251">Si a un método se pasa una matriz como argumento y modifica el valor de elementos individuales, no es necesario que el método devuelva la matriz, aunque puede que se prefiera hacerlo a efectos del buen estilo o el flujo funcional de valores.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-251">If a method is passed an array as an argument and modifies the value of individual elements, it is not necessary for the method to return the array, although you may choose to do so for good style or functional flow of values.</span></span>  <span data-ttu-id="9a7b3-252">Esto se debe a que C# pasa todos los tipos de referencia por valor, y el valor de una referencia a la matriz es el puntero a la matriz.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-252">This is because C# passes all reference types by value, and the value of an array reference is the pointer to the array.</span></span> <span data-ttu-id="9a7b3-253">En el ejemplo siguiente, los cambios al contenido de la matriz `values` que se realizan en el método `DoubleValues` los puede observar cualquier código que tenga una referencia a la matriz.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-253">In the following example, changes to the contents of the `values` array that are made in the `DoubleValues` method are observable by any code that has a reference to the array.</span></span>

[!code-csharp[csSnippets.Methods#101](../../samples/snippets/csharp/concepts/methods/returnarray1.cs#101)]

<a name="extension"></a>

## <a name="extension-methods"></a><span data-ttu-id="9a7b3-254">Métodos de extensión</span><span class="sxs-lookup"><span data-stu-id="9a7b3-254">Extension methods</span></span>

<span data-ttu-id="9a7b3-255">Normalmente, hay dos maneras de agregar un método a un tipo existente:</span><span class="sxs-lookup"><span data-stu-id="9a7b3-255">Ordinarily, there are two ways to add a method to an existing type:</span></span>

- <span data-ttu-id="9a7b3-256">Modificar el código fuente del tipo.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-256">Modify the source code for that type.</span></span> <span data-ttu-id="9a7b3-257">No puede hacerlo si no es propietario del código fuente del tipo.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-257">You cannot do this, of course, if you do not own the type's source code.</span></span> <span data-ttu-id="9a7b3-258">Y esto supone un cambio sustancial si también agrega los campos de datos privados para admitir el método.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-258">And this becomes a breaking change if you also add any private data fields to support the method.</span></span>
- <span data-ttu-id="9a7b3-259">Definir el nuevo método en una clase derivada.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-259">Define the new method in a derived class.</span></span> <span data-ttu-id="9a7b3-260">No se puede agregar un método de este modo con herencia para otros tipos, como estructuras y enumeraciones.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-260">A method cannot be added in this way using inheritance for other types, such as structures and enumerations.</span></span> <span data-ttu-id="9a7b3-261">Tampoco se puede usar para agregar un método a una clase sealed.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-261">Nor can it be used to "add" a method to a sealed class.</span></span>

<span data-ttu-id="9a7b3-262">Los métodos de extensión permiten agregar un método a un tipo existente sin modificar el propio tipo o implementar el nuevo método en un tipo heredado.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-262">Extension methods let you "add" a method to an existing type without modifying the type itself or implementing the new method in an inherited type.</span></span> <span data-ttu-id="9a7b3-263">El método de extensión tampoco tiene que residir en el mismo ensamblado que el tipo que extiende.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-263">The extension method also does not have to reside in the same assembly as the type it extends.</span></span> <span data-ttu-id="9a7b3-264">Llame a un método de extensión como si fuera miembro de un tipo definido.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-264">You call an extension method as if it were a defined member of a type.</span></span>

<span data-ttu-id="9a7b3-265">Para obtener más información, vea [Métodos de extensión](programming-guide/classes-and-structs/extension-methods.md).</span><span class="sxs-lookup"><span data-stu-id="9a7b3-265">For more information, see [Extension Methods](programming-guide/classes-and-structs/extension-methods.md).</span></span>

<a name="async"></a>

## <a name="async-methods"></a><span data-ttu-id="9a7b3-266">Métodos asincrónicos</span><span class="sxs-lookup"><span data-stu-id="9a7b3-266">Async Methods</span></span>

<span data-ttu-id="9a7b3-267">Mediante la característica asincrónica, puede invocar métodos asincrónicos sin usar definiciones de llamada explícitas ni dividir manualmente el código en varios métodos o expresiones lambda.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-267">By using the async feature, you can invoke asynchronous methods without using explicit callbacks or manually splitting your code across multiple methods or lambda expressions.</span></span>

<span data-ttu-id="9a7b3-268">Si marca un método con el modificador [async](language-reference/keywords/async.md), puede usar el operador [await](language-reference/operators/await.md) en el método.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-268">If you mark a method with the [async](language-reference/keywords/async.md) modifier, you can use the [await](language-reference/operators/await.md) operator in the method.</span></span> <span data-ttu-id="9a7b3-269">Cuando el control llega a una expresión `await` en el método asincrónico, el control se devuelve al autor de la llamada si la tarea en espera no se ha completado y se suspende el progreso del método con la palabra clave `await` hasta que dicha tarea se complete.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-269">When control reaches an `await` expression in the async method, control returns to the caller if the awaited task is not completed, and progress in the method with the `await` keyword is suspended until the awaited task completes.</span></span> <span data-ttu-id="9a7b3-270">Cuando se completa la tarea, la ejecución puede reanudarse en el método.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-270">When the task is complete, execution can resume in the method.</span></span>

> [!NOTE]
> <span data-ttu-id="9a7b3-271">Un método asincrónico vuelve al autor de llamada cuando encuentra el primer objeto esperado que aún no se ha completado o cuando llega al final del método asincrónico, lo que ocurra primero.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-271">An async method returns to the caller when either it encounters the first awaited object that’s not yet complete or it gets to the end of the async method, whichever occurs first.</span></span>

<span data-ttu-id="9a7b3-272">Un método asincrónico puede tener un tipo de valor devuelto de <xref:System.Threading.Tasks.Task%601>, <xref:System.Threading.Tasks.Task> o `void`.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-272">An async method can have a return type of <xref:System.Threading.Tasks.Task%601>, <xref:System.Threading.Tasks.Task>, or `void`.</span></span> <span data-ttu-id="9a7b3-273">El tipo de valor devuelto `void` se usa principalmente para definir controladores de eventos, donde se requiere un tipo de valor devuelto `void`.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-273">The `void` return type is used primarily to define event handlers, where a `void` return type is required.</span></span> <span data-ttu-id="9a7b3-274">No se puede esperar un método asincrónico que devuelve `void` y el autor de llamada a un método que no devuelve ningún valor no puede capturar ninguna excepción producida por este.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-274">An async method that returns `void` can't be awaited, and the caller of a void-returning method can't catch exceptions that the method throws.</span></span> <span data-ttu-id="9a7b3-275">A partir de la versión C# 7.0, el método asincrónico puede tener [cualquier tipo de valor devuelto similar a una tarea ](./whats-new/csharp-7.md#generalized-async-return-types).</span><span class="sxs-lookup"><span data-stu-id="9a7b3-275">Starting with C# 7.0, an async method can have [any task-like return type](./whats-new/csharp-7.md#generalized-async-return-types).</span></span>

<span data-ttu-id="9a7b3-276">En el ejemplo siguiente, `DelayAsync` es un método asincrónico que contiene una instrucción return que devuelve un entero.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-276">In the following example, `DelayAsync` is an async method that has a return statement that returns an integer.</span></span> <span data-ttu-id="9a7b3-277">Como se trata de un método asincrónico, su declaración de método debe tener un tipo de valor devuelto de `Task<int>`.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-277">Because it is an async method, its method declaration must have a return type of `Task<int>`.</span></span> <span data-ttu-id="9a7b3-278">Dado que el tipo de valor devuelto es `Task<int>`, la evaluación de la expresión `await` en `DoSomethingAsync` genera un entero, como se demuestra en la instrucción `int result = await delayTask` siguiente.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-278">Because the return type is `Task<int>`, the evaluation of the `await` expression in `DoSomethingAsync` produces an integer, as the following `int result = await delayTask` statement demonstrates.</span></span>

[!code-csharp[csSnippets.Methods#102](../../samples/snippets/csharp/concepts/methods/async1.cs#102)]

<span data-ttu-id="9a7b3-279">Un método asincrónico no puede declarar ningún parámetro [in](language-reference/keywords/in-parameter-modifier.md), [ref](language-reference/keywords/ref.md) o [out](language-reference/keywords/out-parameter-modifier.md), pero puede llamar a los métodos que tienen estos parámetros.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-279">An async method can't declare any [in](language-reference/keywords/in-parameter-modifier.md), [ref](language-reference/keywords/ref.md), or [out](language-reference/keywords/out-parameter-modifier.md) parameters, but it can call methods that have such parameters.</span></span>

 <span data-ttu-id="9a7b3-280">Para obtener más información sobre los métodos asincrónicos, vea [Programación asincrónica con Async y Await](async.md), [Controlar el flujo en los programas asincrónicos](programming-guide/concepts/async/control-flow-in-async-programs.md) y [Tipos de valor devueltos asincrónicos](programming-guide/concepts/async/async-return-types.md).</span><span class="sxs-lookup"><span data-stu-id="9a7b3-280">For more information about async methods, see [Asynchronous Programming with Async and Await](async.md), [Control Flow in Async Programs](programming-guide/concepts/async/control-flow-in-async-programs.md), and [Async Return Types](programming-guide/concepts/async/async-return-types.md).</span></span>

<a name="expr"></a>

## <a name="expression-bodied-members"></a><span data-ttu-id="9a7b3-281">Miembros con forma de expresión</span><span class="sxs-lookup"><span data-stu-id="9a7b3-281">Expression-bodied members</span></span>

<span data-ttu-id="9a7b3-282">Es habitual tener definiciones de método que simplemente hacen las devoluciones de forma inmediata con el resultado de una expresión, o que tienen una sola instrucción como cuerpo del método.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-282">It is common to have method definitions that simply return immediately with the result of an expression, or that have a single statement as the body of the method.</span></span>  <span data-ttu-id="9a7b3-283">Hay un acceso directo de sintaxis para definir este método mediante `=>`:</span><span class="sxs-lookup"><span data-stu-id="9a7b3-283">There is a syntax shortcut for defining such methods using `=>`:</span></span>

```csharp
public Point Move(int dx, int dy) => new Point(x + dx, y + dy);
public void Print() => Console.WriteLine(First + " " + Last);
// Works with operators, properties, and indexers too.
public static Complex operator +(Complex a, Complex b) => a.Add(b);
public string Name => First + " " + Last;
public Customer this[long id] => store.LookupCustomer(id);
```

<span data-ttu-id="9a7b3-284">Si el método devuelve `void` o se trata de un método asincrónico, el cuerpo del método debe ser una expresión de instrucción (igual que con las expresiones lambda).</span><span class="sxs-lookup"><span data-stu-id="9a7b3-284">If the method returns `void` or is an async method, the body of the method must be a statement expression (same as with lambdas).</span></span>  <span data-ttu-id="9a7b3-285">Para propiedades e indexadores, deben ser de solo lectura, y no se usa la palabra clave de descriptor de acceso `get`.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-285">For properties and indexers, they must be read-only, and you do not use the `get` accessor keyword.</span></span>

<a name="iterators"></a>

## <a name="iterators"></a><span data-ttu-id="9a7b3-286">Iterators</span><span class="sxs-lookup"><span data-stu-id="9a7b3-286">Iterators</span></span>

<span data-ttu-id="9a7b3-287">Un iterador realiza una iteración personalizada en una colección, como una lista o matriz.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-287">An iterator performs a custom iteration over a collection, such as a list or an array.</span></span> <span data-ttu-id="9a7b3-288">Un iterador utiliza la instrucción [yield return](language-reference/keywords/yield.md) para devolver cada elemento de uno en uno.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-288">An iterator uses the [yield return](language-reference/keywords/yield.md) statement to return each element one at a time.</span></span> <span data-ttu-id="9a7b3-289">Cuando se llega a una instrucción `yield return`, se recuerda la ubicación actual para que el autor de la llamada pueda solicitar el siguiente elemento en la secuencia.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-289">When a `yield return` statement is reached, the current location is remembered so that the caller can request the next element in the sequence.</span></span>

<span data-ttu-id="9a7b3-290">El tipo de valor devuelto de un iterador puede ser <xref:System.Collections.IEnumerable>, <xref:System.Collections.Generic.IEnumerable%601>, <xref:System.Collections.IEnumerator> o <xref:System.Collections.Generic.IEnumerator%601>.</span><span class="sxs-lookup"><span data-stu-id="9a7b3-290">The return type of an iterator can be <xref:System.Collections.IEnumerable>, <xref:System.Collections.Generic.IEnumerable%601>, <xref:System.Collections.IEnumerator>, or <xref:System.Collections.Generic.IEnumerator%601>.</span></span>

<span data-ttu-id="9a7b3-291">Para obtener más información, consulta [Iteradores](programming-guide/concepts/iterators.md).</span><span class="sxs-lookup"><span data-stu-id="9a7b3-291">For more information, see [Iterators](programming-guide/concepts/iterators.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="9a7b3-292">Consulte también</span><span class="sxs-lookup"><span data-stu-id="9a7b3-292">See also</span></span>

- [<span data-ttu-id="9a7b3-293">Modificadores de acceso</span><span class="sxs-lookup"><span data-stu-id="9a7b3-293">Access Modifiers</span></span>](language-reference/keywords/access-modifiers.md)
- [<span data-ttu-id="9a7b3-294">Clases estáticas y sus miembros</span><span class="sxs-lookup"><span data-stu-id="9a7b3-294">Static Classes and Static Class Members</span></span>](programming-guide/classes-and-structs/static-classes-and-static-class-members.md)
- [<span data-ttu-id="9a7b3-295">Herencia</span><span class="sxs-lookup"><span data-stu-id="9a7b3-295">Inheritance</span></span>](programming-guide/classes-and-structs/inheritance.md)
- [<span data-ttu-id="9a7b3-296">Clases y miembros de clase abstractos y sellados</span><span class="sxs-lookup"><span data-stu-id="9a7b3-296">Abstract and Sealed Classes and Class Members</span></span>](programming-guide/classes-and-structs/abstract-and-sealed-classes-and-class-members.md)
- [<span data-ttu-id="9a7b3-297">params</span><span class="sxs-lookup"><span data-stu-id="9a7b3-297">params</span></span>](language-reference/keywords/params.md)
- [<span data-ttu-id="9a7b3-298">out</span><span class="sxs-lookup"><span data-stu-id="9a7b3-298">out</span></span>](language-reference/keywords/out-parameter-modifier.md)
- [<span data-ttu-id="9a7b3-299">ref</span><span class="sxs-lookup"><span data-stu-id="9a7b3-299">ref</span></span>](language-reference/keywords/ref.md)
- [<span data-ttu-id="9a7b3-300">in</span><span class="sxs-lookup"><span data-stu-id="9a7b3-300">in</span></span>](language-reference/keywords/in-parameter-modifier.md)
- [<span data-ttu-id="9a7b3-301">Pasar parámetros</span><span class="sxs-lookup"><span data-stu-id="9a7b3-301">Passing Parameters</span></span>](programming-guide/classes-and-structs/passing-parameters.md)
