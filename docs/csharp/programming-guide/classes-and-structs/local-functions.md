---
title: 'Funciones locales: Guía de programación de C#'
description: En C#, las funciones locales son métodos privados que están anidados en otro miembro y se pueden llamar desde su miembro contenedor.
ms.date: 10/16/2020
helpviewer_keywords:
- local functions [C#]
ms.openlocfilehash: 1c0cd1b8122f9069e5d6385d698f0ff8278912dd
ms.sourcegitcommit: 42d436ebc2a7ee02fc1848c7742bc7d80e13fc2f
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 03/04/2021
ms.locfileid: "102103249"
---
# <a name="local-functions-c-programming-guide"></a><span data-ttu-id="748b5-103">Funciones locales (Guía de programación de C#)</span><span class="sxs-lookup"><span data-stu-id="748b5-103">Local functions (C# Programming Guide)</span></span>

<span data-ttu-id="748b5-104">A partir de C# 7.0, C# admite *funciones locales*.</span><span class="sxs-lookup"><span data-stu-id="748b5-104">Starting with C# 7.0, C# supports *local functions*.</span></span> <span data-ttu-id="748b5-105">Las funciones locales son métodos privados de un tipo que están anidados en otro miembro.</span><span class="sxs-lookup"><span data-stu-id="748b5-105">Local functions are private methods of a type that are nested in another member.</span></span> <span data-ttu-id="748b5-106">Solo se pueden llamar desde su miembro contenedor.</span><span class="sxs-lookup"><span data-stu-id="748b5-106">They can only be called from their containing member.</span></span> <span data-ttu-id="748b5-107">Las funciones locales se pueden declarar en y llamar desde:</span><span class="sxs-lookup"><span data-stu-id="748b5-107">Local functions can be declared in and called from:</span></span>

- <span data-ttu-id="748b5-108">Métodos, especialmente los métodos de iterador y asincrónicos</span><span class="sxs-lookup"><span data-stu-id="748b5-108">Methods, especially iterator methods and async methods</span></span>
- <span data-ttu-id="748b5-109">Constructores</span><span class="sxs-lookup"><span data-stu-id="748b5-109">Constructors</span></span>
- <span data-ttu-id="748b5-110">Descriptores de acceso de propiedad</span><span class="sxs-lookup"><span data-stu-id="748b5-110">Property accessors</span></span>
- <span data-ttu-id="748b5-111">Descriptores de acceso de un evento</span><span class="sxs-lookup"><span data-stu-id="748b5-111">Event accessors</span></span>
- <span data-ttu-id="748b5-112">Métodos anónimos</span><span class="sxs-lookup"><span data-stu-id="748b5-112">Anonymous methods</span></span>
- <span data-ttu-id="748b5-113">Expresiones lambda</span><span class="sxs-lookup"><span data-stu-id="748b5-113">Lambda expressions</span></span>
- <span data-ttu-id="748b5-114">Finalizadores</span><span class="sxs-lookup"><span data-stu-id="748b5-114">Finalizers</span></span>
- <span data-ttu-id="748b5-115">Otras funciones locales</span><span class="sxs-lookup"><span data-stu-id="748b5-115">Other local functions</span></span>

<span data-ttu-id="748b5-116">En cambio, las funciones locales no se pueden declarar dentro de un miembro con forma de expresión.</span><span class="sxs-lookup"><span data-stu-id="748b5-116">However, local functions can't be declared inside an expression-bodied member.</span></span>

> [!NOTE]
> <span data-ttu-id="748b5-117">En algunos casos, puede usar una expresión lambda para implementar funcionalidad compatible también con una función local.</span><span class="sxs-lookup"><span data-stu-id="748b5-117">In some cases, you can use a lambda expression to implement functionality also supported by a local function.</span></span> <span data-ttu-id="748b5-118">Para ver una comparación, consulte [Funciones locales frente a expresiones lambda](#local-functions-vs-lambda-expressions).</span><span class="sxs-lookup"><span data-stu-id="748b5-118">For a comparison, see [Local functions vs. lambda expressions](#local-functions-vs-lambda-expressions).</span></span>

<span data-ttu-id="748b5-119">Las funciones locales aclaran la intención del código.</span><span class="sxs-lookup"><span data-stu-id="748b5-119">Local functions make the intent of your code clear.</span></span> <span data-ttu-id="748b5-120">Cualquiera que lea el código puede ver que solo el método que lo contiene puede llamar al método.</span><span class="sxs-lookup"><span data-stu-id="748b5-120">Anyone reading your code can see that the method is not callable except by the containing method.</span></span> <span data-ttu-id="748b5-121">Para los proyectos de equipo, también hacen que sea imposible que otro desarrollador llame erróneamente al método de forma directa desde cualquier otro punto de la clase o estructura.</span><span class="sxs-lookup"><span data-stu-id="748b5-121">For team projects, they also make it impossible for another developer to mistakenly call the method directly from elsewhere in the class or struct.</span></span>

## <a name="local-function-syntax"></a><span data-ttu-id="748b5-122">Sintaxis de función local</span><span class="sxs-lookup"><span data-stu-id="748b5-122">Local function syntax</span></span>

<span data-ttu-id="748b5-123">Una función local se define como un método anidado dentro de un miembro contenedor.</span><span class="sxs-lookup"><span data-stu-id="748b5-123">A local function is defined as a nested method inside a containing member.</span></span> <span data-ttu-id="748b5-124">Su definición tiene la siguiente sintaxis:</span><span class="sxs-lookup"><span data-stu-id="748b5-124">Its definition has the following syntax:</span></span>

```csharp
<modifiers> <return-type> <method-name> <parameter-list>
```

<span data-ttu-id="748b5-125">Puede usar los siguientes modificadores con una función local:</span><span class="sxs-lookup"><span data-stu-id="748b5-125">You can use the following modifiers with a local function:</span></span>

- [`async`](../../language-reference/keywords/async.md)
- [`unsafe`](../../language-reference/keywords/unsafe.md)
- <span data-ttu-id="748b5-126">[`static`](../../language-reference/keywords/static.md) (en C# 8.0 y posterior).</span><span class="sxs-lookup"><span data-stu-id="748b5-126">[`static`](../../language-reference/keywords/static.md) (in C# 8.0 and later).</span></span> <span data-ttu-id="748b5-127">Una función local estática no puede capturar variables locales o el estado de la instancia.</span><span class="sxs-lookup"><span data-stu-id="748b5-127">A static local function can't capture local variables or instance state.</span></span>
- <span data-ttu-id="748b5-128">[`extern`](../../language-reference/keywords/extern.md) (en C# 9.0 y posterior).</span><span class="sxs-lookup"><span data-stu-id="748b5-128">[`extern`](../../language-reference/keywords/extern.md) (in C# 9.0 and later).</span></span> <span data-ttu-id="748b5-129">Una función local externa debe ser `static`.</span><span class="sxs-lookup"><span data-stu-id="748b5-129">An external local function must be `static`.</span></span>

<span data-ttu-id="748b5-130">Todas las variables locales que se definen en el miembro contenedor, incluidos sus parámetros de método, son accesibles en la función local no estática.</span><span class="sxs-lookup"><span data-stu-id="748b5-130">All local variables that are defined in the containing member, including its method parameters, are accessible in a non-static local function.</span></span>

<span data-ttu-id="748b5-131">A diferencia de una definición de método, una definición de función local no puede incluir el modificador de acceso de los miembros.</span><span class="sxs-lookup"><span data-stu-id="748b5-131">Unlike a method definition, a local function definition cannot include the member access modifier.</span></span> <span data-ttu-id="748b5-132">Dado que todas las funciones locales son privadas, incluido un modificador de acceso, como la palabra clave `private`, se genera el error del compilador CS0106, "El modificador 'private' no es válido para este elemento".</span><span class="sxs-lookup"><span data-stu-id="748b5-132">Because all local functions are private, including an access modifier, such as the `private` keyword, generates compiler error CS0106, "The modifier 'private' is not valid for this item."</span></span>

<span data-ttu-id="748b5-133">En el ejemplo siguiente, se define una función local denominada `AppendPathSeparator` que es privada a un método denominado `GetText`:</span><span class="sxs-lookup"><span data-stu-id="748b5-133">The following example defines a local function named `AppendPathSeparator` that is private to a method named `GetText`:</span></span>

:::code language="csharp" source="snippets/local-functions/Program.cs" id="Basic" :::

<span data-ttu-id="748b5-134">A partir de C# 9.0, puede aplicar atributos a una función local, sus parámetros y parámetros de tipo, como se muestra en el ejemplo siguiente:</span><span class="sxs-lookup"><span data-stu-id="748b5-134">Beginning with C# 9.0, you can apply attributes to a local function, its parameters and type parameters, as the following example shows:</span></span>

:::code language="csharp" source="snippets/local-functions/Program.cs" id="WithAttributes" :::

<span data-ttu-id="748b5-135">En el ejemplo anterior se usa un [atributo especial](../../language-reference/attributes/nullable-analysis.md) para ayudar al compilador en el análisis estático en un contexto que acepta valores NULL.</span><span class="sxs-lookup"><span data-stu-id="748b5-135">The preceding example uses a [special attribute](../../language-reference/attributes/nullable-analysis.md) to assist the compiler in static analysis in a nullable context.</span></span>

## <a name="local-functions-and-exceptions"></a><span data-ttu-id="748b5-136">Excepciones y funciones locales</span><span class="sxs-lookup"><span data-stu-id="748b5-136">Local functions and exceptions</span></span>

<span data-ttu-id="748b5-137">Una de las características útiles de las funciones locales es que pueden permitir que las excepciones aparezcan inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="748b5-137">One of the useful features of local functions is that they can allow exceptions to surface immediately.</span></span> <span data-ttu-id="748b5-138">Para los iteradores de método, las excepciones aparecen solo cuando la secuencia devuelta se enumera y no cuando se recupera el iterador.</span><span class="sxs-lookup"><span data-stu-id="748b5-138">For method iterators, exceptions are surfaced only when the returned sequence is enumerated, and not when the iterator is retrieved.</span></span> <span data-ttu-id="748b5-139">Para los métodos asincrónicos, las excepciones producidas en un método asincrónico se observan cuando se espera la tarea devuelta.</span><span class="sxs-lookup"><span data-stu-id="748b5-139">For async methods, any exceptions thrown in an async method are observed when the returned task is awaited.</span></span>

<span data-ttu-id="748b5-140">En el ejemplo siguiente se define un método `OddSequence` que enumera los números impares de un intervalo especificado.</span><span class="sxs-lookup"><span data-stu-id="748b5-140">The following example defines an `OddSequence` method that enumerates odd numbers in a specified range.</span></span> <span data-ttu-id="748b5-141">Dado que pasa un número mayor de 100 al método de enumerador `OddSequence`, el método produce una excepción <xref:System.ArgumentOutOfRangeException>.</span><span class="sxs-lookup"><span data-stu-id="748b5-141">Because it passes a number greater than 100 to the `OddSequence` enumerator method, the method throws an <xref:System.ArgumentOutOfRangeException>.</span></span> <span data-ttu-id="748b5-142">Como se muestra en el resultado del ejemplo, la excepción aparece solo cuando itera los números, y no al recuperar el enumerador.</span><span class="sxs-lookup"><span data-stu-id="748b5-142">As the output from the example shows, the exception surfaces only when you iterate the numbers, and not when you retrieve the enumerator.</span></span>

:::code language="csharp" source="snippets/local-functions/IteratorWithoutLocal.cs" :::

<span data-ttu-id="748b5-143">Si coloca la lógica de iterador en una función local, se iniciarán excepciones de validación de argumentos al recuperar el enumerador, como se muestra en el ejemplo siguiente:</span><span class="sxs-lookup"><span data-stu-id="748b5-143">If you put iterator logic into a local function, argument validation exceptions are thrown when you retrieve the enumerator, as the following example shows:</span></span>

:::code language="csharp" source="snippets/local-functions/IteratorWithLocal.cs" :::

## <a name="local-functions-vs-lambda-expressions"></a><span data-ttu-id="748b5-144">Funciones locales frente a expresiones lambda</span><span class="sxs-lookup"><span data-stu-id="748b5-144">Local functions vs. lambda expressions</span></span>

<span data-ttu-id="748b5-145">A primera vista, las funciones locales y las [expresiones lambda](../../language-reference/operators/lambda-expressions.md) son muy similares.</span><span class="sxs-lookup"><span data-stu-id="748b5-145">At first glance, local functions and [lambda expressions](../../language-reference/operators/lambda-expressions.md) are very similar.</span></span> <span data-ttu-id="748b5-146">En muchos casos, la elección entre usar expresiones lambda y funciones locales es una cuestión de estilo y de preferencia personal,</span><span class="sxs-lookup"><span data-stu-id="748b5-146">In many cases, the choice between using lambda expressions and local functions is a matter of style and personal preference.</span></span> <span data-ttu-id="748b5-147">aunque hay diferencias que debe tener en cuenta acerca de dónde puede usar una u otra.</span><span class="sxs-lookup"><span data-stu-id="748b5-147">However, there are real differences in where you can use one or the other that you should be aware of.</span></span>

<span data-ttu-id="748b5-148">Vamos a examinar las diferencias entre las implementaciones de la función local y la expresión lambda del algoritmo factorial.</span><span class="sxs-lookup"><span data-stu-id="748b5-148">Let's examine the differences between the local function and lambda expression implementations of the factorial algorithm.</span></span> <span data-ttu-id="748b5-149">Esta es la versión que usa una función local:</span><span class="sxs-lookup"><span data-stu-id="748b5-149">Here's the version using a local function:</span></span>

:::code language="csharp" source="snippets/local-functions/Program.cs" id="FactorialWithLocal" :::

<span data-ttu-id="748b5-150">Esta versión usa expresiones lambda:</span><span class="sxs-lookup"><span data-stu-id="748b5-150">This version uses lambda expressions:</span></span>

:::code language="csharp" source="snippets/local-functions/Program.cs" id="FactorialWithLambda" :::

### <a name="naming"></a><span data-ttu-id="748b5-151">Nomenclatura</span><span class="sxs-lookup"><span data-stu-id="748b5-151">Naming</span></span>

<span data-ttu-id="748b5-152">Las funciones locales se nombran explícitamente como métodos.</span><span class="sxs-lookup"><span data-stu-id="748b5-152">Local functions are explicitly named like methods.</span></span> <span data-ttu-id="748b5-153">Las expresiones lambda son métodos anónimos y deben asignarse a variables de un tipo `delegate`, normalmente los tipos `Action` o `Func`.</span><span class="sxs-lookup"><span data-stu-id="748b5-153">Lambda expressions are anonymous methods and need to be assigned to variables of a `delegate` type, typically either `Action` or `Func` types.</span></span> <span data-ttu-id="748b5-154">Cuando se declara una función local, el proceso es como escribir un método normal: se declaran un tipo de valor devuelto y una signatura de función.</span><span class="sxs-lookup"><span data-stu-id="748b5-154">When you declare a local function, the process is like writing a normal method; you declare a return type and a function signature.</span></span>

### <a name="function-signatures-and-lambda-expression-types"></a><span data-ttu-id="748b5-155">Signaturas de función y tipos de expresiones lambda</span><span class="sxs-lookup"><span data-stu-id="748b5-155">Function signatures and lambda expression types</span></span>

<span data-ttu-id="748b5-156">Las expresiones lambda se basan en el tipo de la variable `Action`/`Func` al que están asignadas para determinar los tipos de argumento y de valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="748b5-156">Lambda expressions rely on the type of the `Action`/`Func` variable that they're assigned to determine the argument and return types.</span></span> <span data-ttu-id="748b5-157">En las funciones locales, dado que la sintaxis se parece mucho a escribir un método normal, los tipos de argumento y el tipo de valor devuelto ya forman parte de la declaración de función.</span><span class="sxs-lookup"><span data-stu-id="748b5-157">In local functions, since the syntax is much like writing a normal method, argument types and return type are already part of the function declaration.</span></span>

### <a name="definite-assignment"></a><span data-ttu-id="748b5-158">Asignación definitiva</span><span class="sxs-lookup"><span data-stu-id="748b5-158">Definite assignment</span></span>

<span data-ttu-id="748b5-159">Las expresiones lambda son objetos que se declaran y se asignan en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="748b5-159">Lambda expressions are objects that are declared and assigned at runtime.</span></span> <span data-ttu-id="748b5-160">Para poder usar una expresión lambda, debe asignarse definitivamente: se debe declarar la variable `Action`/`Func` a la que se va a asignar y luego asignar a esta la expresión lambda.</span><span class="sxs-lookup"><span data-stu-id="748b5-160">In order for a lambda expression to be used, it needs to be definitely assigned: the `Action`/`Func` variable that it will be assigned to must be declared and the lambda expression assigned to it.</span></span> <span data-ttu-id="748b5-161">Observe que `LambdaFactorial` debe declarar e inicializar la expresión lambda `nthFactorial` antes de definirla.</span><span class="sxs-lookup"><span data-stu-id="748b5-161">Notice that `LambdaFactorial` must declare and initialize the lambda expression `nthFactorial` before defining it.</span></span> <span data-ttu-id="748b5-162">De no hacerlo, se produce un error en tiempo de compilación por hacer referencia a `nthFactorial` antes de asignarlo.</span><span class="sxs-lookup"><span data-stu-id="748b5-162">Not doing so results in a compile time error for referencing `nthFactorial` before assigning it.</span></span>

<span data-ttu-id="748b5-163">Las funciones locales se definen en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="748b5-163">Local functions are defined at compile time.</span></span> <span data-ttu-id="748b5-164">Dado que no están asignadas a variables, se puede hacer referencia a ellas desde cualquier ubicación del código **que esté en ámbito**; en el primer ejemplo `LocalFunctionFactorial`, se podría declarar la función local por encima o por debajo de la instrucción `return` y no desencadenar ningún error del compilador.</span><span class="sxs-lookup"><span data-stu-id="748b5-164">As they're not assigned to variables, they can be referenced from any code location **where it is in scope**; in our first example `LocalFunctionFactorial`, we could declare our local function either above or below the `return` statement and not trigger any compiler errors.</span></span>

<span data-ttu-id="748b5-165">Estas diferencias implican que los algoritmos recursivos son más fáciles de crear usando funciones locales.</span><span class="sxs-lookup"><span data-stu-id="748b5-165">These differences mean that recursive algorithms are easier to create using local functions.</span></span> <span data-ttu-id="748b5-166">Puede declarar y definir una función local que se llama a sí misma.</span><span class="sxs-lookup"><span data-stu-id="748b5-166">You can declare and define a local function that calls itself.</span></span> <span data-ttu-id="748b5-167">Las expresiones lambda se deben declarar y se les debe asignar un valor predeterminado para que se les pueda volver a asignar un cuerpo que haga referencia a la misma expresión lambda.</span><span class="sxs-lookup"><span data-stu-id="748b5-167">Lambda expressions must be declared, and assigned a default value before they can be re-assigned to a body that references the same lambda expression.</span></span>

### <a name="implementation-as-a-delegate"></a><span data-ttu-id="748b5-168">Implementación como delegado</span><span class="sxs-lookup"><span data-stu-id="748b5-168">Implementation as a delegate</span></span>

<span data-ttu-id="748b5-169">Las expresiones lambda se convierten en delegados en el momento en que se declaran.</span><span class="sxs-lookup"><span data-stu-id="748b5-169">Lambda expressions are converted to delegates when they're declared.</span></span> <span data-ttu-id="748b5-170">Las funciones locales son más flexibles, ya que se pueden escribir como un método tradicional *o* como un delegado.</span><span class="sxs-lookup"><span data-stu-id="748b5-170">Local functions are more flexible in that they can be written like a traditional method *or* as a delegate.</span></span> <span data-ttu-id="748b5-171">Las funciones locales solo se convierten en delegados cuando ***se usan*** como delegados.</span><span class="sxs-lookup"><span data-stu-id="748b5-171">Local functions are only converted to delegates when ***used*** as a delegate.</span></span>

<span data-ttu-id="748b5-172">Si se declara una función local y solo se hace referencia a ella llamándola como un método, no se convertirá en un delegado.</span><span class="sxs-lookup"><span data-stu-id="748b5-172">If you declare a local function and only reference it by calling it like a method, it will not be converted to a delegate.</span></span>

### <a name="variable-capture"></a><span data-ttu-id="748b5-173">Captura de variables</span><span class="sxs-lookup"><span data-stu-id="748b5-173">Variable capture</span></span>

<span data-ttu-id="748b5-174">Las reglas de [asignación definitiva](../../../../_csharplang/spec/variables.md#definite-assignment) también afectan a las variables capturadas por la función local o la expresión lambda.</span><span class="sxs-lookup"><span data-stu-id="748b5-174">The rules of [definite assignment](../../../../_csharplang/spec/variables.md#definite-assignment) also affect any variables that are captured by the local function or lambda expression.</span></span> <span data-ttu-id="748b5-175">El compilador puede efectuar un análisis estático que permite a las funciones locales asignar definitivamente variables capturadas en el ámbito de inclusión.</span><span class="sxs-lookup"><span data-stu-id="748b5-175">The compiler can perform static analysis that enables local functions to definitely assign captured variables in the enclosing scope.</span></span> <span data-ttu-id="748b5-176">Considere este ejemplo:</span><span class="sxs-lookup"><span data-stu-id="748b5-176">Consider this example:</span></span>

```csharp
int M()
{
    int y;
    LocalFunction();
    return y;

    void LocalFunction() => y = 0;
}
```

<span data-ttu-id="748b5-177">El compilador puede determinar que `LocalFunction` asigna `y` definitivamente cuando se le llama.</span><span class="sxs-lookup"><span data-stu-id="748b5-177">The compiler can determine that `LocalFunction` definitely assigns `y` when called.</span></span> <span data-ttu-id="748b5-178">Como se llama a `LocalFunction` antes de la instrucción `return`, `y` se asigna definitivamente en la instrucción `return`.</span><span class="sxs-lookup"><span data-stu-id="748b5-178">Because `LocalFunction` is called before the `return` statement, `y` is definitely assigned at the `return` statement.</span></span>

<span data-ttu-id="748b5-179">Observe que cuando una función local captura variables en el ámbito de inclusión, la función local se implementa como un tipo delegado.</span><span class="sxs-lookup"><span data-stu-id="748b5-179">Note that when a local function captures variables in the enclosing scope, the local function is implemented as a delegate type.</span></span>

### <a name="heap-allocations"></a><span data-ttu-id="748b5-180">Asignaciones de montón</span><span class="sxs-lookup"><span data-stu-id="748b5-180">Heap allocations</span></span>

<span data-ttu-id="748b5-181">Dependiendo de su uso, las funciones locales pueden evitar las asignaciones de montón que siempre son necesarias para las expresiones lambda.</span><span class="sxs-lookup"><span data-stu-id="748b5-181">Depending on their use, local functions can avoid heap allocations that are always necessary for lambda expressions.</span></span> <span data-ttu-id="748b5-182">Si una función local no se convierte nunca en un delegado y ninguna de las variables capturadas por la función local se captura con otras expresiones lambda o funciones locales que se han convertido en delegados, el compilador puede evitar las asignaciones de montón.</span><span class="sxs-lookup"><span data-stu-id="748b5-182">If a local function is never converted to a delegate, and none of the variables captured by the local function are captured by other lambdas or local functions that are converted to delegates, the compiler can avoid heap allocations.</span></span>

<span data-ttu-id="748b5-183">Considere este ejemplo asincrónico:</span><span class="sxs-lookup"><span data-stu-id="748b5-183">Consider this async example:</span></span>

:::code language="csharp" source="snippets/local-functions/Program.cs" id="AsyncWithLambda" :::

<span data-ttu-id="748b5-184">La clausura de esta expresión lambda contiene las variables `address`, `index` y `name`.</span><span class="sxs-lookup"><span data-stu-id="748b5-184">The closure for this lambda expression contains the `address`, `index` and `name` variables.</span></span> <span data-ttu-id="748b5-185">En el caso de las funciones locales, el objeto que implementa el cierre puede ser un tipo `struct`.</span><span class="sxs-lookup"><span data-stu-id="748b5-185">In the case of local functions, the object that implements the closure may be a `struct` type.</span></span> <span data-ttu-id="748b5-186">Luego, ese tipo de estructura se pasaría por referencia a la función local.</span><span class="sxs-lookup"><span data-stu-id="748b5-186">That struct type would be passed by reference to the local function.</span></span> <span data-ttu-id="748b5-187">Esta diferencia de implementación supondría un ahorro en una asignación.</span><span class="sxs-lookup"><span data-stu-id="748b5-187">This difference in implementation would save on an allocation.</span></span>

<span data-ttu-id="748b5-188">La creación de instancias necesaria para las expresiones lambda significa asignaciones de memoria adicionales, lo que puede ser un factor de rendimiento en rutas de acceso de código crítico en el tiempo.</span><span class="sxs-lookup"><span data-stu-id="748b5-188">The instantiation necessary for lambda expressions means extra memory allocations, which may be a performance factor in time-critical code paths.</span></span> <span data-ttu-id="748b5-189">Las funciones locales no suponen esta sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="748b5-189">Local functions do not incur this overhead.</span></span> <span data-ttu-id="748b5-190">En el ejemplo anterior, la versión de las funciones locales tiene dos asignaciones menos que la versión de la expresión lambda.</span><span class="sxs-lookup"><span data-stu-id="748b5-190">In the example above, the local functions version has two fewer allocations than the lambda expression version.</span></span>

<span data-ttu-id="748b5-191">Si sabe que la función local no se va a convertir en delegado y ninguna de las variables capturadas por ella han sido capturadas por otras expresiones lambda o funciones locales que se han convertido en delegados, puede garantizar la no asignación de la función local al montón al declararla como función local `static`.</span><span class="sxs-lookup"><span data-stu-id="748b5-191">If you know that your local function won't be converted to a delegate and none of the variables captured by it are captured by other lambdas or local functions that are converted to delegates, you can guarantee that your local function avoids being allocated on the heap by declaring it as a `static` local function.</span></span> <span data-ttu-id="748b5-192">Observe que esta característica está disponible en C# 8.0 y versiones más recientes.</span><span class="sxs-lookup"><span data-stu-id="748b5-192">Note that this feature is available in C# 8.0 and newer.</span></span>

> [!NOTE]
> <span data-ttu-id="748b5-193">La función local equivalente de este método también usa una clase para el cierre.</span><span class="sxs-lookup"><span data-stu-id="748b5-193">The local function equivalent of this method also uses a class for the closure.</span></span> <span data-ttu-id="748b5-194">Si el cierre de una función local se implementa como `class` o `struct` es un detalle de implementación.</span><span class="sxs-lookup"><span data-stu-id="748b5-194">Whether the closure for a local function is implemented as a `class` or a `struct` is an implementation detail.</span></span> <span data-ttu-id="748b5-195">Una función local puede usar `struct` mientras una expresión lambda siempre usará `class`.</span><span class="sxs-lookup"><span data-stu-id="748b5-195">A local function may use a `struct` whereas a lambda will always use a `class`.</span></span>

:::code language="csharp" source="snippets/local-functions/Program.cs" id="AsyncWithLocal" :::

### <a name="usage-of-the-yield-keyword"></a><span data-ttu-id="748b5-196">Uso de la palabra clave `yield`</span><span class="sxs-lookup"><span data-stu-id="748b5-196">Usage of the `yield` keyword</span></span>

<span data-ttu-id="748b5-197">Una ventaja final que no se muestra en este ejemplo es que las funciones locales pueden implementarse como iteradores, con la sintaxis `yield return` para producir una secuencia de valores.</span><span class="sxs-lookup"><span data-stu-id="748b5-197">One final advantage not demonstrated in this sample is that local functions can be implemented as iterators, using the `yield return` syntax to produce a sequence of values.</span></span>

:::code language="csharp" source="snippets/local-functions/Program.cs" id="YieldReturn" :::

<span data-ttu-id="748b5-198">La instrucción `yield return` no se permite en las expresiones lambda; vea el [Error del compilador CS1621](../../misc/cs1621.md).</span><span class="sxs-lookup"><span data-stu-id="748b5-198">The `yield return` statement is not allowed in lambda expressions, see [compiler error CS1621](../../misc/cs1621.md).</span></span>

<span data-ttu-id="748b5-199">Aunque las funciones locales pueden parecer redundantes con respecto a las expresiones lambda, en realidad tienen finalidades y usos diferentes.</span><span class="sxs-lookup"><span data-stu-id="748b5-199">While local functions may seem redundant to lambda expressions, they actually serve different purposes and have different uses.</span></span> <span data-ttu-id="748b5-200">Las funciones locales son más eficaces si se quiere escribir una función a la que solo se llame desde el contexto de otro método.</span><span class="sxs-lookup"><span data-stu-id="748b5-200">Local functions are more efficient for the case when you want to write a function that is called only from the context of another method.</span></span>

## <a name="see-also"></a><span data-ttu-id="748b5-201">Vea también</span><span class="sxs-lookup"><span data-stu-id="748b5-201">See also</span></span>

- [<span data-ttu-id="748b5-202">Métodos</span><span class="sxs-lookup"><span data-stu-id="748b5-202">Methods</span></span>](methods.md)
