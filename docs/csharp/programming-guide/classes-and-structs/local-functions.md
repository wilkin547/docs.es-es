---
title: 'Funciones locales: Guía de programación de C#'
ms.date: 06/14/2017
helpviewer_keywords:
- local functions [C#]
ms.openlocfilehash: 200fbd097b7c71a1cd392d62622955528a80fd66
ms.sourcegitcommit: 73aa9653547a1cd70ee6586221f79cc29b588ebd
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 04/23/2020
ms.locfileid: "82102949"
---
# <a name="local-functions-c-programming-guide"></a><span data-ttu-id="ed0ae-102">Funciones locales (Guía de programación de C#)</span><span class="sxs-lookup"><span data-stu-id="ed0ae-102">Local functions (C# Programming Guide)</span></span>

<span data-ttu-id="ed0ae-103">A partir de C# 7.0, C# admite *funciones locales*.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-103">Starting with C# 7.0, C# supports *local functions*.</span></span> <span data-ttu-id="ed0ae-104">Las funciones locales son métodos privados de un tipo que están anidados en otro miembro.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-104">Local functions are private methods of a type that are nested in another member.</span></span> <span data-ttu-id="ed0ae-105">Solo se pueden llamar desde su miembro contenedor.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-105">They can only be called from their containing member.</span></span> <span data-ttu-id="ed0ae-106">Las funciones locales se pueden declarar en y llamar desde:</span><span class="sxs-lookup"><span data-stu-id="ed0ae-106">Local functions can be declared in and called from:</span></span>

- <span data-ttu-id="ed0ae-107">Métodos, especialmente los métodos de iterador y asincrónicos</span><span class="sxs-lookup"><span data-stu-id="ed0ae-107">Methods, especially iterator methods and async methods</span></span>
- <span data-ttu-id="ed0ae-108">Constructores</span><span class="sxs-lookup"><span data-stu-id="ed0ae-108">Constructors</span></span>
- <span data-ttu-id="ed0ae-109">Descriptores de acceso de propiedad</span><span class="sxs-lookup"><span data-stu-id="ed0ae-109">Property accessors</span></span>
- <span data-ttu-id="ed0ae-110">Descriptores de acceso de un evento</span><span class="sxs-lookup"><span data-stu-id="ed0ae-110">Event accessors</span></span>
- <span data-ttu-id="ed0ae-111">Métodos anónimos</span><span class="sxs-lookup"><span data-stu-id="ed0ae-111">Anonymous methods</span></span>
- <span data-ttu-id="ed0ae-112">Expresiones lambda</span><span class="sxs-lookup"><span data-stu-id="ed0ae-112">Lambda expressions</span></span>
- <span data-ttu-id="ed0ae-113">Finalizadores</span><span class="sxs-lookup"><span data-stu-id="ed0ae-113">Finalizers</span></span>
- <span data-ttu-id="ed0ae-114">Otras funciones locales</span><span class="sxs-lookup"><span data-stu-id="ed0ae-114">Other local functions</span></span>

<span data-ttu-id="ed0ae-115">En cambio, las funciones locales no se pueden declarar dentro de un miembro con forma de expresión.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-115">However, local functions can't be declared inside an expression-bodied member.</span></span>

> [!NOTE]
> <span data-ttu-id="ed0ae-116">En algunos casos, puede usar una expresión lambda para implementar funcionalidad compatible también con una función local.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-116">In some cases, you can use a lambda expression to implement functionality also supported by a local function.</span></span> <span data-ttu-id="ed0ae-117">Para ver una comparación, consulte [Funciones locales frente a expresiones lambda](#local-functions-vs-lambda-expressions).</span><span class="sxs-lookup"><span data-stu-id="ed0ae-117">For a comparison, see [Local functions vs. lambda expressions](#local-functions-vs-lambda-expressions).</span></span>

<span data-ttu-id="ed0ae-118">Las funciones locales aclaran la intención del código.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-118">Local functions make the intent of your code clear.</span></span> <span data-ttu-id="ed0ae-119">Cualquiera que lea el código puede ver que solo el método que lo contiene puede llamar al método.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-119">Anyone reading your code can see that the method is not callable except by the containing method.</span></span> <span data-ttu-id="ed0ae-120">Para los proyectos de equipo, también hacen que sea imposible que otro desarrollador llame erróneamente al método de forma directa desde cualquier otro punto de la clase o estructura.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-120">For team projects, they also make it impossible for another developer to mistakenly call the method directly from elsewhere in the class or struct.</span></span>

## <a name="local-function-syntax"></a><span data-ttu-id="ed0ae-121">Sintaxis de función local</span><span class="sxs-lookup"><span data-stu-id="ed0ae-121">Local function syntax</span></span>

<span data-ttu-id="ed0ae-122">Una función local se define como un método anidado dentro de un miembro contenedor.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-122">A local function is defined as a nested method inside a containing member.</span></span> <span data-ttu-id="ed0ae-123">Su definición tiene la siguiente sintaxis:</span><span class="sxs-lookup"><span data-stu-id="ed0ae-123">Its definition has the following syntax:</span></span>

```csharp
<modifiers: async | unsafe> <return-type> <method-name> <parameter-list>
```

<span data-ttu-id="ed0ae-124">Las funciones locales pueden usar los modificadores [async](../../language-reference/keywords/async.md) y [unsafe](../../language-reference/keywords/unsafe.md).</span><span class="sxs-lookup"><span data-stu-id="ed0ae-124">Local functions can use the [async](../../language-reference/keywords/async.md) and [unsafe](../../language-reference/keywords/unsafe.md) modifiers.</span></span>

<span data-ttu-id="ed0ae-125">Tenga en cuenta que todas las variables locales que se definen en el miembro contenedor, incluidos sus parámetros de método, son accesibles en la función local.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-125">Note that all local variables that are defined in the containing member, including its method parameters, are accessible in the local function.</span></span>

<span data-ttu-id="ed0ae-126">A diferencia de una definición de método, una definición de función local no puede incluir el modificador de acceso de los miembros.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-126">Unlike a method definition, a local function definition cannot include the member access modifier.</span></span> <span data-ttu-id="ed0ae-127">Dado que todas las funciones locales son privadas, incluido un modificador de acceso, como la palabra clave `private`, se genera el error del compilador CS0106, "El modificador 'private' no es válido para este elemento".</span><span class="sxs-lookup"><span data-stu-id="ed0ae-127">Because all local functions are private, including an access modifier, such as the `private` keyword, generates compiler error CS0106, "The modifier 'private' is not valid for this item."</span></span>

> [!NOTE]
> <span data-ttu-id="ed0ae-128">En las versiones anteriores a C# 8.0, las funciones locales no podían incluir el modificador `static`.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-128">Prior to C# 8.0, local functions cannot include the `static` modifier.</span></span> <span data-ttu-id="ed0ae-129">Al incluir la palabra clave `static`, se genera el error del compilador CS0106, "El modificador 'static' no es válido para este elemento".</span><span class="sxs-lookup"><span data-stu-id="ed0ae-129">Including the `static` keyword generates compiler error CS0106, "The modifier 'static' is not valid for this item."</span></span>

<span data-ttu-id="ed0ae-130">Además, los atributos no se pueden aplicar a la función local o a sus parámetros y parámetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-130">In addition, attributes can't be applied to the local function or to its parameters and type parameters.</span></span>

<span data-ttu-id="ed0ae-131">En el ejemplo siguiente, se define una función local denominada `AppendPathSeparator` que es privada a un método denominado `GetText`:</span><span class="sxs-lookup"><span data-stu-id="ed0ae-131">The following example defines a local function named `AppendPathSeparator` that is private to a method named `GetText`:</span></span>

[!code-csharp[LocalFunctionExample](~/samples/snippets/csharp/programming-guide/classes-and-structs/local-functions1.cs)]  

## <a name="local-functions-and-exceptions"></a><span data-ttu-id="ed0ae-132">Excepciones y funciones locales</span><span class="sxs-lookup"><span data-stu-id="ed0ae-132">Local functions and exceptions</span></span>

<span data-ttu-id="ed0ae-133">Una de las características útiles de las funciones locales es que pueden permitir que las excepciones aparezcan inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-133">One of the useful features of local functions is that they can allow exceptions to surface immediately.</span></span> <span data-ttu-id="ed0ae-134">Para los iteradores de método, las excepciones aparecen solo cuando la secuencia devuelta se enumera y no cuando se recupera el iterador.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-134">For method iterators, exceptions are surfaced only when the returned sequence is enumerated, and not when the iterator is retrieved.</span></span> <span data-ttu-id="ed0ae-135">Para los métodos asincrónicos, las excepciones producidas en un método asincrónico se observan cuando se espera la tarea devuelta.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-135">For async methods, any exceptions thrown in an async method are observed when the returned task is awaited.</span></span>

<span data-ttu-id="ed0ae-136">En el ejemplo siguiente, se define un método `OddSequence` que enumera los números impares entre un intervalo especificado.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-136">The following example defines an `OddSequence` method that enumerates odd numbers between a specified range.</span></span> <span data-ttu-id="ed0ae-137">Dado que pasa un número mayor de 100 al método de enumerador `OddSequence`, el método produce una excepción <xref:System.ArgumentOutOfRangeException>.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-137">Because it passes a number greater than 100 to the `OddSequence` enumerator method, the method throws an <xref:System.ArgumentOutOfRangeException>.</span></span> <span data-ttu-id="ed0ae-138">Como se muestra en el resultado del ejemplo, la excepción aparece solo cuando itera los números, y no al recuperar el enumerador.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-138">As the output from the example shows, the exception surfaces only when you iterate the numbers, and not when you retrieve the enumerator.</span></span>

[!code-csharp[LocalFunctionIterator1](~/samples/snippets/csharp/programming-guide/classes-and-structs/local-functions-iterator1.cs)]

<span data-ttu-id="ed0ae-139">En su lugar, puede producir una excepción al realizar la validación y antes de recuperar el iterador al devolver el iterador de una función local, como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-139">Instead, you can throw an exception when performing validation and before retrieving the iterator by returning the iterator from a local function, as the following example shows.</span></span>

[!code-csharp[LocalFunctionIterator2](~/samples/snippets/csharp/programming-guide/classes-and-structs/local-functions-iterator2.cs)]

<span data-ttu-id="ed0ae-140">Las funciones locales se pueden usar de forma similar, para controlar las excepciones fuera de la operación asincrónica.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-140">Local functions can be used in a similar way to handle exceptions outside of the asynchronous operation.</span></span> <span data-ttu-id="ed0ae-141">Normalmente, las excepciones producidas en el método asincrónico requieren que examine las excepciones internas de una excepción <xref:System.AggregateException>.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-141">Ordinarily, exceptions thrown in async method require that you examine the inner exceptions of an <xref:System.AggregateException>.</span></span> <span data-ttu-id="ed0ae-142">Las funciones locales permiten que el código genere un error inmediato y permiten que la excepción se produzca y observe de forma sincrónica.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-142">Local functions allow your code to fail fast and allow your exception to be both thrown and observed synchronously.</span></span>

<span data-ttu-id="ed0ae-143">En el ejemplo siguiente, se usa un método asincrónico denominado `GetMultipleAsync` para pausar durante un número especificado de segundos y se devuelve un valor que es un múltiplo aleatorio de ese número de segundos.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-143">The following example uses an asynchronous method named `GetMultipleAsync` to pause for a specified number of seconds and return a value that is a random multiple of that number of seconds.</span></span> <span data-ttu-id="ed0ae-144">El retraso máximo es de 5 segundos; se produce una excepción <xref:System.ArgumentOutOfRangeException> si el valor es mayor que 5.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-144">The maximum delay is 5 seconds; an <xref:System.ArgumentOutOfRangeException> results if the value is greater than 5.</span></span> <span data-ttu-id="ed0ae-145">Como se muestra en el ejemplo siguiente, la excepción que produce cuando se pasa un valor de 6 al método `GetMultipleAsync` se encapsula en una excepción <xref:System.AggregateException> después de que el método `GetMultipleAsync` empiece a ejecutarse.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-145">As the following example shows, the exception that is thrown when a value of 6 is passed to the `GetMultipleAsync` method is wrapped in an <xref:System.AggregateException> after the `GetMultipleAsync` method begins execution.</span></span>

[!code-csharp[LocalFunctionAsync](~/samples/snippets/csharp/programming-guide/classes-and-structs/local-functions-async1.cs)]

<span data-ttu-id="ed0ae-146">Igual que hemos hecho con el iterador de método, podemos refactorizar el código de este ejemplo para realizar la validación antes de llamar al método asincrónico.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-146">As we did with the method iterator, we can refactor the code from this example to perform the validation before calling the asynchronous method.</span></span> <span data-ttu-id="ed0ae-147">Como se muestra en el resultado del ejemplo siguiente, la excepción <xref:System.ArgumentOutOfRangeException> no se encapsula en una excepción <xref:System.AggregateException>.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-147">As the output from the following example shows, the <xref:System.ArgumentOutOfRangeException> is not wrapped in a <xref:System.AggregateException>.</span></span>

[!code-csharp[LocalFunctionAsync](~/samples/snippets/csharp/programming-guide/classes-and-structs/local-functions-async2.cs)]

## <a name="local-functions-vs-lambda-expressions"></a><span data-ttu-id="ed0ae-148">Funciones locales frente a expresiones lambda</span><span class="sxs-lookup"><span data-stu-id="ed0ae-148">Local functions vs. lambda expressions</span></span>

<span data-ttu-id="ed0ae-149">A primera vista, las funciones locales y las [expresiones lambda](../statements-expressions-operators/lambda-expressions.md) son muy similares.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-149">At first glance, local functions and [lambda expressions](../statements-expressions-operators/lambda-expressions.md) are very similar.</span></span> <span data-ttu-id="ed0ae-150">En muchos casos, la elección entre usar expresiones lambda y funciones locales es una cuestión de estilo y de preferencia personal,</span><span class="sxs-lookup"><span data-stu-id="ed0ae-150">In many cases, the choice between using lambda expressions and local functions is a matter of style and personal preference.</span></span> <span data-ttu-id="ed0ae-151">aunque hay diferencias que debe tener en cuenta acerca de dónde puede usar una u otra.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-151">However, there are real differences in where you can use one or the other that you should be aware of.</span></span>

<span data-ttu-id="ed0ae-152">Vamos a examinar las diferencias entre las implementaciones de la función local y la expresión lambda del algoritmo factorial.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-152">Let's examine the differences between the local function and lambda expression implementations of the factorial algorithm.</span></span> <span data-ttu-id="ed0ae-153">Primero la versión que usa una función local:</span><span class="sxs-lookup"><span data-stu-id="ed0ae-153">First the version using a local function:</span></span>

[!code-csharp[LocalFunctionFactorial](../../../../samples/snippets/csharp/new-in-7/MathUtilities.cs#37_LocalFunctionFactorial "Recursive factorial using local function")]

<span data-ttu-id="ed0ae-154">Compare esa implementación con una versión que use expresiones lambda:</span><span class="sxs-lookup"><span data-stu-id="ed0ae-154">Contrast that implementation with a version that uses lambda expressions:</span></span>

[!code-csharp[26_LambdaFactorial](../../../../samples/snippets/csharp/new-in-7/MathUtilities.cs#38_LambdaFactorial "Recursive factorial using lambda expressions")]

<span data-ttu-id="ed0ae-155">Las funciones locales tienen nombres,</span><span class="sxs-lookup"><span data-stu-id="ed0ae-155">The local functions have names.</span></span> <span data-ttu-id="ed0ae-156">mientras que las expresiones lambda son métodos anónimos que se asignan a variables que son tipos `Func` o `Action`.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-156">The lambda expressions are anonymous methods that are assigned to variables that are `Func` or `Action` types.</span></span> <span data-ttu-id="ed0ae-157">Cuando se declara una función local, los tipos de argumento y el tipo de valor devuelto forman parte de la declaración de función.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-157">When you declare a local function, the argument types and return type are part of the function declaration.</span></span> <span data-ttu-id="ed0ae-158">En lugar de formar parte del cuerpo de la expresión lambda, los tipos de argumento y el tipo de valor devuelto forman parte de la declaración de tipo de variable de la expresión lambda.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-158">Instead of being part of the body of the lambda expression, the argument types and return type are part of the lambda expression's variable type declaration.</span></span> <span data-ttu-id="ed0ae-159">Estas dos diferencias pueden hacer que el código sea más claro.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-159">Those two differences may result in clearer code.</span></span>

<span data-ttu-id="ed0ae-160">Las funciones locales tienen reglas diferentes de las expresiones lambda para la asignación definitiva.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-160">Local functions have different rules for definite assignment than lambda expressions.</span></span> <span data-ttu-id="ed0ae-161">Se puede hacer referencia a una declaración de función local desde cualquier ubicación del código que esté dentro del ámbito.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-161">A local function declaration can be referenced from any code location where it is in scope.</span></span> <span data-ttu-id="ed0ae-162">Las expresiones lambda se deben asignar a una variable de delegado para poder acceder a ellas (o para poder llamarlas mediante el delegado que hace referencia a ellas).</span><span class="sxs-lookup"><span data-stu-id="ed0ae-162">A lambda expression must be assigned to a delegate variable before it can be accessed (or called through the delegate referencing the lambda expression).</span></span> <span data-ttu-id="ed0ae-163">Observe que la versión con la expresión lambda debe declarar e inicializar la expresión lambda, `nthFactorial`, antes de definirla.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-163">Notice that the version using the lambda expression must declare and initialize the lambda expression `nthFactorial` before defining it.</span></span> <span data-ttu-id="ed0ae-164">De no hacerlo, se produce un error en tiempo de compilación por hacer referencia a `nthFactorial` antes de asignarlo.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-164">Not doing so results in a compile time error for referencing `nthFactorial` before assigning it.</span></span> <span data-ttu-id="ed0ae-165">Estas diferencias implican que los algoritmos recursivos son más fáciles de crear usando funciones locales.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-165">These differences mean that recursive algorithms are easier to create using local functions.</span></span> <span data-ttu-id="ed0ae-166">Puede declarar y definir una función local que se llama a sí misma.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-166">You can declare and define a local function that calls itself.</span></span> <span data-ttu-id="ed0ae-167">Las expresiones lambda se deben declarar y se les debe asignar un valor predeterminado para que se les pueda volver a asignar un cuerpo que haga referencia a la misma expresión lambda.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-167">Lambda expressions must be declared, and assigned a default value before they can be re-assigned to a body that references the same lambda expression.</span></span>

<span data-ttu-id="ed0ae-168">Las reglas de asignación definitiva también afectan a las variables que se capturan con la función local o la expresión lambda.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-168">Definite assignment rules also affect any variables that are captured by the local function or lambda expression.</span></span> <span data-ttu-id="ed0ae-169">Tanto las funciones locales como las reglas de expresiones lambda exigen que las variables capturadas se asignen definitivamente en el momento en que la función local o la expresión lambda se convierta en un delegado.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-169">Both local functions and lambda expression rules demand that any captured variables are definitely assigned at the point when the local function or lambda expression is converted to a delegate.</span></span> <span data-ttu-id="ed0ae-170">La diferencia está en que las expresiones lambda se convierten en delegados en el momento en que se declaran,</span><span class="sxs-lookup"><span data-stu-id="ed0ae-170">The difference is that lambda expressions are converted to delegates when they are declared.</span></span> <span data-ttu-id="ed0ae-171">mientras que las funciones locales se convierten en delegados solo cuando se usan como delegados.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-171">Local functions are converted to delegates only when used as a delegate.</span></span> <span data-ttu-id="ed0ae-172">Si se declara una función local y solo se hace referencia a ella llamándola como un método, no se convertirá en un delegado.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-172">If you declare a local function and only reference it by calling it like a method, it will not be converted to a delegate.</span></span> <span data-ttu-id="ed0ae-173">Esta regla le permite declarar una función local en cualquier ubicación adecuada de su ámbito de inclusión.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-173">That rule enables you to declare a local function at any convenient location in its enclosing scope.</span></span> <span data-ttu-id="ed0ae-174">Es habitual declarar funciones locales al final del método principal, después de cualquier instrucción "return".</span><span class="sxs-lookup"><span data-stu-id="ed0ae-174">It's common to declare local functions at the end of the parent method, after any return statements.</span></span>

<span data-ttu-id="ed0ae-175">En tercer lugar, el compilador puede efectuar un análisis estático que permita que las funciones locales asignen definitivamente variables capturadas en el ámbito de inclusión.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-175">Third, the compiler can perform static analysis that enables local functions to definitely assign captured variables in the enclosing scope.</span></span> <span data-ttu-id="ed0ae-176">Considere este ejemplo:</span><span class="sxs-lookup"><span data-stu-id="ed0ae-176">Consider this example:</span></span>

```csharp
int M()
{
    int y;
    LocalFunction();
    return y;

    void LocalFunction() => y = 0;
}
```

<span data-ttu-id="ed0ae-177">El compilador puede determinar que `LocalFunction` asigna `y` definitivamente cuando se le llama.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-177">The compiler can determine that `LocalFunction` definitely assigns `y` when called.</span></span> <span data-ttu-id="ed0ae-178">Como se llama a `LocalFunction` antes de la instrucción `return`, `y` se asigna definitivamente en la instrucción `return`.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-178">Because `LocalFunction` is called before the `return` statement, `y` is definitely assigned at the `return` statement.</span></span>

<span data-ttu-id="ed0ae-179">El análisis que proporciona el análisis de ejemplo posibilita la cuarta diferencia.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-179">The analysis that enables the example analysis enables the fourth difference.</span></span> <span data-ttu-id="ed0ae-180">Dependiendo de su uso, las funciones locales pueden evitar las asignaciones de montón que siempre son necesarias para las expresiones lambda.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-180">Depending on their use, local functions can avoid heap allocations that are always necessary for lambda expressions.</span></span> <span data-ttu-id="ed0ae-181">Si una función local no se convierte nunca en un delegado y ninguna de las variables capturadas con la función local se captura con otras expresiones lambda o funciones locales que se han convertido en delegados, el compilador puede evitar las asignaciones de montón.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-181">If a local function is never converted to a delegate, and none of the variables captured by the local function is captured by other lambdas or local functions that are converted to delegates, the compiler can avoid heap allocations.</span></span>

<span data-ttu-id="ed0ae-182">Considere este ejemplo asincrónico:</span><span class="sxs-lookup"><span data-stu-id="ed0ae-182">Consider this async example:</span></span>

[!code-csharp[TaskLambdaExample](../../../../samples/snippets/csharp/new-in-7/AsyncWork.cs#36_TaskLambdaExample "Task returning method with lambda expression")]

<span data-ttu-id="ed0ae-183">La clausura de esta expresión lambda contiene las variables `address`, `index` y `name`.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-183">The closure for this lambda expression contains the `address`, `index` and `name` variables.</span></span> <span data-ttu-id="ed0ae-184">En el caso de las funciones locales, el objeto que implementa el cierre puede ser un tipo `struct`.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-184">In the case of local functions, the object that implements the closure may be a `struct` type.</span></span> <span data-ttu-id="ed0ae-185">Luego, ese tipo de estructura se pasaría por referencia a la función local.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-185">That struct type would be passed by reference to the local function.</span></span> <span data-ttu-id="ed0ae-186">Esta diferencia de implementación supondría un ahorro en una asignación.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-186">This difference in implementation would save on an allocation.</span></span>

<span data-ttu-id="ed0ae-187">La creación de instancias necesaria para las expresiones lambda significa asignaciones de memoria adicionales, lo que puede ser un factor de rendimiento en rutas de acceso de código crítico en el tiempo.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-187">The instantiation necessary for lambda expressions means extra memory allocations, which may be a performance factor in time-critical code paths.</span></span> <span data-ttu-id="ed0ae-188">Las funciones locales no suponen esta sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-188">Local functions do not incur this overhead.</span></span> <span data-ttu-id="ed0ae-189">En el ejemplo anterior, la versión de las funciones locales tiene 2 asignaciones menos que la versión de la expresión lambda.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-189">In the example above, the local functions version has 2 fewer allocations than the lambda expression version.</span></span>

> [!NOTE]
> <span data-ttu-id="ed0ae-190">La función local equivalente de este método también usa una clase para el cierre.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-190">The local function equivalent of this method also uses a class for the closure.</span></span> <span data-ttu-id="ed0ae-191">Si el cierre de una función local se implementa como `class` o `struct` es un detalle de implementación.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-191">Whether the closure for a local function is implemented as a `class` or a `struct` is an implementation detail.</span></span> <span data-ttu-id="ed0ae-192">Una función local puede usar `struct` mientras una expresión lambda siempre usará `class`.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-192">A local function may use a `struct` whereas a lambda will always use a `class`.</span></span>

[!code-csharp[TaskLocalFunctionExample](../../../../samples/snippets/csharp/new-in-7/AsyncWork.cs#TaskExample "Task returning method with local function")]

<span data-ttu-id="ed0ae-193">Una ventaja final que no se muestra en este ejemplo es que las funciones locales pueden implementarse como iteradores, con la sintaxis `yield return` para producir una secuencia de valores.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-193">One final advantage not demonstrated in this sample is that local functions can be implemented as iterators, using the `yield return` syntax to produce a sequence of values.</span></span> <span data-ttu-id="ed0ae-194">La instrucción `yield return` no está permitida en las expresiones lambda.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-194">The `yield return` statement is not allowed in lambda expressions.</span></span>

<span data-ttu-id="ed0ae-195">Aunque las funciones locales pueden parecer redundantes con respecto a las expresiones lambda, en realidad tienen finalidades y usos diferentes.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-195">While local functions may seem redundant to lambda expressions, they actually serve different purposes and have different uses.</span></span> <span data-ttu-id="ed0ae-196">Las funciones locales son más eficaces si se quiere escribir una función a la que solo se llame desde el contexto de otro método.</span><span class="sxs-lookup"><span data-stu-id="ed0ae-196">Local functions are more efficient for the case when you want to write a function that is called only from the context of another method.</span></span>

## <a name="see-also"></a><span data-ttu-id="ed0ae-197">Vea también</span><span class="sxs-lookup"><span data-stu-id="ed0ae-197">See also</span></span>

- [<span data-ttu-id="ed0ae-198">Métodos</span><span class="sxs-lookup"><span data-stu-id="ed0ae-198">Methods</span></span>](methods.md)
