---
title: 'Métodos: Guía de programación de C#'
description: En C#, un método es un bloque de código que contiene una serie de instrucciones. Un programa ejecuta las instrucciones mediante la llamada al método y la especificación de argumentos.
ms.date: 03/08/2021
helpviewer_keywords:
- methods [C#]
- C# language, methods
ms.assetid: cc738f07-e8cd-4683-9585-9f40c0667c37
ms.openlocfilehash: d503c394e02f6f384e63de4fcd9cc8d2eec43da0
ms.sourcegitcommit: 1dbe25ff484a02025d5c34146e517c236f7161fb
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 03/19/2021
ms.locfileid: "104653509"
---
# <a name="methods-c-programming-guide"></a><span data-ttu-id="c7a30-104">Métodos (Guía de programación de C#)</span><span class="sxs-lookup"><span data-stu-id="c7a30-104">Methods (C# Programming Guide)</span></span>

<span data-ttu-id="c7a30-105">Un método es un bloque de código que contiene una serie de instrucciones.</span><span class="sxs-lookup"><span data-stu-id="c7a30-105">A method is a code block that contains a series of statements.</span></span> <span data-ttu-id="c7a30-106">Un programa hace que se ejecuten las instrucciones al llamar al método y especificando los argumentos de método necesarios.</span><span class="sxs-lookup"><span data-stu-id="c7a30-106">A program causes the statements to be executed by calling the method and specifying any required method arguments.</span></span> <span data-ttu-id="c7a30-107">En C#, todas las instrucciones ejecutadas se realizan en el contexto de un método.</span><span class="sxs-lookup"><span data-stu-id="c7a30-107">In C#, every executed instruction is performed in the context of a method.</span></span>

<span data-ttu-id="c7a30-108">El método `Main` es el punto de entrada para cada aplicación de C# y se llama mediante Common Language Runtime (CLR) cuando se inicia el programa.</span><span class="sxs-lookup"><span data-stu-id="c7a30-108">The `Main` method is the entry point for every C# application and it's called by the common language runtime (CLR) when the program is started.</span></span> <span data-ttu-id="c7a30-109">En una aplicación que usa [instrucciones de nivel superior](../main-and-command-args/top-level-statements.md), el compilador genera el método `Main` y contiene todas las instrucciones de nivel superior.</span><span class="sxs-lookup"><span data-stu-id="c7a30-109">In an application that uses [top-level statements](../main-and-command-args/top-level-statements.md), the `Main` method is generated by the compiler and contains all top-level statements.</span></span>

> [!NOTE]
> <span data-ttu-id="c7a30-110">En este artículo se analizan los métodos denominados.</span><span class="sxs-lookup"><span data-stu-id="c7a30-110">This article discusses named methods.</span></span> <span data-ttu-id="c7a30-111">Para obtener información sobre las funciones anónimas, vea [Funciones anónimas](../statements-expressions-operators/anonymous-functions.md).</span><span class="sxs-lookup"><span data-stu-id="c7a30-111">For information about anonymous functions, see [Anonymous Functions](../statements-expressions-operators/anonymous-functions.md).</span></span>

## <a name="method-signatures"></a><span data-ttu-id="c7a30-112">Firmas de método</span><span class="sxs-lookup"><span data-stu-id="c7a30-112">Method signatures</span></span>

<span data-ttu-id="c7a30-113">Los métodos se declaran en una [clase](../../language-reference/keywords/class.md), [struct](../../language-reference/builtin-types/struct.md) o [interfaz](../interfaces/index.md) especificando el nivel de acceso, como `public` o `private`, modificadores opcionales como `abstract` o `sealed`, el valor devuelto, el nombre del método y cualquier parámetro de método.</span><span class="sxs-lookup"><span data-stu-id="c7a30-113">Methods are declared in a [class](../../language-reference/keywords/class.md), [struct](../../language-reference/builtin-types/struct.md), or [interface](../interfaces/index.md) by specifying the access level such as `public` or `private`, optional modifiers such as `abstract` or `sealed`, the return value, the name of the method, and any method parameters.</span></span> <span data-ttu-id="c7a30-114">Todas estas partes forman la firma del método.</span><span class="sxs-lookup"><span data-stu-id="c7a30-114">These parts together are the signature of the method.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="c7a30-115">Un tipo de valor devuelto de un método no forma parte de la firma del método con el objetivo de sobrecargar el método.</span><span class="sxs-lookup"><span data-stu-id="c7a30-115">A return type of a method is not part of the signature of the method for the purposes of method overloading.</span></span> <span data-ttu-id="c7a30-116">Sin embargo, forma parte de la firma del método al determinar la compatibilidad entre un delegado y el método que señala.</span><span class="sxs-lookup"><span data-stu-id="c7a30-116">However, it is part of the signature of the method when determining the compatibility between a delegate and the method that it points to.</span></span>

<span data-ttu-id="c7a30-117">Los parámetros de método se encierran entre paréntesis y se separan por comas.</span><span class="sxs-lookup"><span data-stu-id="c7a30-117">Method parameters are enclosed in parentheses and are separated by commas.</span></span> <span data-ttu-id="c7a30-118">Los paréntesis vacíos indican que el método no requiere parámetros.</span><span class="sxs-lookup"><span data-stu-id="c7a30-118">Empty parentheses indicate that the method requires no parameters.</span></span> <span data-ttu-id="c7a30-119">Esta clase contiene cuatro métodos:</span><span class="sxs-lookup"><span data-stu-id="c7a30-119">This class contains four methods:</span></span>

[!code-csharp[DifferentModifiersOnMethods#1](snippets/methods/Program.cs#1)]

## <a name="method-access"></a><span data-ttu-id="c7a30-120">Acceso a métodos</span><span class="sxs-lookup"><span data-stu-id="c7a30-120">Method access</span></span>

<span data-ttu-id="c7a30-121">Llamar a un método en un objeto es como acceder a un campo.</span><span class="sxs-lookup"><span data-stu-id="c7a30-121">Calling a method on an object is like accessing a field.</span></span> <span data-ttu-id="c7a30-122">Después del nombre del objeto, agregue un punto, el nombre del método y paréntesis.</span><span class="sxs-lookup"><span data-stu-id="c7a30-122">After the object name, add a period, the name of the method, and parentheses.</span></span> <span data-ttu-id="c7a30-123">Los argumentos se enumeran entre paréntesis y están separados por comas.</span><span class="sxs-lookup"><span data-stu-id="c7a30-123">Arguments are listed within the parentheses, and are separated by commas.</span></span> <span data-ttu-id="c7a30-124">Los métodos de la clase `Motorcycle` se pueden llamar como en el ejemplo siguiente:</span><span class="sxs-lookup"><span data-stu-id="c7a30-124">The methods of the `Motorcycle` class can therefore be called as in the following example:</span></span>

[!code-csharp[CallingMethods#2](snippets/methods/Program.cs#2)]

## <a name="method-parameters-vs-arguments"></a><span data-ttu-id="c7a30-125">Parámetros de métodos frente a argumentos</span><span class="sxs-lookup"><span data-stu-id="c7a30-125">Method parameters vs. arguments</span></span>

<span data-ttu-id="c7a30-126">La definición del método especifica los nombres y tipos de todos los parámetros necesarios.</span><span class="sxs-lookup"><span data-stu-id="c7a30-126">The method definition specifies the names and types of any parameters that are required.</span></span> <span data-ttu-id="c7a30-127">Si el código de llamada llama al métodos, proporciona valores concretos denominados argumentos para cada parámetro.</span><span class="sxs-lookup"><span data-stu-id="c7a30-127">When calling code calls the method, it provides concrete values called arguments for each parameter.</span></span> <span data-ttu-id="c7a30-128">Los argumentos deben ser compatibles con el tipo de parámetro, pero el nombre del argumento (si existe) utilizado en el código de llamada no tiene que ser el mismo que el parámetro con nombre definido en el método.</span><span class="sxs-lookup"><span data-stu-id="c7a30-128">The arguments must be compatible with the parameter type but the argument name (if any) used in the calling code doesn't have to be the same as the parameter named defined in the method.</span></span> <span data-ttu-id="c7a30-129">Por ejemplo:</span><span class="sxs-lookup"><span data-stu-id="c7a30-129">For example:</span></span>

[!code-csharp[MethodExamples#3](snippets/methods/Program.cs#3)]

## <a name="passing-by-reference-vs-passing-by-value"></a><span data-ttu-id="c7a30-130">Pasar por referencia frente a pasar por valor</span><span class="sxs-lookup"><span data-stu-id="c7a30-130">Passing by reference vs. passing by value</span></span>

<span data-ttu-id="c7a30-131">De forma predeterminada, cuando se pasa una instancia de un [tipo de valor](../../language-reference/builtin-types/value-types.md) a un método, se pasa su copia en lugar de la propia instancia.</span><span class="sxs-lookup"><span data-stu-id="c7a30-131">By default, when an instance of a [value type](../../language-reference/builtin-types/value-types.md) is passed to a method, its copy is passed instead of the instance itself.</span></span> <span data-ttu-id="c7a30-132">Por lo tanto, los cambios realizados en el argumento no tienen ningún efecto en la instancia original del método de llamada.</span><span class="sxs-lookup"><span data-stu-id="c7a30-132">Therefore, changes to the argument have no effect on the original instance in the calling method.</span></span> <span data-ttu-id="c7a30-133">Para pasar una instancia de tipo de valor por referencia, use la palabra clave `ref`.</span><span class="sxs-lookup"><span data-stu-id="c7a30-133">To pass a value-type instance by reference, use the `ref` keyword.</span></span> <span data-ttu-id="c7a30-134">Para obtener más información, vea [Pasar parámetros de tipo de valor (Guía de programación de C#)](./passing-value-type-parameters.md).</span><span class="sxs-lookup"><span data-stu-id="c7a30-134">For more information, see [Passing Value-Type Parameters](./passing-value-type-parameters.md).</span></span>

<span data-ttu-id="c7a30-135">Cuando se pasa un objeto de un tipo de referencia a un método, se pasa una referencia al objeto.</span><span class="sxs-lookup"><span data-stu-id="c7a30-135">When an object of a reference type is passed to a method, a reference to the object is passed.</span></span> <span data-ttu-id="c7a30-136">Es decir, el método no recibe el objeto concreto, recibe un argumento que indica la ubicación del objeto.</span><span class="sxs-lookup"><span data-stu-id="c7a30-136">That is, the method receives not the object itself but an argument that indicates the location of the object.</span></span> <span data-ttu-id="c7a30-137">Si cambia un miembro del objeto mediante esta referencia, el cambio se refleja en el argumento del método de llamada, incluso si pasa el objeto por valor.</span><span class="sxs-lookup"><span data-stu-id="c7a30-137">If you change a member of the object by using this reference, the change is reflected in the argument in the calling method, even if you pass the object by value.</span></span>

<span data-ttu-id="c7a30-138">Crea un tipo de referencia mediante la palabra clave `class`, como se muestra en el siguiente ejemplo:</span><span class="sxs-lookup"><span data-stu-id="c7a30-138">You create a reference type by using the `class` keyword, as the following example shows:</span></span>

[!code-csharp[SampleRefTypeClass#4](snippets/methods/Program.cs#4)]

<span data-ttu-id="c7a30-139">Ahora, si se pasa un objeto basado en este tipo a un método, también se pasa una referencia al objeto.</span><span class="sxs-lookup"><span data-stu-id="c7a30-139">Now, if you pass an object that is based on this type to a method, a reference to the object is passed.</span></span> <span data-ttu-id="c7a30-140">En el ejemplo siguiente se pasa un objeto de tipo `SampleRefType` al método `ModifyObject`:</span><span class="sxs-lookup"><span data-stu-id="c7a30-140">The following example passes an object of type `SampleRefType` to method `ModifyObject`:</span></span>

[!code-csharp[PassingAReferenceType#5](snippets/methods/Program.cs#5)]

<span data-ttu-id="c7a30-141">Fundamentalmente, el ejemplo hace lo mismo que el ejemplo anterior en el que se pasa un argumento por valor a un método.</span><span class="sxs-lookup"><span data-stu-id="c7a30-141">The example does essentially the same thing as the previous example in that it passes an argument by value to a method.</span></span> <span data-ttu-id="c7a30-142">Pero, debido a que se utiliza un tipo de referencia, el resultado es diferente.</span><span class="sxs-lookup"><span data-stu-id="c7a30-142">But, because a reference type is used, the result is different.</span></span> <span data-ttu-id="c7a30-143">La modificación que se lleva a cabo en `ModifyObject` al campo `value` del parámetro, `obj`, también cambia el campo `value` del argumento, `rt`, en el método `TestRefType` .</span><span class="sxs-lookup"><span data-stu-id="c7a30-143">The modification that is made in `ModifyObject` to the `value` field of the parameter, `obj`, also changes the `value` field of the argument, `rt`, in the `TestRefType` method.</span></span> <span data-ttu-id="c7a30-144">El método `TestRefType` muestra 33 como salida.</span><span class="sxs-lookup"><span data-stu-id="c7a30-144">The `TestRefType` method displays 33 as the output.</span></span>

<span data-ttu-id="c7a30-145">Para obtener más información sobre cómo pasar tipos de referencia por valor y por referencia, vea [Pasar parámetros Reference-Type (Guía de programación de C#)](./passing-reference-type-parameters.md) y [Tipos de referencia (Referencia de C#)](../../language-reference/keywords/reference-types.md).</span><span class="sxs-lookup"><span data-stu-id="c7a30-145">For more information about how to pass reference types by reference and by value, see [Passing Reference-Type Parameters](./passing-reference-type-parameters.md) and [Reference Types](../../language-reference/keywords/reference-types.md).</span></span>

## <a name="return-values"></a><span data-ttu-id="c7a30-146">Valores devueltos</span><span class="sxs-lookup"><span data-stu-id="c7a30-146">Return values</span></span>

<span data-ttu-id="c7a30-147">Los métodos pueden devolver un valor al autor de llamada.</span><span class="sxs-lookup"><span data-stu-id="c7a30-147">Methods can return a value to the caller.</span></span> <span data-ttu-id="c7a30-148">Si el tipo de valor devuelto, el tipo enumerado antes del nombre de método, no es `void`, el método puede devolver el valor mediante la utilización de la palabra clave `return` .</span><span class="sxs-lookup"><span data-stu-id="c7a30-148">If the return type, the type listed before the method name, is not `void`, the method can return the value by using the `return` keyword.</span></span> <span data-ttu-id="c7a30-149">Una instrucción con la palabra clave `return` seguida de un valor que coincide con el tipo de valor devuelto devolverá este valor al autor de llamada del método.</span><span class="sxs-lookup"><span data-stu-id="c7a30-149">A statement with the `return` keyword followed by a value that matches the return type will return that value to the method caller.</span></span>

<span data-ttu-id="c7a30-150">El valor puede devolverse al autor de la llamada mediante valor o, a partir de C# 7.0, [mediante referencia](ref-returns.md).</span><span class="sxs-lookup"><span data-stu-id="c7a30-150">The value can be returned to the caller by value or, starting with C# 7.0, [by reference](ref-returns.md).</span></span> <span data-ttu-id="c7a30-151">Los valores se devuelven al autor de la llamada mediante referencia si la palabra clave `ref` se usa en la firma del método y sigue cada palabra clave `return`.</span><span class="sxs-lookup"><span data-stu-id="c7a30-151">Values are returned to the caller by reference if the `ref` keyword is used in the method signature and it follows each `return` keyword.</span></span> <span data-ttu-id="c7a30-152">Por ejemplo, la siguiente firma del método y la instrucción return indican que el método devuelve nombres de variable `estDistance` mediante referencia al autor de la llamada.</span><span class="sxs-lookup"><span data-stu-id="c7a30-152">For example, the following method signature and return statement indicate that the method returns a variable names `estDistance` by reference to the caller.</span></span>

```csharp
public ref double GetEstimatedDistance()
{
    return ref estDistance;
}
```

<span data-ttu-id="c7a30-153">La palabra clave `return` también detiene la ejecución del método.</span><span class="sxs-lookup"><span data-stu-id="c7a30-153">The `return` keyword also stops the execution of the method.</span></span> <span data-ttu-id="c7a30-154">Si el tipo de valor devuelto es `void`, una instrucción `return` sin un valor también es útil para detener la ejecución del método.</span><span class="sxs-lookup"><span data-stu-id="c7a30-154">If the return type is `void`, a `return` statement without a value is still useful to stop the execution of the method.</span></span> <span data-ttu-id="c7a30-155">Sin la palabra clave `return` , el método dejará de ejecutarse cuando alcance el final del bloque de código.</span><span class="sxs-lookup"><span data-stu-id="c7a30-155">Without the `return` keyword, the method will stop executing when it reaches the end of the code block.</span></span> <span data-ttu-id="c7a30-156">Los métodos con un tipo de valor devuelto no nulo son necesarios para usar la palabra clave `return` para devolver un valor.</span><span class="sxs-lookup"><span data-stu-id="c7a30-156">Methods with a non-void return type are required to use the `return` keyword to return a value.</span></span> <span data-ttu-id="c7a30-157">Por ejemplo, estos dos métodos utilizan la palabra clave `return` para devolver enteros:</span><span class="sxs-lookup"><span data-stu-id="c7a30-157">For example, these two methods use the `return` keyword to return integers:</span></span>

[!code-csharp[SimpleMathClass#6](snippets/methods/Program.cs#6)]

<span data-ttu-id="c7a30-158">Para utilizar un valor devuelto de un método, el método de llamada puede usar la llamada de método en cualquier lugar; un valor del mismo tipo sería suficiente.</span><span class="sxs-lookup"><span data-stu-id="c7a30-158">To use a value returned from a method, the calling method can use the method call itself anywhere a value of the same type would be sufficient.</span></span> <span data-ttu-id="c7a30-159">También puede asignar el valor devuelto a una variable.</span><span class="sxs-lookup"><span data-stu-id="c7a30-159">You can also assign the return value to a variable.</span></span> <span data-ttu-id="c7a30-160">Por ejemplo, los dos siguientes ejemplos de código logran el mismo objetivo:</span><span class="sxs-lookup"><span data-stu-id="c7a30-160">For example, the following two code examples accomplish the same goal:</span></span>

[!code-csharp[SquareANumberWithAddTwoNumbersUsingLocalVariable#7](snippets/methods/Program.cs#7)]

[!code-csharp[SquareANumberWithAddTwoNumbersInTheSameLine#8](snippets/methods/Program.cs#8)]

<span data-ttu-id="c7a30-161">Usar una variable local, en este caso, `result`, para almacenar un valor es opcional.</span><span class="sxs-lookup"><span data-stu-id="c7a30-161">Using a local variable, in this case, `result`, to store a value is optional.</span></span> <span data-ttu-id="c7a30-162">La legibilidad del código puede ser útil, o puede ser necesaria si debe almacenar el valor original del argumento para todo el ámbito del método.</span><span class="sxs-lookup"><span data-stu-id="c7a30-162">It may help the readability of the code, or it may be necessary if you need to store the original value of the argument for the entire scope of the method.</span></span>

<span data-ttu-id="c7a30-163">Para usar un valor devuelto mediante referencia de un método, debe declarar una variable [local de tipo ref](ref-returns.md#ref-locals) si pretende modificar su valor.</span><span class="sxs-lookup"><span data-stu-id="c7a30-163">To use a value returned by reference from a method, you must declare a [ref local](ref-returns.md#ref-locals) variable if you intend to modify its value.</span></span> <span data-ttu-id="c7a30-164">Por ejemplo, si el método `Planet.GetEstimatedDistance` devuelve un valor <xref:System.Double> mediante referencia, puede definirlo como una variable local de tipo ref con código como el siguiente:</span><span class="sxs-lookup"><span data-stu-id="c7a30-164">For example, if the `Planet.GetEstimatedDistance` method returns a <xref:System.Double> value by reference, you can define it as a ref local variable with code like the following:</span></span>

```csharp
ref int distance = plant
```

<span data-ttu-id="c7a30-165">Devolver una matriz multidimensional de un método, `M`, que modifica el contenido de la matriz no es necesario si la función de llamada ha pasado la matriz a `M`.</span><span class="sxs-lookup"><span data-stu-id="c7a30-165">Returning a multi-dimensional array from a method, `M`, that modifies the array's contents is not necessary if the calling function passed the array into `M`.</span></span>  <span data-ttu-id="c7a30-166">Puede devolver la matriz resultante de `M` para obtener un estilo correcto o un flujo funcional de valores, pero no es necesario porque C# pasa todos los tipos de referencia mediante valor, y el valor de una referencia de matriz es el puntero de la matriz.</span><span class="sxs-lookup"><span data-stu-id="c7a30-166">You may return the resulting array from `M` for good style or functional flow of values, but it is not necessary because C# passes all reference types by value, and the value of an array reference is the pointer to the array.</span></span> <span data-ttu-id="c7a30-167">En el método `M`, los cambios en el contenido de la matriz los puede observar cualquier código que tenga una referencia a la matriz, como se muestra en el ejemplo siguiente:</span><span class="sxs-lookup"><span data-stu-id="c7a30-167">In the method `M`, any changes to the array's contents are observable by any code that has a reference to the array, as shown in the following example:</span></span>

```csharp
static void Main(string[] args)
{
    int[,] matrix = new int[2, 2];
    FillMatrix(matrix);
    // matrix is now full of -1
}

public static void FillMatrix(int[,] matrix)
{
    for (int i = 0; i < matrix.GetLength(0); i++)
    {
        for (int j = 0; j < matrix.GetLength(1); j++)
        {
            matrix[i, j] = -1;
        }
    }
}
```

<span data-ttu-id="c7a30-168">Para obtener más información, consulta [return](../../language-reference/keywords/return.md).</span><span class="sxs-lookup"><span data-stu-id="c7a30-168">For more information, see [return](../../language-reference/keywords/return.md).</span></span>

## <a name="async-methods"></a><span data-ttu-id="c7a30-169">Métodos asincrónicos</span><span class="sxs-lookup"><span data-stu-id="c7a30-169">Async methods</span></span>

<span data-ttu-id="c7a30-170">Mediante la característica asincrónica, puede invocar métodos asincrónicos sin usar definiciones de llamada explícitas ni dividir manualmente el código en varios métodos o expresiones lambda.</span><span class="sxs-lookup"><span data-stu-id="c7a30-170">By using the async feature, you can invoke asynchronous methods without using explicit callbacks or manually splitting your code across multiple methods or lambda expressions.</span></span>

<span data-ttu-id="c7a30-171">Si marca un método con el modificador [async](../../language-reference/keywords/async.md), puede usar el operador [await](../../language-reference/operators/await.md) en el método.</span><span class="sxs-lookup"><span data-stu-id="c7a30-171">If you mark a method with the [async](../../language-reference/keywords/async.md) modifier, you can use the [await](../../language-reference/operators/await.md) operator in the method.</span></span> <span data-ttu-id="c7a30-172">Cuando el control alcanza una expresión await en el método asincrónico, el control se devuelve al autor de llamada y se progreso del método se suspende hasta que se completa la tarea esperada.</span><span class="sxs-lookup"><span data-stu-id="c7a30-172">When control reaches an await expression in the async method, control returns to the caller, and progress in the method is suspended until the awaited task completes.</span></span> <span data-ttu-id="c7a30-173">Cuando se completa la tarea, la ejecución puede reanudarse en el método.</span><span class="sxs-lookup"><span data-stu-id="c7a30-173">When the task is complete, execution can resume in the method.</span></span>

> [!NOTE]
> <span data-ttu-id="c7a30-174">Un método asincrónico vuelve al autor de la llamada cuando encuentra el primer objeto esperado que aún no se ha completado o cuando llega al final del método asincrónico, lo que ocurra primero.</span><span class="sxs-lookup"><span data-stu-id="c7a30-174">An async method returns to the caller when either it encounters the first awaited object that's not yet complete or it gets to the end of the async method, whichever occurs first.</span></span>

<span data-ttu-id="c7a30-175">Un método asincrónico normalmente tiene un tipo de valor devuelto de <xref:System.Threading.Tasks.Task%601>, <xref:System.Threading.Tasks.Task>, <xref:System.Collections.Generic.IAsyncEnumerable%601> o `void`.</span><span class="sxs-lookup"><span data-stu-id="c7a30-175">An async method typically has a return type of <xref:System.Threading.Tasks.Task%601>, <xref:System.Threading.Tasks.Task>, <xref:System.Collections.Generic.IAsyncEnumerable%601>or `void`.</span></span> <span data-ttu-id="c7a30-176">El tipo de valor devuelto `void` se usa principalmente para definir controladores de eventos, donde se requiere un tipo de valor devuelto `void`.</span><span class="sxs-lookup"><span data-stu-id="c7a30-176">The `void` return type is used primarily to define event handlers, where a `void` return type is required.</span></span> <span data-ttu-id="c7a30-177">No se puede esperar un método asincrónico que devuelve `void` y el autor de llamada a un método que no devuelve ningún valor no puede capturar ninguna excepción producida por este.</span><span class="sxs-lookup"><span data-stu-id="c7a30-177">An async method that returns `void` can't be awaited, and the caller of a void-returning method can't catch exceptions that the method throws.</span></span> <span data-ttu-id="c7a30-178">A partir de la versión C# 7.0, el método asincrónico puede tener [cualquier tipo de valor devuelto similar a una tarea ](../../whats-new/csharp-7.md#generalized-async-return-types).</span><span class="sxs-lookup"><span data-stu-id="c7a30-178">Starting with C# 7.0, an async method can have [any task-like return type](../../whats-new/csharp-7.md#generalized-async-return-types).</span></span>

<span data-ttu-id="c7a30-179">En el ejemplo siguiente, `DelayAsync` es un método asincrónico con un tipo de valor devuelto de <xref:System.Threading.Tasks.Task%601>.</span><span class="sxs-lookup"><span data-stu-id="c7a30-179">In the following example, `DelayAsync` is an async method that has a return type of <xref:System.Threading.Tasks.Task%601>.</span></span> <span data-ttu-id="c7a30-180">`DelayAsync` tiene una instrucción `return` que devuelve un entero.</span><span class="sxs-lookup"><span data-stu-id="c7a30-180">`DelayAsync` has a `return` statement that returns an integer.</span></span> <span data-ttu-id="c7a30-181">Por lo tanto, la declaración del método de `DelayAsync` debe tener un tipo de valor devuelto de `Task<int>`.</span><span class="sxs-lookup"><span data-stu-id="c7a30-181">Therefore the method declaration of `DelayAsync` must have a return type of `Task<int>`.</span></span> <span data-ttu-id="c7a30-182">Dado que el tipo de valor devuelto es `Task<int>`, la evaluación de la expresión `await` en `DoSomethingAsync` genera un entero, como se demuestra en la siguiente instrucción: `int result = await delayTask`.</span><span class="sxs-lookup"><span data-stu-id="c7a30-182">Because the return type is `Task<int>`, the evaluation of the `await` expression in `DoSomethingAsync` produces an integer as the following statement demonstrates: `int result = await delayTask`.</span></span>

<span data-ttu-id="c7a30-183">El método `Main` es un ejemplo de método asincrónico con un tipo de valor devuelto <xref:System.Threading.Tasks.Task>.</span><span class="sxs-lookup"><span data-stu-id="c7a30-183">The `Main` method is an example of an async method that has a return type of <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="c7a30-184">Va al método `DoSomethingAsync`, y como se expresa con una sola línea, puede omitir las palabras clave `async` y `await`.</span><span class="sxs-lookup"><span data-stu-id="c7a30-184">It goes to the `DoSomethingAsync` method, and because it is expressed with a single line, it can omit the `async` and `await` keywords.</span></span> <span data-ttu-id="c7a30-185">Dado que `DoSomethingAsync` es un método asincrónico, la tarea de la llamada a `DoSomethingAsync` debe esperar, como se muestra en la siguiente instrucción: `await DoSomethingAsync();`.</span><span class="sxs-lookup"><span data-stu-id="c7a30-185">Because `DoSomethingAsync` is an async method, the task for the call to `DoSomethingAsync` must be awaited, as the following statement shows: `await DoSomethingAsync();`.</span></span>

:::code language="csharp" source="snippets/classes-and-structs/methods/Program.cs":::

<span data-ttu-id="c7a30-186">Un método aisncrónico no puede declarar ningún parámetro [ref](../../language-reference/keywords/ref.md) u [out](../../language-reference/keywords/out-parameter-modifier.md) , pero puede llamar a los métodos que tienen estos parámetros.</span><span class="sxs-lookup"><span data-stu-id="c7a30-186">An async method can't declare any [ref](../../language-reference/keywords/ref.md) or [out](../../language-reference/keywords/out-parameter-modifier.md) parameters, but it can call methods that have such parameters.</span></span>

<span data-ttu-id="c7a30-187">Para obtener más información sobre los métodos asincrónicos, consulte los artículos [Programación asincrónica con async y await](../concepts/async/index.md) y [Tipos de valor devueltos asincrónicos](../concepts/async/async-return-types.md).</span><span class="sxs-lookup"><span data-stu-id="c7a30-187">For more information about async methods, see [Asynchronous programming with async and await](../concepts/async/index.md) and [Async return types](../concepts/async/async-return-types.md).</span></span>

## <a name="expression-body-definitions"></a><span data-ttu-id="c7a30-188">Definiciones de cuerpos de expresión</span><span class="sxs-lookup"><span data-stu-id="c7a30-188">Expression body definitions</span></span>

<span data-ttu-id="c7a30-189">Es habitual tener definiciones de método que simplemente hacen las devoluciones de forma inmediata con el resultado de una expresión, o que tienen una sola instrucción como cuerpo del método.</span><span class="sxs-lookup"><span data-stu-id="c7a30-189">It is common to have method definitions that simply return immediately with the result of an expression, or that have a single statement as the body of the method.</span></span> <span data-ttu-id="c7a30-190">Hay un acceso directo de sintaxis para definir este método mediante `=>`:</span><span class="sxs-lookup"><span data-stu-id="c7a30-190">There is a syntax shortcut for defining such methods using `=>`:</span></span>

```csharp
public Point Move(int dx, int dy) => new Point(x + dx, y + dy);
public void Print() => Console.WriteLine(First + " " + Last);
// Works with operators, properties, and indexers too.
public static Complex operator +(Complex a, Complex b) => a.Add(b);
public string Name => First + " " + Last;
public Customer this[long id] => store.LookupCustomer(id);
```

<span data-ttu-id="c7a30-191">Si el método devuelve `void` o si es un método asincrónico, el cuerpo del método debe ser una expresión de instrucción (igual que con las expresiones lambda).</span><span class="sxs-lookup"><span data-stu-id="c7a30-191">If the method returns `void` or is an async method, then the body of the method must be a statement expression (same as with lambdas).</span></span> <span data-ttu-id="c7a30-192">Para las propiedades y los indexadores, solo deben leerse, y no usa la palabra clave de descriptor de acceso `get`.</span><span class="sxs-lookup"><span data-stu-id="c7a30-192">For properties and indexers, they must be read only, and you don't use the `get` accessor keyword.</span></span>

## <a name="iterators"></a><span data-ttu-id="c7a30-193">Iterators</span><span class="sxs-lookup"><span data-stu-id="c7a30-193">Iterators</span></span>

<span data-ttu-id="c7a30-194">Un iterador realiza una iteración personalizada en una colección, como una lista o matriz.</span><span class="sxs-lookup"><span data-stu-id="c7a30-194">An iterator performs a custom iteration over a collection, such as a list or an array.</span></span> <span data-ttu-id="c7a30-195">Un iterador utiliza la instrucción [yield return](../../language-reference/keywords/yield.md) para devolver cada elemento de uno en uno.</span><span class="sxs-lookup"><span data-stu-id="c7a30-195">An iterator uses the [yield return](../../language-reference/keywords/yield.md) statement to return each element one at a time.</span></span> <span data-ttu-id="c7a30-196">Cuando se alcanza la instrucción [yield return](../../language-reference/keywords/yield.md) , se recuerda la ubicación actual en el código.</span><span class="sxs-lookup"><span data-stu-id="c7a30-196">When a [yield return](../../language-reference/keywords/yield.md) statement is reached, the current location in code is remembered.</span></span> <span data-ttu-id="c7a30-197">La ejecución se reinicia desde esa ubicación la próxima vez que se llama el iterador.</span><span class="sxs-lookup"><span data-stu-id="c7a30-197">Execution is restarted from that location when the iterator is called the next time.</span></span>

<span data-ttu-id="c7a30-198">Llame a un iterador a partir del código de cliente mediante una instrucción [foreach](../../language-reference/keywords/foreach-in.md) .</span><span class="sxs-lookup"><span data-stu-id="c7a30-198">You call an iterator from client code by using a [foreach](../../language-reference/keywords/foreach-in.md) statement.</span></span>

<span data-ttu-id="c7a30-199">El tipo de valor devuelto de un iterador puede ser <xref:System.Collections.IEnumerable>, <xref:System.Collections.Generic.IEnumerable%601>, <xref:System.Collections.IEnumerator> o <xref:System.Collections.Generic.IEnumerator%601>.</span><span class="sxs-lookup"><span data-stu-id="c7a30-199">The return type of an iterator can be <xref:System.Collections.IEnumerable>, <xref:System.Collections.Generic.IEnumerable%601>, <xref:System.Collections.IEnumerator>, or <xref:System.Collections.Generic.IEnumerator%601>.</span></span>

<span data-ttu-id="c7a30-200">Para obtener más información, consulta [Iteradores](../concepts/iterators.md).</span><span class="sxs-lookup"><span data-stu-id="c7a30-200">For more information, see [Iterators](../concepts/iterators.md).</span></span>

## <a name="c-language-specification"></a><span data-ttu-id="c7a30-201">Especificación del lenguaje C#</span><span class="sxs-lookup"><span data-stu-id="c7a30-201">C# language specification</span></span>

[!INCLUDE[CSharplangspec](~/includes/csharplangspec-md.md)]

## <a name="see-also"></a><span data-ttu-id="c7a30-202">Consulte también</span><span class="sxs-lookup"><span data-stu-id="c7a30-202">See also</span></span>

- [<span data-ttu-id="c7a30-203">Guía de programación de C#</span><span class="sxs-lookup"><span data-stu-id="c7a30-203">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="c7a30-204">Clases y structs</span><span class="sxs-lookup"><span data-stu-id="c7a30-204">Classes and Structs</span></span>](index.md)
- [<span data-ttu-id="c7a30-205">Modificadores de acceso</span><span class="sxs-lookup"><span data-stu-id="c7a30-205">Access Modifiers</span></span>](access-modifiers.md)
- [<span data-ttu-id="c7a30-206">Clases estáticas y sus miembros</span><span class="sxs-lookup"><span data-stu-id="c7a30-206">Static Classes and Static Class Members</span></span>](static-classes-and-static-class-members.md)
- [<span data-ttu-id="c7a30-207">Herencia</span><span class="sxs-lookup"><span data-stu-id="c7a30-207">Inheritance</span></span>](inheritance.md)
- [<span data-ttu-id="c7a30-208">Clases y miembros de clase abstractos y sellados</span><span class="sxs-lookup"><span data-stu-id="c7a30-208">Abstract and Sealed Classes and Class Members</span></span>](abstract-and-sealed-classes-and-class-members.md)
- [<span data-ttu-id="c7a30-209">params</span><span class="sxs-lookup"><span data-stu-id="c7a30-209">params</span></span>](../../language-reference/keywords/params.md)
- [<span data-ttu-id="c7a30-210">return</span><span class="sxs-lookup"><span data-stu-id="c7a30-210">return</span></span>](../../language-reference/keywords/return.md)
- [<span data-ttu-id="c7a30-211">out</span><span class="sxs-lookup"><span data-stu-id="c7a30-211">out</span></span>](../../language-reference/keywords/out.md)
- [<span data-ttu-id="c7a30-212">ref</span><span class="sxs-lookup"><span data-stu-id="c7a30-212">ref</span></span>](../../language-reference/keywords/ref.md)
- [<span data-ttu-id="c7a30-213">Pasar parámetros</span><span class="sxs-lookup"><span data-stu-id="c7a30-213">Passing Parameters</span></span>](passing-parameters.md)
