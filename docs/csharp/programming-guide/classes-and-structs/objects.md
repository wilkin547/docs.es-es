---
title: 'Objetos: Guía de programación de C#'
description: C# usa una definición de clase o estructura para definir tipos de objetos. En un lenguaje orientado a objetos como C#, un programa consta de objetos que interactúan de forma dinámica.
ms.date: 02/03/2021
helpviewer_keywords:
- objects [C#], about objects
- variables [C#]
ms.assetid: af4a5230-fbf3-4eea-95e1-8b883c2f845c
ms.openlocfilehash: df549b76c5bd49fa91424915928527ec14d7689c
ms.sourcegitcommit: 65af0f0ad316858882845391d60ef7e303b756e8
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 02/05/2021
ms.locfileid: "99585719"
---
# <a name="objects-c-programming-guide"></a><span data-ttu-id="4e26d-104">Objetos (Guía de programación de C#)</span><span class="sxs-lookup"><span data-stu-id="4e26d-104">Objects (C# Programming Guide)</span></span>

<span data-ttu-id="4e26d-105">Una definición de clase o estructura es como un plano que especifica qué puede hacer el tipo.</span><span class="sxs-lookup"><span data-stu-id="4e26d-105">A class or struct definition is like a blueprint that specifies what the type can do.</span></span> <span data-ttu-id="4e26d-106">Un objeto es básicamente un bloque de memoria que se ha asignado y configurado de acuerdo con el plano.</span><span class="sxs-lookup"><span data-stu-id="4e26d-106">An object is basically a block of memory that has been allocated and configured according to the blueprint.</span></span> <span data-ttu-id="4e26d-107">Un programa puede crear muchos objetos de la misma clase.</span><span class="sxs-lookup"><span data-stu-id="4e26d-107">A program may create many objects of the same class.</span></span> <span data-ttu-id="4e26d-108">Los objetos también se denominan instancias y pueden almacenarse en una variable con nombre, o en una matriz o colección.</span><span class="sxs-lookup"><span data-stu-id="4e26d-108">Objects are also called instances, and they can be stored in either a named variable or in an array or collection.</span></span> <span data-ttu-id="4e26d-109">El código de cliente es el código que usa estas variables para llamar a los métodos y acceder a las propiedades públicas del objeto.</span><span class="sxs-lookup"><span data-stu-id="4e26d-109">Client code is the code that uses these variables to call the methods and access the public properties of the object.</span></span> <span data-ttu-id="4e26d-110">En un lenguaje orientado a objetos, como C#, un programa típico consta de varios objetos que interactúan dinámicamente.</span><span class="sxs-lookup"><span data-stu-id="4e26d-110">In an object-oriented language such as C#, a typical program consists of multiple objects interacting dynamically.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="4e26d-111">Los tipos estáticos se comportan de forma diferente a lo que se describe aquí.</span><span class="sxs-lookup"><span data-stu-id="4e26d-111">Static types behave differently than what is described here.</span></span> <span data-ttu-id="4e26d-112">Para más información, vea [Clases estáticas y sus miembros](./static-classes-and-static-class-members.md).</span><span class="sxs-lookup"><span data-stu-id="4e26d-112">For more information, see [Static Classes and Static Class Members](./static-classes-and-static-class-members.md).</span></span>
  
## <a name="struct-instances-vs-class-instances"></a><span data-ttu-id="4e26d-113">Instancias de estructura frente a Instancias de clase</span><span class="sxs-lookup"><span data-stu-id="4e26d-113">Struct Instances vs. Class Instances</span></span>  

 <span data-ttu-id="4e26d-114">Puesto que las clases son tipos de referencia, una variable de un objeto de clase contiene una referencia a la dirección del objeto del montón administrado.</span><span class="sxs-lookup"><span data-stu-id="4e26d-114">Because classes are reference types, a variable of a class object holds a reference to the address of the object on the managed heap.</span></span> <span data-ttu-id="4e26d-115">Si se asigna un segundo objeto del mismo tipo al primer objeto, ambas variables hacen referencia al objeto de esa dirección.</span><span class="sxs-lookup"><span data-stu-id="4e26d-115">If a second object of the same type is assigned to the first object, then both variables refer to the object at that address.</span></span> <span data-ttu-id="4e26d-116">Este punto se analiza con más detalle más adelante en este tema.</span><span class="sxs-lookup"><span data-stu-id="4e26d-116">This point is discussed in more detail later in this topic.</span></span>  
  
 <span data-ttu-id="4e26d-117">Las instancias de clases se crean mediante el [operador new](../../language-reference/operators/new-operator.md).</span><span class="sxs-lookup"><span data-stu-id="4e26d-117">Instances of classes are created by using the [new operator](../../language-reference/operators/new-operator.md).</span></span> <span data-ttu-id="4e26d-118">En el ejemplo siguiente, `Person` es el tipo, y `person1` y `person2` son instancias u objetos de ese tipo.</span><span class="sxs-lookup"><span data-stu-id="4e26d-118">In the following example, `Person` is the type and `person1` and `person2` are instances, or objects, of that type.</span></span>  
  
 [!code-csharp[csProgGuideStatements#30](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStatements/CS/Statements.cs#30)]  
  
 <span data-ttu-id="4e26d-119">Dado que las estructuras son tipos de valor, una variable de un objeto de estructura contiene una copia de todo el objeto.</span><span class="sxs-lookup"><span data-stu-id="4e26d-119">Because structs are value types, a variable of a struct object holds a copy of the entire object.</span></span> <span data-ttu-id="4e26d-120">También se pueden crear instancias de estructuras usando el operador `new`, pero esto no resulta necesario, como se muestra en el ejemplo siguiente:</span><span class="sxs-lookup"><span data-stu-id="4e26d-120">Instances of structs can also be created by using the `new` operator, but this is not required, as shown in the following example:</span></span>  
  
 [!code-csharp[csProgGuideStatements#31](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStatements/CS/Statements.cs#31)]  
  
 <span data-ttu-id="4e26d-121">La memoria para `p1` y `p2` se asigna en la pila de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="4e26d-121">The memory for both `p1` and `p2` is allocated on the thread stack.</span></span> <span data-ttu-id="4e26d-122">Esta memoria se reclama junto con el tipo o método en el que se declara.</span><span class="sxs-lookup"><span data-stu-id="4e26d-122">That memory is reclaimed along with the type or method in which it is declared.</span></span> <span data-ttu-id="4e26d-123">Este es uno de los motivos por los que se copian las estructuras en la asignación.</span><span class="sxs-lookup"><span data-stu-id="4e26d-123">This is one reason why structs are copied on assignment.</span></span> <span data-ttu-id="4e26d-124">Por el contrario, la memoria que se asigna a una instancia de clase la reclama automáticamente (recolección de elementos no utilizados) Common Language Runtime cuando todas las referencias al objeto se han salido del ámbito.</span><span class="sxs-lookup"><span data-stu-id="4e26d-124">By contrast, the memory that is allocated for a class instance is automatically reclaimed (garbage collected) by the common language runtime when all references to the object have gone out of scope.</span></span> <span data-ttu-id="4e26d-125">No es posible destruir de forma determinante un objeto de clase como en C++.</span><span class="sxs-lookup"><span data-stu-id="4e26d-125">It is not possible to deterministically destroy a class object like you can in C++.</span></span> <span data-ttu-id="4e26d-126">Para obtener más información sobre la recolección de elementos no utilizados en .NET, vea [Recolección de elementos no utilizados](../../../standard/garbage-collection/index.md).</span><span class="sxs-lookup"><span data-stu-id="4e26d-126">For more information about garbage collection in .NET, see [Garbage Collection](../../../standard/garbage-collection/index.md).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="4e26d-127">La asignación y desasignación de memoria en el montón administrado están muy optimizadas en Common Language Runtime.</span><span class="sxs-lookup"><span data-stu-id="4e26d-127">The allocation and deallocation of memory on the managed heap is highly optimized in the common language runtime.</span></span> <span data-ttu-id="4e26d-128">En la mayoría de los casos, no existe ninguna diferencia significativa en el costo de rendimiento entre asignar una instancia de clase en el montón y asignar una instancia de estructura en la pila.</span><span class="sxs-lookup"><span data-stu-id="4e26d-128">In most cases there is no significant difference in the performance cost of allocating a class instance on the heap versus allocating a struct instance on the stack.</span></span>
  
## <a name="object-identity-vs-value-equality"></a><span data-ttu-id="4e26d-129">Identidad de objeto frente a igualdad de valores</span><span class="sxs-lookup"><span data-stu-id="4e26d-129">Object Identity vs. Value Equality</span></span>  

 <span data-ttu-id="4e26d-130">Cuando se comparan dos objetos para comprobar si son iguales, primero debe determinar si quiere saber si las dos variables representan el mismo objeto en la memoria o si los valores de uno o varios de sus campos son equivalentes.</span><span class="sxs-lookup"><span data-stu-id="4e26d-130">When you compare two objects for equality, you must first distinguish whether you want to know whether the two variables represent the same object in memory, or whether the values of one or more of their fields are equivalent.</span></span> <span data-ttu-id="4e26d-131">Si tiene previsto comparar valores, debe tener en cuenta si los objetos son instancias de tipos de valor (estructuras) o tipos de referencia (clases, delegados y matrices).</span><span class="sxs-lookup"><span data-stu-id="4e26d-131">If you are intending to compare values, you must consider whether the objects are instances of value types (structs) or reference types (classes, delegates, arrays).</span></span>  
  
- <span data-ttu-id="4e26d-132">Para determinar si dos instancias de clase hacen referencia a la misma ubicación en la memoria (lo que significa que tienen la misma *identidad*), use el método estático <xref:System.Object.Equals%2A>.</span><span class="sxs-lookup"><span data-stu-id="4e26d-132">To determine whether two class instances refer to the same location in memory (which means that they have the same *identity*), use the static <xref:System.Object.Equals%2A> method.</span></span> <span data-ttu-id="4e26d-133">(<xref:System.Object?displayProperty=nameWithType> es la clase base implícita para todos los tipos de valor y tipos de referencia, incluidas las clases y estructuras definidas por el usuario).</span><span class="sxs-lookup"><span data-stu-id="4e26d-133">(<xref:System.Object?displayProperty=nameWithType> is the implicit base class for all value types and reference types, including user-defined structs and classes.)</span></span>  
  
- <span data-ttu-id="4e26d-134">Para determinar si los campos de instancia de dos instancias de estructura presentan los mismos valores, use el método <xref:System.ValueType.Equals%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4e26d-134">To determine whether the instance fields in two struct instances have the same values, use the <xref:System.ValueType.Equals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="4e26d-135">Dado que todas las estructuras heredan implícitamente de <xref:System.ValueType?displayProperty=nameWithType>, se llama al método directamente en el objeto, como se muestra en el ejemplo siguiente:</span><span class="sxs-lookup"><span data-stu-id="4e26d-135">Because all structs implicitly inherit from <xref:System.ValueType?displayProperty=nameWithType>, you call the method directly on your object as shown in the following example:</span></span>  
  
 [!code-csharp[csProgGuideStatements#32](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStatements/CS/Statements.cs#32)]  
  
 <span data-ttu-id="4e26d-136">En algunos casos, la implementación de <xref:System.ValueType?displayProperty=nameWithType> de `Equals` utiliza la conversión boxing y la reflexión.</span><span class="sxs-lookup"><span data-stu-id="4e26d-136">The <xref:System.ValueType?displayProperty=nameWithType> implementation of `Equals` uses boxing and reflection in some cases.</span></span> <span data-ttu-id="4e26d-137">Para obtener información sobre cómo proporcionar un algoritmo de igualdad eficaz que sea específico del tipo, consulte [cómo definir la igualdad de valores para un tipo](../statements-expressions-operators/how-to-define-value-equality-for-a-type.md).</span><span class="sxs-lookup"><span data-stu-id="4e26d-137">For information about how to provide an efficient equality algorithm that is specific to your type, see [How to define value equality for a type](../statements-expressions-operators/how-to-define-value-equality-for-a-type.md)</span></span>

- <span data-ttu-id="4e26d-138">Para determinar si los valores de los campos de dos instancias de clase son iguales, puede usar el método <xref:System.Object.Equals%2A> o el [operador ==](../../language-reference/operators/equality-operators.md#equality-operator-).</span><span class="sxs-lookup"><span data-stu-id="4e26d-138">To determine whether the values of the fields in two class instances are equal, you might be able to use the <xref:System.Object.Equals%2A> method or the [== operator](../../language-reference/operators/equality-operators.md#equality-operator-).</span></span> <span data-ttu-id="4e26d-139">En cambio, úselos solo si la clase los ha invalidado o sobrecargado para proporcionar una definición personalizada de lo que significa "igualdad" para los objetos de ese tipo.</span><span class="sxs-lookup"><span data-stu-id="4e26d-139">However, only use them if the class has overridden or overloaded them to provide a custom definition of what "equality" means for objects of that type.</span></span> <span data-ttu-id="4e26d-140">La clase también puede implementar la interfaz <xref:System.IEquatable%601> o la interfaz <xref:System.Collections.Generic.IEqualityComparer%601>.</span><span class="sxs-lookup"><span data-stu-id="4e26d-140">The class might also implement the <xref:System.IEquatable%601> interface or the <xref:System.Collections.Generic.IEqualityComparer%601> interface.</span></span> <span data-ttu-id="4e26d-141">Ambas interfaces proporcionan métodos que pueden servir para comprobar la igualdad de valores.</span><span class="sxs-lookup"><span data-stu-id="4e26d-141">Both interfaces provide methods that can be used to test value equality.</span></span> <span data-ttu-id="4e26d-142">Al diseñar sus propias clases que invaliden `Equals`, asegúrese de seguir las instrucciones descritas en [Procedimiento: Definición de la igualdad de valores para un tipo](../statements-expressions-operators/how-to-define-value-equality-for-a-type.md) y <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4e26d-142">When designing your own classes that override `Equals`, make sure to follow the guidelines stated in [How to define value equality for a type](../statements-expressions-operators/how-to-define-value-equality-for-a-type.md) and <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>.</span></span>
  
## <a name="related-sections"></a><span data-ttu-id="4e26d-143">Secciones relacionadas</span><span class="sxs-lookup"><span data-stu-id="4e26d-143">Related Sections</span></span>  

 <span data-ttu-id="4e26d-144">Para obtener más información:</span><span class="sxs-lookup"><span data-stu-id="4e26d-144">For more information:</span></span>  
  
- [<span data-ttu-id="4e26d-145">Clases</span><span class="sxs-lookup"><span data-stu-id="4e26d-145">Classes</span></span>](./classes.md)  
  
- [<span data-ttu-id="4e26d-146">Constructores</span><span class="sxs-lookup"><span data-stu-id="4e26d-146">Constructors</span></span>](./constructors.md)  
  
- [<span data-ttu-id="4e26d-147">Finalizadores</span><span class="sxs-lookup"><span data-stu-id="4e26d-147">Finalizers</span></span>](./destructors.md)  
  
- [<span data-ttu-id="4e26d-148">Eventos</span><span class="sxs-lookup"><span data-stu-id="4e26d-148">Events</span></span>](../events/index.md)  
  
## <a name="see-also"></a><span data-ttu-id="4e26d-149">Vea también</span><span class="sxs-lookup"><span data-stu-id="4e26d-149">See also</span></span>

- [<span data-ttu-id="4e26d-150">Guía de programación de C#</span><span class="sxs-lookup"><span data-stu-id="4e26d-150">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="4e26d-151">object</span><span class="sxs-lookup"><span data-stu-id="4e26d-151">object</span></span>](../../language-reference/builtin-types/reference-types.md)
- [<span data-ttu-id="4e26d-152">Herencia</span><span class="sxs-lookup"><span data-stu-id="4e26d-152">Inheritance</span></span>](./inheritance.md)
- [<span data-ttu-id="4e26d-153">class</span><span class="sxs-lookup"><span data-stu-id="4e26d-153">class</span></span>](../../language-reference/keywords/class.md)
- [<span data-ttu-id="4e26d-154">Tipos de estructura</span><span class="sxs-lookup"><span data-stu-id="4e26d-154">Structure types</span></span>](../../language-reference/builtin-types/struct.md)
- [<span data-ttu-id="4e26d-155">new (operador)</span><span class="sxs-lookup"><span data-stu-id="4e26d-155">new Operator</span></span>](../../language-reference/operators/new-operator.md)
- [<span data-ttu-id="4e26d-156">Sistema de tipos comunes</span><span class="sxs-lookup"><span data-stu-id="4e26d-156">Common Type System</span></span>](../../../standard/base-types/common-type-system.md)
