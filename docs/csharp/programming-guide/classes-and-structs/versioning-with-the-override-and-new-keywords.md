---
title: 'Control de versiones con las palabras clave Override y New: Guía de programación de C#'
ms.date: 07/20/2015
helpviewer_keywords:
- C# language, versioning
- C# language, override and new
ms.assetid: 88247d07-bd0d-49e9-a619-45ccbbfdf0c5
ms.openlocfilehash: 089d5d7c7a95e2de4629f53255d9d9790fd5508a
ms.sourcegitcommit: 5f236cd78cf09593c8945a7d753e0850e96a0b80
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 01/07/2020
ms.locfileid: "75705397"
---
# <a name="versioning-with-the-override-and-new-keywords-c-programming-guide"></a><span data-ttu-id="6ecdb-102">Control de versiones con las palabras clave Override y New (Guía de programación de C#)</span><span class="sxs-lookup"><span data-stu-id="6ecdb-102">Versioning with the Override and New Keywords (C# Programming Guide)</span></span>
<span data-ttu-id="6ecdb-103">El lenguaje C# está diseñado para que las versiones entre clases [base](../../language-reference/keywords/base.md) y derivadas de diferentes bibliotecas puedan evolucionar y mantener la compatibilidad con versiones anteriores.</span><span class="sxs-lookup"><span data-stu-id="6ecdb-103">The C# language is designed so that versioning between [base](../../language-reference/keywords/base.md) and derived classes in different libraries can evolve and maintain backward compatibility.</span></span> <span data-ttu-id="6ecdb-104">Esto significa, por ejemplo, que la introducción de un nuevo miembro en una [clase](../../language-reference/keywords/class.md) base con el mismo nombre que un miembro de una clase derivada es totalmente compatible con C# y no lleva a un comportamiento inesperado.</span><span class="sxs-lookup"><span data-stu-id="6ecdb-104">This means, for example, that the introduction of a new member in a base [class](../../language-reference/keywords/class.md) with the same name as a member in a derived class is completely supported by C# and does not lead to unexpected behavior.</span></span> <span data-ttu-id="6ecdb-105">Además, implica que una clase debe declarar explícitamente si un método está pensado para reemplazar un método heredado o si se trata de un nuevo método que oculta un método heredado de nombre similar.</span><span class="sxs-lookup"><span data-stu-id="6ecdb-105">It also means that a class must explicitly state whether a method is intended to override an inherited method, or whether a method is a new method that hides a similarly named inherited method.</span></span>  
  
 <span data-ttu-id="6ecdb-106">En C#, las clases derivadas pueden contener métodos con el mismo nombre que los métodos de clase base.</span><span class="sxs-lookup"><span data-stu-id="6ecdb-106">In C#, derived classes can contain methods with the same name as base class methods.</span></span>  
  
- <span data-ttu-id="6ecdb-107">El método de clase base debe definirse como [virtual](../../language-reference/keywords/virtual.md).</span><span class="sxs-lookup"><span data-stu-id="6ecdb-107">The base class method must be defined [virtual](../../language-reference/keywords/virtual.md).</span></span>  
  
- <span data-ttu-id="6ecdb-108">Si el método de la clase derivada no va precedido por las palabras clave [new](../../language-reference/keywords/new-modifier.md) u [override](../../language-reference/keywords/override.md), el compilador emite una advertencia y el método se comporta como si la palabra clave `new` estuviese presente.</span><span class="sxs-lookup"><span data-stu-id="6ecdb-108">If the method in the derived class is not preceded by [new](../../language-reference/keywords/new-modifier.md) or [override](../../language-reference/keywords/override.md) keywords, the compiler will issue a warning and the method will behave as if the `new` keyword were present.</span></span>  
  
- <span data-ttu-id="6ecdb-109">Si el método de la clase derivada va precedido de la palabra clave `new`, el método se define como independiente del método de la clase base.</span><span class="sxs-lookup"><span data-stu-id="6ecdb-109">If the method in the derived class is preceded with the `new` keyword, the method is defined as being independent of the method in the base class.</span></span>  
  
- <span data-ttu-id="6ecdb-110">Si el método de la clase derivada va precedido de la palabra clave `override`, los objetos de la clase derivada llamarán a ese método y no al método de la clase base.</span><span class="sxs-lookup"><span data-stu-id="6ecdb-110">If the method in the derived class is preceded with the `override` keyword, objects of the derived class will call that method instead of the base class method.</span></span>  
  
- <span data-ttu-id="6ecdb-111">El método de clase base puede llamarse desde dentro de la clase derivada mediante la palabra clave `base`.</span><span class="sxs-lookup"><span data-stu-id="6ecdb-111">The base class method can be called from within the derived class using the `base` keyword.</span></span>  
  
- <span data-ttu-id="6ecdb-112">Las palabras clave `override`, `virtual` y `new` también pueden aplicarse a propiedades, indexadores y eventos.</span><span class="sxs-lookup"><span data-stu-id="6ecdb-112">The `override`, `virtual`, and `new` keywords can also be applied to properties, indexers, and events.</span></span>  
  
 <span data-ttu-id="6ecdb-113">De forma predeterminada, los métodos de C# no son virtuales.</span><span class="sxs-lookup"><span data-stu-id="6ecdb-113">By default, C# methods are not virtual.</span></span> <span data-ttu-id="6ecdb-114">Si se declara un método como virtual, toda clase que hereda el método puede implementar su propia versión</span><span class="sxs-lookup"><span data-stu-id="6ecdb-114">If a method is declared as virtual, any class inheriting the method can implement its own version.</span></span> <span data-ttu-id="6ecdb-115">Para que un método sea virtual, se usa el modificador `virtual` en la declaración del método de la clase base.</span><span class="sxs-lookup"><span data-stu-id="6ecdb-115">To make a method virtual, the `virtual` modifier is used in the method declaration of the base class.</span></span> <span data-ttu-id="6ecdb-116">La clase derivada puede luego reemplazar el método base virtual mediante la palabra clave `override` u ocultar el método virtual en la clase base mediante la palabra clave `new`.</span><span class="sxs-lookup"><span data-stu-id="6ecdb-116">The derived class can then override the base virtual method by using the `override` keyword or hide the virtual method in the base class by using the `new` keyword.</span></span> <span data-ttu-id="6ecdb-117">Si no se especifican las palabras clave `override` o `new`, el compilador emite una advertencia y el método de la clase derivada oculta el método de la clase base.</span><span class="sxs-lookup"><span data-stu-id="6ecdb-117">If neither the `override` keyword nor the `new` keyword is specified, the compiler will issue a warning and the method in the derived class will hide the method in the base class.</span></span>  
  
 <span data-ttu-id="6ecdb-118">Para demostrar esto en la práctica, supongamos por un momento que la compañía A ha creado una clase denominada `GraphicsClass`, que su programa usa.</span><span class="sxs-lookup"><span data-stu-id="6ecdb-118">To demonstrate this in practice, assume for a moment that Company A has created a class named `GraphicsClass`, which your program uses.</span></span> <span data-ttu-id="6ecdb-119">La siguiente es `GraphicsClass`:</span><span class="sxs-lookup"><span data-stu-id="6ecdb-119">The following is `GraphicsClass`:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#27](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#27)]  
  
 <span data-ttu-id="6ecdb-120">Su compañía usa esta clase y usted la usa para derivar su propia clase, agregando un nuevo método:</span><span class="sxs-lookup"><span data-stu-id="6ecdb-120">Your company uses this class, and you use it to derive your own class, adding a new method:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#28](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#28)]  
  
 <span data-ttu-id="6ecdb-121">La aplicación se usa sin problemas, hasta que la compañía A lanza una nueva versión de `GraphicsClass`, que es similar al código siguiente:</span><span class="sxs-lookup"><span data-stu-id="6ecdb-121">Your application is used without problems, until Company A releases a new version of `GraphicsClass`, which resembles the following code:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#29](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#29)]  
  
 <span data-ttu-id="6ecdb-122">La nueva versión de `GraphicsClass` contiene ahora un método denominado `DrawRectangle`.</span><span class="sxs-lookup"><span data-stu-id="6ecdb-122">The new version of `GraphicsClass` now contains a method named `DrawRectangle`.</span></span> <span data-ttu-id="6ecdb-123">Inicialmente, no sucede nada.</span><span class="sxs-lookup"><span data-stu-id="6ecdb-123">Initially, nothing occurs.</span></span> <span data-ttu-id="6ecdb-124">La nueva versión sigue siendo compatible a nivel binario con la versión anterior.</span><span class="sxs-lookup"><span data-stu-id="6ecdb-124">The new version is still binary compatible with the old version.</span></span> <span data-ttu-id="6ecdb-125">Cualquier software que haya implementado seguirá funcionando, aunque la nueva clase se instale en esos sistemas informáticos.</span><span class="sxs-lookup"><span data-stu-id="6ecdb-125">Any software that you have deployed will continue to work, even if the new class is installed on those computer systems.</span></span> <span data-ttu-id="6ecdb-126">Cualquier llamada existente al método `DrawRectangle` seguirá haciendo referencia a su versión en la clase derivada.</span><span class="sxs-lookup"><span data-stu-id="6ecdb-126">Any existing calls to the method `DrawRectangle` will continue to reference your version, in your derived class.</span></span>  
  
 <span data-ttu-id="6ecdb-127">Pero en cuanto vuelva a compilar la aplicación con la nueva versión de `GraphicsClass`, recibirá una advertencia del compilador, CS0108.</span><span class="sxs-lookup"><span data-stu-id="6ecdb-127">However, as soon as you recompile your application by using the new version of `GraphicsClass`, you will receive a warning from the compiler, CS0108.</span></span> <span data-ttu-id="6ecdb-128">Esta advertencia le informa de que debe plantearse cómo quiere que el método `DrawRectangle` se comporte en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="6ecdb-128">This warning informs you that you have to consider how you want your `DrawRectangle` method to behave in your application.</span></span>  
  
 <span data-ttu-id="6ecdb-129">Si quiere que su método reemplace al nuevo método de clase base, use la palabra clave `override`:</span><span class="sxs-lookup"><span data-stu-id="6ecdb-129">If you want your method to override the new base class method, use the `override` keyword:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#30](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#30)]  
  
 <span data-ttu-id="6ecdb-130">La palabra clave `override` se asegura de que los objetos derivados de `YourDerivedGraphicsClass` usen la versión de la clase derivada de `DrawRectangle`.</span><span class="sxs-lookup"><span data-stu-id="6ecdb-130">The `override` keyword makes sure that any objects derived from `YourDerivedGraphicsClass` will use the derived class version of `DrawRectangle`.</span></span> <span data-ttu-id="6ecdb-131">Los objetos derivados de `YourDerivedGraphicsClass` todavía pueden acceder a la versión de clase base `DrawRectangle` mediante la palabra clave base:</span><span class="sxs-lookup"><span data-stu-id="6ecdb-131">Objects derived from `YourDerivedGraphicsClass` can still access the base class version of `DrawRectangle` by using the base keyword:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#44](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#44)]  
  
 <span data-ttu-id="6ecdb-132">Si no quiere que el método reemplace al nuevo método de clase base, se aplican las consideraciones siguientes.</span><span class="sxs-lookup"><span data-stu-id="6ecdb-132">If you do not want your method to override the new base class method, the following considerations apply.</span></span> <span data-ttu-id="6ecdb-133">Para evitar la confusión entre los dos métodos, puede cambiarle el nombre a su método.</span><span class="sxs-lookup"><span data-stu-id="6ecdb-133">To avoid confusion between the two methods, you can rename your method.</span></span> <span data-ttu-id="6ecdb-134">Esto puede ser un proceso lento y propenso a errores y no resultar práctico en algunos casos.</span><span class="sxs-lookup"><span data-stu-id="6ecdb-134">This can be time-consuming and error-prone, and just not practical in some cases.</span></span> <span data-ttu-id="6ecdb-135">Pero si el proyecto es relativamente pequeño, puede usar opciones de refactorización de Visual Studio para cambiar el nombre del método.</span><span class="sxs-lookup"><span data-stu-id="6ecdb-135">However, if your project is relatively small, you can use Visual Studio's Refactoring options to rename the method.</span></span> <span data-ttu-id="6ecdb-136">Para obtener más información, vea [Refactoring Classes and Types (Class Designer)](/visualstudio/ide/class-designer/refactoring-classes-and-types) (Refactorización de clases y tipos [Diseñador de clases]).</span><span class="sxs-lookup"><span data-stu-id="6ecdb-136">For more information, see [Refactoring Classes and Types (Class Designer)](/visualstudio/ide/class-designer/refactoring-classes-and-types).</span></span>  
  
 <span data-ttu-id="6ecdb-137">También puede evitar la advertencia mediante la palabra clave `new` en la definición de clase derivada:</span><span class="sxs-lookup"><span data-stu-id="6ecdb-137">Alternatively, you can prevent the warning by using the keyword `new` in your derived class definition:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#31](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#31)]  
  
 <span data-ttu-id="6ecdb-138">Con la palabra clave `new` se indica al compilador que su definición oculta la definición contenida en la clase base.</span><span class="sxs-lookup"><span data-stu-id="6ecdb-138">Using the `new` keyword tells the compiler that your definition hides the definition that is contained in the base class.</span></span> <span data-ttu-id="6ecdb-139">Éste es el comportamiento predeterminado.</span><span class="sxs-lookup"><span data-stu-id="6ecdb-139">This is the default behavior.</span></span>  
  
## <a name="override-and-method-selection"></a><span data-ttu-id="6ecdb-140">Selección de método y reemplazo</span><span class="sxs-lookup"><span data-stu-id="6ecdb-140">Override and Method Selection</span></span>  
 <span data-ttu-id="6ecdb-141">Cuando se llama a un método en una clase, el compilador de C# selecciona el mejor método para llamar si hay más de uno compatible con la llamada, como cuando hay dos métodos con el mismo nombre y parámetros que son compatibles con el parámetro pasado.</span><span class="sxs-lookup"><span data-stu-id="6ecdb-141">When a method is named on a class, the C# compiler selects the best method to call if more than one method is compatible with the call, such as when there are two methods with the same name, and parameters that are compatible with the parameter passed.</span></span> <span data-ttu-id="6ecdb-142">Los métodos siguientes serían compatibles:</span><span class="sxs-lookup"><span data-stu-id="6ecdb-142">The following methods would be compatible:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#32](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#32)]  
  
 <span data-ttu-id="6ecdb-143">Cuando se llama a `DoWork` en una instancia de `Derived`, el compilador de C# intentará en primer lugar que la llamada sea compatible con las versiones de `DoWork` declaradas originalmente en `Derived`.</span><span class="sxs-lookup"><span data-stu-id="6ecdb-143">When `DoWork` is called on an instance of `Derived`, the C# compiler will first try to make the call compatible with the versions of `DoWork` declared originally on `Derived`.</span></span> <span data-ttu-id="6ecdb-144">Los métodos de reemplazo no se consideran como declarados en una clase, son nuevas implementaciones de un método que se declara en una clase base.</span><span class="sxs-lookup"><span data-stu-id="6ecdb-144">Override methods are not considered as declared on a class, they are new implementations of a method declared on a base class.</span></span> <span data-ttu-id="6ecdb-145">Solo si el compilador de C# no puede hacer coincidir la llamada al método con un método original en `Derived`, intentará hacer coincidir la llamada con un método reemplazado con el mismo nombre y parámetros compatibles.</span><span class="sxs-lookup"><span data-stu-id="6ecdb-145">Only if the C# compiler cannot match the method call to an original method on `Derived` will it try to match the call to an overridden method with the same name and compatible parameters.</span></span> <span data-ttu-id="6ecdb-146">Por ejemplo:</span><span class="sxs-lookup"><span data-stu-id="6ecdb-146">For example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#33](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#33)]  
  
 <span data-ttu-id="6ecdb-147">Dado que la variable `val` se puede convertir implícitamente en un valor doble, el compilador de C# llama a `DoWork(double)` en lugar de a `DoWork(int)`.</span><span class="sxs-lookup"><span data-stu-id="6ecdb-147">Because the variable `val` can be converted to a double implicitly, the C# compiler calls `DoWork(double)` instead of `DoWork(int)`.</span></span> <span data-ttu-id="6ecdb-148">Hay dos maneras de evitarlo.</span><span class="sxs-lookup"><span data-stu-id="6ecdb-148">There are two ways to avoid this.</span></span> <span data-ttu-id="6ecdb-149">En primer lugar, evite declarar nuevos métodos con el mismo nombre que los métodos virtuales.</span><span class="sxs-lookup"><span data-stu-id="6ecdb-149">First, avoid declaring new methods with the same name as virtual methods.</span></span> <span data-ttu-id="6ecdb-150">En segundo lugar, puede indicar al compilador de C# que llame al método virtual haciendo que busque la lista de métodos de clase base mediante la conversión de la instancia de `Derived` a `Base`.</span><span class="sxs-lookup"><span data-stu-id="6ecdb-150">Second, you can instruct the C# compiler to call the virtual method by making it search the base class method list by casting the instance of `Derived` to `Base`.</span></span> <span data-ttu-id="6ecdb-151">Como el método es virtual, se llamará a la implementación de `DoWork(int)` en `Derived`.</span><span class="sxs-lookup"><span data-stu-id="6ecdb-151">Because the method is virtual, the implementation of `DoWork(int)` on `Derived` will be called.</span></span> <span data-ttu-id="6ecdb-152">Por ejemplo:</span><span class="sxs-lookup"><span data-stu-id="6ecdb-152">For example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#34](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#34)]  
  
 <span data-ttu-id="6ecdb-153">Para obtener otros ejemplos de `new` y `override`, vea [Knowing When to Use Override and New Keywords](./knowing-when-to-use-override-and-new-keywords.md) (Saber cuándo usar las palabras clave override y new [Guía de programación de C#]).</span><span class="sxs-lookup"><span data-stu-id="6ecdb-153">For more examples of `new` and `override`, see [Knowing When to Use Override and New Keywords](./knowing-when-to-use-override-and-new-keywords.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="6ecdb-154">Vea también</span><span class="sxs-lookup"><span data-stu-id="6ecdb-154">See also</span></span>

- [<span data-ttu-id="6ecdb-155">Guía de programación de C#</span><span class="sxs-lookup"><span data-stu-id="6ecdb-155">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="6ecdb-156">Clases y structs</span><span class="sxs-lookup"><span data-stu-id="6ecdb-156">Classes and Structs</span></span>](./index.md)
- [<span data-ttu-id="6ecdb-157">Métodos</span><span class="sxs-lookup"><span data-stu-id="6ecdb-157">Methods</span></span>](./methods.md)
- [<span data-ttu-id="6ecdb-158">Herencia</span><span class="sxs-lookup"><span data-stu-id="6ecdb-158">Inheritance</span></span>](./inheritance.md)
