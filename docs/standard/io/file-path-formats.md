---
title: Formatos de ruta de acceso de archivo en los sistemas Windows
description: En este artículo, conocerá los formatos de ruta de acceso de archivo en sistemas Windows, como las rutas de acceso de DOS tradicionales, las rutas de acceso de dispositivos DOS y las rutas de acceso de convención de nomenclatura universal (UNC).
ms.date: 06/06/2019
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- I/O, long paths
- long paths
- path formats, Windows
ms.openlocfilehash: 2d3ede97b372dd8922a10a377f69155a12f88bda
ms.sourcegitcommit: b16c00371ea06398859ecd157defc81301c9070f
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 06/05/2020
ms.locfileid: "84447139"
---
# <a name="file-path-formats-on-windows-systems"></a><span data-ttu-id="7eb9d-103">Formatos de ruta de acceso de archivo en los sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="7eb9d-103">File path formats on Windows systems</span></span>

<span data-ttu-id="7eb9d-104">Los miembros de muchos de los tipos del espacio de nombres <xref:System.IO> incluyen un parámetro `path` que permite especificar una ruta de acceso absoluta o relativa a un recurso de sistema de archivos.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-104">Members of many of the types in the <xref:System.IO> namespace include a `path` parameter that lets you specify an absolute or relative path to a file system resource.</span></span> <span data-ttu-id="7eb9d-105">Después, esta ruta de acceso se pasa a las [API del sistema de archivos de Windows](/windows/desktop/fileio/file-systems).</span><span class="sxs-lookup"><span data-stu-id="7eb9d-105">This path is then passed to [Windows file system APIs](/windows/desktop/fileio/file-systems).</span></span> <span data-ttu-id="7eb9d-106">En este tema se describen los formatos de las rutas de acceso de archivo que se pueden usar en los sistemas Windows.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-106">This topic discusses the formats for file paths that you can use on Windows systems.</span></span>

## <a name="traditional-dos-paths"></a><span data-ttu-id="7eb9d-107">Rutas de acceso DOS tradicionales</span><span class="sxs-lookup"><span data-stu-id="7eb9d-107">Traditional DOS paths</span></span>

<span data-ttu-id="7eb9d-108">Una ruta de acceso DOS estándar puede constar de tres componentes:</span><span class="sxs-lookup"><span data-stu-id="7eb9d-108">A standard DOS path can consist of three components:</span></span>

- <span data-ttu-id="7eb9d-109">Una letra de volumen o unidad seguida por el separador de volumen (`:`).</span><span class="sxs-lookup"><span data-stu-id="7eb9d-109">A volume or drive letter followed by the volume separator (`:`).</span></span>
- <span data-ttu-id="7eb9d-110">Un nombre de directorio.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-110">A directory name.</span></span> <span data-ttu-id="7eb9d-111">El [carácter separador de directorio](<xref:System.IO.Path.DirectorySeparatorChar>) separa los subdirectorios dentro de la jerarquía de directorios anidados.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-111">The [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>) separates subdirectories within the nested directory hierarchy.</span></span>
- <span data-ttu-id="7eb9d-112">Un nombre de archivo opcional.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-112">An optional filename.</span></span> <span data-ttu-id="7eb9d-113">El [carácter separador de directorio](<xref:System.IO.Path.DirectorySeparatorChar>) separa la ruta de acceso y el nombre del archivo.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-113">The [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>) separates the file path and the filename.</span></span>

<span data-ttu-id="7eb9d-114">Si los tres componentes están presentes, la ruta de acceso es absoluta.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-114">If all three components are present, the path is absolute.</span></span> <span data-ttu-id="7eb9d-115">Si no se especifica la letra de volumen o unidad y el nombre de directorio comienza por el [carácter separador de directorio](<xref:System.IO.Path.DirectorySeparatorChar>), la ruta de acceso es relativa con respecto a la raíz de la unidad actual.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-115">If no volume or drive letter is specified and the directory name begins with the [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>), the path is relative from the root of the current drive.</span></span> <span data-ttu-id="7eb9d-116">En caso contrario, la ruta de acceso es relativa al directorio actual.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-116">Otherwise, the path is relative to the current directory.</span></span> <span data-ttu-id="7eb9d-117">En la tabla siguiente se muestran algunas rutas de acceso de directorio y archivo posibles.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-117">The following table shows some possible directory and file paths.</span></span>

|<span data-ttu-id="7eb9d-118">Ruta de acceso</span><span class="sxs-lookup"><span data-stu-id="7eb9d-118">Path</span></span>  |<span data-ttu-id="7eb9d-119">Descripción</span><span class="sxs-lookup"><span data-stu-id="7eb9d-119">Description</span></span>  |
| -- | -- |
| `C:\Documents\Newsletters\Summer2018.pdf` | <span data-ttu-id="7eb9d-120">Ruta de acceso de archivo absoluta desde la raíz de la unidad C:.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-120">An absolute file path from the root of drive C:</span></span> |
| `\Program Files\Custom Utilities\StringFinder.exe` | <span data-ttu-id="7eb9d-121">Ruta de acceso absoluta desde la raíz de la unidad actual.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-121">An absolute path from the root of the current drive.</span></span> |
| `2018\January.xlsx` | <span data-ttu-id="7eb9d-122">Ruta de acceso relativa a un archivo en un subdirectorio del directorio actual.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-122">A relative path to a file in a subdirectory of the current directory.</span></span> |
| `..\Publications\TravelBrochure.pdf` | <span data-ttu-id="7eb9d-123">Ruta de acceso relativa a un archivo en un directorio del mismo nivel del directorio actual.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-123">A relative path to file in a directory that is a peer of the current directory.</span></span> |
| `C:\Projects\apilibrary\apilibrary.sln` | <span data-ttu-id="7eb9d-124">Ruta de acceso absoluta a un archivo desde la raíz de la unidad C:</span><span class="sxs-lookup"><span data-stu-id="7eb9d-124">An absolute path to a file from the root of drive C:</span></span> |
| `C:Projects\apilibrary\apilibrary.sln` | <span data-ttu-id="7eb9d-125">Ruta de acceso relativa desde el directorio actual de la unidad C:.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-125">A relative path from the current directory of the C: drive.</span></span> |

> [!IMPORTANT]
> <span data-ttu-id="7eb9d-126">Observe la diferencia entre las dos últimas rutas de acceso.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-126">Note the difference between the last two paths.</span></span> <span data-ttu-id="7eb9d-127">En ambas figura el especificador de volumen opcional (C: en ambos casos), pero la primera comienza por la raíz del volumen especificado, mientras que la segunda, no.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-127">Both specify the optional volume specifier (C: in both cases), but the first begins with the root of the specified volume, whereas the second does not.</span></span> <span data-ttu-id="7eb9d-128">Como resultado, la primera es una ruta de acceso absoluta desde el directorio raíz de la unidad C:, mientras que la segunda es una ruta de acceso relativa desde el directorio actual de la unidad C:.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-128">As result, the first is an absolute path from the root directory of drive C:, whereas the second is a relative path from the current directory of drive C:.</span></span> <span data-ttu-id="7eb9d-129">El uso de la segunda forma cuando está previsto el de la primera suele ser motivo de errores que implican rutas de acceso de archivo de Windows.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-129">Use of the second form when the first is intended is a common source of bugs that involve Windows file paths.</span></span>

<span data-ttu-id="7eb9d-130">Puede determinar si una ruta de acceso de archivo es un nombre completo (es decir, si la ruta de acceso es independiente del directorio actual y no cambia cuando cambia el directorio actual) mediante una llamada al método <xref:System.IO.Path.IsPathFullyQualified%2A?displayProperty=nameWthType>.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-130">You can determine whether a file path is fully qualified (that is, it the path is independent of the current directory and does not change when the current directory changes) by calling the <xref:System.IO.Path.IsPathFullyQualified%2A?displayProperty=nameWthType> method.</span></span> <span data-ttu-id="7eb9d-131">Tenga en cuenta que una ruta de acceso de este tipo puede incluir segmentos de directorio relativos (`.` y `..`) y seguir siendo completa si la ruta de acceso resuelta siempre apunta a la misma ubicación.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-131">Note that such a path can include relative directory segments (`.` and `..`) and still be fully qualified if the resolved path always points to the same location.</span></span>

<span data-ttu-id="7eb9d-132">En el ejemplo siguiente se muestra la diferencia entre las rutas de acceso absolutas y relativas.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-132">The following example illustrates the difference between absolute and relative paths.</span></span> <span data-ttu-id="7eb9d-133">Se supone que existe el directorio D:\FY2018\ y que aún no ha establecido ningún directorio actual para D:\ desde el símbolo del sistema antes de ejecutar el ejemplo.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-133">It assumes that the directory D:\FY2018\ exists, and that you haven't set any current directory for D:\ from the command prompt before running the example.</span></span>

[!code-csharp[absolute-and-relative-paths](~/samples/snippets/standard/io/file-names/cs/paths.cs)]
[!code-vb[absolute-and-relative-paths](~/samples/snippets/standard/io/file-names/vb/paths.vb)]

[!INCLUDE [localized code comments](../../../includes/code-comments-loc.md)]

## <a name="unc-paths"></a><span data-ttu-id="7eb9d-134">Rutas de acceso UNC</span><span class="sxs-lookup"><span data-stu-id="7eb9d-134">UNC paths</span></span>

<span data-ttu-id="7eb9d-135">Las rutas de acceso de convención de nomenclatura universal (UNC), que se usan para acceder a los recursos de red, tienen el formato siguiente:</span><span class="sxs-lookup"><span data-stu-id="7eb9d-135">Universal naming convention (UNC) paths, which are used to access network resources, have the following format:</span></span>

- <span data-ttu-id="7eb9d-136">Un nombre de servidor o host que va precedido por \\\\.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-136">A server or host name, which is prefaced by \\\\.</span></span> <span data-ttu-id="7eb9d-137">El nombre del servidor puede ser un nombre de equipo NetBIOS o una dirección IP o FQDN (se admiten tanto IPv4 como v6).</span><span class="sxs-lookup"><span data-stu-id="7eb9d-137">The server name can be a NetBIOS machine name or an IP/FQDN address (IPv4 as well as v6 are supported).</span></span>
- <span data-ttu-id="7eb9d-138">Un nombre de recurso compartido, que se separa del nombre de host mediante \\.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-138">A share name, which is separated from the host name by \\.</span></span> <span data-ttu-id="7eb9d-139">Juntos, el nombre del servidor y el del recurso compartido forman el volumen.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-139">Together, the server and share name make up the volume.</span></span>
- <span data-ttu-id="7eb9d-140">Un nombre de directorio.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-140">A directory name.</span></span> <span data-ttu-id="7eb9d-141">El [carácter separador de directorio](<xref:System.IO.Path.DirectorySeparatorChar>) separa los subdirectorios dentro de la jerarquía de directorios anidados.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-141">The [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>) separates subdirectories within the nested directory hierarchy.</span></span>
- <span data-ttu-id="7eb9d-142">Un nombre de archivo opcional.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-142">An optional filename.</span></span> <span data-ttu-id="7eb9d-143">El [carácter separador de directorio](<xref:System.IO.Path.DirectorySeparatorChar>) separa la ruta de acceso y el nombre del archivo.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-143">The [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>) separates the file path and the filename.</span></span>

<span data-ttu-id="7eb9d-144">A continuación se muestran algunos ejemplos de rutas de acceso UNC:</span><span class="sxs-lookup"><span data-stu-id="7eb9d-144">The following are some examples of UNC paths:</span></span>

|<span data-ttu-id="7eb9d-145">Ruta de acceso</span><span class="sxs-lookup"><span data-stu-id="7eb9d-145">Path</span></span>  |<span data-ttu-id="7eb9d-146">Descripción</span><span class="sxs-lookup"><span data-stu-id="7eb9d-146">Description</span></span>  |
| -- | -- |
| `\\system07\C$\` | <span data-ttu-id="7eb9d-147">Directorio raíz de la unidad C: en `system07`.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-147">The root directory of the C: drive on `system07`.</span></span> |
| `\\Server2\Share\Test\Foo.txt` | <span data-ttu-id="7eb9d-148">El archivo Foo.txt en el directorio Test del volumen \\\\Server2\\Share.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-148">The Foo.txt file in the Test directory of the \\\\Server2\\Share volume.</span></span>|

<span data-ttu-id="7eb9d-149">Las rutas de acceso UNC siempre deben ser completas.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-149">UNC paths must always be fully qualified.</span></span> <span data-ttu-id="7eb9d-150">Pueden incluir segmentos de directorio relativos (`.` y `..`), pero estos deben formar parte de una ruta de acceso completa.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-150">They can include relative directory segments (`.` and `..`), but these must be part of a fully qualified path.</span></span> <span data-ttu-id="7eb9d-151">Solo puede usar rutas de acceso relativas mediante la asignación de una ruta de acceso UNC a una letra de unidad.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-151">You can use relative paths only by mapping a UNC path to a drive letter.</span></span>

## <a name="dos-device-paths"></a><span data-ttu-id="7eb9d-152">Rutas de acceso de dispositivo DOS</span><span class="sxs-lookup"><span data-stu-id="7eb9d-152">DOS device paths</span></span>

<span data-ttu-id="7eb9d-153">El sistema operativo Windows tiene un modelo de objetos unificado que apunta a todos los recursos, incluidos los archivos.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-153">The Windows operating system has a unified object model that points to all resources, including files.</span></span> <span data-ttu-id="7eb9d-154">Estas rutas de acceso de objeto son accesibles desde la ventana de consola y se exponen a la capa de Win32 a través de una carpeta especial para vínculos simbólicos a la que se asignan las rutas de acceso DOS y UNC heredadas.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-154">These object paths are accessible from the console window and are exposed to the Win32 layer through a special folder of symbolic links that legacy DOS and UNC paths are mapped to.</span></span> <span data-ttu-id="7eb9d-155">A esta carpeta especial se accede a través de la sintaxis de ruta de acceso de dispositivo DOS, que es una de las siguientes:</span><span class="sxs-lookup"><span data-stu-id="7eb9d-155">This special folder is accessed via the DOS device path syntax, which is one of:</span></span>

`\\.\C:\Test\Foo.txt`
`\\?\C:\Test\Foo.txt`

<span data-ttu-id="7eb9d-156">Además de identificar una unidad por su letra de unidad, puede identificar un volumen mediante su GUID de volumen.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-156">In addition to identifying a drive by its drive letter, you can identify a volume by using its volume GUID.</span></span> <span data-ttu-id="7eb9d-157">Esto toma la forma:</span><span class="sxs-lookup"><span data-stu-id="7eb9d-157">This takes the form:</span></span>

`\\.\Volume{b75e2c83-0000-0000-0000-602f00000000}\Test\Foo.txt`
`\\?\Volume{b75e2c83-0000-0000-0000-602f00000000}\Test\Foo.txt`

> [!NOTE]
> <span data-ttu-id="7eb9d-158">La sintaxis de ruta de acceso de dispositivo DOS es compatible con las implementaciones de .NET que se ejecutan en Windows a partir de .NET Core 1.1 y .NET Framework 4.6.2.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-158">DOS device path syntax is supported on .NET implementations running on Windows starting with .NET Core 1.1 and .NET Framework 4.6.2.</span></span>

<span data-ttu-id="7eb9d-159">La ruta de acceso de dispositivo DOS consta de los componentes siguientes:</span><span class="sxs-lookup"><span data-stu-id="7eb9d-159">The DOS device path consists of the following components:</span></span>

- <span data-ttu-id="7eb9d-160">El especificador de ruta de acceso de dispositivo (`\\.\` o `\\?\`), que identifica la ruta de acceso como una ruta de acceso de dispositivo DOS.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-160">The device path specifier (`\\.\` or `\\?\`), which identifies the path as a DOS device path.</span></span>

   > [!NOTE]
   > <span data-ttu-id="7eb9d-161">`\\?\` se admite en todas las versiones de .NET Core y en .NET Framework a partir de la versión 4.6.2.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-161">The `\\?\` is supported in all versions of .NET Core and in the .NET Framework starting with version 4.6.2.</span></span>

- <span data-ttu-id="7eb9d-162">Un vínculo simbólico para el objeto de dispositivo "real" (C: en el caso de un nombre de unidad o Volume{b75e2c83-0000-0000-0000-602f00000000} en el caso de un identificador de volumen).</span><span class="sxs-lookup"><span data-stu-id="7eb9d-162">A symbolic link to the "real" device object (C: in the case of a drive name, or Volume{b75e2c83-0000-0000-0000-602f00000000} in the case of a volume GUID).</span></span>

   <span data-ttu-id="7eb9d-163">El primer segmento de la ruta de acceso de dispositivo DOS, una vez que el especificador de ruta de acceso de dispositivo identifica el volumen o la unidad.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-163">The first segment of the DOS device path after the device path specifier identifies the volume or drive.</span></span> <span data-ttu-id="7eb9d-164">(Por ejemplo, `\\?\C:\` y `\\.\BootPartition\`).</span><span class="sxs-lookup"><span data-stu-id="7eb9d-164">(For example, `\\?\C:\` and `\\.\BootPartition\`.)</span></span>

   <span data-ttu-id="7eb9d-165">Existe un vínculo específico para las UNC que, de forma lógica, se denomina `UNC`.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-165">There is a specific link for UNCs that is called, not surprisingly, `UNC`.</span></span> <span data-ttu-id="7eb9d-166">Por ejemplo:</span><span class="sxs-lookup"><span data-stu-id="7eb9d-166">For example:</span></span>

  `\\.\UNC\Server\Share\Test\Foo.txt`
  `\\?\UNC\Server\Share\Test\Foo.txt`

    <span data-ttu-id="7eb9d-167">Para las UNC de dispositivo, la parte del servidor o recurso compartido forma el volumen.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-167">For device UNCs, the server/share portion forms the volume.</span></span> <span data-ttu-id="7eb9d-168">Por ejemplo, en `\\?\server1\e:\utilities\\filecomparer\`, la parte del servidor o recurso compartido es server1\utilities.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-168">For example, in `\\?\server1\e:\utilities\\filecomparer\`, the server/share portion is server1\utilities.</span></span> <span data-ttu-id="7eb9d-169">Esto es importante cuando se llama a un método como <xref:System.IO.Path.GetFullPath(System.String,System.String)?displayProperty=nameWithType> con segmentos de directorio relativos, pues nunca se puede ir más allá del volumen.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-169">This is significant when calling a method such as <xref:System.IO.Path.GetFullPath(System.String,System.String)?displayProperty=nameWithType> with relative directory segments; it is never possible to navigate past the volume.</span></span>

<span data-ttu-id="7eb9d-170">Por definición, las rutas de acceso de dispositivo DOS son completas.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-170">DOS device paths are fully qualified by definition.</span></span> <span data-ttu-id="7eb9d-171">No se permiten los segmentos de directorio relativos (`.` y `..`).</span><span class="sxs-lookup"><span data-stu-id="7eb9d-171">Relative directory segments (`.` and `..`) are not allowed.</span></span> <span data-ttu-id="7eb9d-172">Los directorios actuales nunca entran en uso.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-172">Current directories never enter into their usage.</span></span>

## <a name="example-ways-to-refer-to-the-same-file"></a><span data-ttu-id="7eb9d-173">Ejemplo: Formas de hacer referencia al mismo archivo</span><span class="sxs-lookup"><span data-stu-id="7eb9d-173">Example: Ways to refer to the same file</span></span>

<span data-ttu-id="7eb9d-174">En el ejemplo siguiente se muestran algunas formas de hacer referencia a un archivo cuando se usan las API del espacio de nombres <xref:System.IO>.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-174">The following example illustrates some of the ways in which you can refer to a file when using the APIs in the <xref:System.IO> namespace.</span></span> <span data-ttu-id="7eb9d-175">En el ejemplo se crea una instancia de un objeto <xref:System.IO.FileInfo> y se usan sus propiedades <xref:System.IO.FileInfo.Name> y <xref:System.IO.FileInfo.Length> para mostrar el nombre y la longitud del archivo.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-175">The example instantiates a <xref:System.IO.FileInfo> object and uses its <xref:System.IO.FileInfo.Name> and <xref:System.IO.FileInfo.Length> properties to display the filename and the length of the file.</span></span>

[!code-csharp[referring-to-the-same-file](~/samples/snippets/standard/io/file-names/cs/file-refs.cs)]
[!code-vb[referring-to-the-same-file](~/samples/snippets/standard/io/file-names/vb/file-refs.vb)]

## <a name="path-normalization"></a><span data-ttu-id="7eb9d-176">Normalización de la ruta de acceso</span><span class="sxs-lookup"><span data-stu-id="7eb9d-176">Path normalization</span></span>

<span data-ttu-id="7eb9d-177">Casi todas las rutas de acceso que se pasan a las API de Windows se normalizan.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-177">Almost all paths passed to Windows APIs are normalized.</span></span> <span data-ttu-id="7eb9d-178">Durante la normalización, Windows realiza los pasos siguientes:</span><span class="sxs-lookup"><span data-stu-id="7eb9d-178">During normalization, Windows performs the following steps:</span></span>

- <span data-ttu-id="7eb9d-179">Identifica la ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-179">Identifies the path.</span></span>
- <span data-ttu-id="7eb9d-180">Aplica el directorio actual a rutas de acceso parciales (relativas).</span><span class="sxs-lookup"><span data-stu-id="7eb9d-180">Applies the current directory to partially qualified (relative) paths.</span></span>
- <span data-ttu-id="7eb9d-181">Aplica formato canónico a los separadores de componentes y directorios.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-181">Canonicalizes component and directory separators.</span></span>
- <span data-ttu-id="7eb9d-182">Evalúa los componentes de directorio relativos (`.` para el directorio actual y `..` para el directorio principal).</span><span class="sxs-lookup"><span data-stu-id="7eb9d-182">Evaluates relative directory components (`.` for the current directory and `..` for the parent directory).</span></span>
- <span data-ttu-id="7eb9d-183">Recorta determinados caracteres.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-183">Trims certain characters.</span></span>

<span data-ttu-id="7eb9d-184">Esta normalización se produce de manera implícita, pero se puede realizar de forma explícita mediante una llamada al método <xref:System.IO.Path.GetFullPath%2A?displayProperty=nameWithType>, que encapsula una llamada a la [función GetFullPathName()](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea).</span><span class="sxs-lookup"><span data-stu-id="7eb9d-184">This normalization happens implicitly, but you can do it explicitly by calling the <xref:System.IO.Path.GetFullPath%2A?displayProperty=nameWithType> method, which wraps a call to the  [GetFullPathName() function](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea).</span></span> <span data-ttu-id="7eb9d-185">También se puede llamar directamente a la [función GetFullPathName()](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) de Windows mediante P/Invoke.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-185">You can also call the Windows [GetFullPathName() function](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) directly using P/Invoke.</span></span>

### <a name="identifying-the-path"></a><span data-ttu-id="7eb9d-186">Identificación de la ruta de acceso</span><span class="sxs-lookup"><span data-stu-id="7eb9d-186">Identifying the path</span></span>

<span data-ttu-id="7eb9d-187">El primer paso de la normalización de la ruta de acceso consiste en identificar el tipo de ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-187">The first step in path normalization is identifying the type of path.</span></span> <span data-ttu-id="7eb9d-188">Las rutas de acceso se incluyen en una de estas categorías:</span><span class="sxs-lookup"><span data-stu-id="7eb9d-188">Paths fall into one of a few categories:</span></span>

- <span data-ttu-id="7eb9d-189">Son rutas de acceso de dispositivo; es decir, comienzan con dos separadores y un signo de interrogación o un punto (`\\?` o `\\.`).</span><span class="sxs-lookup"><span data-stu-id="7eb9d-189">They are device paths; that is, they begin with two separators and a question mark or period (`\\?` or `\\.`).</span></span>
- <span data-ttu-id="7eb9d-190">Son rutas de acceso UNC, es decir, comienzan por dos separadores sin un signo de interrogación o un punto.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-190">They are UNC paths; that is, they begin with two separators without a question mark or period.</span></span>
- <span data-ttu-id="7eb9d-191">Son rutas de acceso DOS completas, es decir, comienzan por una letra de unidad, un separador de volumen y un separador de componentes (`C:\`).</span><span class="sxs-lookup"><span data-stu-id="7eb9d-191">They are fully qualified DOS paths; that is, they begin with a drive letter, a volume separator, and a component separator (`C:\`).</span></span>
- <span data-ttu-id="7eb9d-192">Designan un dispositivo heredado (`CON`, `LPT1`).</span><span class="sxs-lookup"><span data-stu-id="7eb9d-192">They designate a legacy device (`CON`, `LPT1`).</span></span>
- <span data-ttu-id="7eb9d-193">Son relativas a la raíz de la unidad actual; es decir, comienzan con un único separador de componente (`\`).</span><span class="sxs-lookup"><span data-stu-id="7eb9d-193">They are relative to the root of the current drive; that is, they begin with a single component separator (`\`).</span></span>
- <span data-ttu-id="7eb9d-194">Son relativas al directorio actual de una unidad especificada, es decir, comienzan por una letra de unidad, un separador de volumen y ningún separador de componente (`C:`).</span><span class="sxs-lookup"><span data-stu-id="7eb9d-194">They are relative to the current directory of a specified drive; that is, they begin with a drive letter, a volume separator, and no component separator (`C:`).</span></span>
- <span data-ttu-id="7eb9d-195">Son relativas al directorio actual, es decir, comienzan por cualquier otro elemento (`temp\testfile.txt`).</span><span class="sxs-lookup"><span data-stu-id="7eb9d-195">They are relative to the current directory; that is, they begin with anything else (`temp\testfile.txt`).</span></span>

<span data-ttu-id="7eb9d-196">El tipo de la ruta de acceso determina si se aplica o no un directorio actual de alguna manera.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-196">The type of the path determines whether or not a current directory is applied in some way.</span></span> <span data-ttu-id="7eb9d-197">También determina lo que es la "raíz" de la ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-197">It also determines what the "root" of the path is.</span></span>

### <a name="handling-legacy-devices"></a><span data-ttu-id="7eb9d-198">Control de dispositivos heredados</span><span class="sxs-lookup"><span data-stu-id="7eb9d-198">Handling legacy devices</span></span>

<span data-ttu-id="7eb9d-199">Si la ruta de acceso es un dispositivo DOS heredado como `CON`, `COM1` o `LPT1`, se convierte en una ruta de acceso de dispositivo mediante la anteposición `\\.\` y se devuelve.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-199">If the path is a legacy DOS device such as `CON`, `COM1`, or `LPT1`, it is converted into a device path by prepending `\\.\` and returned.</span></span>

<span data-ttu-id="7eb9d-200">Una ruta de acceso que comienza por un nombre de dispositivo heredado se interpreta siempre como un dispositivo heredado por el método <xref:System.IO.Path.GetFullPath(System.String)?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-200">A path that begins with a legacy device name is always interpreted as a legacy device by the <xref:System.IO.Path.GetFullPath(System.String)?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="7eb9d-201">Por ejemplo la ruta de acceso de dispositivo DOS para `CON.TXT` es `\\.\CON`, y la de `COM1.TXT\file1.txt` es `\\.\COM1`.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-201">For example, the DOS device path for `CON.TXT` is `\\.\CON`, and the DOS device path for `COM1.TXT\file1.txt` is `\\.\COM1`.</span></span>

### <a name="applying-the-current-directory"></a><span data-ttu-id="7eb9d-202">Aplicación del directorio actual</span><span class="sxs-lookup"><span data-stu-id="7eb9d-202">Applying the current directory</span></span>

<span data-ttu-id="7eb9d-203">Si una ruta de acceso no es completa, Windows le aplica el directorio actual.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-203">If a path isn't fully qualified, Windows applies the current directory to it.</span></span> <span data-ttu-id="7eb9d-204">El directorio actual no se aplica a las rutas de acceso de dispositivo y UNC.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-204">UNCs and device paths do not have the current directory applied.</span></span> <span data-ttu-id="7eb9d-205">Ni tampoco una unidad completa con separador C:\\.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-205">Neither does a full drive with separator C:\\.</span></span>

<span data-ttu-id="7eb9d-206">Si la ruta de acceso comienza por un único separador de componente, se aplica la unidad desde el directorio actual.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-206">If the path starts with a single component separator, the drive from the current directory is applied.</span></span> <span data-ttu-id="7eb9d-207">Por ejemplo, si la ruta de acceso de archivo es `\utilities` y el directorio actual es `C:\temp\`, la normalización genera `C:\utilities`.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-207">For example, if the file path is `\utilities` and the current directory is `C:\temp\`, normalization produces `C:\utilities`.</span></span>

<span data-ttu-id="7eb9d-208">Si la ruta de acceso comienza por una letra de unidad, el separador de volumen y ningún separador de componente, se aplica el último directorio actual establecido desde el shell de comandos para la unidad especificada.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-208">If the path starts with a drive letter, volume separator, and no component separator, the last current directory set from the command shell for the specified drive is applied.</span></span> <span data-ttu-id="7eb9d-209">Si no se estableció el último directorio actual, solo se aplica la unidad.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-209">If the last current directory was not set, the drive alone is applied.</span></span> <span data-ttu-id="7eb9d-210">Por ejemplo, si la ruta de acceso de archivo es `D:sources`, el directorio actual es `C:\Documents\` y el último directorio actual en la unidad D: era `D:\sources\`, el resultado es `D:\sources\sources`.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-210">For example, if the file path is `D:sources`, the current directory is `C:\Documents\`, and the last current directory on drive D: was `D:\sources\`, the result is `D:\sources\sources`.</span></span> <span data-ttu-id="7eb9d-211">Estas rutas de acceso "relativas a la unidad" son un origen común de errores lógicos de programas y scripts.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-211">These "drive relative" paths are a common source of program and script logic errors.</span></span> <span data-ttu-id="7eb9d-212">Asumir que una ruta de acceso que comienza con una letra y dos puntos no es relativa evidentemente no es correcto.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-212">Assuming that a path beginning with a letter and a colon isn't relative is obviously not correct.</span></span>

<span data-ttu-id="7eb9d-213">Si la ruta de acceso comienza por un valor distinto de un separador, se aplican la unidad y el directorio actuales.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-213">If the path starts with something other than a separator, the current drive and current directory are applied.</span></span> <span data-ttu-id="7eb9d-214">Por ejemplo, si la ruta de acceso es `filecompare` y el directorio actual es `C:\utilities\`, el resultado es `C:\utilities\filecompare\`.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-214">For example, if the path is `filecompare` and the current directory is `C:\utilities\`, the result is `C:\utilities\filecompare\`.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="7eb9d-215">El uso de rutas de acceso relativas en las aplicaciones multiproceso (es decir, en la mayoría de aplicaciones) es peligroso, porque el directorio actual es un valor de cada proceso.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-215">Relative paths are dangerous in multithreaded applications (that is, most applications) because the current directory is a per-process setting.</span></span> <span data-ttu-id="7eb9d-216">Cualquier subproceso puede cambiar el directorio actual en cualquier momento.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-216">Any thread can change the current directory at any time.</span></span> <span data-ttu-id="7eb9d-217">A partir de .NET Core 2.1, se puede llamar al método <xref:System.IO.Path.GetFullPath(System.String,System.String)?displayProperty=nameWithType> para obtener una ruta de acceso absoluta a partir de una ruta de acceso relativa y la ruta de acceso base (el directorio actual) sobre la que se quiere resolver.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-217">Starting with .NET Core 2.1, you can call the <xref:System.IO.Path.GetFullPath(System.String,System.String)?displayProperty=nameWithType> method to get an absolute path from a relative path and the base path (the current directory) that you want to resolve it against.</span></span>

### <a name="canonicalizing-separators"></a><span data-ttu-id="7eb9d-218">Asignación canónica de separadores</span><span class="sxs-lookup"><span data-stu-id="7eb9d-218">Canonicalizing separators</span></span>

<span data-ttu-id="7eb9d-219">Todas las barras diagonales (`/`) se convierten en el separador estándar de Windows, que es la barra diagonal inversa (`\`).</span><span class="sxs-lookup"><span data-stu-id="7eb9d-219">All forward slashes (`/`) are converted into the standard Windows separator, the back slash (`\`).</span></span> <span data-ttu-id="7eb9d-220">Si están presentes, una serie de barras diagonales que siguen a las dos primeras barras diagonales se contraen en una sola barra diagonal.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-220">If they are present, a series of slashes that follow the first two slashes are collapsed into a single slash.</span></span>

### <a name="evaluating-relative-components"></a><span data-ttu-id="7eb9d-221">Evaluación de componentes relativos</span><span class="sxs-lookup"><span data-stu-id="7eb9d-221">Evaluating relative components</span></span>

<span data-ttu-id="7eb9d-222">Cuando se procesa la ruta de acceso, se evalúan los componentes o segmentos que se componen de un punto o un punto doble (`.` o `..`):</span><span class="sxs-lookup"><span data-stu-id="7eb9d-222">As the path is processed, any components or segments that are composed of a single or a double period (`.` or `..`) are evaluated:</span></span>

- <span data-ttu-id="7eb9d-223">Para un punto, se quita el segmento actual, ya que hace referencia al directorio actual.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-223">For a single period, the current segment is removed, since it refers to the current directory.</span></span>

- <span data-ttu-id="7eb9d-224">Para un punto doble, se quitan el segmento actual y el principal, ya que el punto doble hace referencia al directorio principal.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-224">For a double period, the current segment and the parent segment are removed, since the double period refers to the parent directory.</span></span>

   <span data-ttu-id="7eb9d-225">Los directorios principales solo se quitan si no están después de la raíz de la ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-225">Parent directories are only removed if they aren't past the root of the path.</span></span> <span data-ttu-id="7eb9d-226">La raíz de la ruta de acceso depende del tipo de ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-226">The root of the path depends on the type of path.</span></span> <span data-ttu-id="7eb9d-227">Es la unidad (`C:\`) para las rutas de acceso DOS, el servidor o recurso compartido para las UNC (`\\Server\Share`), y el prefijo de ruta de acceso de dispositivo para las rutas de acceso de dispositivo (`\\?\` o `\\.\`).</span><span class="sxs-lookup"><span data-stu-id="7eb9d-227">It is the drive (`C:\`) for DOS paths, the server/share for UNCs (`\\Server\Share`), and the device path prefix for device paths (`\\?\` or `\\.\`).</span></span>

### <a name="trimming-characters"></a><span data-ttu-id="7eb9d-228">Recorte de caracteres</span><span class="sxs-lookup"><span data-stu-id="7eb9d-228">Trimming characters</span></span>

<span data-ttu-id="7eb9d-229">Junto con las ejecuciones de los separadores y segmentos relativos que se han quitado anteriormente, durante la normalización se quitan algunos caracteres adicionales:</span><span class="sxs-lookup"><span data-stu-id="7eb9d-229">Along with the runs of separators and relative segments removed earlier, some additional characters are removed during normalization:</span></span>

- <span data-ttu-id="7eb9d-230">Si un segmento termina en un punto, se quita ese punto.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-230">If a segment ends in a single period, that period is removed.</span></span> <span data-ttu-id="7eb9d-231">(Un segmento de un punto o un punto doble se normaliza en el paso anterior.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-231">(A segment of a single or double period is normalized in the previous step.</span></span> <span data-ttu-id="7eb9d-232">Un segmento de tres o más puntos no se normaliza y, en realidad, es un nombre de archivo o directorio válido).</span><span class="sxs-lookup"><span data-stu-id="7eb9d-232">A segment of three or more periods is not normalized and is actually a valid file/directory name.)</span></span>

- <span data-ttu-id="7eb9d-233">Si la ruta de acceso no termina en un separador, se quitan todos los puntos y espacios finales (U+0020).</span><span class="sxs-lookup"><span data-stu-id="7eb9d-233">If the path doesn't end in a separator, all trailing periods and spaces (U+0020) are removed.</span></span> <span data-ttu-id="7eb9d-234">Si el último segmento es simplemente un punto o un punto doble, se aplica la regla anterior de componentes relativos.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-234">If the last segment is simply a single or double period, it falls under the relative components rule above.</span></span>

   <span data-ttu-id="7eb9d-235">Esta regla significa que se puede crear un nombre de directorio con un espacio final si se agrega un separador final después del espacio.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-235">This rule means that you can create a directory name with a trailing space by adding a trailing separator after the space.</span></span>

   > [!IMPORTANT]
   > <span data-ttu-id="7eb9d-236">**Nunca** se debe crear un nombre de archivo o directorio con un espacio final.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-236">You should **never** create a directory or filename with a trailing space.</span></span> <span data-ttu-id="7eb9d-237">Los espacios finales pueden dificultar o impedir el acceso a un directorio, y se suelen producir errores en las aplicaciones cuando se intenta controlar directorios o archivos con nombres que incluyen espacios.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-237">Trailing spaces can make it difficult or impossible to access a directory, and applications commonly fail when attempting to handle directories or files whose names include trailing spaces.</span></span>

## <a name="skipping-normalization"></a><span data-ttu-id="7eb9d-238">Omisión de la normalización</span><span class="sxs-lookup"><span data-stu-id="7eb9d-238">Skipping normalization</span></span>

<span data-ttu-id="7eb9d-239">Normalmente, todas las rutas de acceso que se pasan a una API de Windows se pasan (de forma efectiva) a la [función GetFullPathName](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) y se normalizan.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-239">Normally, any path passed to a Windows API is (effectively) passed to the [GetFullPathName function](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) and normalized.</span></span> <span data-ttu-id="7eb9d-240">Hay una excepción importante: una ruta de acceso de dispositivo que comienza con un signo de interrogación en lugar de un punto.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-240">There is one important exception: a device path that begins with a question mark instead of a period.</span></span> <span data-ttu-id="7eb9d-241">A menos que la ruta de acceso comience exactamente con `\\?\` (observe el uso de la barra diagonal inversa canónica), se normaliza.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-241">Unless the path starts exactly with `\\?\` (note the use of the canonical backslash), it is normalized.</span></span>

<span data-ttu-id="7eb9d-242">¿Por qué querría omitir la normalización?</span><span class="sxs-lookup"><span data-stu-id="7eb9d-242">Why would you want to skip normalization?</span></span> <span data-ttu-id="7eb9d-243">Hay tres razones principales:</span><span class="sxs-lookup"><span data-stu-id="7eb9d-243">There are three major reasons:</span></span>

1. <span data-ttu-id="7eb9d-244">Para obtener acceso a las rutas de acceso que normalmente no están disponibles pero que son válidas.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-244">To get access to paths that are normally unavailable but are legal.</span></span> <span data-ttu-id="7eb9d-245">A un archivo o directorio denominado `hidden.`, por ejemplo, no se puede acceder de otra forma.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-245">A file or directory called `hidden.`, for example, is impossible to access in any other way.</span></span>

1. <span data-ttu-id="7eb9d-246">Para mejorar el rendimiento omitiendo la normalización, si ya se ha normalizado.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-246">To improve performance by skipping normalization if you've already normalized.</span></span>

1. <span data-ttu-id="7eb9d-247">Solo en .NET Framework, para omitir la comprobación `MAX_PATH` de la longitud de ruta de acceso para permitir rutas de acceso que tienen más de 259 caracteres.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-247">On the .NET Framework only, to skip the `MAX_PATH` check for path length to allow for paths that are greater than 259 characters.</span></span> <span data-ttu-id="7eb9d-248">En la mayoría de API se permite esto, con algunas excepciones.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-248">Most APIs allow this, with some exceptions.</span></span>

> [!NOTE]
> <span data-ttu-id="7eb9d-249">En .NET Core las rutas de acceso largas se administran de forma implícita y no se realiza una comprobación `MAX_PATH`.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-249">.NET Core handles long paths implicitly and does not perform a `MAX_PATH` check.</span></span> <span data-ttu-id="7eb9d-250">La comprobación `MAX_PATH` solo se aplica a .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-250">The `MAX_PATH` check applies only to the .NET Framework.</span></span>

<span data-ttu-id="7eb9d-251">La omisión de la normalización y las comprobaciones de ruta de acceso máximas es la única diferencia entre las dos sintaxis de ruta de acceso de dispositivo. En los demás casos son idénticas.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-251">Skipping normalization and max path checks is the only difference between the two device path syntaxes; they are otherwise identical.</span></span> <span data-ttu-id="7eb9d-252">Tenga cuidado al omitir la normalización, dado que es muy fácil crear rutas de acceso difíciles de controlar para las aplicaciones "normales".</span><span class="sxs-lookup"><span data-stu-id="7eb9d-252">Be careful with skipping normalization, since you can easily create paths that are difficult for "normal" applications to deal with.</span></span>

<span data-ttu-id="7eb9d-253">Las rutas de acceso que empiezan por `\\?\` se siguen normalizando si se pasan de forma explícita a la [función GetFullPathName](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea).</span><span class="sxs-lookup"><span data-stu-id="7eb9d-253">Paths that start with `\\?\` are still normalized if you explicitly pass them to the [GetFullPathName function](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea).</span></span>

<span data-ttu-id="7eb9d-254">Puede pasar rutas de acceso de más de `MAX_PATH` caracteres a [GetFullPathName](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) sin `\\?\`.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-254">You can pass paths of more than `MAX_PATH` characters to [GetFullPathName](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) without `\\?\`.</span></span> <span data-ttu-id="7eb9d-255">Admite rutas de acceso de longitud arbitraria hasta el tamaño de cadena máximo admitido por Windows.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-255">It supports arbitrary length paths up to the maximum string size that Windows can handle.</span></span>

## <a name="case-and-the-windows-file-system"></a><span data-ttu-id="7eb9d-256">Las mayúsculas y minúsculas y el sistema de archivos de Windows</span><span class="sxs-lookup"><span data-stu-id="7eb9d-256">Case and the Windows file system</span></span>

<span data-ttu-id="7eb9d-257">Una peculiaridad del sistema de archivos de Windows que resulta confuso para los usuarios y desarrolladores que no usan Windows es que los nombres de ruta de acceso y directorio no distinguen mayúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-257">A peculiarity of the Windows file system that non-Windows users and developers find confusing is that path and directory names are case-insensitive.</span></span> <span data-ttu-id="7eb9d-258">Es decir, los nombres de archivos y directorios reflejan las mayúsculas y minúsculas de las cadenas que se usan cuando se crean.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-258">That is, directory and file names reflect the casing of the strings used when they are created.</span></span> <span data-ttu-id="7eb9d-259">Por ejemplo, la llamada al método</span><span class="sxs-lookup"><span data-stu-id="7eb9d-259">For example, the method call</span></span>

```csharp
Directory.Create("TeStDiReCtOrY");
```

```vb
Directory.Create("TeStDiReCtOrY")
```

<span data-ttu-id="7eb9d-260">crea un directorio denominado TeStDiReCtOrY.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-260">creates a directory named TeStDiReCtOrY.</span></span> <span data-ttu-id="7eb9d-261">Si modifica el nombre de un directorio o archivo para cambiar sus mayúsculas y minúsculas, el nombre del directorio o archivo refleja las mayúsculas y minúsculas de la cadena usada al cambiar el nombre.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-261">If you rename a directory or file to change its case, the directory or file name reflects the case of the string used when you rename it.</span></span> <span data-ttu-id="7eb9d-262">Por ejemplo, en el código siguiente se cambia el nombre de un archivo de test.txt a Test.txt:</span><span class="sxs-lookup"><span data-stu-id="7eb9d-262">For example, the following code renames a file named test.txt to Test.txt:</span></span>

[!code-csharp[case-and-renaming](~/samples/snippets/standard/io/file-names/cs/rename.cs)]
[!code-vb[case-and-renaming](~/samples/snippets/standard/io/file-names/vb/rename.vb)]

<span data-ttu-id="7eb9d-263">Pero las comparaciones de nombre de directorio y archivo no distinguen mayúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-263">However, directory and file name comparisons are case-insensitive.</span></span> <span data-ttu-id="7eb9d-264">Si busca un archivo denominado "test.txt", las API del sistema de archivos de .NET ignoran las mayúsculas y minúsculas en la comparación.</span><span class="sxs-lookup"><span data-stu-id="7eb9d-264">If you search for a file named "test.txt", .NET file system APIs ignore case in the comparison.</span></span> <span data-ttu-id="7eb9d-265">Test.txt, TEST.TXT, test.TXT y cualquier otra combinación de letras mayúsculas y minúsculas coincidirán con "test.txt".</span><span class="sxs-lookup"><span data-stu-id="7eb9d-265">Test.txt, TEST.TXT, test.TXT, and any other combination of upper- and lowercase letters will match "test.txt".</span></span>
