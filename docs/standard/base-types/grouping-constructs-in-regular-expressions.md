---
title: Construcciones de agrupamiento en expresiones regulares
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- lookbehinds
- regular expressions, grouping constructs
- lookaheads
- .NET Framework regular expressions, grouping constructs
- constructs, grouping
- grouping constructs
ms.assetid: 0fc18634-f590-4062-8d5c-f0b71abe405b
ms.openlocfilehash: 5be98a5a213592b169bee430d84c4fc3a1d5fcef
ms.sourcegitcommit: 33deec3e814238fb18a49b2a7e89278e27888291
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 06/02/2020
ms.locfileid: "84290531"
---
# <a name="grouping-constructs-in-regular-expressions"></a><span data-ttu-id="bb994-102">Construcciones de agrupamiento en expresiones regulares</span><span class="sxs-lookup"><span data-stu-id="bb994-102">Grouping Constructs in Regular Expressions</span></span>
<span data-ttu-id="bb994-103">Las construcciones de agrupamiento definen las subexpresiones de una expresión regular y capturan las subcadenas de una cadena de entrada.</span><span class="sxs-lookup"><span data-stu-id="bb994-103">Grouping constructs delineate the subexpressions of a regular expression and capture the substrings of an input string.</span></span> <span data-ttu-id="bb994-104">Puede utilizar construcciones de agrupamiento para hacer lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="bb994-104">You can use grouping constructs to do the following:</span></span>  
  
- <span data-ttu-id="bb994-105">Buscar una subexpresión que se repite en la cadena de entrada.</span><span class="sxs-lookup"><span data-stu-id="bb994-105">Match a subexpression that is repeated in the input string.</span></span>  
  
- <span data-ttu-id="bb994-106">Aplicar un cuantificador a una subexpresión que tiene varios elementos del lenguaje de expresiones regulares.</span><span class="sxs-lookup"><span data-stu-id="bb994-106">Apply a quantifier to a subexpression that has multiple regular expression language elements.</span></span> <span data-ttu-id="bb994-107">Para más información sobre los cuantificadores, vea [Quantifiers](quantifiers-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="bb994-107">For more information about quantifiers, see [Quantifiers](quantifiers-in-regular-expressions.md).</span></span>  
  
- <span data-ttu-id="bb994-108">Incluir una subexpresión en la cadena devuelta por los métodos <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> y <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="bb994-108">Include a subexpression in the string that is returned by the <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> and <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> methods.</span></span>  
  
- <span data-ttu-id="bb994-109">Recuperar subexpresiones individuales de la propiedad <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> y procesarlas por separado del texto coincidente en su conjunto.</span><span class="sxs-lookup"><span data-stu-id="bb994-109">Retrieve individual subexpressions from the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property and process them separately from the matched text as a whole.</span></span>  
  
 <span data-ttu-id="bb994-110">En la tabla siguiente se enumeran las construcciones de agrupamiento admitidas por el motor de expresiones regulares de .NET y se indica si son de captura o sin captura.</span><span class="sxs-lookup"><span data-stu-id="bb994-110">The following table lists the grouping constructs supported by the .NET regular expression engine and indicates whether they are capturing or non-capturing.</span></span>  
  
|<span data-ttu-id="bb994-111">Construcción de agrupamiento</span><span class="sxs-lookup"><span data-stu-id="bb994-111">Grouping construct</span></span>|<span data-ttu-id="bb994-112">De captura o sin captura</span><span class="sxs-lookup"><span data-stu-id="bb994-112">Capturing or noncapturing</span></span>|  
|------------------------|-------------------------------|  
|[<span data-ttu-id="bb994-113">Subexpresiones coincidentes</span><span class="sxs-lookup"><span data-stu-id="bb994-113">Matched subexpressions</span></span>](#matched_subexpression)|<span data-ttu-id="bb994-114">Capturando</span><span class="sxs-lookup"><span data-stu-id="bb994-114">Capturing</span></span>|  
|[<span data-ttu-id="bb994-115">Subexpresiones coincidentes con nombre</span><span class="sxs-lookup"><span data-stu-id="bb994-115">Named matched subexpressions</span></span>](#named_matched_subexpression)|<span data-ttu-id="bb994-116">Capturando</span><span class="sxs-lookup"><span data-stu-id="bb994-116">Capturing</span></span>|  
|[<span data-ttu-id="bb994-117">Definiciones de grupos de compensación</span><span class="sxs-lookup"><span data-stu-id="bb994-117">Balancing group definitions</span></span>](#balancing_group_definition)|<span data-ttu-id="bb994-118">Capturando</span><span class="sxs-lookup"><span data-stu-id="bb994-118">Capturing</span></span>|  
|[<span data-ttu-id="bb994-119">Grupos sin captura</span><span class="sxs-lookup"><span data-stu-id="bb994-119">Noncapturing groups</span></span>](#noncapturing_group)|<span data-ttu-id="bb994-120">Sin captura</span><span class="sxs-lookup"><span data-stu-id="bb994-120">Noncapturing</span></span>|  
|[<span data-ttu-id="bb994-121">Opciones de grupo</span><span class="sxs-lookup"><span data-stu-id="bb994-121">Group options</span></span>](#group_options)|<span data-ttu-id="bb994-122">Sin captura</span><span class="sxs-lookup"><span data-stu-id="bb994-122">Noncapturing</span></span>|  
|[<span data-ttu-id="bb994-123">Aserciones de búsqueda anticipada positiva de ancho cero</span><span class="sxs-lookup"><span data-stu-id="bb994-123">Zero-width positive lookahead assertions</span></span>](#zerowidth_positive_lookahead_assertion)|<span data-ttu-id="bb994-124">Sin captura</span><span class="sxs-lookup"><span data-stu-id="bb994-124">Noncapturing</span></span>|  
|[<span data-ttu-id="bb994-125">Aserciones de búsqueda anticipada negativa de ancho cero</span><span class="sxs-lookup"><span data-stu-id="bb994-125">Zero-width negative lookahead assertions</span></span>](#zerowidth_negative_lookahead_assertion)|<span data-ttu-id="bb994-126">Sin captura</span><span class="sxs-lookup"><span data-stu-id="bb994-126">Noncapturing</span></span>|  
|[<span data-ttu-id="bb994-127">Aserciones de búsqueda tardía positiva de ancho cero</span><span class="sxs-lookup"><span data-stu-id="bb994-127">Zero-width positive lookbehind assertions</span></span>](#zerowidth_positive_lookbehind_assertion)|<span data-ttu-id="bb994-128">Sin captura</span><span class="sxs-lookup"><span data-stu-id="bb994-128">Noncapturing</span></span>|  
|[<span data-ttu-id="bb994-129">Aserciones de búsqueda tardía negativa de ancho cero</span><span class="sxs-lookup"><span data-stu-id="bb994-129">Zero-width negative lookbehind assertions</span></span>](#zerowidth_negative_lookbehind_assertion)|<span data-ttu-id="bb994-130">Sin captura</span><span class="sxs-lookup"><span data-stu-id="bb994-130">Noncapturing</span></span>|  
|[<span data-ttu-id="bb994-131">Grupos atómicos</span><span class="sxs-lookup"><span data-stu-id="bb994-131">Atomic groups</span></span>](#atomic_groups)|<span data-ttu-id="bb994-132">Sin captura</span><span class="sxs-lookup"><span data-stu-id="bb994-132">Noncapturing</span></span>|  
  
 <span data-ttu-id="bb994-133">Para obtener información sobre los grupos y el modelo de objetos de expresiones regulares, vea [Construcciones de agrupamiento y objetos de las expresiones regulares](#Objects).</span><span class="sxs-lookup"><span data-stu-id="bb994-133">For information on groups and the regular expression object model, see [Grouping constructs and regular expression objects](#Objects).</span></span>  
  
<a name="matched_subexpression"></a>
## <a name="matched-subexpressions"></a><span data-ttu-id="bb994-134">Subexpresiones coincidentes</span><span class="sxs-lookup"><span data-stu-id="bb994-134">Matched Subexpressions</span></span>  
 <span data-ttu-id="bb994-135">La construcción de agrupación siguiente captura una subexpresión coincidente:</span><span class="sxs-lookup"><span data-stu-id="bb994-135">The following grouping construct captures a matched subexpression:</span></span>  
  
 <span data-ttu-id="bb994-136">`(` *subexpresión* `)`</span><span class="sxs-lookup"><span data-stu-id="bb994-136">`(` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="bb994-137">donde *subexpresión* es cualquier patrón de expresión regular válido.</span><span class="sxs-lookup"><span data-stu-id="bb994-137">where *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="bb994-138">Las capturas que usan paréntesis se numeran automáticamente de izquierda a derecha según el orden de los paréntesis de apertura de la expresión regular, empezando desde uno.</span><span class="sxs-lookup"><span data-stu-id="bb994-138">Captures that use parentheses are numbered automatically from left to right based on the order of the opening parentheses in the regular expression, starting from one.</span></span> <span data-ttu-id="bb994-139">La captura con el número cero es el texto coincidente con el patrón de la expresión regular completa.</span><span class="sxs-lookup"><span data-stu-id="bb994-139">The capture that is numbered zero is the text matched by the entire regular expression pattern.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="bb994-140">De manera predeterminada, el elemento de lenguaje `(`*subexpresión*`)` captura la subexpresión coincidente.</span><span class="sxs-lookup"><span data-stu-id="bb994-140">By default, the `(`*subexpression*`)` language element captures the matched subexpression.</span></span> <span data-ttu-id="bb994-141">No obstante, la subexpresión coincidente no se captura si el parámetro <xref:System.Text.RegularExpressions.RegexOptions> del método de coincidencia de patrones de una expresión regular incluye la marca <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> o si se aplica la opción `n` a esta subexpresión (vea [Opciones de grupo](#group_options) más adelante en este tema).</span><span class="sxs-lookup"><span data-stu-id="bb994-141">But if the <xref:System.Text.RegularExpressions.RegexOptions> parameter of a regular expression pattern matching method includes the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> flag, or if the `n` option is applied to this subexpression (see [Group options](#group_options) later in this topic), the matched subexpression is not captured.</span></span>  
  
 <span data-ttu-id="bb994-142">Existen cuatro formas de tener acceso a los grupos capturados:</span><span class="sxs-lookup"><span data-stu-id="bb994-142">You can access captured groups in four ways:</span></span>  
  
- <span data-ttu-id="bb994-143">Usando la construcción de referencia inversa dentro de la expresión regular.</span><span class="sxs-lookup"><span data-stu-id="bb994-143">By using the backreference construct within the regular expression.</span></span> <span data-ttu-id="bb994-144">Para hacer referencia a la subexpresión coincidente desde la misma expresión regular, se usa la sintaxis `\`*número*, donde *número* es el número ordinal de la subexpresión capturada.</span><span class="sxs-lookup"><span data-stu-id="bb994-144">The matched subexpression is referenced in the same regular expression by using the syntax `\`*number*, where *number* is the ordinal number of the captured subexpression.</span></span>  
  
- <span data-ttu-id="bb994-145">Usando la construcción de referencia inversa con nombre dentro de la expresión regular.</span><span class="sxs-lookup"><span data-stu-id="bb994-145">By using the named backreference construct within the regular expression.</span></span> <span data-ttu-id="bb994-146">Para hacer referencia a la subexpresión coincidente desde la misma expresión regular, se usa la sintaxis `\k<`*nombre*`>`, donde *nombre* es el nombre de un grupo de captura, o `\k<`*número*`>`, donde *número* es el número ordinal de un grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="bb994-146">The matched subexpression is referenced in the same regular expression by using the syntax `\k<`*name*`>`, where *name* is the name of a capturing group, or `\k<`*number*`>`, where *number* is the ordinal number of a capturing group.</span></span> <span data-ttu-id="bb994-147">Un grupo de captura tiene un nombre predeterminado que es idéntico a su número ordinal.</span><span class="sxs-lookup"><span data-stu-id="bb994-147">A capturing group has a default name that is identical to its ordinal number.</span></span> <span data-ttu-id="bb994-148">Para obtener más información, vea [Subexpresiones coincidentes con nombre](#named_matched_subexpression) más adelante en este tema.</span><span class="sxs-lookup"><span data-stu-id="bb994-148">For more information, see [Named matched subexpressions](#named_matched_subexpression) later in this topic.</span></span>  
  
- <span data-ttu-id="bb994-149">Usando la secuencia de reemplazo `$`*número* en una llamada al método <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> o <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> , donde *número* es el número ordinal de la subexpresión capturada.</span><span class="sxs-lookup"><span data-stu-id="bb994-149">By using the `$`*number* replacement sequence in a <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> method call, where *number* is the ordinal number of the captured subexpression.</span></span>  
  
- <span data-ttu-id="bb994-150">Mediante programación, usando el objeto <xref:System.Text.RegularExpressions.GroupCollection> devuelto por la propiedad <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="bb994-150">Programmatically, by using the <xref:System.Text.RegularExpressions.GroupCollection> object returned by the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="bb994-151">El miembro en la posición cero de la colección representa la coincidencia de la expresión regular completa.</span><span class="sxs-lookup"><span data-stu-id="bb994-151">The member at position zero in the collection represents the entire regular expression match.</span></span> <span data-ttu-id="bb994-152">Cada miembro subsiguiente representa una subexpresión coincidente.</span><span class="sxs-lookup"><span data-stu-id="bb994-152">Each subsequent member represents a matched subexpression.</span></span> <span data-ttu-id="bb994-153">Para más información, vea la sección [Grouping Constructs and Regular Expression Objects](#Objects) .</span><span class="sxs-lookup"><span data-stu-id="bb994-153">For more information, see the [Grouping Constructs and Regular Expression Objects](#Objects) section.</span></span>  
  
 <span data-ttu-id="bb994-154">En el ejemplo siguiente se muestra una expresión regular que identifica las palabras duplicadas en el texto.</span><span class="sxs-lookup"><span data-stu-id="bb994-154">The following example illustrates a regular expression that identifies duplicated words in text.</span></span> <span data-ttu-id="bb994-155">Los dos grupos de captura del patrón de la expresión regular representan las dos instancias de la palabra duplicada.</span><span class="sxs-lookup"><span data-stu-id="bb994-155">The regular expression pattern's two capturing groups represent the two instances of the duplicated word.</span></span> <span data-ttu-id="bb994-156">La segunda instancia se captura para notificar su posición inicial en la cadena de entrada.</span><span class="sxs-lookup"><span data-stu-id="bb994-156">The second instance is captured to report its starting position in the input string.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#1](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/grouping1.cs#1)]
 [!code-vb[RegularExpressions.Language.Grouping#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/grouping1.vb#1)]  
  
 <span data-ttu-id="bb994-157">El patrón de la expresión regular es el siguiente:</span><span class="sxs-lookup"><span data-stu-id="bb994-157">The regular expression pattern is the following:</span></span>  
  
`(\w+)\s(\1)\W`  
  
 <span data-ttu-id="bb994-158">En la siguiente tabla se muestra cómo se interpreta el patrón de expresión regular.</span><span class="sxs-lookup"><span data-stu-id="bb994-158">The following table shows how the regular expression pattern is interpreted.</span></span>  
  
|<span data-ttu-id="bb994-159">Modelo</span><span class="sxs-lookup"><span data-stu-id="bb994-159">Pattern</span></span>|<span data-ttu-id="bb994-160">Descripción</span><span class="sxs-lookup"><span data-stu-id="bb994-160">Description</span></span>|  
|-------------|-----------------|  
|`(\w+)`|<span data-ttu-id="bb994-161">Buscar coincidencias con uno o más caracteres alfabéticos.</span><span class="sxs-lookup"><span data-stu-id="bb994-161">Match one or more word characters.</span></span> <span data-ttu-id="bb994-162">Este es el primer grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="bb994-162">This is the first capturing group.</span></span>|  
|`\s`|<span data-ttu-id="bb994-163">Coincide con un carácter de espacio en blanco.</span><span class="sxs-lookup"><span data-stu-id="bb994-163">Match a white-space character.</span></span>|  
|`(\1)`|<span data-ttu-id="bb994-164">Coincide con la cadena del primer grupo capturado.</span><span class="sxs-lookup"><span data-stu-id="bb994-164">Match the string in the first captured group.</span></span> <span data-ttu-id="bb994-165">Este es el segundo grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="bb994-165">This is the second capturing group.</span></span> <span data-ttu-id="bb994-166">El ejemplo lo asigna a un grupo capturado de forma que la posición inicial de la palabra duplicada se pueda recuperar de la propiedad `Match.Index` .</span><span class="sxs-lookup"><span data-stu-id="bb994-166">The example assigns it to a captured group so that the starting position of the duplicate word can be retrieved from the `Match.Index` property.</span></span>|  
|`\W`|<span data-ttu-id="bb994-167">Coincide con un carácter que no se usa para formar palabras, como los espacios en blanco y los signos de puntuación.</span><span class="sxs-lookup"><span data-stu-id="bb994-167">Match a non-word character, including white space and punctuation.</span></span> <span data-ttu-id="bb994-168">Esto evita que el patrón de la expresión regular coincida con una palabra que comience por la palabra del primer grupo capturado.</span><span class="sxs-lookup"><span data-stu-id="bb994-168">This prevents the regular expression pattern from matching a word that starts with the word from the first captured group.</span></span>|  
  
<a name="named_matched_subexpression"></a>
## <a name="named-matched-subexpressions"></a><span data-ttu-id="bb994-169">Subexpresiones coincidentes con nombre</span><span class="sxs-lookup"><span data-stu-id="bb994-169">Named Matched Subexpressions</span></span>  
 <span data-ttu-id="bb994-170">La construcción de agrupamiento siguiente captura una subexpresión coincidente y permite tener acceso a ella por nombre o por número:</span><span class="sxs-lookup"><span data-stu-id="bb994-170">The following grouping construct captures a matched subexpression and lets you access it by name or by number:</span></span>  
  
`(?<name>subexpression)`  
  
 <span data-ttu-id="bb994-171">O bien</span><span class="sxs-lookup"><span data-stu-id="bb994-171">or:</span></span>  
  
`(?'name'subexpression)`  
  
 <span data-ttu-id="bb994-172">donde *nombre* es un nombre de grupo válido, y *subexpresión* es cualquier patrón de expresión regular válido.</span><span class="sxs-lookup"><span data-stu-id="bb994-172">where *name* is a valid group name, and *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="bb994-173">*nombre* no debe contener ningún carácter de puntuación y no puede comenzar por un número.</span><span class="sxs-lookup"><span data-stu-id="bb994-173">*name* must not contain any punctuation characters and cannot begin with a number.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="bb994-174">Si el parámetro <xref:System.Text.RegularExpressions.RegexOptions> del método de coincidencia de patrones de una expresión regular incluye la marca <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> o si se aplica la opción `n` a esta subexpresión (vea [Opciones de grupo](#group_options) más adelante en este tema), la única forma de capturar una subexpresión es asignar nombres explícitamente a los grupos de captura.</span><span class="sxs-lookup"><span data-stu-id="bb994-174">If the <xref:System.Text.RegularExpressions.RegexOptions> parameter of a regular expression pattern matching method includes the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> flag, or if the `n` option is applied to this subexpression (see [Group options](#group_options) later in this topic), the only way to capture a subexpression is to explicitly name capturing groups.</span></span>  
  
 <span data-ttu-id="bb994-175">Puede tener acceso a los grupos capturados con nombre de las maneras siguientes:</span><span class="sxs-lookup"><span data-stu-id="bb994-175">You can access named captured groups in the following ways:</span></span>  
  
- <span data-ttu-id="bb994-176">Usando la construcción de referencia inversa con nombre dentro de la expresión regular.</span><span class="sxs-lookup"><span data-stu-id="bb994-176">By using the named backreference construct within the regular expression.</span></span> <span data-ttu-id="bb994-177">Para hacer referencia a la subexpresión coincidente desde la misma expresión regular, se usa la sintaxis `\k<`*nombre*`>`, donde *nombre* es el nombre de la subexpresión capturada.</span><span class="sxs-lookup"><span data-stu-id="bb994-177">The matched subexpression is referenced in the same regular expression by using the syntax `\k<`*name*`>`, where *name* is the name of the captured subexpression.</span></span>  
  
- <span data-ttu-id="bb994-178">Usando la construcción de referencia inversa dentro de la expresión regular.</span><span class="sxs-lookup"><span data-stu-id="bb994-178">By using the backreference construct within the regular expression.</span></span> <span data-ttu-id="bb994-179">Para hacer referencia a la subexpresión coincidente desde la misma expresión regular, se usa la sintaxis `\`*número*, donde *número* es el número ordinal de la subexpresión capturada.</span><span class="sxs-lookup"><span data-stu-id="bb994-179">The matched subexpression is referenced in the same regular expression by using the syntax `\`*number*, where *number* is the ordinal number of the captured subexpression.</span></span> <span data-ttu-id="bb994-180">Las subexpresiones coincidentes con nombre se numeran consecutivamente de izquierda a derecha después de las subexpresiones coincidentes.</span><span class="sxs-lookup"><span data-stu-id="bb994-180">Named matched subexpressions are numbered consecutively from left to right after matched subexpressions.</span></span>  
  
- <span data-ttu-id="bb994-181">Usando la secuencia de reemplazo `${`*nombre*`}` en una llamada al método <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> o <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> , donde *nombre* es el nombre de la subexpresión capturada.</span><span class="sxs-lookup"><span data-stu-id="bb994-181">By using the `${`*name*`}` replacement sequence in a <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> method call, where *name* is the name of the captured subexpression.</span></span>  
  
- <span data-ttu-id="bb994-182">Usando la secuencia de reemplazo `$`*número* en una llamada al método <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> o <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> , donde *número* es el número ordinal de la subexpresión capturada.</span><span class="sxs-lookup"><span data-stu-id="bb994-182">By using the `$`*number* replacement sequence in a <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> method call, where *number* is the ordinal number of the captured subexpression.</span></span>  
  
- <span data-ttu-id="bb994-183">Mediante programación, usando el objeto <xref:System.Text.RegularExpressions.GroupCollection> devuelto por la propiedad <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="bb994-183">Programmatically, by using the <xref:System.Text.RegularExpressions.GroupCollection> object returned by the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="bb994-184">El miembro en la posición cero de la colección representa la coincidencia de la expresión regular completa.</span><span class="sxs-lookup"><span data-stu-id="bb994-184">The member at position zero in the collection represents the entire regular expression match.</span></span> <span data-ttu-id="bb994-185">Cada miembro subsiguiente representa una subexpresión coincidente.</span><span class="sxs-lookup"><span data-stu-id="bb994-185">Each subsequent member represents a matched subexpression.</span></span> <span data-ttu-id="bb994-186">Los grupos capturados con nombre se almacenan en la colección después de los grupos capturados numerados.</span><span class="sxs-lookup"><span data-stu-id="bb994-186">Named captured groups are stored in the collection after numbered captured groups.</span></span>  
  
- <span data-ttu-id="bb994-187">Mediante programación, proporcionando el nombre de la subexpresión al indizador del objeto <xref:System.Text.RegularExpressions.GroupCollection> (en C#) o a su propiedad <xref:System.Text.RegularExpressions.GroupCollection.Item%2A> (en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="bb994-187">Programmatically, by providing the subexpression name to the <xref:System.Text.RegularExpressions.GroupCollection> object's indexer (in C#) or to its <xref:System.Text.RegularExpressions.GroupCollection.Item%2A> property (in Visual Basic).</span></span>  
  
 <span data-ttu-id="bb994-188">Un patrón de expresión regular simple muestra cómo se puede hacer referencia a los grupos numerados (sin nombre) y con nombre mediante programación o utilizando la sintaxis del lenguaje de expresiones regulares.</span><span class="sxs-lookup"><span data-stu-id="bb994-188">A simple regular expression pattern illustrates how numbered (unnamed) and named groups can be referenced either programmatically or by using regular expression language syntax.</span></span> <span data-ttu-id="bb994-189">La expresión regular `((?<One>abc)\d+)?(?<Two>xyz)(.*)` produce los siguientes grupos de captura por número y por nombre.</span><span class="sxs-lookup"><span data-stu-id="bb994-189">The regular expression `((?<One>abc)\d+)?(?<Two>xyz)(.*)` produces the following capturing groups by number and by name.</span></span> <span data-ttu-id="bb994-190">El primer grupo de captura (el número 0) siempre hace referencia al patrón completo.</span><span class="sxs-lookup"><span data-stu-id="bb994-190">The first capturing group (number 0) always refers to the entire pattern.</span></span>  
  
|<span data-ttu-id="bb994-191">número</span><span class="sxs-lookup"><span data-stu-id="bb994-191">Number</span></span>|<span data-ttu-id="bb994-192">NOMBRE</span><span class="sxs-lookup"><span data-stu-id="bb994-192">Name</span></span>|<span data-ttu-id="bb994-193">Modelo</span><span class="sxs-lookup"><span data-stu-id="bb994-193">Pattern</span></span>|  
|------------|----------|-------------|  
|<span data-ttu-id="bb994-194">0</span><span class="sxs-lookup"><span data-stu-id="bb994-194">0</span></span>|<span data-ttu-id="bb994-195">0 (nombre predeterminado)</span><span class="sxs-lookup"><span data-stu-id="bb994-195">0 (default name)</span></span>|`((?<One>abc)\d+)?(?<Two>xyz)(.*)`|  
|<span data-ttu-id="bb994-196">1</span><span class="sxs-lookup"><span data-stu-id="bb994-196">1</span></span>|<span data-ttu-id="bb994-197">1 (nombre predeterminado)</span><span class="sxs-lookup"><span data-stu-id="bb994-197">1 (default name)</span></span>|`((?<One>abc)\d+)`|  
|<span data-ttu-id="bb994-198">2</span><span class="sxs-lookup"><span data-stu-id="bb994-198">2</span></span>|<span data-ttu-id="bb994-199">2 (nombre predeterminado)</span><span class="sxs-lookup"><span data-stu-id="bb994-199">2 (default name)</span></span>|`(.*)`|  
|<span data-ttu-id="bb994-200">3</span><span class="sxs-lookup"><span data-stu-id="bb994-200">3</span></span>|<span data-ttu-id="bb994-201">Uno</span><span class="sxs-lookup"><span data-stu-id="bb994-201">One</span></span>|`(?<One>abc)`|  
|<span data-ttu-id="bb994-202">4</span><span class="sxs-lookup"><span data-stu-id="bb994-202">4</span></span>|<span data-ttu-id="bb994-203">Dos</span><span class="sxs-lookup"><span data-stu-id="bb994-203">Two</span></span>|`(?<Two>xyz)`|  
  
 <span data-ttu-id="bb994-204">En el ejemplo siguiente se muestra una expresión regular que identifica las palabras duplicadas y la palabra que sigue inmediatamente a cada palabra duplicada.</span><span class="sxs-lookup"><span data-stu-id="bb994-204">The following example illustrates a regular expression that identifies duplicated words and the word that immediately follows each duplicated word.</span></span> <span data-ttu-id="bb994-205">El patrón de la expresión regular define dos subexpresiones con nombre: `duplicateWord`, que representa la palabra duplicada; y `nextWord`, que representa la palabra que sigue a la palabra duplicada.</span><span class="sxs-lookup"><span data-stu-id="bb994-205">The regular expression pattern defines two named subexpressions: `duplicateWord`, which represents the duplicated word; and `nextWord`, which represents the word that follows the duplicated word.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#2](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/grouping2.cs#2)]
 [!code-vb[RegularExpressions.Language.Grouping#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/grouping2.vb#2)]  
  
 <span data-ttu-id="bb994-206">El patrón de la expresión regular es el siguiente:</span><span class="sxs-lookup"><span data-stu-id="bb994-206">The regular expression pattern is as follows:</span></span>  
  
`(?<duplicateWord>\w+)\s\k<duplicateWord>\W(?<nextWord>\w+)`  
  
 <span data-ttu-id="bb994-207">La tabla siguiente muestra cómo se interpreta la expresión regular.</span><span class="sxs-lookup"><span data-stu-id="bb994-207">The following table shows how the regular expression is interpreted.</span></span>  
  
|<span data-ttu-id="bb994-208">Modelo</span><span class="sxs-lookup"><span data-stu-id="bb994-208">Pattern</span></span>|<span data-ttu-id="bb994-209">Descripción</span><span class="sxs-lookup"><span data-stu-id="bb994-209">Description</span></span>|  
|-------------|-----------------|  
|`(?<duplicateWord>\w+)`|<span data-ttu-id="bb994-210">Buscar coincidencias con uno o más caracteres alfabéticos.</span><span class="sxs-lookup"><span data-stu-id="bb994-210">Match one or more word characters.</span></span> <span data-ttu-id="bb994-211">Este grupo de captura se denomina `duplicateWord`.</span><span class="sxs-lookup"><span data-stu-id="bb994-211">Name this capturing group `duplicateWord`.</span></span>|  
|`\s`|<span data-ttu-id="bb994-212">Coincide con un carácter de espacio en blanco.</span><span class="sxs-lookup"><span data-stu-id="bb994-212">Match a white-space character.</span></span>|  
|`\k<duplicateWord>`|<span data-ttu-id="bb994-213">Coincide con la cadena del grupo capturado denominada `duplicateWord`.</span><span class="sxs-lookup"><span data-stu-id="bb994-213">Match the string from the captured group that is named `duplicateWord`.</span></span>|  
|`\W`|<span data-ttu-id="bb994-214">Coincide con un carácter que no se usa para formar palabras, como los espacios en blanco y los signos de puntuación.</span><span class="sxs-lookup"><span data-stu-id="bb994-214">Match a non-word character, including white space and punctuation.</span></span> <span data-ttu-id="bb994-215">Esto evita que el patrón de la expresión regular coincida con una palabra que comience por la palabra del primer grupo capturado.</span><span class="sxs-lookup"><span data-stu-id="bb994-215">This prevents the regular expression pattern from matching a word that starts with the word from the first captured group.</span></span>|  
|`(?<nextWord>\w+)`|<span data-ttu-id="bb994-216">Buscar coincidencias con uno o más caracteres alfabéticos.</span><span class="sxs-lookup"><span data-stu-id="bb994-216">Match one or more word characters.</span></span> <span data-ttu-id="bb994-217">Este grupo de captura se denomina `nextWord`.</span><span class="sxs-lookup"><span data-stu-id="bb994-217">Name this capturing group `nextWord`.</span></span>|  
  
 <span data-ttu-id="bb994-218">Tenga en cuenta que un nombre de grupo se puede repetir en una expresión regular.</span><span class="sxs-lookup"><span data-stu-id="bb994-218">Note that a group name can be repeated in a regular expression.</span></span> <span data-ttu-id="bb994-219">Por ejemplo, es posible que más de un grupo se llame `digit`, como muestra el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="bb994-219">For example, it is possible for more than one group to be named `digit`, as the following example illustrates.</span></span> <span data-ttu-id="bb994-220">En el caso de nombres duplicados, el valor del objeto <xref:System.Text.RegularExpressions.Group> viene determinado por la última captura correcta en la cadena de entrada.</span><span class="sxs-lookup"><span data-stu-id="bb994-220">In the case of duplicate names, the value of the <xref:System.Text.RegularExpressions.Group> object is determined by the last successful capture in the input string.</span></span> <span data-ttu-id="bb994-221">Además, la colección <xref:System.Text.RegularExpressions.CaptureCollection> se rellena con información de cada captura igual que si el nombre de grupo no estuviera duplicado.</span><span class="sxs-lookup"><span data-stu-id="bb994-221">In addition, the <xref:System.Text.RegularExpressions.CaptureCollection> is populated with information about each capture just as it would be if the group name was not duplicated.</span></span>  
  
 <span data-ttu-id="bb994-222">En el ejemplo siguiente, la expresión regular `\D+(?<digit>\d+)\D+(?<digit>\d+)?` incluye dos apariciones de un grupo llamado `digit`.</span><span class="sxs-lookup"><span data-stu-id="bb994-222">In the following example, the regular expression `\D+(?<digit>\d+)\D+(?<digit>\d+)?` includes two occurrences of a group named `digit`.</span></span> <span data-ttu-id="bb994-223">El primer grupo llamado `digit` captura uno o más caracteres de dígito.</span><span class="sxs-lookup"><span data-stu-id="bb994-223">The first `digit` named group captures one or more digit characters.</span></span> <span data-ttu-id="bb994-224">El segundo grupo llamado `digit` captura cero o una aparición de uno o más caracteres de dígito.</span><span class="sxs-lookup"><span data-stu-id="bb994-224">The second `digit` named group captures either zero or one occurrence of one or more digit characters.</span></span> <span data-ttu-id="bb994-225">Tal y como muestra la salida del ejemplo, si el segundo grupo de captura coincide correctamente con el texto, el valor de ese texto define el valor del objeto <xref:System.Text.RegularExpressions.Group> .</span><span class="sxs-lookup"><span data-stu-id="bb994-225">As the output from the example shows, if the second capturing group successfully matches text, the value of that text defines the value of the <xref:System.Text.RegularExpressions.Group> object.</span></span> <span data-ttu-id="bb994-226">Si el segundo grupo de captura no coincide con la cadena de entrada, el valor de la última coincidencia correcta define el valor del objeto <xref:System.Text.RegularExpressions.Group> .</span><span class="sxs-lookup"><span data-stu-id="bb994-226">If the second capturing group cannot does not match the input string, the value of the last successful match defines the value of the <xref:System.Text.RegularExpressions.Group> object.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#12](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/duplicate1.cs#12)]
 [!code-vb[RegularExpressions.Language.Grouping#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/duplicate1.vb#12)]  
  
 <span data-ttu-id="bb994-227">La tabla siguiente muestra cómo se interpreta la expresión regular.</span><span class="sxs-lookup"><span data-stu-id="bb994-227">The following table shows how the regular expression is interpreted.</span></span>  
  
|<span data-ttu-id="bb994-228">Modelo</span><span class="sxs-lookup"><span data-stu-id="bb994-228">Pattern</span></span>|<span data-ttu-id="bb994-229">Descripción</span><span class="sxs-lookup"><span data-stu-id="bb994-229">Description</span></span>|  
|-------------|-----------------|  
|`\D+`|<span data-ttu-id="bb994-230">Coincide con uno o más caracteres de dígito no decimal.</span><span class="sxs-lookup"><span data-stu-id="bb994-230">Match one or more non-decimal digit characters.</span></span>|  
|`(?<digit>\d+)`|<span data-ttu-id="bb994-231">Coincide con uno o más caracteres de dígito decimal.</span><span class="sxs-lookup"><span data-stu-id="bb994-231">Match one or more decimal digit characters.</span></span> <span data-ttu-id="bb994-232">Asigna la coincidencia al grupo llamado `digit`.</span><span class="sxs-lookup"><span data-stu-id="bb994-232">Assign the match to the `digit` named group.</span></span>|  
|`\D+`|<span data-ttu-id="bb994-233">Coincide con uno o más caracteres de dígito no decimal.</span><span class="sxs-lookup"><span data-stu-id="bb994-233">Match one or more non-decimal digit characters.</span></span>|  
|`(?<digit>\d+)?`|<span data-ttu-id="bb994-234">Coincide con ninguna o una aparición de uno o más caracteres de dígito decimal.</span><span class="sxs-lookup"><span data-stu-id="bb994-234">Match zero or one occurrence of one or more decimal digit characters.</span></span> <span data-ttu-id="bb994-235">Asigna la coincidencia al grupo llamado `digit` .</span><span class="sxs-lookup"><span data-stu-id="bb994-235">Assign the match to the `digit` named group.</span></span>|  
  
<a name="balancing_group_definition"></a>
## <a name="balancing-group-definitions"></a><span data-ttu-id="bb994-236">Definiciones de grupos de compensación</span><span class="sxs-lookup"><span data-stu-id="bb994-236">Balancing Group Definitions</span></span>  
 <span data-ttu-id="bb994-237">Una definición de grupo de compensación elimina la definición de un grupo definido anteriormente y almacena, en el grupo actual, el intervalo entre el grupo definido anteriormente y el grupo actual.</span><span class="sxs-lookup"><span data-stu-id="bb994-237">A balancing group definition deletes the definition of a previously defined group and stores, in the current group, the interval between the previously defined group and the current group.</span></span> <span data-ttu-id="bb994-238">Esta construcción de agrupamiento tiene el formato siguiente:</span><span class="sxs-lookup"><span data-stu-id="bb994-238">This grouping construct has the following format:</span></span>  
  
`(?<name1-name2>subexpression)`  
  
 <span data-ttu-id="bb994-239">O bien</span><span class="sxs-lookup"><span data-stu-id="bb994-239">or:</span></span>  
  
`(?'name1-name2' subexpression)`
  
 <span data-ttu-id="bb994-240">donde *nombre1* es el grupo actual (opcional), *nombre2* es un grupo definido previamente y *subexpresión* es cualquier patrón de expresión regular válido.</span><span class="sxs-lookup"><span data-stu-id="bb994-240">where *name1* is the current group (optional), *name2* is a previously defined group, and *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="bb994-241">La definición de grupo de compensación elimina la definición de *nombre2* y almacena el intervalo entre *nombre2* y *nombre1* en *nombre1*.</span><span class="sxs-lookup"><span data-stu-id="bb994-241">The balancing group definition deletes the definition of *name2* and stores the interval between *name2* and *name1* in *name1*.</span></span> <span data-ttu-id="bb994-242">Si no se ha definido el grupo *nombre2* , la búsqueda de coincidencias retrocede.</span><span class="sxs-lookup"><span data-stu-id="bb994-242">If no *name2* group is defined, the match backtracks.</span></span> <span data-ttu-id="bb994-243">Como al eliminar la última definición de *nombre2* se revela la definición anterior de *nombre2*, esta construcción permite usar la pila de capturas del grupo *nombre2* como contador para realizar el seguimiento de construcciones anidadas como paréntesis o corchetes de apertura y cierre.</span><span class="sxs-lookup"><span data-stu-id="bb994-243">Because deleting the last definition of *name2* reveals the previous definition of *name2*, this construct lets you use the stack of captures for group *name2* as a counter for keeping track of nested constructs such as parentheses or opening and closing brackets.</span></span>  
  
 <span data-ttu-id="bb994-244">La definición del grupo de compensación utiliza *nombre2* como pila.</span><span class="sxs-lookup"><span data-stu-id="bb994-244">The balancing group definition uses *name2* as a stack.</span></span> <span data-ttu-id="bb994-245">El carácter inicial de cada construcción anidada se coloca en el grupo y en su colección <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="bb994-245">The beginning character of each nested construct is placed in the group and in its <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> collection.</span></span> <span data-ttu-id="bb994-246">Cuando se encuentra una coincidencia con el carácter de cierre, el carácter de apertura correspondiente se quita del grupo, y la colección <xref:System.Text.RegularExpressions.Group.Captures%2A> disminuye en una unidad.</span><span class="sxs-lookup"><span data-stu-id="bb994-246">When the closing character is matched, its corresponding opening character is removed from the group, and the <xref:System.Text.RegularExpressions.Group.Captures%2A> collection is decreased by one.</span></span> <span data-ttu-id="bb994-247">Después de buscar las coincidencias con los caracteres de apertura y cierre de todas las construcciones anidadas, *nombre2* estará vacío.</span><span class="sxs-lookup"><span data-stu-id="bb994-247">After the opening and closing characters of all nested constructs have been matched, *name2* is empty.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="bb994-248">Después de modificar la expresión regular del ejemplo siguiente para que utilice el carácter de apertura y cierre adecuado de una construcción anidada, puede utilizarla con la mayoría de las estructuras anidadas, como expresiones matemáticas o líneas de código de programa que incluyen varias llamadas a métodos anidadas.</span><span class="sxs-lookup"><span data-stu-id="bb994-248">After you modify the regular expression in the following example to use the appropriate opening and closing character of a nested construct, you can use it to handle most nested constructs, such as mathematical expressions or lines of program code that include multiple nested method calls.</span></span>  
  
 <span data-ttu-id="bb994-249">En el ejemplo siguiente se usa una definición de grupo de compensación para que coincida con los corchetes angulares de apertura y de cierre (<>) de una cadena de entrada.</span><span class="sxs-lookup"><span data-stu-id="bb994-249">The following example uses a balancing group definition to match left and right angle brackets (<>) in an input string.</span></span> <span data-ttu-id="bb994-250">En el ejemplo se definen dos grupos con nombre, `Open` y `Close`, que se utilizan como una pila para realizar el seguimiento de los pares de corchetes angulares coincidentes.</span><span class="sxs-lookup"><span data-stu-id="bb994-250">The example defines two named groups, `Open` and `Close`, that are used like a stack to track matching pairs of angle brackets.</span></span> <span data-ttu-id="bb994-251">Cada corchete angular de apertura capturado se inserta en la colección de captura del grupo `Open` , y cada corchete angular de cierre capturado se inserta en la colección de captura del grupo `Close` .</span><span class="sxs-lookup"><span data-stu-id="bb994-251">Each captured left angle bracket is pushed into the capture collection of the `Open` group, and each captured right angle bracket is pushed into the capture collection of the `Close` group.</span></span> <span data-ttu-id="bb994-252">Mediante la definición del grupo de compensación se comprueba que haya un corchete angular de cierre para cada corchete angular de apertura.</span><span class="sxs-lookup"><span data-stu-id="bb994-252">The balancing group definition ensures that there is a matching right angle bracket for each left angle bracket.</span></span> <span data-ttu-id="bb994-253">Si no lo hay, el subpatrón final, `(?(Open)(?!))`, se evalúa solo si el grupo `Open` no está vacío (y, por consiguiente, si no se han cerrado todas las construcciones anidadas).</span><span class="sxs-lookup"><span data-stu-id="bb994-253">If there is not, the final subpattern, `(?(Open)(?!))`, is evaluated only if the `Open` group is not empty (and, therefore, if all nested constructs have not been closed).</span></span> <span data-ttu-id="bb994-254">Si se evalúa el subpatrón final, la coincidencia produce un error, porque el subpatrón `(?!)` es una aserción de búsqueda anticipada negativa de ancho cero que siempre produce un error.</span><span class="sxs-lookup"><span data-stu-id="bb994-254">If the final subpattern is evaluated, the match fails, because the `(?!)` subpattern is a zero-width negative lookahead assertion that always fails.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#3](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/grouping3.cs#3)]
 [!code-vb[RegularExpressions.Language.Grouping#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/grouping3.vb#3)]  
  
 <span data-ttu-id="bb994-255">El patrón de la expresión regular es:</span><span class="sxs-lookup"><span data-stu-id="bb994-255">The regular expression pattern is:</span></span>  
  
`^[^<>]*(((?'Open'<)[^<>]*)+((?'Close-Open'>)[^<>]*)+)*(?(Open)(?!))$`  
  
 <span data-ttu-id="bb994-256">La expresión regular se interpreta como sigue:</span><span class="sxs-lookup"><span data-stu-id="bb994-256">The regular expression is interpreted as follows:</span></span>  
  
|<span data-ttu-id="bb994-257">Modelo</span><span class="sxs-lookup"><span data-stu-id="bb994-257">Pattern</span></span>|<span data-ttu-id="bb994-258">Descripción</span><span class="sxs-lookup"><span data-stu-id="bb994-258">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="bb994-259">Comienza al principio de la cadena.</span><span class="sxs-lookup"><span data-stu-id="bb994-259">Begin at the start of the string.</span></span>|  
|`[^<>]*`|<span data-ttu-id="bb994-260">Coincide con cero o más caracteres que no son corchetes angulares de apertura o cierre.</span><span class="sxs-lookup"><span data-stu-id="bb994-260">Match zero or more characters that are not left or right angle brackets.</span></span>|  
|`(?'Open'<)`|<span data-ttu-id="bb994-261">Coincide con un corchete angular de apertura y se lo asigna a un grupo denominado `Open`.</span><span class="sxs-lookup"><span data-stu-id="bb994-261">Match a left angle bracket and assign it to a group named `Open`.</span></span>|  
|`[^<>]*`|<span data-ttu-id="bb994-262">Coincide con cero o más caracteres que no son corchetes angulares de apertura o cierre.</span><span class="sxs-lookup"><span data-stu-id="bb994-262">Match zero or more characters that are not left or right angle brackets.</span></span>|  
|`((?'Open'<)[^<>]*)+`|<span data-ttu-id="bb994-263">Coincide con una o más apariciones de un corchete angular de apertura seguido de cero o más caracteres que no son corchetes angulares de apertura o cierre.</span><span class="sxs-lookup"><span data-stu-id="bb994-263">Match one or more occurrences of a left angle bracket followed by zero or more characters that are not left or right angle brackets.</span></span> <span data-ttu-id="bb994-264">Este es el segundo grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="bb994-264">This is the second capturing group.</span></span>|  
|`(?'Close-Open'>)`|<span data-ttu-id="bb994-265">Coincide con un corchete angular de cierre, asigna la subcadena entre el grupo `Open` y el grupo actual al grupo `Close` y elimina la definición del grupo `Open` .</span><span class="sxs-lookup"><span data-stu-id="bb994-265">Match a right angle bracket, assign the substring between the `Open` group and the current group to the `Close` group, and delete the definition of the `Open` group.</span></span>|  
|`[^<>]*`|<span data-ttu-id="bb994-266">Coincide con cero o más apariciones de cualquier carácter que no sea un corchete angular de apertura ni de cierre.</span><span class="sxs-lookup"><span data-stu-id="bb994-266">Match zero or more occurrences of any character that is neither a left  nor a right angle bracket.</span></span>|  
|`((?'Close-Open'>)[^<>]*)+`|<span data-ttu-id="bb994-267">Coincide con una o más apariciones de un corchete angular de cierre, seguido de cero o más apariciones de cualquier carácter que no sea un corchete angular de apertura ni de cierre.</span><span class="sxs-lookup"><span data-stu-id="bb994-267">Match one or more occurrences of a right angle bracket, followed by zero or more occurrences of any character that is neither a left nor a right angle bracket.</span></span> <span data-ttu-id="bb994-268">Al buscar una coincidencia con el corchete angular de cierre, asigna la subcadena entre el grupo `Open` y el grupo actual al grupo `Close` , y elimina la definición del grupo `Open` .</span><span class="sxs-lookup"><span data-stu-id="bb994-268">When matching the right angle bracket, assign the substring between the `Open` group and the current group to the `Close` group, and delete the definition of the `Open` group.</span></span> <span data-ttu-id="bb994-269">Éste es el tercer grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="bb994-269">This is the third capturing group.</span></span>|  
|`(((?'Open'<)[^<>]*)+((?'Close-Open'>)[^<>]*)+)*`|<span data-ttu-id="bb994-270">Coincide con cero o más apariciones del patrón siguiente: una o varias apariciones de un corchete angular de apertura, seguidas de cero o más caracteres que no sean corchetes angulares, seguidas de una o más apariciones de un corchete angular de cierre, seguidas de cero o más apariciones de caracteres que no sean corchetes angulares.</span><span class="sxs-lookup"><span data-stu-id="bb994-270">Match zero or more occurrences of the following pattern: one or more occurrences of a left angle bracket, followed by zero or more non-angle bracket characters, followed by one or more occurrences of a right angle bracket, followed by zero or more occurrences of non-angle brackets.</span></span> <span data-ttu-id="bb994-271">Al buscar una coincidencia con el corchete angular de cierre, borra la definición del grupo `Open` y asigna la subcadena entre el grupo `Open` y el grupo actual al grupo `Close` .</span><span class="sxs-lookup"><span data-stu-id="bb994-271">When matching the right angle bracket, delete the definition of the `Open` group, and assign the substring between the `Open` group and the current group to the `Close` group.</span></span> <span data-ttu-id="bb994-272">Este es el primer grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="bb994-272">This is the first capturing group.</span></span>|  
|`(?(Open)(?!))`|<span data-ttu-id="bb994-273">Si existe el grupo `Open` , abandona la coincidencia si se encuentra una cadena vacía, pero no avanza la posición del motor de expresiones regulares en la cadena.</span><span class="sxs-lookup"><span data-stu-id="bb994-273">If the `Open` group exists, abandon the match if an empty string can be matched, but do not advance the position of the regular expression engine in the string.</span></span> <span data-ttu-id="bb994-274">Esta es una aserción de búsqueda anticipada negativa de ancho cero.</span><span class="sxs-lookup"><span data-stu-id="bb994-274">This is a zero-width negative lookahead assertion.</span></span> <span data-ttu-id="bb994-275">Dado que siempre existe implícitamente una cadena vacía en una cadena de entrada, esta coincidencia siempre produce un error.</span><span class="sxs-lookup"><span data-stu-id="bb994-275">Because an empty string is always implicitly present in an input string, this match always fails.</span></span> <span data-ttu-id="bb994-276">Un error en esta coincidencia indica que no hay el mismo número de corchetes angulares de apertura y de cierre.</span><span class="sxs-lookup"><span data-stu-id="bb994-276">Failure of this match indicates that the angle brackets are not balanced.</span></span>|  
|`$`|<span data-ttu-id="bb994-277">Coincide con el final de la cadena de entrada.</span><span class="sxs-lookup"><span data-stu-id="bb994-277">Match the end of the input string.</span></span>|  
  
 <span data-ttu-id="bb994-278">La subexpresión final, `(?(Open)(?!))`, indica si las construcciones de anidamiento de la cadena de entrada están compensadas correctamente (por ejemplo, si cada corchete angular de apertura coincide con un corchete angular de cierre).</span><span class="sxs-lookup"><span data-stu-id="bb994-278">The final subexpression, `(?(Open)(?!))`, indicates whether the nesting constructs in the input string are properly balanced (for example, whether each left angle bracket is matched by a right angle bracket).</span></span> <span data-ttu-id="bb994-279">Utiliza la coincidencia condicional basada en un grupo capturado válido; para más información, vea [Construcciones de alternancia](alternation-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="bb994-279">It uses conditional matching based on a valid captured group; for more information, see [Alternation Constructs](alternation-constructs-in-regular-expressions.md).</span></span> <span data-ttu-id="bb994-280">Si se define el grupo `Open` , el motor de expresiones regulares intenta buscar la subexpresión `(?!)` en la cadena de entrada.</span><span class="sxs-lookup"><span data-stu-id="bb994-280">If the `Open` group is defined, the regular expression engine attempts to match the subexpression `(?!)` in the input string.</span></span> <span data-ttu-id="bb994-281">El grupo `Open` solo se debería definir si las construcciones de anidamiento están descompensadas.</span><span class="sxs-lookup"><span data-stu-id="bb994-281">The `Open` group should be defined only if nesting constructs are unbalanced.</span></span> <span data-ttu-id="bb994-282">Por consiguiente, el patrón que se va a comparar en la cadena de entrada debe ser uno que siempre produzca un error en la coincidencia.</span><span class="sxs-lookup"><span data-stu-id="bb994-282">Therefore, the pattern to be matched in the input string should be one that always causes the match to fail.</span></span> <span data-ttu-id="bb994-283">En este caso, `(?!)` es una aserción de búsqueda anticipada negativa de ancho cero que siempre produce un error, porque siempre existe implícitamente una cadena vacía en la posición siguiente de la cadena de entrada.</span><span class="sxs-lookup"><span data-stu-id="bb994-283">In this case, `(?!)` is a zero-width negative lookahead assertion that always fails, because an empty string is always implicitly present at the next position in the input string.</span></span>  
  
 <span data-ttu-id="bb994-284">En el ejemplo, el motor de expresiones regulares evalúa la cadena de entrada "\<abc><mno\<xyz>>" como se muestra en la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="bb994-284">In the example, the regular expression engine evaluates the input string "\<abc><mno\<xyz>>" as shown in the following table.</span></span>  
  
|<span data-ttu-id="bb994-285">Paso</span><span class="sxs-lookup"><span data-stu-id="bb994-285">Step</span></span>|<span data-ttu-id="bb994-286">Modelo</span><span class="sxs-lookup"><span data-stu-id="bb994-286">Pattern</span></span>|<span data-ttu-id="bb994-287">Resultado</span><span class="sxs-lookup"><span data-stu-id="bb994-287">Result</span></span>|  
|----------|-------------|------------|  
|<span data-ttu-id="bb994-288">1</span><span class="sxs-lookup"><span data-stu-id="bb994-288">1</span></span>|`^`|<span data-ttu-id="bb994-289">Comienza la búsqueda de coincidencias al principio de la cadena de entrada</span><span class="sxs-lookup"><span data-stu-id="bb994-289">Starts the match at the beginning of the input string</span></span>|  
|<span data-ttu-id="bb994-290">2</span><span class="sxs-lookup"><span data-stu-id="bb994-290">2</span></span>|`[^<>]*`|<span data-ttu-id="bb994-291">Busca caracteres que no sean corchetes angulares antes del corchete angular de apertura; no encuentra ninguna coincidencia.</span><span class="sxs-lookup"><span data-stu-id="bb994-291">Looks for non-angle bracket characters before the left angle bracket;finds no matches.</span></span>|  
|<span data-ttu-id="bb994-292">3</span><span class="sxs-lookup"><span data-stu-id="bb994-292">3</span></span>|`(((?'Open'<)`|<span data-ttu-id="bb994-293">Encuentra el corchete angular de apertura de "\<abc>" y lo asigna al grupo `Open`.</span><span class="sxs-lookup"><span data-stu-id="bb994-293">Matches the left angle bracket in "\<abc>" and assigns it to the `Open` group.</span></span>|  
|<span data-ttu-id="bb994-294">4</span><span class="sxs-lookup"><span data-stu-id="bb994-294">4</span></span>|`[^<>]*`|<span data-ttu-id="bb994-295">Encuentra "abc".</span><span class="sxs-lookup"><span data-stu-id="bb994-295">Matches "abc".</span></span>|  
|<span data-ttu-id="bb994-296">5</span><span class="sxs-lookup"><span data-stu-id="bb994-296">5</span></span>|`)+`|<span data-ttu-id="bb994-297">"<abc" es el valor del segundo grupo capturado.</span><span class="sxs-lookup"><span data-stu-id="bb994-297">"<abc" is the value of the second captured group.</span></span><br /><br /> <span data-ttu-id="bb994-298">El carácter siguiente de la cadena de entrada no es un corchete angular de apertura, por lo que el motor de expresiones regulares no retrocede al subpatrón `(?'Open'<)[^<>]*)` .</span><span class="sxs-lookup"><span data-stu-id="bb994-298">The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the `(?'Open'<)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="bb994-299">6</span><span class="sxs-lookup"><span data-stu-id="bb994-299">6</span></span>|`((?'Close-Open'>)`|<span data-ttu-id="bb994-300">Encuentra el corchete angular de cierre de "\<abc>", asigna "abc", que es la subcadena entre el grupo `Open` y el corchete angular de cierre, al grupo `Close`, y elimina el valor actual ("<") del grupo `Open`, dejándolo vacío.</span><span class="sxs-lookup"><span data-stu-id="bb994-300">Matches the right angle bracket in "\<abc>", assigns "abc", which is the substring between the `Open` group and the right angle bracket, to the `Close` group, and deletes the current value ("<") of the `Open` group, leaving it empty.</span></span>|  
|<span data-ttu-id="bb994-301">7</span><span class="sxs-lookup"><span data-stu-id="bb994-301">7</span></span>|`[^<>]*`|<span data-ttu-id="bb994-302">Busca caracteres que no sean corchetes angulares después del corchete angular de cierre; no encuentra ninguna coincidencia.</span><span class="sxs-lookup"><span data-stu-id="bb994-302">Looks for non-angle bracket characters after the right angle bracket; finds no matches.</span></span>|  
|<span data-ttu-id="bb994-303">8</span><span class="sxs-lookup"><span data-stu-id="bb994-303">8</span></span>|`)+`|<span data-ttu-id="bb994-304">El valor del tercer grupo capturado es ">".</span><span class="sxs-lookup"><span data-stu-id="bb994-304">The value of the third captured group is ">".</span></span><br /><br /> <span data-ttu-id="bb994-305">El carácter siguiente de la cadena de entrada no es un corchete angular de cierre, por lo que el motor de expresiones regulares no retrocede al subpatrón `((?'Close-Open'>)[^<>]*)` .</span><span class="sxs-lookup"><span data-stu-id="bb994-305">The next character in the input string is not a right angle bracket, so the regular expression engine does not loop back to the `((?'Close-Open'>)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="bb994-306">9</span><span class="sxs-lookup"><span data-stu-id="bb994-306">9</span></span>|`)*`|<span data-ttu-id="bb994-307">El valor del primer grupo capturado es "\<abc>".</span><span class="sxs-lookup"><span data-stu-id="bb994-307">The value of the first captured group is "\<abc>".</span></span><br /><br /> <span data-ttu-id="bb994-308">El carácter siguiente de la cadena de entrada es un corchete angular de apertura, por lo que el motor de expresiones regulares retrocede al subpatrón `(((?'Open'<)` .</span><span class="sxs-lookup"><span data-stu-id="bb994-308">The next character in the input string is a left  angle bracket, so the regular expression engine loops back to the `(((?'Open'<)` subpattern.</span></span>|  
|<span data-ttu-id="bb994-309">10</span><span class="sxs-lookup"><span data-stu-id="bb994-309">10</span></span>|`(((?'Open'<)`|<span data-ttu-id="bb994-310">Encuentra el corchete angular de apertura de "\<mno" and assigns it to the `Open` group. Its <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> colección ahora tiene un valor único: "<".</span><span class="sxs-lookup"><span data-stu-id="bb994-310">Matches the left angle bracket in "\<mno" and assigns it to the `Open` group. Its <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> collection now has a single value, "<".</span></span>|  
|<span data-ttu-id="bb994-311">11</span><span class="sxs-lookup"><span data-stu-id="bb994-311">11</span></span>|`[^<>]*`|<span data-ttu-id="bb994-312">Encuentra "mno".</span><span class="sxs-lookup"><span data-stu-id="bb994-312">Matches "mno".</span></span>|  
|<span data-ttu-id="bb994-313">12</span><span class="sxs-lookup"><span data-stu-id="bb994-313">12</span></span>|`)+`|<span data-ttu-id="bb994-314">"<mno" es el valor del segundo grupo capturado.</span><span class="sxs-lookup"><span data-stu-id="bb994-314">"<mno" is the value of the second captured group.</span></span><br /><br /> <span data-ttu-id="bb994-315">El carácter siguiente de la cadena de entrada es un corchete angular de apertura, por lo que el motor de expresiones regulares retrocede al subpatrón `(?'Open'<)[^<>]*)` .</span><span class="sxs-lookup"><span data-stu-id="bb994-315">The next character in the input string is an left angle bracket, so the regular expression engine loops back to the `(?'Open'<)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="bb994-316">13</span><span class="sxs-lookup"><span data-stu-id="bb994-316">13</span></span>|`(((?'Open'<)`|<span data-ttu-id="bb994-317">Encuentra el corchete angular de apertura de "\<xyz>" y lo asigna al grupo `Open`.</span><span class="sxs-lookup"><span data-stu-id="bb994-317">Matches the left angle bracket in "\<xyz>" and assigns it to the `Open` group.</span></span> <span data-ttu-id="bb994-318">La colección <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> del grupo `Open` ahora incluye dos capturas: el corchete angular de apertura de "\<mno", and the left angle bracket from "\<xyz>".</span><span class="sxs-lookup"><span data-stu-id="bb994-318">The <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> collection of the `Open` group now includes two captures: the left angle bracket from "\<mno", and the left angle bracket from "\<xyz>".</span></span>|  
|<span data-ttu-id="bb994-319">14</span><span class="sxs-lookup"><span data-stu-id="bb994-319">14</span></span>|`[^<>]*`|<span data-ttu-id="bb994-320">Encuentra "xyz".</span><span class="sxs-lookup"><span data-stu-id="bb994-320">Matches "xyz".</span></span>|  
|<span data-ttu-id="bb994-321">15</span><span class="sxs-lookup"><span data-stu-id="bb994-321">15</span></span>|`)+`|<span data-ttu-id="bb994-322">"<xyz" es el valor del segundo grupo capturado.</span><span class="sxs-lookup"><span data-stu-id="bb994-322">"<xyz" is the value of the second captured group.</span></span><br /><br /> <span data-ttu-id="bb994-323">El carácter siguiente de la cadena de entrada no es un corchete angular de apertura, por lo que el motor de expresiones regulares no retrocede al subpatrón `(?'Open'<)[^<>]*)` .</span><span class="sxs-lookup"><span data-stu-id="bb994-323">The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the `(?'Open'<)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="bb994-324">16</span><span class="sxs-lookup"><span data-stu-id="bb994-324">16</span></span>|`((?'Close-Open'>)`|<span data-ttu-id="bb994-325">Encuentra el corchete angular de cierre de "\<xyz>".</span><span class="sxs-lookup"><span data-stu-id="bb994-325">Matches the right angle bracket in "\<xyz>".</span></span> <span data-ttu-id="bb994-326">"xyz", asigna la subcadena entre el grupo `Open` y el corchete angular de cierre al grupo `Close` , y elimina el valor actual del grupo `Open` .</span><span class="sxs-lookup"><span data-stu-id="bb994-326">"xyz", assigns the substring between the `Open` group and the right angle bracket to the `Close` group, and deletes the current value of the `Open` group.</span></span> <span data-ttu-id="bb994-327">El valor de la captura anterior (el corchete angular de apertura de "\<mno") becomes the current value of the `Open` group. The <xref:System.Text.RegularExpressions.Group.Captures%2A> colección del grupo `Open` ahora incluye una única captura, el corchete angular de apertura de "\<xyz>".</span><span class="sxs-lookup"><span data-stu-id="bb994-327">The value of the previous capture (the left angle bracket in "\<mno") becomes the current value of the `Open` group. The <xref:System.Text.RegularExpressions.Group.Captures%2A> collection of the `Open` group now includes a single capture, the left angle bracket from "\<xyz>".</span></span>|  
|<span data-ttu-id="bb994-328">17</span><span class="sxs-lookup"><span data-stu-id="bb994-328">17</span></span>|`[^<>]*`|<span data-ttu-id="bb994-329">Busca caracteres que no sean corchetes angulares; no encuentra ninguna coincidencia.</span><span class="sxs-lookup"><span data-stu-id="bb994-329">Looks for non-angle bracket characters; finds no matches.</span></span>|  
|<span data-ttu-id="bb994-330">18</span><span class="sxs-lookup"><span data-stu-id="bb994-330">18</span></span>|`)+`|<span data-ttu-id="bb994-331">El valor del tercer grupo capturado es ">".</span><span class="sxs-lookup"><span data-stu-id="bb994-331">The value of the third captured group is ">".</span></span><br /><br /> <span data-ttu-id="bb994-332">El carácter siguiente de la cadena de entrada es un corchete angular de cierre, por lo que el motor de expresiones regulares retrocede al subpatrón `((?'Close-Open'>)[^<>]*)` .</span><span class="sxs-lookup"><span data-stu-id="bb994-332">The next character in the input string is a right angle bracket, so the regular expression engine loops back to the `((?'Close-Open'>)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="bb994-333">19</span><span class="sxs-lookup"><span data-stu-id="bb994-333">19</span></span>|`((?'Close-Open'>)`|<span data-ttu-id="bb994-334">Encuentra el último corchete angular de cierre de "xyz>>", asigna "mno\<xyz>" (la subcadena entre el grupo `Open` y el corchete angular de cierre) al grupo `Close` y elimina el valor actual del grupo `Open`.</span><span class="sxs-lookup"><span data-stu-id="bb994-334">Matches the final right angle bracket in "xyz>>", assigns "mno\<xyz>" (the substring between the `Open` group and the right angle bracket) to the `Close` group, and deletes the current value of the `Open` group.</span></span> <span data-ttu-id="bb994-335">El grupo `Open` está ahora vacío.</span><span class="sxs-lookup"><span data-stu-id="bb994-335">The `Open` group is now empty.</span></span>|  
|<span data-ttu-id="bb994-336">20</span><span class="sxs-lookup"><span data-stu-id="bb994-336">20</span></span>|`[^<>]*`|<span data-ttu-id="bb994-337">Busca caracteres que no sean corchetes angulares; no encuentra ninguna coincidencia.</span><span class="sxs-lookup"><span data-stu-id="bb994-337">Looks for non-angle bracket characters; finds no matches.</span></span>|  
|<span data-ttu-id="bb994-338">21</span><span class="sxs-lookup"><span data-stu-id="bb994-338">21</span></span>|`)+`|<span data-ttu-id="bb994-339">El valor del tercer grupo capturado es ">".</span><span class="sxs-lookup"><span data-stu-id="bb994-339">The value of the third captured group is ">".</span></span><br /><br /> <span data-ttu-id="bb994-340">El carácter siguiente de la cadena de entrada no es un corchete angular de cierre, por lo que el motor de expresiones regulares no retrocede al subpatrón `((?'Close-Open'>)[^<>]*)` .</span><span class="sxs-lookup"><span data-stu-id="bb994-340">The next character in the input string is not a right angle bracket, so the regular expression engine does not loop back to the `((?'Close-Open'>)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="bb994-341">22</span><span class="sxs-lookup"><span data-stu-id="bb994-341">22</span></span>|`)*`|<span data-ttu-id="bb994-342">El valor del primer grupo capturado es "<mno\<xyz>>".</span><span class="sxs-lookup"><span data-stu-id="bb994-342">The value of the first captured group is "<mno\<xyz>>".</span></span><br /><br /> <span data-ttu-id="bb994-343">El carácter siguiente de la cadena de entrada no es un corchete angular de apertura, por lo que el motor de expresiones regulares no retrocede al subpatrón `(((?'Open'<)`.</span><span class="sxs-lookup"><span data-stu-id="bb994-343">The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the `(((?'Open'<)` subpattern.</span></span>|  
|<span data-ttu-id="bb994-344">23</span><span class="sxs-lookup"><span data-stu-id="bb994-344">23</span></span>|`(?(Open)(?!))`|<span data-ttu-id="bb994-345">El grupo `Open` no está definido, por lo que no se intenta encontrar ninguna coincidencia.</span><span class="sxs-lookup"><span data-stu-id="bb994-345">The `Open` group is not defined, so no match is attempted.</span></span>|  
|<span data-ttu-id="bb994-346">24</span><span class="sxs-lookup"><span data-stu-id="bb994-346">24</span></span>|`$`|<span data-ttu-id="bb994-347">Encuentra el final de la cadena de entrada.</span><span class="sxs-lookup"><span data-stu-id="bb994-347">Matches the end of the input string.</span></span>|  
  
<a name="noncapturing_group"></a>
## <a name="noncapturing-groups"></a><span data-ttu-id="bb994-348">Grupos sin captura</span><span class="sxs-lookup"><span data-stu-id="bb994-348">Noncapturing Groups</span></span>  
 <span data-ttu-id="bb994-349">La construcción de agrupamiento siguiente no captura la subcadena con la que coincide una subexpresión:</span><span class="sxs-lookup"><span data-stu-id="bb994-349">The following grouping construct does not capture the substring that is matched by a subexpression:</span></span>  
  
`(?:subexpression)`
  
 <span data-ttu-id="bb994-350">donde *subexpresión* es cualquier patrón de expresión regular válido.</span><span class="sxs-lookup"><span data-stu-id="bb994-350">where *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="bb994-351">La construcción de grupo sin captura se utiliza normalmente cuando un cuantificador se aplica a un grupo, pero las subcadenas capturadas por el grupo no tienen ningún interés.</span><span class="sxs-lookup"><span data-stu-id="bb994-351">The noncapturing group construct is typically used when a quantifier is applied to a group, but the substrings captured by the group are of no interest.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="bb994-352">Si una expresión regular incluye construcciones de agrupamiento anidadas, no se aplica una construcción de grupo sin captura exterior a las construcciones de grupo anidadas interiores.</span><span class="sxs-lookup"><span data-stu-id="bb994-352">If a regular expression includes nested grouping constructs, an outer noncapturing group construct does not apply to the inner nested group constructs.</span></span>  
  
 <span data-ttu-id="bb994-353">En el ejemplo siguiente se muestra una expresión regular que incluye grupos sin captura.</span><span class="sxs-lookup"><span data-stu-id="bb994-353">The following example illustrates a regular expression that includes noncapturing groups.</span></span> <span data-ttu-id="bb994-354">Observe que la salida no incluye ningún grupo capturado.</span><span class="sxs-lookup"><span data-stu-id="bb994-354">Note that the output does not include any captured groups.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#5](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/noncapture1.cs#5)]
 [!code-vb[RegularExpressions.Language.Grouping#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/noncapture1.vb#5)]  
  
 <span data-ttu-id="bb994-355">La expresión regular `(?:\b(?:\w+)\W*)+\.` coincide con una frase que termina en un punto.</span><span class="sxs-lookup"><span data-stu-id="bb994-355">The regular expression `(?:\b(?:\w+)\W*)+\.` matches a sentence that is terminated by a period.</span></span> <span data-ttu-id="bb994-356">Dado que la expresión regular se centra en frases y no en palabras individuales, las construcciones de agrupamiento se usan exclusivamente como cuantificadores.</span><span class="sxs-lookup"><span data-stu-id="bb994-356">Because the regular expression focuses on sentences and not on individual words, grouping constructs are used exclusively as quantifiers.</span></span> <span data-ttu-id="bb994-357">El patrón de la expresión regular se interpreta como se muestra en la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="bb994-357">The regular expression pattern is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="bb994-358">Modelo</span><span class="sxs-lookup"><span data-stu-id="bb994-358">Pattern</span></span>|<span data-ttu-id="bb994-359">Descripción</span><span class="sxs-lookup"><span data-stu-id="bb994-359">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="bb994-360">Iniciar la búsqueda de coincidencias en un límite de palabras.</span><span class="sxs-lookup"><span data-stu-id="bb994-360">Begin the match at a word boundary.</span></span>|  
|`(?:\w+)`|<span data-ttu-id="bb994-361">Buscar coincidencias con uno o más caracteres alfabéticos.</span><span class="sxs-lookup"><span data-stu-id="bb994-361">Match one or more word characters.</span></span> <span data-ttu-id="bb994-362">No asigna el texto coincidente a un grupo capturado.</span><span class="sxs-lookup"><span data-stu-id="bb994-362">Do not assign the matched text to a captured group.</span></span>|  
|`\W*`|<span data-ttu-id="bb994-363">Coincide con cero o más caracteres que no se usan para formar palabras.</span><span class="sxs-lookup"><span data-stu-id="bb994-363">Match zero or more non-word characters.</span></span>|  
|`(?:\b(?:\w+)\W*)+`|<span data-ttu-id="bb994-364">Coincide una o varias veces con el patrón de uno o varios caracteres que se usan para formar palabras comenzando por un límite de palabras, seguido de cero o más caracteres que no se usan para formar palabras.</span><span class="sxs-lookup"><span data-stu-id="bb994-364">Match the pattern of one or more word characters starting at a word boundary, followed by zero or more non-word characters, one or more times.</span></span> <span data-ttu-id="bb994-365">No asigna el texto coincidente a un grupo capturado.</span><span class="sxs-lookup"><span data-stu-id="bb994-365">Do not assign the matched text to a captured group.</span></span>|  
|`\.`|<span data-ttu-id="bb994-366">Coincide con un punto.</span><span class="sxs-lookup"><span data-stu-id="bb994-366">Match a period.</span></span>|  
  
<a name="group_options"></a>
## <a name="group-options"></a><span data-ttu-id="bb994-367">Opciones de grupo</span><span class="sxs-lookup"><span data-stu-id="bb994-367">Group Options</span></span>  
 <span data-ttu-id="bb994-368">La siguiente construcción de agrupamiento aplica o deshabilita las opciones especificadas dentro de una subexpresión:</span><span class="sxs-lookup"><span data-stu-id="bb994-368">The following grouping construct applies or disables the specified options within a subexpression:</span></span>  
  
 <span data-ttu-id="bb994-369">`(?imnsx-imnsx:` *subexpresión* `)`</span><span class="sxs-lookup"><span data-stu-id="bb994-369">`(?imnsx-imnsx:` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="bb994-370">donde *subexpresión* es cualquier patrón de expresión regular válido.</span><span class="sxs-lookup"><span data-stu-id="bb994-370">where *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="bb994-371">Por ejemplo, `(?i-s:)` activa la opción que no hace distinción entre mayúsculas y minúsculas y deshabilita el modo de una sola línea.</span><span class="sxs-lookup"><span data-stu-id="bb994-371">For example, `(?i-s:)` turns on case insensitivity and disables single-line mode.</span></span> <span data-ttu-id="bb994-372">Para obtener más información sobre las opciones insertadas que puede especificar, vea [Opciones de expresiones regulares](regular-expression-options.md).</span><span class="sxs-lookup"><span data-stu-id="bb994-372">For more information about the inline options you can specify, see [Regular Expression Options](regular-expression-options.md).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="bb994-373">Puede especificar opciones que se apliquen a una expresión regular completa en lugar de a una subexpresión usando un constructor de la clase <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> o un método estático.</span><span class="sxs-lookup"><span data-stu-id="bb994-373">You can specify options that apply to an entire regular expression rather than a subexpression by using a <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> class constructor or a static method.</span></span> <span data-ttu-id="bb994-374">También puede especificar opciones insertadas que se aplican después de un punto concreto en una expresión regular usando la construcción de lenguaje `(?imnsx-imnsx)` .</span><span class="sxs-lookup"><span data-stu-id="bb994-374">You can also specify inline options that apply after a specific point in a regular expression by using the `(?imnsx-imnsx)` language construct.</span></span>  
  
 <span data-ttu-id="bb994-375">La construcción de opciones de grupo no es un grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="bb994-375">The group options construct is not a capturing group.</span></span> <span data-ttu-id="bb994-376">Es decir, aunque cualquier parte de una cadena capturada por *subexpresión* se incluye en la coincidencia, no se incluye en un grupo capturado ni se usa para rellenar el objeto <xref:System.Text.RegularExpressions.GroupCollection> .</span><span class="sxs-lookup"><span data-stu-id="bb994-376">That is, although any portion of a string that is captured by *subexpression* is included in the match, it is not included in a captured group nor used to populate the <xref:System.Text.RegularExpressions.GroupCollection> object.</span></span>  
  
 <span data-ttu-id="bb994-377">Por ejemplo, la expresión regular `\b(?ix: d \w+)\s` del ejemplo siguiente utiliza opciones insertadas en una construcción de agrupamiento para habilitar la coincidencia sin distinción entre mayúsculas y minúsculas y omitir el espacio en blanco del patrón para identificar todas las palabras que comienzan por la letra "d".</span><span class="sxs-lookup"><span data-stu-id="bb994-377">For example, the regular expression `\b(?ix: d \w+)\s` in the following example uses inline options in a grouping construct to enable case-insensitive matching and ignore pattern white space in identifying all words that begin with the letter "d".</span></span> <span data-ttu-id="bb994-378">La expresión regular se define como se muestra en la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="bb994-378">The regular expression is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="bb994-379">Modelo</span><span class="sxs-lookup"><span data-stu-id="bb994-379">Pattern</span></span>|<span data-ttu-id="bb994-380">Descripción</span><span class="sxs-lookup"><span data-stu-id="bb994-380">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="bb994-381">Iniciar la búsqueda de coincidencias en un límite de palabras.</span><span class="sxs-lookup"><span data-stu-id="bb994-381">Begin the match at a word boundary.</span></span>|  
|`(?ix: d \w+)`|<span data-ttu-id="bb994-382">Usando una coincidencia sin distinción entre mayúsculas y minúsculas y omitiendo los espacios en blanco en este patrón, busca una "d" seguida de uno o varios caracteres que se usan para formar palabras.</span><span class="sxs-lookup"><span data-stu-id="bb994-382">Using case-insensitive matching and ignoring white space in this pattern, match a "d" followed by one or more word characters.</span></span>|  
|`\s`|<span data-ttu-id="bb994-383">Coincide con un carácter de espacio en blanco.</span><span class="sxs-lookup"><span data-stu-id="bb994-383">Match a white-space character.</span></span>|  
  
 [!code-csharp[Conceptual.Regex.Language.Options#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/example1.cs#8)]
 [!code-vb[Conceptual.Regex.Language.Options#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/example1.vb#8)]  
  
<a name="zerowidth_positive_lookahead_assertion"></a>
## <a name="zero-width-positive-lookahead-assertions"></a><span data-ttu-id="bb994-384">Aserciones de búsqueda anticipada positiva de ancho cero</span><span class="sxs-lookup"><span data-stu-id="bb994-384">Zero-Width Positive Lookahead Assertions</span></span>  
 <span data-ttu-id="bb994-385">La construcción de agrupamiento siguiente define una aserción de búsqueda anticipada positiva de ancho cero:</span><span class="sxs-lookup"><span data-stu-id="bb994-385">The following grouping construct defines a zero-width positive lookahead assertion:</span></span>  
  
 <span data-ttu-id="bb994-386">`(?=` *subexpresión* `)`</span><span class="sxs-lookup"><span data-stu-id="bb994-386">`(?=` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="bb994-387">donde *subexpresión* es cualquier patrón de expresión regular.</span><span class="sxs-lookup"><span data-stu-id="bb994-387">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="bb994-388">Para que se produzca una coincidencia, la cadena de entrada debe coincidir con el patrón de expresión regular de *subexpresión*, aunque la subcadena coincidente no se incluya en el resultado de la coincidencia.</span><span class="sxs-lookup"><span data-stu-id="bb994-388">For a match to be successful, the input string must match the regular expression pattern in *subexpression*, although the matched substring is not included in the match result.</span></span> <span data-ttu-id="bb994-389">Una aserción de búsqueda anticipada positiva de ancho cero no retrocede.</span><span class="sxs-lookup"><span data-stu-id="bb994-389">A zero-width positive lookahead assertion does not backtrack.</span></span>  
  
 <span data-ttu-id="bb994-390">Normalmente, una aserción de búsqueda anticipada positiva de ancho cero se encuentra al final de un patrón de expresión regular.</span><span class="sxs-lookup"><span data-stu-id="bb994-390">Typically, a zero-width positive lookahead assertion is found at the end of a regular expression pattern.</span></span> <span data-ttu-id="bb994-391">Define una subcadena que se debe encontrar al final de una cadena para que se produzca una coincidencia, pero que no debe incluirse en la coincidencia.</span><span class="sxs-lookup"><span data-stu-id="bb994-391">It defines a substring that must be found at the end of a string for a match to occur but that should not be included in the match.</span></span> <span data-ttu-id="bb994-392">También resulta útil para evitar un retroceso excesivo.</span><span class="sxs-lookup"><span data-stu-id="bb994-392">It is also useful for preventing excessive backtracking.</span></span> <span data-ttu-id="bb994-393">Puede usar una aserción de búsqueda anticipada positiva de ancho cero para asegurarse de que un grupo capturado determinado comienza por un texto que coincide con un subconjunto del patrón definido para dicho grupo capturado.</span><span class="sxs-lookup"><span data-stu-id="bb994-393">You can use a zero-width positive lookahead assertion to ensure that a particular captured group begins with text that matches a subset of the pattern defined for that captured group.</span></span> <span data-ttu-id="bb994-394">Por ejemplo, si un grupo de captura coincide con caracteres consecutivos que se usan para formar palabras, puede usar una aserción de búsqueda anticipada positiva de ancho cero para requerir que el primero de los caracteres sea alfabético y esté en mayúsculas.</span><span class="sxs-lookup"><span data-stu-id="bb994-394">For example, if a capturing group matches consecutive word characters, you can use a zero-width positive lookahead assertion to require that the first character be an alphabetical uppercase character.</span></span>  
  
 <span data-ttu-id="bb994-395">En el ejemplo siguiente se usa una aserción de búsqueda anticipada positiva de ancho cero para buscar la palabra que precede al verbo "is" en la cadena de entrada.</span><span class="sxs-lookup"><span data-stu-id="bb994-395">The following example uses a zero-width positive lookahead assertion to match the word that precedes the verb "is" in the input string.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#6](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/lookahead1.cs#6)]
 [!code-vb[RegularExpressions.Language.Grouping#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/lookahead1.vb#6)]  
  
 <span data-ttu-id="bb994-396">La expresión regular `\b\w+(?=\sis\b)` se interpreta como se muestra en la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="bb994-396">The regular expression `\b\w+(?=\sis\b)` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="bb994-397">Modelo</span><span class="sxs-lookup"><span data-stu-id="bb994-397">Pattern</span></span>|<span data-ttu-id="bb994-398">Descripción</span><span class="sxs-lookup"><span data-stu-id="bb994-398">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="bb994-399">Iniciar la búsqueda de coincidencias en un límite de palabras.</span><span class="sxs-lookup"><span data-stu-id="bb994-399">Begin the match at a word boundary.</span></span>|  
|`\w+`|<span data-ttu-id="bb994-400">Buscar coincidencias con uno o más caracteres alfabéticos.</span><span class="sxs-lookup"><span data-stu-id="bb994-400">Match one or more word characters.</span></span>|  
|`(?=\sis\b)`|<span data-ttu-id="bb994-401">Determina si los caracteres que se usan para formar palabras van seguidos de un carácter de espacio en blanco y la cadena "is", seguida de un límite de palabras.</span><span class="sxs-lookup"><span data-stu-id="bb994-401">Determine whether the word characters are followed by a white-space character and the string "is", which ends on a word boundary.</span></span> <span data-ttu-id="bb994-402">En ese caso, la coincidencia es correcta.</span><span class="sxs-lookup"><span data-stu-id="bb994-402">If so, the match is successful.</span></span>|  
  
<a name="zerowidth_negative_lookahead_assertion"></a>
## <a name="zero-width-negative-lookahead-assertions"></a><span data-ttu-id="bb994-403">Aserciones de búsqueda anticipada negativa de ancho cero</span><span class="sxs-lookup"><span data-stu-id="bb994-403">Zero-Width Negative Lookahead Assertions</span></span>  
 <span data-ttu-id="bb994-404">La construcción de agrupamiento siguiente define una aserción de búsqueda anticipada negativa de ancho cero:</span><span class="sxs-lookup"><span data-stu-id="bb994-404">The following grouping construct defines a zero-width negative lookahead assertion:</span></span>  
  
 <span data-ttu-id="bb994-405">`(?!` *subexpresión* `)`</span><span class="sxs-lookup"><span data-stu-id="bb994-405">`(?!` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="bb994-406">donde *subexpresión* es cualquier patrón de expresión regular.</span><span class="sxs-lookup"><span data-stu-id="bb994-406">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="bb994-407">Para que se produzca la coincidencia, la cadena de entrada no debe coincidir con el patrón de expresión regular de *subexpresión*, aunque la cadena coincidente no se incluya en el resultado de la coincidencia.</span><span class="sxs-lookup"><span data-stu-id="bb994-407">For the match to be successful, the input string must not match the regular expression pattern in *subexpression*, although the matched string is not included in the match result.</span></span>  
  
 <span data-ttu-id="bb994-408">Una aserción de búsqueda anticipada negativa de ancho cero se utiliza normalmente al principio o al final de una expresión regular.</span><span class="sxs-lookup"><span data-stu-id="bb994-408">A zero-width negative lookahead assertion is typically used either at the beginning or at the end of a regular expression.</span></span> <span data-ttu-id="bb994-409">Al principio de una expresión regular, puede definir un patrón concreto que no se debería buscar cuando el principio de la expresión regular define un patrón similar pero más general que se desea buscar.</span><span class="sxs-lookup"><span data-stu-id="bb994-409">At the beginning of a regular expression, it can define a specific pattern that should not be matched when the beginning of the regular expression defines a similar but more general pattern to be matched.</span></span> <span data-ttu-id="bb994-410">En este caso, se usa a menudo para limitar el retroceso.</span><span class="sxs-lookup"><span data-stu-id="bb994-410">In this case, it is often used to limit backtracking.</span></span> <span data-ttu-id="bb994-411">Al final de una expresión regular, puede definir una subexpresión que no se puede producir al final de una coincidencia.</span><span class="sxs-lookup"><span data-stu-id="bb994-411">At the end of a regular expression, it can define a subexpression that cannot occur at the end of a match.</span></span>  
  
 <span data-ttu-id="bb994-412">En el ejemplo siguiente se define una expresión regular que utiliza una aserción de búsqueda anticipada negativa de ancho cero al principio de la expresión regular para buscar palabras que no comienzan por "un".</span><span class="sxs-lookup"><span data-stu-id="bb994-412">The following example defines a regular expression that uses a zero-width lookahead assertion at the beginning of the regular expression to match words that do not begin with "un".</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#7](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/negativelookahead1.cs#7)]
 [!code-vb[RegularExpressions.Language.Grouping#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/negativelookahead1.vb#7)]  
  
 <span data-ttu-id="bb994-413">La expresión regular `\b(?!un)\w+\b` se interpreta como se muestra en la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="bb994-413">The regular expression `\b(?!un)\w+\b` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="bb994-414">Modelo</span><span class="sxs-lookup"><span data-stu-id="bb994-414">Pattern</span></span>|<span data-ttu-id="bb994-415">Descripción</span><span class="sxs-lookup"><span data-stu-id="bb994-415">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="bb994-416">Iniciar la búsqueda de coincidencias en un límite de palabras.</span><span class="sxs-lookup"><span data-stu-id="bb994-416">Begin the match at a word boundary.</span></span>|  
|`(?!un)`|<span data-ttu-id="bb994-417">Determina si los dos caracteres siguientes son "un".</span><span class="sxs-lookup"><span data-stu-id="bb994-417">Determine whether the next two characters are "un".</span></span> <span data-ttu-id="bb994-418">Si no lo son, es posible una coincidencia.</span><span class="sxs-lookup"><span data-stu-id="bb994-418">If they are not, a match is possible.</span></span>|  
|`\w+`|<span data-ttu-id="bb994-419">Buscar coincidencias con uno o más caracteres alfabéticos.</span><span class="sxs-lookup"><span data-stu-id="bb994-419">Match one or more word characters.</span></span>|  
|`\b`|<span data-ttu-id="bb994-420">Finalizar la búsqueda de coincidencias en un límite de palabras.</span><span class="sxs-lookup"><span data-stu-id="bb994-420">End the match at a word boundary.</span></span>|  
  
 <span data-ttu-id="bb994-421">En el ejemplo siguiente se define una expresión regular que utiliza una aserción de búsqueda anticipada negativa de ancho cero al final de la expresión regular para buscar palabras que no terminan por un carácter de puntuación.</span><span class="sxs-lookup"><span data-stu-id="bb994-421">The following example defines a regular expression that uses a zero-width lookahead assertion at the end of the regular expression to match words that do not end with a punctuation character.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#8](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/negativelookahead2.cs#8)]
 [!code-vb[RegularExpressions.Language.Grouping#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/negativelookahead2.vb#8)]  
  
 <span data-ttu-id="bb994-422">La expresión regular `\b\w+\b(?!\p{P})` se interpreta como se muestra en la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="bb994-422">The regular expression `\b\w+\b(?!\p{P})` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="bb994-423">Modelo</span><span class="sxs-lookup"><span data-stu-id="bb994-423">Pattern</span></span>|<span data-ttu-id="bb994-424">Descripción</span><span class="sxs-lookup"><span data-stu-id="bb994-424">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="bb994-425">Iniciar la búsqueda de coincidencias en un límite de palabras.</span><span class="sxs-lookup"><span data-stu-id="bb994-425">Begin the match at a word boundary.</span></span>|  
|`\w+`|<span data-ttu-id="bb994-426">Buscar coincidencias con uno o más caracteres alfabéticos.</span><span class="sxs-lookup"><span data-stu-id="bb994-426">Match one or more word characters.</span></span>|  
|`\b`|<span data-ttu-id="bb994-427">Finalizar la búsqueda de coincidencias en un límite de palabras.</span><span class="sxs-lookup"><span data-stu-id="bb994-427">End the match at a word boundary.</span></span>|  
|`\p{P})`|<span data-ttu-id="bb994-428">Si el carácter siguiente no es un signo de puntuación (como un punto o una coma), la coincidencia se realiza.</span><span class="sxs-lookup"><span data-stu-id="bb994-428">If the next character is not a punctuation symbol (such as a period or a comma), the match succeeds.</span></span>|  
  
<a name="zerowidth_positive_lookbehind_assertion"></a>
## <a name="zero-width-positive-lookbehind-assertions"></a><span data-ttu-id="bb994-429">Aserciones de búsqueda tardía positiva de ancho cero</span><span class="sxs-lookup"><span data-stu-id="bb994-429">Zero-Width Positive Lookbehind Assertions</span></span>  
 <span data-ttu-id="bb994-430">La construcción de agrupamiento siguiente define una aserción de búsqueda tardía positiva de ancho cero:</span><span class="sxs-lookup"><span data-stu-id="bb994-430">The following grouping construct defines a zero-width positive lookbehind assertion:</span></span>  
  
 <span data-ttu-id="bb994-431">`(?<=` *subexpresión* `)`</span><span class="sxs-lookup"><span data-stu-id="bb994-431">`(?<=` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="bb994-432">donde *subexpresión* es cualquier patrón de expresión regular.</span><span class="sxs-lookup"><span data-stu-id="bb994-432">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="bb994-433">Para que se produzca una coincidencia, *subexpresión* debe encontrarse en la cadena de entrada a la izquierda de la posición actual, aunque `subexpression` no esté incluida en el resultado de la coincidencia.</span><span class="sxs-lookup"><span data-stu-id="bb994-433">For a match to be successful, *subexpression* must occur at the input string to the left of the current position, although `subexpression` is not included in the match result.</span></span> <span data-ttu-id="bb994-434">Una aserción de búsqueda tardía positiva de ancho cero no retrocede.</span><span class="sxs-lookup"><span data-stu-id="bb994-434">A zero-width positive lookbehind assertion does not backtrack.</span></span>  
  
 <span data-ttu-id="bb994-435">Las aserciones de búsqueda tardía positiva de ancho cero se usan normalmente al principio de las expresiones regulares.</span><span class="sxs-lookup"><span data-stu-id="bb994-435">Zero-width positive lookbehind assertions are typically used at the beginning of regular expressions.</span></span> <span data-ttu-id="bb994-436">El patrón que definen es una condición previa de una coincidencia, aunque no forma parte del resultado de la coincidencia.</span><span class="sxs-lookup"><span data-stu-id="bb994-436">The pattern that they define is a precondition for a match, although it is not a part of the match result.</span></span>  
  
 <span data-ttu-id="bb994-437">Por ejemplo, el ejemplo siguiente coincide con los dos últimos dígitos del año para el siglo XXI (es decir, requiere que los dígitos "20" precedan a la cadena coincidente).</span><span class="sxs-lookup"><span data-stu-id="bb994-437">For example, the following example matches the last two digits of the year for the twenty first century (that is, it requires that the digits "20" precede the matched string).</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#9](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/lookbehind1.cs#9)]
 [!code-vb[RegularExpressions.Language.Grouping#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/lookbehind1.vb#9)]  
  
 <span data-ttu-id="bb994-438">El patrón de la expresión regular `(?<=\b20)\d{2}\b` se interpreta como se muestra en la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="bb994-438">The regular expression pattern `(?<=\b20)\d{2}\b` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="bb994-439">Modelo</span><span class="sxs-lookup"><span data-stu-id="bb994-439">Pattern</span></span>|<span data-ttu-id="bb994-440">Descripción</span><span class="sxs-lookup"><span data-stu-id="bb994-440">Description</span></span>|  
|-------------|-----------------|  
|`\d{2}`|<span data-ttu-id="bb994-441">Coincide con dos dígitos decimales.</span><span class="sxs-lookup"><span data-stu-id="bb994-441">Match two decimal digits.</span></span>|  
|`(?<=\b20)`|<span data-ttu-id="bb994-442">Continúa la búsqueda si los dos dígitos decimales van precedidos de los dos dígitos decimales "20" en un límite de palabra.</span><span class="sxs-lookup"><span data-stu-id="bb994-442">Continue the match if the two decimal digits are preceded by the decimal digits "20" on a word boundary.</span></span>|  
|`\b`|<span data-ttu-id="bb994-443">Finalizar la búsqueda de coincidencias en un límite de palabras.</span><span class="sxs-lookup"><span data-stu-id="bb994-443">End the match at a word boundary.</span></span>|  
  
 <span data-ttu-id="bb994-444">Las aserciones de búsqueda tardía positiva de ancho cero también se usan para limitar el retroceso cuando el último carácter o caracteres de un grupo capturado debe ser un subconjunto de los caracteres que coincide con el patrón de la expresión regular de dicho grupo.</span><span class="sxs-lookup"><span data-stu-id="bb994-444">Zero-width positive lookbehind assertions are also used to limit backtracking when the last character or characters in a captured group must be a subset of the characters that match that group's regular expression pattern.</span></span> <span data-ttu-id="bb994-445">Por ejemplo, si un grupo captura todos los caracteres que se usan para formar palabras consecutivos, puede usar una aserción de búsqueda tardía positiva de ancho cero para requerir que el último carácter sea alfabético.</span><span class="sxs-lookup"><span data-stu-id="bb994-445">For example, if a group captures all consecutive word characters, you can use a zero-width positive lookbehind assertion to require that the last character be alphabetical.</span></span>  
  
<a name="zerowidth_negative_lookbehind_assertion"></a>
## <a name="zero-width-negative-lookbehind-assertions"></a><span data-ttu-id="bb994-446">Aserciones de búsqueda tardía negativa de ancho cero</span><span class="sxs-lookup"><span data-stu-id="bb994-446">Zero-Width Negative Lookbehind Assertions</span></span>  
 <span data-ttu-id="bb994-447">La construcción de agrupamiento siguiente define una aserción de búsqueda tardía negativa de ancho cero:</span><span class="sxs-lookup"><span data-stu-id="bb994-447">The following grouping construct defines a zero-width negative lookbehind assertion:</span></span>  
  
 <span data-ttu-id="bb994-448">`(?<!` *subexpresión* `)`</span><span class="sxs-lookup"><span data-stu-id="bb994-448">`(?<!` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="bb994-449">donde *subexpresión* es cualquier patrón de expresión regular.</span><span class="sxs-lookup"><span data-stu-id="bb994-449">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="bb994-450">Para que se produzca una coincidencia, *subexpresión* no debe encontrarse en la cadena de entrada a la izquierda de la posición actual.</span><span class="sxs-lookup"><span data-stu-id="bb994-450">For a match to be successful, *subexpression* must not occur at the input string to the left of the current position.</span></span> <span data-ttu-id="bb994-451">Sin embargo, cualquier subcadena que no coincida con `subexpression` no se incluye en el resultado de la coincidencia.</span><span class="sxs-lookup"><span data-stu-id="bb994-451">However, any substring that does not match `subexpression` is not included in the match result.</span></span>  
  
 <span data-ttu-id="bb994-452">Las aserciones de búsqueda tardía negativa de ancho cero se usan normalmente al principio de las expresiones regulares.</span><span class="sxs-lookup"><span data-stu-id="bb994-452">Zero-width negative lookbehind assertions are typically used at the beginning of regular expressions.</span></span> <span data-ttu-id="bb994-453">El patrón que definen impide una coincidencia en la cadena que sigue.</span><span class="sxs-lookup"><span data-stu-id="bb994-453">The pattern that they define precludes a match in the string that follows.</span></span> <span data-ttu-id="bb994-454">También se usan para limitar el retroceso cuando el último carácter o caracteres de un grupo capturado no debe ser uno o varios de los caracteres que coinciden con el patrón de expresión regular de dicho grupo.</span><span class="sxs-lookup"><span data-stu-id="bb994-454">They are also used to limit backtracking when the last character or characters in a captured group must not be one or more of the characters that match that group's regular expression pattern.</span></span> <span data-ttu-id="bb994-455">Por ejemplo, si un grupo captura todos los caracteres que se usan para formar palabras consecutivos, se puede usar una aserción de búsqueda tardía positiva de ancho cero para requerir que el último carácter no sea de subrayado (\_).</span><span class="sxs-lookup"><span data-stu-id="bb994-455">For example, if a group captures all consecutive word characters, you can use a zero-width positive lookbehind assertion to require that the last character not be an underscore (\_).</span></span>  
  
 <span data-ttu-id="bb994-456">El ejemplo siguiente busca la fecha de cualquier día de la semana que no sea fin de semana (es decir, que no sea ni sábado ni domingo).</span><span class="sxs-lookup"><span data-stu-id="bb994-456">The following example matches the date for any day of the week that is not a weekend (that is, that is neither Saturday nor Sunday).</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#10](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/negativelookbehind1.cs#10)]
 [!code-vb[RegularExpressions.Language.Grouping#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/negativelookbehind1.vb#10)]  
  
 <span data-ttu-id="bb994-457">El patrón de la expresión regular `(?<!(Saturday|Sunday) )\b\w+ \d{1,2}, \d{4}\b` se interpreta como se muestra en la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="bb994-457">The regular expression pattern `(?<!(Saturday|Sunday) )\b\w+ \d{1,2}, \d{4}\b` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="bb994-458">Modelo</span><span class="sxs-lookup"><span data-stu-id="bb994-458">Pattern</span></span>|<span data-ttu-id="bb994-459">Descripción</span><span class="sxs-lookup"><span data-stu-id="bb994-459">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="bb994-460">Iniciar la búsqueda de coincidencias en un límite de palabras.</span><span class="sxs-lookup"><span data-stu-id="bb994-460">Begin the match at a word boundary.</span></span>|  
|`\w+`|<span data-ttu-id="bb994-461">Coincide con uno o varios caracteres que se usan para formar palabras seguidos de un carácter de espacio en blanco.</span><span class="sxs-lookup"><span data-stu-id="bb994-461">Match one or more word characters followed by a white-space character.</span></span>|  
|`\d{1,2},`|<span data-ttu-id="bb994-462">Coincide con uno o dos dígitos decimales seguidos de un carácter de espacio en blanco y una coma.</span><span class="sxs-lookup"><span data-stu-id="bb994-462">Match either one or two decimal digits followed by a white-space character and a comma.</span></span>|  
|`\d{4}\b`|<span data-ttu-id="bb994-463">Coincide con cuatro dígitos decimales seguidos de un límite de palabras.</span><span class="sxs-lookup"><span data-stu-id="bb994-463">Match four decimal digits, and end the match at a word boundary.</span></span>|  
|<code>(?<!(Saturday&#124;Sunday) )</code>|<span data-ttu-id="bb994-464">Si la coincidencia va precedida por algo distinto de las cadenas "Saturday" o "Sunday" seguidas de un espacio, la coincidencia es correcta.</span><span class="sxs-lookup"><span data-stu-id="bb994-464">If the match is preceded by something other than the strings "Saturday" or "Sunday" followed by a space, the match is successful.</span></span>|  
  
<a name="atomic_groups"></a>
## <a name="atomic-groups"></a><span data-ttu-id="bb994-465">Grupos atómicos</span><span class="sxs-lookup"><span data-stu-id="bb994-465">Atomic groups</span></span>  
 <span data-ttu-id="bb994-466">La construcción de agrupamiento siguiente representa un grupo atómico (conocido en otros motores de expresiones regulares como subexpresión sin retroceso, subexpresión atómica o subexpresión de una sola vez):</span><span class="sxs-lookup"><span data-stu-id="bb994-466">The following grouping construct represents an atomic group (known in some other regular expression engines as a nonbacktracking subexpression, an atomic subexpression, or a once-only subexpression):</span></span>
  
 <span data-ttu-id="bb994-467">`(?>` *subexpresión* `)`</span><span class="sxs-lookup"><span data-stu-id="bb994-467">`(?>` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="bb994-468">donde *subexpresión* es cualquier patrón de expresión regular.</span><span class="sxs-lookup"><span data-stu-id="bb994-468">where *subexpression* is any regular expression pattern.</span></span>  
  
 <span data-ttu-id="bb994-469">Comúnmente, si una expresión regular incluye un patrón de coincidencia opcional o alternativo y no se produce una coincidencia, el motor de expresiones regulares puede crear una bifurcación en varias direcciones para buscar coincidencias de una cadena de entrada con un patrón.</span><span class="sxs-lookup"><span data-stu-id="bb994-469">Ordinarily, if a regular expression includes an optional or alternative matching pattern and a match does not succeed, the regular expression engine can branch in multiple directions to match an input string with a pattern.</span></span> <span data-ttu-id="bb994-470">Si no se encuentra una coincidencia cuando toma la primera bifurcación, el motor de expresiones regulares puede regresar o retroceder al punto donde tomó la primera bifurcación e intentar la coincidencia usando la segunda bifurcación.</span><span class="sxs-lookup"><span data-stu-id="bb994-470">If a match is not found when it takes the first branch, the regular expression engine can back up or backtrack to the point where it took the first match and attempt the match using the second branch.</span></span> <span data-ttu-id="bb994-471">Este proceso puede continuar hasta que se hayan probado todas las bifurcaciones.</span><span class="sxs-lookup"><span data-stu-id="bb994-471">This process can continue until all branches have been tried.</span></span>  
  
 <span data-ttu-id="bb994-472">El grupo `(?>`*subexpresión*`)` deshabilita el retroceso.</span><span class="sxs-lookup"><span data-stu-id="bb994-472">The `(?>`*subexpression*`)` language construct disables backtracking.</span></span> <span data-ttu-id="bb994-473">El motor de expresiones regulares buscará coincidencias con tantos caracteres de la cadena de entrada como pueda.</span><span class="sxs-lookup"><span data-stu-id="bb994-473">The regular expression engine will match as many characters in the input string as it can.</span></span> <span data-ttu-id="bb994-474">Cuando ya no sean posibles más coincidencias, no retrocederá para intentar coincidencias con patrones alternativos.</span><span class="sxs-lookup"><span data-stu-id="bb994-474">When no further match is possible, it will not backtrack to attempt alternate pattern matches.</span></span> <span data-ttu-id="bb994-475">(Es decir, la subexpresión solo busca cadenas que coincidan exclusivamente con la subexpresión; no intenta buscar una cadena basándose en la subexpresión y en cualquier subexpresión que la siga).</span><span class="sxs-lookup"><span data-stu-id="bb994-475">(That is, the subexpression matches only strings that would be matched by the subexpression alone; it does not attempt to match a string based on the subexpression and any subexpressions that follow it.)</span></span>  
  
 <span data-ttu-id="bb994-476">Se recomienda usar esta opción si se sabe que el retroceso no tendrá éxito.</span><span class="sxs-lookup"><span data-stu-id="bb994-476">This option is recommended if you know that backtracking will not succeed.</span></span> <span data-ttu-id="bb994-477">Si se evita que el motor de expresiones regulares realice búsquedas innecesarias, se mejora el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="bb994-477">Preventing the regular expression engine from performing unnecessary searching improves performance.</span></span>  
  
 <span data-ttu-id="bb994-478">En el ejemplo siguiente se muestra cómo un grupo atómico modifica los resultados de una coincidencia de patrones.</span><span class="sxs-lookup"><span data-stu-id="bb994-478">The following example illustrates how an atomic group modifies the results of a pattern match.</span></span> <span data-ttu-id="bb994-479">La expresión regular con retroceso coincide correctamente con una serie de caracteres repetidos seguidos de una o varias apariciones del mismo carácter en un límite de palabras, pero la expresión regular sin retroceso no lo hace.</span><span class="sxs-lookup"><span data-stu-id="bb994-479">The backtracking regular expression successfully matches a series of repeated characters followed by one more occurrence of the same character on a word boundary, but the nonbacktracking regular expression does not.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#11](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/nonbacktracking1.cs#11)]
 [!code-vb[RegularExpressions.Language.Grouping#11](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/nonbacktracking1.vb#11)]  
  
 <span data-ttu-id="bb994-480">La expresión regular sin retroceso `(?>(\w)\1+).\b` se define como se muestra en la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="bb994-480">The nonbacktracking regular expression `(?>(\w)\1+).\b` is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="bb994-481">Modelo</span><span class="sxs-lookup"><span data-stu-id="bb994-481">Pattern</span></span>|<span data-ttu-id="bb994-482">Descripción</span><span class="sxs-lookup"><span data-stu-id="bb994-482">Description</span></span>|  
|-------------|-----------------|  
|`(\w)`|<span data-ttu-id="bb994-483">Coincide con un único carácter que se usa para formar palabras y se lo asigna al primer grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="bb994-483">Match a single word character and assign it to the first capturing group.</span></span>|  
|`\1+`|<span data-ttu-id="bb994-484">Coincide con el valor de la primera subcadena capturada una o varias veces.</span><span class="sxs-lookup"><span data-stu-id="bb994-484">Match the value of the first captured substring one or more times.</span></span>|  
|`.`|<span data-ttu-id="bb994-485">Coincide con cualquier carácter.</span><span class="sxs-lookup"><span data-stu-id="bb994-485">Match any character.</span></span>|  
|`\b`|<span data-ttu-id="bb994-486">Finalizar la búsqueda de coincidencias en un límite de palabras.</span><span class="sxs-lookup"><span data-stu-id="bb994-486">End the match on a word boundary.</span></span>|  
|`(?>(\w)\1+)`|<span data-ttu-id="bb994-487">Coincide con una o varias apariciones de un carácter que se usa para formar palabras duplicado, pero no retrocede para buscar el último carácter de un límite de palabras.</span><span class="sxs-lookup"><span data-stu-id="bb994-487">Match one or more occurrences of a duplicated word character, but do not backtrack to match the last character on a word boundary.</span></span>|  
  
<a name="Objects"></a>
## <a name="grouping-constructs-and-regular-expression-objects"></a><span data-ttu-id="bb994-488">Construcciones de agrupamiento y objetos de las expresiones regulares</span><span class="sxs-lookup"><span data-stu-id="bb994-488">Grouping Constructs and Regular Expression Objects</span></span>  
 <span data-ttu-id="bb994-489">Las subcadenas con las que coincide un grupo de captura de una expresión regular se representan mediante objetos <xref:System.Text.RegularExpressions.Group?displayProperty=nameWithType> , que se pueden recuperar del objeto <xref:System.Text.RegularExpressions.GroupCollection?displayProperty=nameWithType> que devuelve la propiedad <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="bb994-489">Substrings that are matched by a regular expression capturing group are represented by <xref:System.Text.RegularExpressions.Group?displayProperty=nameWithType> objects, which can be retrieved from the <xref:System.Text.RegularExpressions.GroupCollection?displayProperty=nameWithType> object that is returned by the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="bb994-490">El objeto <xref:System.Text.RegularExpressions.GroupCollection> se rellena como sigue:</span><span class="sxs-lookup"><span data-stu-id="bb994-490">The <xref:System.Text.RegularExpressions.GroupCollection> object is populated as follows:</span></span>  
  
- <span data-ttu-id="bb994-491">El primer objeto <xref:System.Text.RegularExpressions.Group> de la colección (el objeto con el índice cero) representa la coincidencia completa.</span><span class="sxs-lookup"><span data-stu-id="bb994-491">The first <xref:System.Text.RegularExpressions.Group> object in the collection (the object at index zero) represents the entire match.</span></span>  
  
- <span data-ttu-id="bb994-492">El siguiente conjunto de objetos <xref:System.Text.RegularExpressions.Group> representa los grupos de captura sin nombre (numerados).</span><span class="sxs-lookup"><span data-stu-id="bb994-492">The next set of <xref:System.Text.RegularExpressions.Group> objects represent unnamed (numbered) capturing groups.</span></span> <span data-ttu-id="bb994-493">Aparecen en el orden en el que se definen en la expresión regular, de izquierda a derecha.</span><span class="sxs-lookup"><span data-stu-id="bb994-493">They appear in the order in which they are defined in the regular expression, from left to right.</span></span> <span data-ttu-id="bb994-494">Los valores de índice de estos grupos van de 1 al número de grupos de captura sin nombre de la colección.</span><span class="sxs-lookup"><span data-stu-id="bb994-494">The index values of these groups range from 1 to the number of unnamed capturing groups in the collection.</span></span> <span data-ttu-id="bb994-495">(El índice de un grupo determinado es equivalente a su referencia inversa numerada.</span><span class="sxs-lookup"><span data-stu-id="bb994-495">(The index of a particular group is equivalent to its numbered backreference.</span></span> <span data-ttu-id="bb994-496">Para más información sobre las referencias inversas, vea [Construcciones de referencia inversa)](backreference-constructs-in-regular-expressions.md)).</span><span class="sxs-lookup"><span data-stu-id="bb994-496">For more information about backreferences, see [Backreference Constructs](backreference-constructs-in-regular-expressions.md).)</span></span>  
  
- <span data-ttu-id="bb994-497">El conjunto final de objetos <xref:System.Text.RegularExpressions.Group> representa los grupos de captura con nombre.</span><span class="sxs-lookup"><span data-stu-id="bb994-497">The final set of <xref:System.Text.RegularExpressions.Group> objects represent named capturing groups.</span></span> <span data-ttu-id="bb994-498">Aparecen en el orden en el que se definen en la expresión regular, de izquierda a derecha.</span><span class="sxs-lookup"><span data-stu-id="bb994-498">They appear in the order in which they are defined in the regular expression, from left to right.</span></span> <span data-ttu-id="bb994-499">El valor de índice del primer grupo de captura con nombre es una unidad mayor que el índice del último grupo de captura sin nombre.</span><span class="sxs-lookup"><span data-stu-id="bb994-499">The index value of the first named capturing group is one greater than the index of the last unnamed capturing group.</span></span> <span data-ttu-id="bb994-500">Si no hay ningún grupo de captura sin nombre en la expresión regular, el valor de índice del primer grupo de captura con nombre es uno.</span><span class="sxs-lookup"><span data-stu-id="bb994-500">If there are no unnamed capturing groups in the regular expression, the index value of the first named capturing group is one.</span></span>  
  
 <span data-ttu-id="bb994-501">Si se aplica un cuantificador a un grupo de captura, las propiedades <xref:System.Text.RegularExpressions.Group> , <xref:System.Text.RegularExpressions.Capture.Value%2A?displayProperty=nameWithType>e <xref:System.Text.RegularExpressions.Capture.Index%2A?displayProperty=nameWithType>del objeto <xref:System.Text.RegularExpressions.Capture.Length%2A?displayProperty=nameWithType> correspondiente reflejarán la última subcadena capturada por un grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="bb994-501">If you apply a quantifier to a capturing group, the corresponding <xref:System.Text.RegularExpressions.Group> object's <xref:System.Text.RegularExpressions.Capture.Value%2A?displayProperty=nameWithType>, <xref:System.Text.RegularExpressions.Capture.Index%2A?displayProperty=nameWithType>, and <xref:System.Text.RegularExpressions.Capture.Length%2A?displayProperty=nameWithType> properties reflect the last substring that is captured by a capturing group.</span></span> <span data-ttu-id="bb994-502">Se puede recuperar un conjunto completo de subcadenas capturadas por grupos que tienen cuantificadores desde el objeto <xref:System.Text.RegularExpressions.CaptureCollection> devuelto por la propiedad <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="bb994-502">You can retrieve a complete set of substrings that are captured by groups that have quantifiers from the <xref:System.Text.RegularExpressions.CaptureCollection> object that is returned by the <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="bb994-503">El ejemplo siguiente aclara la relación entre los objetos <xref:System.Text.RegularExpressions.Group> y <xref:System.Text.RegularExpressions.Capture> .</span><span class="sxs-lookup"><span data-stu-id="bb994-503">The following example clarifies the relationship between the <xref:System.Text.RegularExpressions.Group> and <xref:System.Text.RegularExpressions.Capture> objects.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#4](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/objectmodel1.cs#4)]
 [!code-vb[RegularExpressions.Language.Grouping#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/objectmodel1.vb#4)]  
  
 <span data-ttu-id="bb994-504">El patrón de expresión regular `(\b(\w+)\W+)+` extrae palabras individuales de una cadena.</span><span class="sxs-lookup"><span data-stu-id="bb994-504">The regular expression pattern `(\b(\w+)\W+)+` extracts individual words from a string.</span></span> <span data-ttu-id="bb994-505">Se define como se muestra en la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="bb994-505">It is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="bb994-506">Modelo</span><span class="sxs-lookup"><span data-stu-id="bb994-506">Pattern</span></span>|<span data-ttu-id="bb994-507">Descripción</span><span class="sxs-lookup"><span data-stu-id="bb994-507">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="bb994-508">Iniciar la búsqueda de coincidencias en un límite de palabras.</span><span class="sxs-lookup"><span data-stu-id="bb994-508">Begin the match at a word boundary.</span></span>|  
|`(\w+)`|<span data-ttu-id="bb994-509">Buscar coincidencias con uno o más caracteres alfabéticos.</span><span class="sxs-lookup"><span data-stu-id="bb994-509">Match one or more word characters.</span></span> <span data-ttu-id="bb994-510">Juntos, estos caracteres forman una palabra.</span><span class="sxs-lookup"><span data-stu-id="bb994-510">Together, these characters form a word.</span></span> <span data-ttu-id="bb994-511">Este es el segundo grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="bb994-511">This is the second capturing group.</span></span>|  
|`\W+`|<span data-ttu-id="bb994-512">Coincide con uno o varios caracteres que no se usan para formar palabras.</span><span class="sxs-lookup"><span data-stu-id="bb994-512">Match one or more non-word characters.</span></span>|  
|`(\b(\w+)\W+)`|<span data-ttu-id="bb994-513">Coincide una o varias veces con el patrón de uno o varios caracteres que se usan para formar palabras seguidos de uno o varios caracteres que no se usan para formar palabras.</span><span class="sxs-lookup"><span data-stu-id="bb994-513">Match the pattern of one or more word characters followed by one or more non-word characters one or more times.</span></span> <span data-ttu-id="bb994-514">Este es el primer grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="bb994-514">This is the first capturing group.</span></span>|  
  
 <span data-ttu-id="bb994-515">El segundo grupo de captura coincide con cada palabra de la frase.</span><span class="sxs-lookup"><span data-stu-id="bb994-515">The second capturing group matches each word of the sentence.</span></span> <span data-ttu-id="bb994-516">El primer grupo de captura coincide con cada palabra, junto con la puntuación y el espacio en blanco que siguen a la palabra.</span><span class="sxs-lookup"><span data-stu-id="bb994-516">The first capturing group matches each word along with the punctuation and white space that follow the word.</span></span> <span data-ttu-id="bb994-517">El objeto <xref:System.Text.RegularExpressions.Group> cuyo índice es 2 proporciona información sobre el texto coincidente con el segundo grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="bb994-517">The <xref:System.Text.RegularExpressions.Group> object whose index is 2 provides information about the text matched by the second capturing group.</span></span> <span data-ttu-id="bb994-518">El conjunto de palabras completo capturado por el grupo de captura está disponible desde el objeto <xref:System.Text.RegularExpressions.CaptureCollection> devuelto por la propiedad <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="bb994-518">The complete set of words captured by the capturing group are available from the <xref:System.Text.RegularExpressions.CaptureCollection> object returned by the <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> property.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="bb994-519">Vea también</span><span class="sxs-lookup"><span data-stu-id="bb994-519">See also</span></span>

- [<span data-ttu-id="bb994-520">Lenguaje de expresiones regulares: referencia rápida</span><span class="sxs-lookup"><span data-stu-id="bb994-520">Regular Expression Language - Quick Reference</span></span>](regular-expression-language-quick-reference.md)
- [<span data-ttu-id="bb994-521">Retroceso</span><span class="sxs-lookup"><span data-stu-id="bb994-521">Backtracking</span></span>](backtracking-in-regular-expressions.md)
