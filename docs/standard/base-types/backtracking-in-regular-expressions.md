---
title: Retroceso en expresiones regulares de .NET
description: Obtenga información sobre cómo controlar el retroceso en la coincidencia de patrones de expresiones regulares.
ms.date: 11/12/2018
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- .NET Framework regular expressions, backtracking
- alternative matching patterns
- optional matching patterns
- searching with regular expressions, backtracking
- pattern-matching with regular expressions, backtracking
- backtracking
- regular expressions [.NET Framework], backtracking
- strings [.NET Framework], regular expressions
- parsing text with regular expressions, backtracking
ms.assetid: 34df1152-0b22-4a1c-a76c-3c28c47b70d8
ms.openlocfilehash: 1b61cc88de4f73abfe6d8e77f8f32c2c71e70a9d
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 03/15/2020
ms.locfileid: "78158069"
---
# <a name="backtracking-in-regular-expressions"></a><span data-ttu-id="2cb84-103">Retroceso en expresiones regulares</span><span class="sxs-lookup"><span data-stu-id="2cb84-103">Backtracking in Regular Expressions</span></span>
<span data-ttu-id="2cb84-104">El retroceso se produce cuando un patrón de expresión regular contiene [cuantificadores](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md) o [construcciones de alternancia](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md) opcionales y el motor de expresiones regulares vuelve a un estado guardado anterior para continuar la búsqueda de una coincidencia.</span><span class="sxs-lookup"><span data-stu-id="2cb84-104">Backtracking occurs when a regular expression pattern contains optional [quantifiers](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md) or [alternation constructs](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md), and the regular expression engine returns to a previous saved state to continue its search for a match.</span></span> <span data-ttu-id="2cb84-105">El retroceso es fundamental para la eficacia de las expresiones regulares; permite que las expresiones sean eficaces y flexibles, y que coincidan con modelos muy complejos.</span><span class="sxs-lookup"><span data-stu-id="2cb84-105">Backtracking is central to the power of regular expressions; it makes it possible for expressions to be powerful and flexible, and to match very complex patterns.</span></span> <span data-ttu-id="2cb84-106">Al mismo tiempo, esta eficacia tiene un costo.</span><span class="sxs-lookup"><span data-stu-id="2cb84-106">At the same time, this power comes at a cost.</span></span> <span data-ttu-id="2cb84-107">El retroceso suele ser el factor único más importante que afecta al rendimiento del motor de expresiones regulares.</span><span class="sxs-lookup"><span data-stu-id="2cb84-107">Backtracking is often the single most important factor that affects the performance of the regular expression engine.</span></span> <span data-ttu-id="2cb84-108">Afortunadamente, el desarrollador tiene control sobre el comportamiento del motor de expresiones regulares y cómo usa el retroceso.</span><span class="sxs-lookup"><span data-stu-id="2cb84-108">Fortunately, the developer has control over the behavior of the regular expression engine and how it uses backtracking.</span></span> <span data-ttu-id="2cb84-109">En este tema se explica cómo funciona el retroceso y cómo se puede controlar.</span><span class="sxs-lookup"><span data-stu-id="2cb84-109">This topic explains how backtracking works and how it can be controlled.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="2cb84-110">En general, un motor NFA (autómata finito no determinista), como el motor de expresiones regulares de .NET, se encarga de crear expresiones regulares eficaces y rápidas para el desarrollador.</span><span class="sxs-lookup"><span data-stu-id="2cb84-110">In general, a Nondeterministic Finite Automaton (NFA) engine like .NET regular expression engine places the responsibility for crafting efficient, fast regular expressions on the developer.</span></span>  

## <a name="linear-comparison-without-backtracking"></a><span data-ttu-id="2cb84-111">Comparación lineal sin retroceso</span><span class="sxs-lookup"><span data-stu-id="2cb84-111">Linear Comparison Without Backtracking</span></span>  
 <span data-ttu-id="2cb84-112">Si un patrón de expresión regular no tiene ningún cuantificador o construcción de alternancia opcional, el motor de expresiones regulares se ejecuta en tiempo lineal.</span><span class="sxs-lookup"><span data-stu-id="2cb84-112">If a regular expression pattern has no optional quantifiers or alternation constructs, the regular expression engine executes in linear time.</span></span> <span data-ttu-id="2cb84-113">Es decir, una vez que el motor de expresiones regulares hace coincidir el primer elemento de lenguaje del patrón con texto de la cadena de entrada, intenta buscar una coincidencia del siguiente elemento de lenguaje del patrón con el siguiente carácter o grupo de caracteres de la cadena de entrada.</span><span class="sxs-lookup"><span data-stu-id="2cb84-113">That is, after the regular expression engine matches the first language element in the pattern with text in the input string, it tries to match the next language element in the pattern with the next character or group of characters in the input string.</span></span> <span data-ttu-id="2cb84-114">Este proceso continúa hasta que la coincidencia se realiza correctamente o se produce un error.</span><span class="sxs-lookup"><span data-stu-id="2cb84-114">This continues until the match either succeeds or fails.</span></span> <span data-ttu-id="2cb84-115">En cualquier caso, el motor de expresiones regulares avanza de carácter en carácter por la cadena de entrada.</span><span class="sxs-lookup"><span data-stu-id="2cb84-115">In either case, the regular expression engine advances by one character at a time in the input string.</span></span>  
  
 <span data-ttu-id="2cb84-116">Esto se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="2cb84-116">The following example provides an illustration.</span></span> <span data-ttu-id="2cb84-117">La expresión regular `e{2}\w\b` busca dos apariciones de la letra "e" seguida de cualquier carácter alfabético seguido de un límite de palabras.</span><span class="sxs-lookup"><span data-stu-id="2cb84-117">The regular expression `e{2}\w\b` looks for two occurrences of the letter "e" followed by any word character followed by a word boundary.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking1.cs#1)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking1.vb#1)]  
  
 <span data-ttu-id="2cb84-118">Aunque esta expresión regular incluye el cuantificador `{2}`, se evalúa de manera lineal.</span><span class="sxs-lookup"><span data-stu-id="2cb84-118">Although this regular expression includes the quantifier `{2}`, it is evaluated in a linear manner.</span></span> <span data-ttu-id="2cb84-119">El motor de expresiones regulares no retrocede porque `{2}` no es un cuantificador opcional, ya que especifica un número exacto y no un número variable de veces que la subexpresión anterior debe coincidir.</span><span class="sxs-lookup"><span data-stu-id="2cb84-119">The regular expression engine does not backtrack because `{2}` is not an optional quantifier; it specifies an exact number and not a variable number of times that the previous subexpression must match.</span></span> <span data-ttu-id="2cb84-120">Como resultado, el motor de expresiones regulares intenta hacer coincidir el patrón de expresión regular con la cadena de entrada como se muestra en la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="2cb84-120">As a result, the regular expression engine tries to match the regular expression pattern with the input string as shown in the following table.</span></span>  
  
|<span data-ttu-id="2cb84-121">Operación</span><span class="sxs-lookup"><span data-stu-id="2cb84-121">Operation</span></span>|<span data-ttu-id="2cb84-122">Posición en el patrón</span><span class="sxs-lookup"><span data-stu-id="2cb84-122">Position in pattern</span></span>|<span data-ttu-id="2cb84-123">Posición en la cadena</span><span class="sxs-lookup"><span data-stu-id="2cb84-123">Position in string</span></span>|<span data-ttu-id="2cb84-124">Resultado</span><span class="sxs-lookup"><span data-stu-id="2cb84-124">Result</span></span>|  
|---------------|-------------------------|------------------------|------------|  
|<span data-ttu-id="2cb84-125">1</span><span class="sxs-lookup"><span data-stu-id="2cb84-125">1</span></span>|<span data-ttu-id="2cb84-126">h</span><span class="sxs-lookup"><span data-stu-id="2cb84-126">e</span></span>|<span data-ttu-id="2cb84-127">"needing a reed" (índice 0)</span><span class="sxs-lookup"><span data-stu-id="2cb84-127">"needing a reed" (index 0)</span></span>|<span data-ttu-id="2cb84-128">Ninguna coincidencia.</span><span class="sxs-lookup"><span data-stu-id="2cb84-128">No match.</span></span>|  
|<span data-ttu-id="2cb84-129">2</span><span class="sxs-lookup"><span data-stu-id="2cb84-129">2</span></span>|<span data-ttu-id="2cb84-130">h</span><span class="sxs-lookup"><span data-stu-id="2cb84-130">e</span></span>|<span data-ttu-id="2cb84-131">"eeding a reed" (índice 1)</span><span class="sxs-lookup"><span data-stu-id="2cb84-131">"eeding a reed" (index 1)</span></span>|<span data-ttu-id="2cb84-132">Posible coincidencia.</span><span class="sxs-lookup"><span data-stu-id="2cb84-132">Possible match.</span></span>|  
|<span data-ttu-id="2cb84-133">3</span><span class="sxs-lookup"><span data-stu-id="2cb84-133">3</span></span>|<span data-ttu-id="2cb84-134">e{2}</span><span class="sxs-lookup"><span data-stu-id="2cb84-134">e{2}</span></span>|<span data-ttu-id="2cb84-135">"eding a reed" (índice 2)</span><span class="sxs-lookup"><span data-stu-id="2cb84-135">"eding a reed" (index 2)</span></span>|<span data-ttu-id="2cb84-136">Posible coincidencia.</span><span class="sxs-lookup"><span data-stu-id="2cb84-136">Possible match.</span></span>|  
|<span data-ttu-id="2cb84-137">4</span><span class="sxs-lookup"><span data-stu-id="2cb84-137">4</span></span>|<span data-ttu-id="2cb84-138">\w</span><span class="sxs-lookup"><span data-stu-id="2cb84-138">\w</span></span>|<span data-ttu-id="2cb84-139">"ding a reed" (índice 3)</span><span class="sxs-lookup"><span data-stu-id="2cb84-139">"ding a reed" (index 3)</span></span>|<span data-ttu-id="2cb84-140">Posible coincidencia.</span><span class="sxs-lookup"><span data-stu-id="2cb84-140">Possible match.</span></span>|  
|<span data-ttu-id="2cb84-141">5</span><span class="sxs-lookup"><span data-stu-id="2cb84-141">5</span></span>|<span data-ttu-id="2cb84-142">\b</span><span class="sxs-lookup"><span data-stu-id="2cb84-142">\b</span></span>|<span data-ttu-id="2cb84-143">"ing a reed" (índice 4)</span><span class="sxs-lookup"><span data-stu-id="2cb84-143">"ing a reed" (index 4)</span></span>|<span data-ttu-id="2cb84-144">Error en posible coincidencia.</span><span class="sxs-lookup"><span data-stu-id="2cb84-144">Possible match fails.</span></span>|  
|<span data-ttu-id="2cb84-145">6</span><span class="sxs-lookup"><span data-stu-id="2cb84-145">6</span></span>|<span data-ttu-id="2cb84-146">h</span><span class="sxs-lookup"><span data-stu-id="2cb84-146">e</span></span>|<span data-ttu-id="2cb84-147">"eding a reed" (índice 2)</span><span class="sxs-lookup"><span data-stu-id="2cb84-147">"eding a reed" (index 2)</span></span>|<span data-ttu-id="2cb84-148">Posible coincidencia.</span><span class="sxs-lookup"><span data-stu-id="2cb84-148">Possible match.</span></span>|  
|<span data-ttu-id="2cb84-149">7</span><span class="sxs-lookup"><span data-stu-id="2cb84-149">7</span></span>|<span data-ttu-id="2cb84-150">e{2}</span><span class="sxs-lookup"><span data-stu-id="2cb84-150">e{2}</span></span>|<span data-ttu-id="2cb84-151">"ding a reed" (índice 3)</span><span class="sxs-lookup"><span data-stu-id="2cb84-151">"ding a reed" (index 3)</span></span>|<span data-ttu-id="2cb84-152">Error en posible coincidencia.</span><span class="sxs-lookup"><span data-stu-id="2cb84-152">Possible match fails.</span></span>|  
|<span data-ttu-id="2cb84-153">8</span><span class="sxs-lookup"><span data-stu-id="2cb84-153">8</span></span>|<span data-ttu-id="2cb84-154">h</span><span class="sxs-lookup"><span data-stu-id="2cb84-154">e</span></span>|<span data-ttu-id="2cb84-155">"ding a reed" (índice 3)</span><span class="sxs-lookup"><span data-stu-id="2cb84-155">"ding a reed" (index 3)</span></span>|<span data-ttu-id="2cb84-156">Se produce un error de coincidencia.</span><span class="sxs-lookup"><span data-stu-id="2cb84-156">Match fails.</span></span>|  
|<span data-ttu-id="2cb84-157">9</span><span class="sxs-lookup"><span data-stu-id="2cb84-157">9</span></span>|<span data-ttu-id="2cb84-158">h</span><span class="sxs-lookup"><span data-stu-id="2cb84-158">e</span></span>|<span data-ttu-id="2cb84-159">"ing a reed" (índice 4)</span><span class="sxs-lookup"><span data-stu-id="2cb84-159">"ing a reed" (index 4)</span></span>|<span data-ttu-id="2cb84-160">Ninguna coincidencia.</span><span class="sxs-lookup"><span data-stu-id="2cb84-160">No match.</span></span>|  
|<span data-ttu-id="2cb84-161">10</span><span class="sxs-lookup"><span data-stu-id="2cb84-161">10</span></span>|<span data-ttu-id="2cb84-162">h</span><span class="sxs-lookup"><span data-stu-id="2cb84-162">e</span></span>|<span data-ttu-id="2cb84-163">"ng a reed" (índice 5)</span><span class="sxs-lookup"><span data-stu-id="2cb84-163">"ng a reed" (index 5)</span></span>|<span data-ttu-id="2cb84-164">Ninguna coincidencia.</span><span class="sxs-lookup"><span data-stu-id="2cb84-164">No match.</span></span>|  
|<span data-ttu-id="2cb84-165">11</span><span class="sxs-lookup"><span data-stu-id="2cb84-165">11</span></span>|<span data-ttu-id="2cb84-166">h</span><span class="sxs-lookup"><span data-stu-id="2cb84-166">e</span></span>|<span data-ttu-id="2cb84-167">"g a reed" (índice 6)</span><span class="sxs-lookup"><span data-stu-id="2cb84-167">"g a reed" (index 6)</span></span>|<span data-ttu-id="2cb84-168">Ninguna coincidencia.</span><span class="sxs-lookup"><span data-stu-id="2cb84-168">No match.</span></span>|  
|<span data-ttu-id="2cb84-169">12</span><span class="sxs-lookup"><span data-stu-id="2cb84-169">12</span></span>|<span data-ttu-id="2cb84-170">h</span><span class="sxs-lookup"><span data-stu-id="2cb84-170">e</span></span>|<span data-ttu-id="2cb84-171">" a reed" (índice 7)</span><span class="sxs-lookup"><span data-stu-id="2cb84-171">" a reed" (index 7)</span></span>|<span data-ttu-id="2cb84-172">Ninguna coincidencia.</span><span class="sxs-lookup"><span data-stu-id="2cb84-172">No match.</span></span>|  
|<span data-ttu-id="2cb84-173">13</span><span class="sxs-lookup"><span data-stu-id="2cb84-173">13</span></span>|<span data-ttu-id="2cb84-174">h</span><span class="sxs-lookup"><span data-stu-id="2cb84-174">e</span></span>|<span data-ttu-id="2cb84-175">“a reed” (índice 8)</span><span class="sxs-lookup"><span data-stu-id="2cb84-175">"a reed" (index 8)</span></span>|<span data-ttu-id="2cb84-176">Ninguna coincidencia.</span><span class="sxs-lookup"><span data-stu-id="2cb84-176">No match.</span></span>|  
|<span data-ttu-id="2cb84-177">14</span><span class="sxs-lookup"><span data-stu-id="2cb84-177">14</span></span>|<span data-ttu-id="2cb84-178">h</span><span class="sxs-lookup"><span data-stu-id="2cb84-178">e</span></span>|<span data-ttu-id="2cb84-179">" reed" (índice 9)</span><span class="sxs-lookup"><span data-stu-id="2cb84-179">" reed" (index 9)</span></span>|<span data-ttu-id="2cb84-180">Ninguna coincidencia.</span><span class="sxs-lookup"><span data-stu-id="2cb84-180">No match.</span></span>|  
|<span data-ttu-id="2cb84-181">15</span><span class="sxs-lookup"><span data-stu-id="2cb84-181">15</span></span>|<span data-ttu-id="2cb84-182">h</span><span class="sxs-lookup"><span data-stu-id="2cb84-182">e</span></span>|<span data-ttu-id="2cb84-183">“reed” (índice 10)</span><span class="sxs-lookup"><span data-stu-id="2cb84-183">"reed" (index 10)</span></span>|<span data-ttu-id="2cb84-184">Ninguna coincidencia</span><span class="sxs-lookup"><span data-stu-id="2cb84-184">No match</span></span>|  
|<span data-ttu-id="2cb84-185">16</span><span class="sxs-lookup"><span data-stu-id="2cb84-185">16</span></span>|<span data-ttu-id="2cb84-186">h</span><span class="sxs-lookup"><span data-stu-id="2cb84-186">e</span></span>|<span data-ttu-id="2cb84-187">"eed" (índice 11)</span><span class="sxs-lookup"><span data-stu-id="2cb84-187">"eed" (index 11)</span></span>|<span data-ttu-id="2cb84-188">Posible coincidencia.</span><span class="sxs-lookup"><span data-stu-id="2cb84-188">Possible match.</span></span>|  
|<span data-ttu-id="2cb84-189">17</span><span class="sxs-lookup"><span data-stu-id="2cb84-189">17</span></span>|<span data-ttu-id="2cb84-190">e{2}</span><span class="sxs-lookup"><span data-stu-id="2cb84-190">e{2}</span></span>|<span data-ttu-id="2cb84-191">"ed" (índice 12)</span><span class="sxs-lookup"><span data-stu-id="2cb84-191">"ed" (index 12)</span></span>|<span data-ttu-id="2cb84-192">Posible coincidencia.</span><span class="sxs-lookup"><span data-stu-id="2cb84-192">Possible match.</span></span>|  
|<span data-ttu-id="2cb84-193">18</span><span class="sxs-lookup"><span data-stu-id="2cb84-193">18</span></span>|<span data-ttu-id="2cb84-194">\w</span><span class="sxs-lookup"><span data-stu-id="2cb84-194">\w</span></span>|<span data-ttu-id="2cb84-195">"d" (índice 13)</span><span class="sxs-lookup"><span data-stu-id="2cb84-195">"d" (index 13)</span></span>|<span data-ttu-id="2cb84-196">Posible coincidencia.</span><span class="sxs-lookup"><span data-stu-id="2cb84-196">Possible match.</span></span>|  
|<span data-ttu-id="2cb84-197">19</span><span class="sxs-lookup"><span data-stu-id="2cb84-197">19</span></span>|<span data-ttu-id="2cb84-198">\b</span><span class="sxs-lookup"><span data-stu-id="2cb84-198">\b</span></span>|<span data-ttu-id="2cb84-199">"" (índice 14)</span><span class="sxs-lookup"><span data-stu-id="2cb84-199">"" (index 14)</span></span>|<span data-ttu-id="2cb84-200">Coincidencia.</span><span class="sxs-lookup"><span data-stu-id="2cb84-200">Match.</span></span>|  
  
 <span data-ttu-id="2cb84-201">Si un patrón de expresión regular no incluye ningún cuantificador o construcción de alternancia opcional, el número máximo de comparaciones necesarias para hacer coincidir el patrón de expresión regular con la cadena de entrada es aproximadamente equivalente al número de caracteres de la cadena de entrada.</span><span class="sxs-lookup"><span data-stu-id="2cb84-201">If a regular expression pattern includes no optional quantifiers or alternation constructs, the maximum number of comparisons required to match the regular expression pattern with the input string is roughly equivalent to the number of characters in the input string.</span></span> <span data-ttu-id="2cb84-202">En este caso, el motor de expresiones regulares usa 19 comparaciones para identificar posibles coincidencias en esta cadena de 13 caracteres.</span><span class="sxs-lookup"><span data-stu-id="2cb84-202">In this case, the regular expression engine uses 19 comparisons to identify possible matches in this 13-character string.</span></span>  <span data-ttu-id="2cb84-203">Es decir, el motor de expresiones regulares se ejecuta en tiempo prácticamente lineal si no contiene ningún cuantificador o construcción de alternancia opcional.</span><span class="sxs-lookup"><span data-stu-id="2cb84-203">In other words, the regular expression engine runs in near-linear time if it contains no optional quantifiers or alternation constructs.</span></span>

## <a name="backtracking-with-optional-quantifiers-or-alternation-constructs"></a><span data-ttu-id="2cb84-204">Retroceso con cuantificadores o construcciones de alternancia opcionales</span><span class="sxs-lookup"><span data-stu-id="2cb84-204">Backtracking with Optional Quantifiers or Alternation Constructs</span></span>  
 <span data-ttu-id="2cb84-205">Cuando una expresión regular incluye cuantificadores o construcciones de alternancia opcionales, la evaluación de la cadena de entrada ya no es lineal.</span><span class="sxs-lookup"><span data-stu-id="2cb84-205">When a regular expression includes optional quantifiers or alternation constructs, the evaluation of the input string is no longer linear.</span></span> <span data-ttu-id="2cb84-206">La coincidencia de modelos con un motor NFA está controlada por los elementos de lenguaje de la expresión regular y no por los caracteres que se hacen coincidir en la cadena de entrada.</span><span class="sxs-lookup"><span data-stu-id="2cb84-206">Pattern matching with an NFA engine is driven by the language elements in the regular expression and not by the characters to be matched in the input string.</span></span> <span data-ttu-id="2cb84-207">Por tanto, el motor de expresiones regulares intenta hacer coincidir totalmente subexpresiones opcionales o alternativas.</span><span class="sxs-lookup"><span data-stu-id="2cb84-207">Therefore, the regular expression engine tries to fully match optional or alternative subexpressions.</span></span> <span data-ttu-id="2cb84-208">Cuando avanza al elemento de lenguaje siguiente de la subexpresión y la coincidencia no se realiza correctamente, el motor de expresiones regulares puede abandonar una parte de su coincidencia correcta y volver a un estado guardado anterior para hacer coincidir la expresión regular en su conjunto con la cadena de entrada.</span><span class="sxs-lookup"><span data-stu-id="2cb84-208">When it advances to the next language element in the subexpression and the match is unsuccessful, the regular expression engine can abandon a portion of its successful match and return to an earlier saved state in the interest of matching the regular expression as a whole with the input string.</span></span> <span data-ttu-id="2cb84-209">Este proceso de volver a un estado guardado anterior para encontrar una coincidencia se denomina retroceso.</span><span class="sxs-lookup"><span data-stu-id="2cb84-209">This process of returning to a previous saved state to find a match is known as backtracking.</span></span>  
  
 <span data-ttu-id="2cb84-210">Por ejemplo, considere el patrón de expresión regular `.*(es)`, que hace coincidir los caracteres "es" y todos los caracteres que lo preceden.</span><span class="sxs-lookup"><span data-stu-id="2cb84-210">For example, consider the regular expression pattern `.*(es)`, which matches the characters "es" and all the characters that precede it.</span></span> <span data-ttu-id="2cb84-211">Como se muestra en el ejemplo siguiente, si la cadena de entrada es "Essential services are provided by regular expressions.", el patrón coincide con toda la cadena hasta e incluyendo "es" en "expressions".</span><span class="sxs-lookup"><span data-stu-id="2cb84-211">As the following example shows, if the input string is "Essential services are provided by regular expressions.", the pattern matches the whole string up to and including the "es" in "expressions".</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking2.cs#2)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking2.vb#2)]  
  
 <span data-ttu-id="2cb84-212">Para ello, el motor de expresiones regulares usa el retroceso de la manera siguiente:</span><span class="sxs-lookup"><span data-stu-id="2cb84-212">To do this, the regular expression engine uses backtracking as follows:</span></span>  
  
- <span data-ttu-id="2cb84-213">Coincide con `.*` (que coincide con cero, una o más apariciones de cualquier carácter) con la cadena de entrada completa.</span><span class="sxs-lookup"><span data-stu-id="2cb84-213">It matches the `.*` (which matches zero, one, or more occurrences of any character) with the whole input string.</span></span>  
  
- <span data-ttu-id="2cb84-214">Intenta hacer coincidir "e" en el patrón de expresión regular.</span><span class="sxs-lookup"><span data-stu-id="2cb84-214">It attempts to match "e" in the regular expression pattern.</span></span> <span data-ttu-id="2cb84-215">Sin embargo, la cadena de entrada no tiene ningún carácter restante disponible para coincidir.</span><span class="sxs-lookup"><span data-stu-id="2cb84-215">However, the input string has no remaining characters available to match.</span></span>  
  
- <span data-ttu-id="2cb84-216">Retrocede hasta su última coincidencia correcta, "Essential services are provided by regular expressions", e intenta hacer coincidir "e" con el punto del final de la frase.</span><span class="sxs-lookup"><span data-stu-id="2cb84-216">It backtracks to its last successful match, "Essential services are provided by regular expressions", and attempts to match "e" with the period at the end of the sentence.</span></span> <span data-ttu-id="2cb84-217">Se produce un error de coincidencia.</span><span class="sxs-lookup"><span data-stu-id="2cb84-217">The match fails.</span></span>  
  
- <span data-ttu-id="2cb84-218">Sigue retrocediendo hasta una coincidencia correcta anterior, de carácter en carácter, hasta que la subcadena coincidente tentativa sea "Essential services are provided by regular expr".</span><span class="sxs-lookup"><span data-stu-id="2cb84-218">It continues to backtrack to a previous successful match one character at a time until the tentatively matched substring is "Essential services are provided by regular expr".</span></span> <span data-ttu-id="2cb84-219">A continuación, compara la "e" del patrón con la segunda "e" de "expressions" y encuentra una coincidencia.</span><span class="sxs-lookup"><span data-stu-id="2cb84-219">It then compares the "e" in the pattern to the second "e" in "expressions" and finds a match.</span></span>  
  
- <span data-ttu-id="2cb84-220">Compara la "s" del patrón con la "s" que sigue al carácter "e" coincidente (la primera "s" de "expressions").</span><span class="sxs-lookup"><span data-stu-id="2cb84-220">It compares "s" in the pattern to the "s" that follows the matched "e" character (the first "s" in "expressions").</span></span> <span data-ttu-id="2cb84-221">La coincidencia es correcta.</span><span class="sxs-lookup"><span data-stu-id="2cb84-221">The match is successful.</span></span>  
  
 <span data-ttu-id="2cb84-222">Cuando se usa retroceso, la coincidencia del patrón de expresión regular con la cadena de entrada, que tiene 55 caracteres de longitud, necesita 67 operaciones de comparación.</span><span class="sxs-lookup"><span data-stu-id="2cb84-222">When you use backtracking, matching the regular expression pattern with the input string, which is 55 characters long, requires 67 comparison operations.</span></span> <span data-ttu-id="2cb84-223">Normalmente, si un patrón de expresión regular tiene una única construcción de alternancia o un único cuantificador opcional, el número de operaciones de comparación necesarias para que coincida con el patrón es más del doble del número de caracteres de la cadena de entrada.</span><span class="sxs-lookup"><span data-stu-id="2cb84-223">Generally, if a regular expression pattern has a single alternation construct or a single optional quantifier, the number of comparison operations required to match the pattern is more than twice the number of characters in the input string.</span></span>

## <a name="backtracking-with-nested-optional-quantifiers"></a><span data-ttu-id="2cb84-224">Retroceso con cuantificadores opcionales anidados</span><span class="sxs-lookup"><span data-stu-id="2cb84-224">Backtracking with Nested Optional Quantifiers</span></span>  
 <span data-ttu-id="2cb84-225">El número de operaciones de comparación necesarias para coincidir con un patrón de expresión regular puede aumentar exponencial si el patrón incluye muchas construcciones de alternancia, si incluye construcciones de alternancia anidadas o, lo que es más frecuente, si incluye cuantificadores opcionales anidados.</span><span class="sxs-lookup"><span data-stu-id="2cb84-225">The number of comparison operations required to match a regular expression pattern can increase exponentially if the pattern includes a large number of alternation constructs, if it includes nested alternation constructs, or, most commonly, if it includes nested optional quantifiers.</span></span> <span data-ttu-id="2cb84-226">Por ejemplo, el patrón de expresión regular `^(a+)+$` está diseñado para coincidir con una cadena completa que contiene uno o más caracteres "a".</span><span class="sxs-lookup"><span data-stu-id="2cb84-226">For example, the regular expression pattern `^(a+)+$` is designed to match a complete string that contains one or more "a" characters.</span></span> <span data-ttu-id="2cb84-227">El ejemplo proporciona dos cadenas de entrada de longitud idéntica, pero solo la primera cadena coincide con el patrón.</span><span class="sxs-lookup"><span data-stu-id="2cb84-227">The example provides two input strings of identical length, but only the first string matches the pattern.</span></span> <span data-ttu-id="2cb84-228">La clase <xref:System.Diagnostics.Stopwatch?displayProperty=nameWithType> se usa para determinar cuánto tiempo tarda la operación de coincidencia.</span><span class="sxs-lookup"><span data-stu-id="2cb84-228">The <xref:System.Diagnostics.Stopwatch?displayProperty=nameWithType> class is used to determine how long the match operation takes.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking3.cs#3)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking3.vb#3)]  
  
 <span data-ttu-id="2cb84-229">Como muestra el resultado del ejemplo, el motor de expresiones regulares tardó en descubrir que una cadena de entrada no coincidía con el patrón aproximadamente el doble que en identificar una cadena coincidente.</span><span class="sxs-lookup"><span data-stu-id="2cb84-229">As the output from the example shows, the regular expression engine took about twice as long to find that an input string did not match the pattern as it did to identify a matching string.</span></span> <span data-ttu-id="2cb84-230">Esto se debe a que una coincidencia infructuosa siempre representa un escenario de caso peor.</span><span class="sxs-lookup"><span data-stu-id="2cb84-230">This is because an unsuccessful match always represents a worst-case scenario.</span></span> <span data-ttu-id="2cb84-231">El motor de expresiones regulares debe usar la expresión regular para seguir todas las rutas posibles a través de los datos antes de poder concluir que la coincidencia no es correcta y los paréntesis anidados crean muchas rutas de acceso adicionales a través de los datos.</span><span class="sxs-lookup"><span data-stu-id="2cb84-231">The regular expression engine must use the regular expression to follow all possible paths through the data before it can conclude that the match is unsuccessful, and the nested parentheses create many additional paths through the data.</span></span> <span data-ttu-id="2cb84-232">El motor de expresiones regulares concluye que la segunda cadena no coincide con el patrón; para ello, hace lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="2cb84-232">The regular expression engine concludes that the second string did not match the pattern by doing the following:</span></span>  
  
- <span data-ttu-id="2cb84-233">Comprueba que está al principio de la cadena y, a continuación, busca una coincidencia de los cinco primeros caracteres de la cadena con el patrón `a+`.</span><span class="sxs-lookup"><span data-stu-id="2cb84-233">It checks that it was at the beginning of the string, and then matches the first five characters in the string with the pattern `a+`.</span></span> <span data-ttu-id="2cb84-234">A continuación, determina que no hay ningún grupo adicional de caracteres "a" en la cadena.</span><span class="sxs-lookup"><span data-stu-id="2cb84-234">It then determines that there are no additional groups of "a" characters in the string.</span></span> <span data-ttu-id="2cb84-235">Por último, comprueba que está al final de la cadena.</span><span class="sxs-lookup"><span data-stu-id="2cb84-235">Finally, it tests for the end of the string.</span></span> <span data-ttu-id="2cb84-236">Como en la cadena queda un carácter adicional, la coincidencia produce un error.</span><span class="sxs-lookup"><span data-stu-id="2cb84-236">Because one additional character remains in the string, the match fails.</span></span> <span data-ttu-id="2cb84-237">Esta coincidencia errónea necesita 9 comparaciones.</span><span class="sxs-lookup"><span data-stu-id="2cb84-237">This failed match requires 9 comparisons.</span></span> <span data-ttu-id="2cb84-238">El motor de expresiones regulares también guarda información de estado de las coincidencias de "a" (que llamaremos coincidencia 1), "aa" (coincidencia 2), "aaa" (coincidencia 3) y "aaaa" (coincidencia 4).</span><span class="sxs-lookup"><span data-stu-id="2cb84-238">The regular expression engine also saves state information from its matches of "a" (which we will call match 1), "aa" (match 2), "aaa" (match 3), and "aaaa" (match 4).</span></span>  
  
- <span data-ttu-id="2cb84-239">Vuelve a la coincidencia 4 guardada previamente.</span><span class="sxs-lookup"><span data-stu-id="2cb84-239">It returns to the previously saved match 4.</span></span> <span data-ttu-id="2cb84-240">Determina que hay un carácter "a" adicional para asignar a un grupo capturado adicional.</span><span class="sxs-lookup"><span data-stu-id="2cb84-240">It determines that there is one additional "a" character to assign to an additional captured group.</span></span> <span data-ttu-id="2cb84-241">Por último, comprueba que está al final de la cadena.</span><span class="sxs-lookup"><span data-stu-id="2cb84-241">Finally, it tests for the end of the string.</span></span> <span data-ttu-id="2cb84-242">Como en la cadena queda un carácter adicional, la coincidencia produce un error.</span><span class="sxs-lookup"><span data-stu-id="2cb84-242">Because one additional character remains in the string, the match fails.</span></span> <span data-ttu-id="2cb84-243">Esta coincidencia errónea necesita 4 comparaciones.</span><span class="sxs-lookup"><span data-stu-id="2cb84-243">This failed match requires 4 comparisons.</span></span> <span data-ttu-id="2cb84-244">Hasta ahora, se han realizado un total de 13 comparaciones.</span><span class="sxs-lookup"><span data-stu-id="2cb84-244">So far, a total of 13 comparisons have been performed.</span></span>  
  
- <span data-ttu-id="2cb84-245">Vuelve a la coincidencia 3 guardada previamente.</span><span class="sxs-lookup"><span data-stu-id="2cb84-245">It returns to the previously saved match 3.</span></span> <span data-ttu-id="2cb84-246">Determina que hay dos caracteres "a" adicionales para asignar a un grupo capturado adicional.</span><span class="sxs-lookup"><span data-stu-id="2cb84-246">It determines that there are two additional "a" characters to assign to an additional captured group.</span></span> <span data-ttu-id="2cb84-247">Sin embargo, se produce un error en la prueba de fin de cadena.</span><span class="sxs-lookup"><span data-stu-id="2cb84-247">However, the end-of-string test fails.</span></span> <span data-ttu-id="2cb84-248">Vuelva a la coincidencia 3 e intenta hacer coincidir los dos caracteres "a" adicionales en dos grupos capturados adicionales.</span><span class="sxs-lookup"><span data-stu-id="2cb84-248">It then returns to match3 and tries to match the two additional "a" characters in two additional captured groups.</span></span> <span data-ttu-id="2cb84-249">Se sigue produciendo un error en la prueba de fin de cadena.</span><span class="sxs-lookup"><span data-stu-id="2cb84-249">The end-of-string test still fails.</span></span> <span data-ttu-id="2cb84-250">Estas coincidencias con error necesitan 12 comparaciones.</span><span class="sxs-lookup"><span data-stu-id="2cb84-250">These failed matches require 12 comparisons.</span></span> <span data-ttu-id="2cb84-251">Hasta ahora, se ha realizado un total de 25 comparaciones.</span><span class="sxs-lookup"><span data-stu-id="2cb84-251">So far, a total of 25 comparisons have been performed.</span></span>  
  
 <span data-ttu-id="2cb84-252">La comparación de la cadena de entrada con la expresión regular continúa de esta manera hasta que el motor de expresiones regulares ha intentado todas las posibles combinaciones de coincidencias y, a continuación, concluye que no hay ninguna coincidencia.</span><span class="sxs-lookup"><span data-stu-id="2cb84-252">Comparison of the input string with the regular expression continues in this way until the regular expression engine has tried all possible combinations of matches, and then concludes that there is no match.</span></span> <span data-ttu-id="2cb84-253">Debido a los cuantificadores anidados, esta comparación es O(2<sup>n</sup>) o una operación exponencial, donde *n* es el número de caracteres de la cadena de entrada.</span><span class="sxs-lookup"><span data-stu-id="2cb84-253">Because of the nested quantifiers, this comparison is an O(2<sup>n</sup>) or an exponential operation, where *n* is the number of characters in the input string.</span></span> <span data-ttu-id="2cb84-254">Esto significa que, en el peor de los casos, una cadena de entrada de 30 caracteres necesita aproximadamente 1.073.741.824 comparaciones y una cadena de entrada de 40 caracteres necesita aproximadamente 1.099.511.627.776 comparaciones.</span><span class="sxs-lookup"><span data-stu-id="2cb84-254">This means that in the worst case, an input string of 30 characters requires approximately 1,073,741,824 comparisons, and an input string of 40 characters requires approximately 1,099,511,627,776 comparisons.</span></span> <span data-ttu-id="2cb84-255">Si usa cadenas de estas longitudes o incluso mayores, los métodos de expresión regular pueden tardar mucho tiempo en completarse cuando procesan datos de entrada que no coinciden con el patrón de expresión regular.</span><span class="sxs-lookup"><span data-stu-id="2cb84-255">If you use strings of these or even greater lengths, regular expression methods can take an extremely long time to complete when they process input that does not match the regular expression pattern.</span></span>

## <a name="controlling-backtracking"></a><span data-ttu-id="2cb84-256">Controlar el retroceso</span><span class="sxs-lookup"><span data-stu-id="2cb84-256">Controlling Backtracking</span></span>  
 <span data-ttu-id="2cb84-257">El retroceso permite crear expresiones regulares eficaces y flexibles.</span><span class="sxs-lookup"><span data-stu-id="2cb84-257">Backtracking lets you create powerful, flexible regular expressions.</span></span> <span data-ttu-id="2cb84-258">Sin embargo, como se ha mostrado en la sección anterior, estas ventajas pueden conllevar un bajo rendimiento inaceptable.</span><span class="sxs-lookup"><span data-stu-id="2cb84-258">However, as the previous section showed, these benefits may be coupled with unacceptably poor performance.</span></span> <span data-ttu-id="2cb84-259">Para evitar el retroceso excesivo, se debe definir un intervalo de tiempo de espera cuando se instancie un objeto <xref:System.Text.RegularExpressions.Regex> o se llame a un método estático de coincidencia de expresión regular.</span><span class="sxs-lookup"><span data-stu-id="2cb84-259">To prevent excessive backtracking, you should define a time-out interval when you instantiate a <xref:System.Text.RegularExpressions.Regex> object or call a static regular expression matching method.</span></span> <span data-ttu-id="2cb84-260">Esta técnica se analiza en la sección siguiente.</span><span class="sxs-lookup"><span data-stu-id="2cb84-260">This is discussed in the next section.</span></span> <span data-ttu-id="2cb84-261">Además, .NET admite tres elementos del lenguaje de expresiones regulares que limitan o suprimen la vuelta atrás (backtracking) y que admiten expresiones regulares complejas con poca o ninguna reducción del rendimiento: [grupos atómicos](#atomic-groups), [aserciones de búsqueda retrasada (lookbehind)](#lookbehind-assertions) y [aserciones de búsqueda anticipada (lookahead)](#lookahead-assertions).</span><span class="sxs-lookup"><span data-stu-id="2cb84-261">In addition, .NET supports three regular expression language elements that limit or suppress backtracking and that support complex regular expressions with little or no performance penalty: [atomic groups](#atomic-groups), [lookbehind assertions](#lookbehind-assertions), and [lookahead assertions](#lookahead-assertions).</span></span> <span data-ttu-id="2cb84-262">Para obtener más información sobre cada elemento del lenguaje, vea [Construcciones de agrupamiento](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="2cb84-262">For more information about each language element, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  

### <a name="defining-a-time-out-interval"></a><span data-ttu-id="2cb84-263">Definición de un intervalo de tiempo de espera</span><span class="sxs-lookup"><span data-stu-id="2cb84-263">Defining a Time-out Interval</span></span>  
 <span data-ttu-id="2cb84-264">A partir de .NET Framework 4.5, se puede establecer un valor de tiempo de espera que representa el intervalo más largo en el que el motor de expresión regular buscará una coincidencia única antes de abandonar el intento y generar una excepción <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>.</span><span class="sxs-lookup"><span data-stu-id="2cb84-264">Starting with the .NET Framework 4.5, you can set a time-out value that represents the longest interval the regular expression engine will search for a single match before it abandons the attempt and throws a <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception.</span></span> <span data-ttu-id="2cb84-265">El intervalo de tiempo de espera se especifica al proporcionar un valor <xref:System.TimeSpan> al constructor <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> para las expresiones regulares de instancias.</span><span class="sxs-lookup"><span data-stu-id="2cb84-265">You specify the time-out interval by supplying a <xref:System.TimeSpan> value to the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor for instance regular expressions.</span></span> <span data-ttu-id="2cb84-266">Además, cada método estático de coincidencia de patrones tiene una sobrecarga con un parámetro <xref:System.TimeSpan> que permite especificar un valor de tiempo de espera.</span><span class="sxs-lookup"><span data-stu-id="2cb84-266">In addition, each static pattern matching method has an overload with a <xref:System.TimeSpan> parameter that allows you to specify a time-out value.</span></span> <span data-ttu-id="2cb84-267">De forma predeterminada, el intervalo de tiempo de espera se establece en <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> y el motor de expresiones regulares no agota dicho tiempo.</span><span class="sxs-lookup"><span data-stu-id="2cb84-267">By default, the time-out interval is set to <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> and the regular expression engine does not time out.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="2cb84-268">Recomendamos que se establezca siempre un intervalo de tiempo de espera si la expresión regular se basa en el retroceso.</span><span class="sxs-lookup"><span data-stu-id="2cb84-268">We recommend that you always set a time-out interval if your regular expression relies on backtracking.</span></span>  
  
 <span data-ttu-id="2cb84-269">Una excepción <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> indica que el motor de expresiones regulares no pudo encontrar una coincidencia en el intervalo de tiempo de espera especificado, pero no indica por qué se produjo la excepción.</span><span class="sxs-lookup"><span data-stu-id="2cb84-269">A <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception indicates that the regular expression engine was unable to find a match within the specified time-out interval but does not indicate why the exception was thrown.</span></span> <span data-ttu-id="2cb84-270">La razón puede ser un retroceso excesivo, aunque también es posible que el intervalo de tiempo de espera establecido fuera demasiado bajo, dada la carga del sistema en el momento en que se produjo la excepción.</span><span class="sxs-lookup"><span data-stu-id="2cb84-270">The reason might be excessive backtracking, but it is also possible that the time-out interval was set too low given the system load at the time the exception was thrown.</span></span> <span data-ttu-id="2cb84-271">Cuando se controla la excepción, se puede elegir entre abandonar otras coincidencias con la cadena de entrada o incrementar el intervalo de tiempo de espera y reintentar la operación de coincidencia.</span><span class="sxs-lookup"><span data-stu-id="2cb84-271">When you handle the exception, you can choose to abandon further matches with the input string or increase the time-out interval and retry the matching operation.</span></span>  
  
 <span data-ttu-id="2cb84-272">Por ejemplo, el código siguiente llama al constructor <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> para crear instancias de un objeto <xref:System.Text.RegularExpressions.Regex> con un valor de tiempo de espera de un segundo.</span><span class="sxs-lookup"><span data-stu-id="2cb84-272">For example, the following code calls the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor to instantiate a <xref:System.Text.RegularExpressions.Regex> object with a time-out value of one second.</span></span> <span data-ttu-id="2cb84-273">El patrón de expresión regular `(a+)+$`, que coincide con una o más secuencias de uno o varios caracteres "a" al final de una línea, está sujeto a un retroceso excesivo.</span><span class="sxs-lookup"><span data-stu-id="2cb84-273">The regular expression pattern `(a+)+$`, which matches one or more sequences of one or more "a" characters at the end of a line, is subject to excessive backtracking.</span></span> <span data-ttu-id="2cb84-274">Si se produce una excepción <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> , el ejemplo incrementa el valor de tiempo de espera hasta un intervalo máximo de tres segundos.</span><span class="sxs-lookup"><span data-stu-id="2cb84-274">If a <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> is thrown, the example increases the time-out value up to a maximum interval of three seconds.</span></span> <span data-ttu-id="2cb84-275">Después, abandona el intento de coincidir con el patrón.</span><span class="sxs-lookup"><span data-stu-id="2cb84-275">After that, it abandons the attempt to match the pattern.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.ctor#1](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.ctor#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/vb/ctor1.vb#1)]  

### <a name="atomic-groups"></a><span data-ttu-id="2cb84-276">Grupos atómicos</span><span class="sxs-lookup"><span data-stu-id="2cb84-276">Atomic groups</span></span>
 <span data-ttu-id="2cb84-277">El elemento de lenguaje `(?>` *subexpresión*`)` suprime la vuelta atrás (backtracking) en una subexpresión.</span><span class="sxs-lookup"><span data-stu-id="2cb84-277">The `(?>` *subexpression*`)` language element suppresses backtracking into the subexpression.</span></span> <span data-ttu-id="2cb84-278">Una vez que coincida correctamente, no abandonará ninguna parte de su coincidencia a la vuelta atrás (backtracking) posterior.</span><span class="sxs-lookup"><span data-stu-id="2cb84-278">Once it has successfully matched, it will not give up any part of its match to subsequent backtracking.</span></span> <span data-ttu-id="2cb84-279">Por ejemplo, en el patrón `(?>\w*\d*)1`, si no se puede hacer coincidir `1`, `\d*` no abandonará ninguna coincidencia, aunque esto signifique que permita que `1` coincida correctamente.</span><span class="sxs-lookup"><span data-stu-id="2cb84-279">For example, in the pattern `(?>\w*\d*)1`, if the `1` cannot be matched, the `\d*` will not give up any of its match even if that means it would allow the `1` to successfully match.</span></span> <span data-ttu-id="2cb84-280">Los grupos atómicos pueden ayudar a evitar los problemas de rendimiento asociados a las coincidencias con error.</span><span class="sxs-lookup"><span data-stu-id="2cb84-280">Atomic groups can help prevent the performance problems associated with failed matches.</span></span>
  
 <span data-ttu-id="2cb84-281">En el ejemplo siguiente se muestra cómo la supresión del retroceso mejora el rendimiento cuando se usan cuantificadores anidados.</span><span class="sxs-lookup"><span data-stu-id="2cb84-281">The following example illustrates how suppressing backtracking improves performance when using nested quantifiers.</span></span> <span data-ttu-id="2cb84-282">Mide el tiempo necesario para que el motor de expresiones regulares determine que una cadena de entrada no coincide con dos expresiones regulares.</span><span class="sxs-lookup"><span data-stu-id="2cb84-282">It measures the time required for the regular expression engine to determine that an input string does not match two regular expressions.</span></span> <span data-ttu-id="2cb84-283">La primera expresión regular usa el retroceso para intentar buscar una coincidencia de una cadena que contiene una o más apariciones de uno o más dígitos hexadecimales, seguidas de un signo de dos puntos, seguido de uno o más dígitos hexadecimales, seguido de dos signos de dos puntos.</span><span class="sxs-lookup"><span data-stu-id="2cb84-283">The first regular expression uses backtracking to attempt to match a string that contains one or more occurrences of one or more hexadecimal digits, followed by a colon, followed by one or more hexadecimal digits, followed by two colons.</span></span> <span data-ttu-id="2cb84-284">La segunda expresión regular es idéntica a la primera, salvo que deshabilita el retroceso.</span><span class="sxs-lookup"><span data-stu-id="2cb84-284">The second regular expression is identical to the first, except that it disables backtracking.</span></span> <span data-ttu-id="2cb84-285">Como muestra el resultado del ejemplo, la mejora de rendimiento que supone deshabilitar el retroceso es significativa.</span><span class="sxs-lookup"><span data-stu-id="2cb84-285">As the output from the example shows, the performance improvement from disabling backtracking is significant.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking4.cs#4)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking4.vb#4)]  

### <a name="lookbehind-assertions"></a><span data-ttu-id="2cb84-286">aserciones de búsqueda tardía</span><span class="sxs-lookup"><span data-stu-id="2cb84-286">Lookbehind Assertions</span></span>  
 <span data-ttu-id="2cb84-287">.NET incluye dos elementos de lenguaje, `(?<=`*subexpresión*`)` y `(?<!`*subexpresión*`)`, que buscan una coincidencia con el carácter o los caracteres anteriores de la cadena de entrada.</span><span class="sxs-lookup"><span data-stu-id="2cb84-287">.NET includes two language elements, `(?<=`*subexpression*`)` and `(?<!`*subexpression*`)`, that match the previous character or characters in the input string.</span></span> <span data-ttu-id="2cb84-288">Ambos elementos de lenguaje son aserciones de ancho cero, es decir, determinan si el carácter o los caracteres que preceden inmediatamente al carácter actual coinciden con *subexpression*, sin avanzar o retroceder.</span><span class="sxs-lookup"><span data-stu-id="2cb84-288">Both language elements are zero-width assertions; that is, they determine whether the character or characters that immediately precede the current character can be matched by *subexpression*, without advancing or backtracking.</span></span>  
  
 <span data-ttu-id="2cb84-289">`(?<=` *subexpression* `)` es una aserción de búsqueda tardía positiva, es decir, el carácter o los caracteres situados antes de la posición actual deben coincidir con *subexpression*.</span><span class="sxs-lookup"><span data-stu-id="2cb84-289">`(?<=` *subexpression* `)` is a positive lookbehind assertion; that is, the character or characters before the current position must match *subexpression*.</span></span> <span data-ttu-id="2cb84-290">`(?<!`*subexpression*`)` es una aserción de búsqueda tardía negativa, es decir, el carácter o los caracteres situados antes de la posición actual no deben coincidir con *subexpression*.</span><span class="sxs-lookup"><span data-stu-id="2cb84-290">`(?<!`*subexpression*`)` is a negative lookbehind assertion; that is, the character or characters before the current position must not match *subexpression*.</span></span> <span data-ttu-id="2cb84-291">Tanto las aserciones de búsqueda tardía positivas como las negativas son más útiles cuando *subexpression* es un subconjunto de la subexpresión anterior.</span><span class="sxs-lookup"><span data-stu-id="2cb84-291">Both positive and negative lookbehind assertions are most useful when *subexpression* is a subset of the previous subexpression.</span></span>  
  
 <span data-ttu-id="2cb84-292">En el ejemplo siguiente se usan dos patrones de expresiones regulares equivalentes que validan el nombre de usuario de una dirección de correo electrónico.</span><span class="sxs-lookup"><span data-stu-id="2cb84-292">The following example uses two equivalent regular expression patterns that validate the user name in an email address.</span></span> <span data-ttu-id="2cb84-293">El primer patrón tiene un rendimiento bajo debido a un retroceso excesivo.</span><span class="sxs-lookup"><span data-stu-id="2cb84-293">The first pattern is subject to poor performance because of excessive backtracking.</span></span> <span data-ttu-id="2cb84-294">El segundo patrón modifica la primera expresión regular reemplazando un cuantificador anidado con una aserción de búsqueda tardía positiva.</span><span class="sxs-lookup"><span data-stu-id="2cb84-294">The second pattern modifies the first regular expression by replacing a nested quantifier with a positive lookbehind assertion.</span></span> <span data-ttu-id="2cb84-295">El resultado del ejemplo muestra el tiempo de ejecución del método <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="2cb84-295">The output from the example displays the execution time of the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking5.cs#5)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking5.vb#5)]  
  
 <span data-ttu-id="2cb84-296">El primer patrón de expresión regular, `^[0-9A-Z]([-.\w]*[0-9A-Z])*@`, se define como se muestra en la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="2cb84-296">The first regular expression pattern, `^[0-9A-Z]([-.\w]*[0-9A-Z])*@`, is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="2cb84-297">Modelo</span><span class="sxs-lookup"><span data-stu-id="2cb84-297">Pattern</span></span>|<span data-ttu-id="2cb84-298">Descripción</span><span class="sxs-lookup"><span data-stu-id="2cb84-298">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="2cb84-299">Iniciar la búsqueda de coincidencias en el principio de la cadena.</span><span class="sxs-lookup"><span data-stu-id="2cb84-299">Start the match at the beginning of the string.</span></span>|  
|`[0-9A-Z]`|<span data-ttu-id="2cb84-300">Buscar coincidencias de un carácter alfanumérico.</span><span class="sxs-lookup"><span data-stu-id="2cb84-300">Match an alphanumeric character.</span></span> <span data-ttu-id="2cb84-301">Esta comparación no distingue mayúsculas de minúsculas, ya que se llama al método <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> con la opción <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="2cb84-301">This comparison is case-insensitive, because the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option.</span></span>|  
|`[-.\w]*`|<span data-ttu-id="2cb84-302">Buscar coincidencias con cero, una o más apariciones de un guión, un punto o un carácter alfabético.</span><span class="sxs-lookup"><span data-stu-id="2cb84-302">Match zero, one, or more occurrences of a hyphen, period, or word character.</span></span>|  
|`[0-9A-Z]`|<span data-ttu-id="2cb84-303">Buscar coincidencias de un carácter alfanumérico.</span><span class="sxs-lookup"><span data-stu-id="2cb84-303">Match an alphanumeric character.</span></span>|  
|`([-.\w]*[0-9A-Z])*`|<span data-ttu-id="2cb84-304">Buscar coincidencias con cero o más apariciones de la combinación de cero o más guiones, puntos o caracteres alfabéticos, seguidos de un carácter alfanumérico.</span><span class="sxs-lookup"><span data-stu-id="2cb84-304">Match zero or more occurrences of the combination of zero or more hyphens, periods, or word characters, followed by an alphanumeric character.</span></span> <span data-ttu-id="2cb84-305">Este es el primer grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="2cb84-305">This is the first capturing group.</span></span>|  
|`@`|<span data-ttu-id="2cb84-306">Buscar coincidencias con un signo ("\@").</span><span class="sxs-lookup"><span data-stu-id="2cb84-306">Match an at sign ("\@").</span></span>|  
  
 <span data-ttu-id="2cb84-307">El segundo patrón de expresión regular, `^[0-9A-Z][-.\w]*(?<=[0-9A-Z])@`, emplea una aserción de búsqueda tardía positiva.</span><span class="sxs-lookup"><span data-stu-id="2cb84-307">The second regular expression pattern, `^[0-9A-Z][-.\w]*(?<=[0-9A-Z])@`, uses a positive lookbehind assertion.</span></span> <span data-ttu-id="2cb84-308">Se define como se muestra en la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="2cb84-308">It is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="2cb84-309">Modelo</span><span class="sxs-lookup"><span data-stu-id="2cb84-309">Pattern</span></span>|<span data-ttu-id="2cb84-310">Descripción</span><span class="sxs-lookup"><span data-stu-id="2cb84-310">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="2cb84-311">Iniciar la búsqueda de coincidencias en el principio de la cadena.</span><span class="sxs-lookup"><span data-stu-id="2cb84-311">Start the match at the beginning of the string.</span></span>|  
|`[0-9A-Z]`|<span data-ttu-id="2cb84-312">Buscar coincidencias de un carácter alfanumérico.</span><span class="sxs-lookup"><span data-stu-id="2cb84-312">Match an alphanumeric character.</span></span> <span data-ttu-id="2cb84-313">Esta comparación no distingue mayúsculas de minúsculas, ya que se llama al método <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> con la opción <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="2cb84-313">This comparison is case-insensitive, because the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option.</span></span>|  
|`[-.\w]*`|<span data-ttu-id="2cb84-314">Buscar coincidencias con cero o más apariciones de un guión, un punto o un carácter alfabético.</span><span class="sxs-lookup"><span data-stu-id="2cb84-314">Match zero or more occurrences of a hyphen, period, or word character.</span></span>|  
|`(?<=[0-9A-Z])`|<span data-ttu-id="2cb84-315">Volver a examinar el último carácter coincidente y continuar con la coincidencia si es alfanumérica.</span><span class="sxs-lookup"><span data-stu-id="2cb84-315">Look back at the last matched character and continue the match if it is alphanumeric.</span></span> <span data-ttu-id="2cb84-316">Tenga en cuenta que los caracteres alfanuméricos son un subconjunto del conjunto formado por puntos, guiones y todos los caracteres alfabéticos.</span><span class="sxs-lookup"><span data-stu-id="2cb84-316">Note that alphanumeric characters are a subset of the set that consists of periods, hyphens, and all word characters.</span></span>|  
|`@`|<span data-ttu-id="2cb84-317">Buscar coincidencias con un signo ("\@").</span><span class="sxs-lookup"><span data-stu-id="2cb84-317">Match an at sign ("\@").</span></span>|  

### <a name="lookahead-assertions"></a><span data-ttu-id="2cb84-318">aserciones de búsqueda anticipada</span><span class="sxs-lookup"><span data-stu-id="2cb84-318">Lookahead Assertions</span></span>  
 <span data-ttu-id="2cb84-319">.NET incluye dos elementos de lenguaje, `(?=`*subexpresión*`)` y `(?!`*subexpresión*`)`, que buscan una coincidencia con el carácter o los caracteres siguientes de la cadena de entrada.</span><span class="sxs-lookup"><span data-stu-id="2cb84-319">.NET includes two language elements, `(?=`*subexpression*`)` and `(?!`*subexpression*`)`, that match the next character or characters in the input string.</span></span> <span data-ttu-id="2cb84-320">Ambos elementos de lenguaje son aserciones de ancho cero, es decir, determinan si el carácter o los caracteres que siguen inmediatamente al carácter actual coinciden con *subexpression*, sin avanzar o retroceder.</span><span class="sxs-lookup"><span data-stu-id="2cb84-320">Both language elements are zero-width assertions; that is, they determine whether the character or characters that immediately follow the current character can be matched by *subexpression*, without advancing or backtracking.</span></span>  
  
 <span data-ttu-id="2cb84-321">`(?=` *subexpression* `)` es una aserción de búsqueda anticipada positiva, es decir, el carácter o los caracteres situados después de la posición actual deben coincidir con *subexpression*.</span><span class="sxs-lookup"><span data-stu-id="2cb84-321">`(?=` *subexpression* `)` is a positive lookahead assertion; that is, the character or characters after the current position must match *subexpression*.</span></span> <span data-ttu-id="2cb84-322">`(?!`*subexpression*`)` es una aserción de búsqueda anticipada negativa, es decir, el carácter o los caracteres situados después de la posición actual no deben coincidir con *subexpression*.</span><span class="sxs-lookup"><span data-stu-id="2cb84-322">`(?!`*subexpression*`)` is a negative lookahead assertion; that is, the character or characters after the current position must not match *subexpression*.</span></span> <span data-ttu-id="2cb84-323">Tanto las aserciones de búsqueda anticipada positivas como las negativas son más útiles cuando *subexpression* es un subconjunto de la siguiente subexpresión.</span><span class="sxs-lookup"><span data-stu-id="2cb84-323">Both positive and negative lookahead assertions are most useful when *subexpression* is a subset of the next subexpression.</span></span>  
  
 <span data-ttu-id="2cb84-324">En el ejemplo siguiente se usan dos patrones de expresiones regulares que validan un nombre de tipo completo.</span><span class="sxs-lookup"><span data-stu-id="2cb84-324">The following example uses two equivalent regular expression patterns that validate a fully qualified type name.</span></span> <span data-ttu-id="2cb84-325">El primer patrón tiene un rendimiento bajo debido a un retroceso excesivo.</span><span class="sxs-lookup"><span data-stu-id="2cb84-325">The first pattern is subject to poor performance because of excessive backtracking.</span></span> <span data-ttu-id="2cb84-326">El segundo modifica la primera expresión regular reemplazando un cuantificador anidado con una aserción de búsqueda anticipada positiva.</span><span class="sxs-lookup"><span data-stu-id="2cb84-326">The second modifies the first regular expression by replacing a nested quantifier with a positive lookahead assertion.</span></span> <span data-ttu-id="2cb84-327">El resultado del ejemplo muestra el tiempo de ejecución del método <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="2cb84-327">The output from the example displays the execution time of the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking6.cs#6)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking6.vb#6)]  
  
 <span data-ttu-id="2cb84-328">El primer patrón de expresión regular, `^(([A-Z]\w*)+\.)*[A-Z]\w*$`, se define como se muestra en la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="2cb84-328">The first regular expression pattern, `^(([A-Z]\w*)+\.)*[A-Z]\w*$`, is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="2cb84-329">Modelo</span><span class="sxs-lookup"><span data-stu-id="2cb84-329">Pattern</span></span>|<span data-ttu-id="2cb84-330">Descripción</span><span class="sxs-lookup"><span data-stu-id="2cb84-330">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="2cb84-331">Iniciar la búsqueda de coincidencias en el principio de la cadena.</span><span class="sxs-lookup"><span data-stu-id="2cb84-331">Start the match at the beginning of the string.</span></span>|  
|`([A-Z]\w*)+\.`|<span data-ttu-id="2cb84-332">Buscar coincidencias con un carácter alfabético (A-Z) seguido de cero o más caracteres alfabéticos una o más veces, seguidas de un punto.</span><span class="sxs-lookup"><span data-stu-id="2cb84-332">Match an alphabetical character (A-Z) followed by zero or more word characters one or more times, followed by a period.</span></span> <span data-ttu-id="2cb84-333">Esta comparación no distingue mayúsculas de minúsculas, ya que se llama al método <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> con la opción <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="2cb84-333">This comparison is case-insensitive, because the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option.</span></span>|  
|`(([A-Z]\w*)+\.)*`|<span data-ttu-id="2cb84-334">Buscar coincidencias con el patrón anterior cero o más veces.</span><span class="sxs-lookup"><span data-stu-id="2cb84-334">Match the previous pattern zero or more times.</span></span>|  
|`[A-Z]\w*`|<span data-ttu-id="2cb84-335">Buscar coincidencias con un carácter alfabético seguido de cero o más caracteres alfabéticos.</span><span class="sxs-lookup"><span data-stu-id="2cb84-335">Match an alphabetical character followed by zero or more word characters.</span></span>|  
|`$`|<span data-ttu-id="2cb84-336">Finalizar la búsqueda de coincidencias al final de la cadena de entrada.</span><span class="sxs-lookup"><span data-stu-id="2cb84-336">End the match at the end of the input string.</span></span>|  
  
 <span data-ttu-id="2cb84-337">El segundo patrón de expresión regular, `^((?=[A-Z])\w+\.)*[A-Z]\w*$`, emplea una aserción de búsqueda anticipada positiva.</span><span class="sxs-lookup"><span data-stu-id="2cb84-337">The second regular expression pattern, `^((?=[A-Z])\w+\.)*[A-Z]\w*$`, uses a positive lookahead assertion.</span></span> <span data-ttu-id="2cb84-338">Se define como se muestra en la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="2cb84-338">It is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="2cb84-339">Modelo</span><span class="sxs-lookup"><span data-stu-id="2cb84-339">Pattern</span></span>|<span data-ttu-id="2cb84-340">Descripción</span><span class="sxs-lookup"><span data-stu-id="2cb84-340">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="2cb84-341">Iniciar la búsqueda de coincidencias en el principio de la cadena.</span><span class="sxs-lookup"><span data-stu-id="2cb84-341">Start the match at the beginning of the string.</span></span>|  
|`(?=[A-Z])`|<span data-ttu-id="2cb84-342">Examinar hacia delante el primer carácter y continuar la búsqueda de coincidencias si es alfabético (A-Z).</span><span class="sxs-lookup"><span data-stu-id="2cb84-342">Look ahead to the first character and continue the match if it is alphabetical (A-Z).</span></span> <span data-ttu-id="2cb84-343">Esta comparación no distingue mayúsculas de minúsculas, ya que se llama al método <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> con la opción <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="2cb84-343">This comparison is case-insensitive, because the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option.</span></span>|  
|`\w+\.`|<span data-ttu-id="2cb84-344">Buscar coincidencias con uno o más caracteres alfabéticos seguidos de un punto.</span><span class="sxs-lookup"><span data-stu-id="2cb84-344">Match one or more word characters followed by a period.</span></span>|  
|`((?=[A-Z])\w+\.)*`|<span data-ttu-id="2cb84-345">Buscar coincidencias con el patrón de uno o varios caracteres alfabéticos seguidos de un punto una o varias veces.</span><span class="sxs-lookup"><span data-stu-id="2cb84-345">Match the pattern of one or more word characters followed by a period zero or more times.</span></span> <span data-ttu-id="2cb84-346">El carácter alfabético inicial debe ser alfabético.</span><span class="sxs-lookup"><span data-stu-id="2cb84-346">The initial word character must be alphabetical.</span></span>|  
|`[A-Z]\w*`|<span data-ttu-id="2cb84-347">Buscar coincidencias con un carácter alfabético seguido de cero o más caracteres alfabéticos.</span><span class="sxs-lookup"><span data-stu-id="2cb84-347">Match an alphabetical character followed by zero or more word characters.</span></span>|  
|`$`|<span data-ttu-id="2cb84-348">Finalizar la búsqueda de coincidencias al final de la cadena de entrada.</span><span class="sxs-lookup"><span data-stu-id="2cb84-348">End the match at the end of the input string.</span></span>|  
  
## <a name="see-also"></a><span data-ttu-id="2cb84-349">Vea también</span><span class="sxs-lookup"><span data-stu-id="2cb84-349">See also</span></span>

- [<span data-ttu-id="2cb84-350">Expresiones regulares de .NET</span><span class="sxs-lookup"><span data-stu-id="2cb84-350">.NET Regular Expressions</span></span>](../../../docs/standard/base-types/regular-expressions.md)
- [<span data-ttu-id="2cb84-351">Lenguaje de expresiones regulares: referencia rápida</span><span class="sxs-lookup"><span data-stu-id="2cb84-351">Regular Expression Language - Quick Reference</span></span>](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)
- [<span data-ttu-id="2cb84-352">Cuantificadores</span><span class="sxs-lookup"><span data-stu-id="2cb84-352">Quantifiers</span></span>](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md)
- [<span data-ttu-id="2cb84-353">Construcciones de alternancia</span><span class="sxs-lookup"><span data-stu-id="2cb84-353">Alternation Constructs</span></span>](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md)
- [<span data-ttu-id="2cb84-354">Construcciones de agrupamiento</span><span class="sxs-lookup"><span data-stu-id="2cb84-354">Grouping Constructs</span></span>](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md)
