---
title: Procedimientos recomendados con expresiones regulares en .NET
description: Obtenga información sobre cómo crear expresiones regulares eficaces y efectivas en .NET.
ms.date: 06/30/2020
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- .NET Framework regular expressions, best practices
- regular expressions, best practices
ms.assetid: 618e5afb-3a97-440d-831a-70e4c526a51c
ms.openlocfilehash: 03eda8a419dc60c75576e15da9b3595274894c75
ms.sourcegitcommit: 27a15a55019f6b5f2733961738babe94aec0def3
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 09/15/2020
ms.locfileid: "90554585"
---
# <a name="best-practices-for-regular-expressions-in-net"></a><span data-ttu-id="be03e-103">Procedimientos recomendados con expresiones regulares en .NET</span><span class="sxs-lookup"><span data-stu-id="be03e-103">Best practices for regular expressions in .NET</span></span>

<span data-ttu-id="be03e-104">El motor de expresiones regulares de .NET es una herramienta eficaz y completa que procesa texto basándose en coincidencias de patrones en lugar de comparar y buscar coincidencias con texto literal.</span><span class="sxs-lookup"><span data-stu-id="be03e-104">The regular expression engine in .NET is a powerful, full-featured tool that processes text based on pattern matches rather than on comparing and matching literal text.</span></span> <span data-ttu-id="be03e-105">En la mayoría de los casos, realiza la coincidencia de modelos de manera rápida y eficaz.</span><span class="sxs-lookup"><span data-stu-id="be03e-105">In most cases, it performs pattern matching rapidly and efficiently.</span></span> <span data-ttu-id="be03e-106">Sin embargo, en algunos casos, puede parecer que el motor de expresiones regulares es muy lento.</span><span class="sxs-lookup"><span data-stu-id="be03e-106">However, in some cases, the regular expression engine can appear to be very slow.</span></span> <span data-ttu-id="be03e-107">En casos extremos, incluso puede parecer que deja de responder mientras procesa una entrada relativamente pequeña a lo largo de las horas o incluso los días.</span><span class="sxs-lookup"><span data-stu-id="be03e-107">In extreme cases, it can even appear to stop responding as it processes a relatively small input over the course of hours or even days.</span></span>

<span data-ttu-id="be03e-108">En este tema se describen algunos de los procedimientos recomendados que los desarrolladores pueden adoptar para garantizar que sus expresiones regulares alcancen un rendimiento óptimo.</span><span class="sxs-lookup"><span data-stu-id="be03e-108">This topic outlines some of the best practices that developers can adopt to ensure that their regular expressions achieve optimal performance.</span></span>

[!INCLUDE [regex](../../../includes/regex.md)]

## <a name="consider-the-input-source"></a><span data-ttu-id="be03e-109">Considerar el origen de entrada</span><span class="sxs-lookup"><span data-stu-id="be03e-109">Consider the input source</span></span>

<span data-ttu-id="be03e-110">En general, las expresiones regulares pueden aceptar dos tipos de datos de entrada: restringidos o sin restricciones.</span><span class="sxs-lookup"><span data-stu-id="be03e-110">In general, regular expressions can accept two types of input: constrained or unconstrained.</span></span> <span data-ttu-id="be03e-111">La entrada restringida es texto que se origina en una fuente conocida o confiable y sigue un formato predefinido.</span><span class="sxs-lookup"><span data-stu-id="be03e-111">Constrained input is text that originates from a known or reliable source and follows a predefined format.</span></span> <span data-ttu-id="be03e-112">La entrada sin restricciones es texto que se origina en un origen no confiable, como un usuario web, y puede no seguir un formato predefinido o esperado.</span><span class="sxs-lookup"><span data-stu-id="be03e-112">Unconstrained input is text that originates from an unreliable source, such as a web user, and may not follow a predefined or expected format.</span></span>

<span data-ttu-id="be03e-113">Los patrones de expresiones regulares se suelen escribir para buscar coincidencias con entradas válidas.</span><span class="sxs-lookup"><span data-stu-id="be03e-113">Regular expression patterns are typically written to match valid input.</span></span> <span data-ttu-id="be03e-114">Es decir, los desarrolladores examinan el texto que desean buscar y escriben un patrón de expresión regular que coincida con él.</span><span class="sxs-lookup"><span data-stu-id="be03e-114">That is, developers examine the text that they want to match and then write a regular expression pattern that matches it.</span></span> <span data-ttu-id="be03e-115">A continuación, los desarrolladores determinan si este patrón necesita alguna corrección o algún procesamiento adicional probándolo con varios elementos de entrada válidos.</span><span class="sxs-lookup"><span data-stu-id="be03e-115">Developers then determine whether this pattern requires correction or further elaboration by testing it with multiple valid input items.</span></span> <span data-ttu-id="be03e-116">Cuando el modelo coincide con todas las entradas válidas previstas, se declara que está listo para producción y se puede incluir en una aplicación comercial.</span><span class="sxs-lookup"><span data-stu-id="be03e-116">When the pattern matches all presumed valid inputs, it is declared to be production-ready and can be included in a released application.</span></span> <span data-ttu-id="be03e-117">Esto hace que un patrón de expresión regular sea adecuado para entradas restringidas coincidentes.</span><span class="sxs-lookup"><span data-stu-id="be03e-117">This makes a regular expression pattern suitable for matching constrained input.</span></span> <span data-ttu-id="be03e-118">Sin embargo, no es adecuado para datos de entrada sin restricciones coincidentes.</span><span class="sxs-lookup"><span data-stu-id="be03e-118">However, it does not make it suitable for matching unconstrained input.</span></span>

<span data-ttu-id="be03e-119">Para buscar coincidencias con datos de entrada sin restricciones, una expresión regular debe poder administrar eficazmente tres clases de texto:</span><span class="sxs-lookup"><span data-stu-id="be03e-119">To match unconstrained input, a regular expression must be able to efficiently handle three kinds of text:</span></span>

- <span data-ttu-id="be03e-120">Texto que coincide con el patrón de expresión regular.</span><span class="sxs-lookup"><span data-stu-id="be03e-120">Text that matches the regular expression pattern.</span></span>

- <span data-ttu-id="be03e-121">Texto que no coincide con el patrón de expresión regular.</span><span class="sxs-lookup"><span data-stu-id="be03e-121">Text that does not match the regular expression pattern.</span></span>

- <span data-ttu-id="be03e-122">Texto que casi coincide con el patrón de expresión regular.</span><span class="sxs-lookup"><span data-stu-id="be03e-122">Text that nearly matches the regular expression pattern.</span></span>

<span data-ttu-id="be03e-123">El último tipo de texto es especialmente problemático para una expresión regular que se ha escrito para tratar datos de entrada restringidos.</span><span class="sxs-lookup"><span data-stu-id="be03e-123">The last text type is especially problematic for a regular expression that has been written to handle constrained input.</span></span> <span data-ttu-id="be03e-124">Si esa expresión regular también usa mucho [retroceso](backtracking-in-regular-expressions.md), el motor de expresiones regulares puede dedicar una cantidad de tiempo excesiva (en algunos casos, muchas horas o días) procesando texto aparentemente inofensivo.</span><span class="sxs-lookup"><span data-stu-id="be03e-124">If that regular expression also relies on extensive [backtracking](backtracking-in-regular-expressions.md), the regular expression engine can spend an inordinate amount of time (in some cases, many hours or days) processing seemingly innocuous text.</span></span>

> [!WARNING]
> <span data-ttu-id="be03e-125">En el ejemplo siguiente se utiliza una expresión regular que es propensa a un retroceso excesivo y que es probable que rechace direcciones de correo electrónico válidas.</span><span class="sxs-lookup"><span data-stu-id="be03e-125">The following example uses a regular expression that is prone to excessive backtracking and that is likely to reject valid email addresses.</span></span> <span data-ttu-id="be03e-126">No debería utilizarse en una rutina de validación de correo electrónico.</span><span class="sxs-lookup"><span data-stu-id="be03e-126">You should not use it in an email validation routine.</span></span> <span data-ttu-id="be03e-127">Si desea que una expresión regular valide las direcciones de correo electrónico, vea [Procedimiento: Comprobación de que las cadenas están en un formato de correo electrónico válido](how-to-verify-that-strings-are-in-valid-email-format.md).</span><span class="sxs-lookup"><span data-stu-id="be03e-127">If you would like a regular expression that validates email addresses, see [How to: Verify that Strings Are in Valid Email Format](how-to-verify-that-strings-are-in-valid-email-format.md).</span></span>

<span data-ttu-id="be03e-128">Por ejemplo, considere una expresión regular de uso muy frecuente pero sumamente problemática para validar el alias de una dirección de correo electrónico.</span><span class="sxs-lookup"><span data-stu-id="be03e-128">For example, consider a very commonly used but extremely problematic regular expression for validating the alias of an email address.</span></span> <span data-ttu-id="be03e-129">Se escribe la expresión regular `^[0-9A-Z]([-.\w]*[0-9A-Z])*$` para procesar qué se considera una dirección de correo electrónico válida, que consta de un carácter alfanumérico seguido de cero o más caracteres que pueden ser alfanuméricos, puntos o guiones.</span><span class="sxs-lookup"><span data-stu-id="be03e-129">The regular expression `^[0-9A-Z]([-.\w]*[0-9A-Z])*$` is written to process what is considered to be a valid email address, which consists of an alphanumeric character, followed by zero or more characters that can be alphanumeric, periods, or hyphens.</span></span> <span data-ttu-id="be03e-130">La expresión regular debe finalizar con un carácter alfanumérico.</span><span class="sxs-lookup"><span data-stu-id="be03e-130">The regular expression must end with an alphanumeric character.</span></span> <span data-ttu-id="be03e-131">Sin embargo, como se muestra en el ejemplo siguiente, aunque esta expresión regular trata la entrada válida fácilmente, su rendimiento es muy ineficaz cuando está procesando datos de entrada casi válidos.</span><span class="sxs-lookup"><span data-stu-id="be03e-131">However, as the following example shows, although this regular expression handles valid input easily, its performance is very inefficient when it is processing nearly valid input.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/design2.cs#1)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/design2.vb#1)]

<span data-ttu-id="be03e-132">Como muestra el resultado del ejemplo, el motor de expresiones regulares procesa el alias válido de correo electrónico casi en el mismo intervalo de tiempo independientemente de su longitud.</span><span class="sxs-lookup"><span data-stu-id="be03e-132">As the output from the example shows, the regular expression engine processes the valid email alias in about the same time interval regardless of its length.</span></span> <span data-ttu-id="be03e-133">Por otra parte, cuando la dirección de correo electrónico casi válida tiene más de cinco caracteres, el tiempo de procesamiento se duplica aproximadamente por cada carácter de la cadena.</span><span class="sxs-lookup"><span data-stu-id="be03e-133">On the other hand, when the nearly valid email address has more than five characters, processing time approximately doubles for each additional character in the string.</span></span> <span data-ttu-id="be03e-134">Esto significa que una cadena casi válida de 28 caracteres tardaría más de una hora en procesarse y una cadena casi válida de 33 caracteres tardaría casi un día en procesarse.</span><span class="sxs-lookup"><span data-stu-id="be03e-134">This means that a nearly valid 28-character string would take over an hour to process, and a nearly valid 33-character string would take nearly a day to process.</span></span>

<span data-ttu-id="be03e-135">Como esta expresión regular se desarrolló teniendo en cuenta solamente el formato de entrada que había que hacer coincidir, no tiene en cuenta los datos de entrada que no coinciden con el patrón.</span><span class="sxs-lookup"><span data-stu-id="be03e-135">Because this regular expression was developed solely by considering the format of input to be matched, it fails to take account of input that does not match the pattern.</span></span> <span data-ttu-id="be03e-136">A su vez, esto puede permitir que unos datos de entrada sin restricciones que casi coinciden con el patrón de expresión regular reduzcan considerablemente el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="be03e-136">This, in turn, can allow unconstrained input that nearly matches the regular expression pattern to significantly degrade performance.</span></span>

<span data-ttu-id="be03e-137">Para resolver este problema, puede hacer lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="be03e-137">To solve this problem, you can do the following:</span></span>

- <span data-ttu-id="be03e-138">A la hora de desarrollar un modelo, debe considerar cómo puede afectar el retroceso al rendimiento del motor de expresiones regulares, especialmente si la expresión regular está diseñada para procesar datos de entrada sin restricciones.</span><span class="sxs-lookup"><span data-stu-id="be03e-138">When developing a pattern, you should consider how backtracking might affect the performance of the regular expression engine, particularly if your regular expression is designed to process unconstrained input.</span></span> <span data-ttu-id="be03e-139">Para obtener más información, consulte la sección [Controlar el retroceso](#take-charge-of-backtracking).</span><span class="sxs-lookup"><span data-stu-id="be03e-139">For more information, see the [Take Charge of Backtracking](#take-charge-of-backtracking) section.</span></span>

- <span data-ttu-id="be03e-140">Probar exhaustivamente la expresión regular usando datos de entrada no válidos y casi válidos, así como datos de entrada válidos.</span><span class="sxs-lookup"><span data-stu-id="be03e-140">Thoroughly test your regular expression using invalid and near-valid input as well as valid input.</span></span> <span data-ttu-id="be03e-141">Para generar de forma aleatoria la entrada para una expresión regular determinada, puede usar [Rex](https://www.microsoft.com/research/project/rex-regular-expression-exploration/), que es una herramienta de exploración de expresiones regulares de Microsoft Research.</span><span class="sxs-lookup"><span data-stu-id="be03e-141">To generate input for a particular regular expression randomly, you can use [Rex](https://www.microsoft.com/research/project/rex-regular-expression-exploration/), which is a regular expression exploration tool from Microsoft Research.</span></span>

## <a name="handle-object-instantiation-appropriately"></a><span data-ttu-id="be03e-142">Controlar la creación de instancias de objeto correctamente</span><span class="sxs-lookup"><span data-stu-id="be03e-142">Handle object instantiation appropriately</span></span>

<span data-ttu-id="be03e-143">El núcleo del modelo de objetos de expresiones regulares de .NET es la clase <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType>, que representa el motor de expresiones regulares.</span><span class="sxs-lookup"><span data-stu-id="be03e-143">At the heart of .NET’s regular expression object model is the <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> class, which represents the regular expression engine.</span></span> <span data-ttu-id="be03e-144">A menudo, el mayor factor único que afecta al rendimiento de las expresiones regulares es la manera en que se emplea el motor de <xref:System.Text.RegularExpressions.Regex>.</span><span class="sxs-lookup"><span data-stu-id="be03e-144">Often, the single greatest factor that affects regular expression performance is the way in which the <xref:System.Text.RegularExpressions.Regex> engine is used.</span></span> <span data-ttu-id="be03e-145">La definición de una expresión regular implica acoplar estrechamente el motor de expresiones regulares con un patrón de expresión regular.</span><span class="sxs-lookup"><span data-stu-id="be03e-145">Defining a regular expression involves tightly coupling the regular expression engine with a regular expression pattern.</span></span> <span data-ttu-id="be03e-146">Ese proceso de acoplamiento, tanto si consiste en crear una instancia de un objeto <xref:System.Text.RegularExpressions.Regex> pasando a su constructor una expresión regular como en llamar a un método estático pasándole el patrón de expresión regular junto con la cadena que se va a analizar, es necesariamente costoso.</span><span class="sxs-lookup"><span data-stu-id="be03e-146">That coupling process, whether it involves instantiating a <xref:System.Text.RegularExpressions.Regex> object by passing its constructor a regular expression pattern or calling a static method by passing it the regular expression pattern along with the string to be analyzed, is by necessity an expensive one.</span></span>

> [!NOTE]
> <span data-ttu-id="be03e-147">Para obtener una explicación más detallada de las implicaciones sobre el rendimiento de usar expresiones regulares interpretadas y compiladas, vea [Optimizing Regular Expression Performance, Part II: (Optimización del rendimiento de expresiones regulares, Parte II: Control del retroceso](/archive/blogs/bclteam/optimizing-regular-expression-performance-part-ii-taking-charge-of-backtracking-ron-petrusha)) en el blog del equipo de BCL.</span><span class="sxs-lookup"><span data-stu-id="be03e-147">For a more detailed discussion of the performance implications of using interpreted and compiled regular expressions, see [Optimizing Regular Expression Performance, Part II: Taking Charge of Backtracking](/archive/blogs/bclteam/optimizing-regular-expression-performance-part-ii-taking-charge-of-backtracking-ron-petrusha) in the BCL Team blog.</span></span>

<span data-ttu-id="be03e-148">Puede acoplar el motor de expresiones regulares con un determinado patrón de expresión regular y, a continuación, usar el motor para buscar coincidencias con texto de varias maneras:</span><span class="sxs-lookup"><span data-stu-id="be03e-148">You can couple the regular expression engine with a particular regular expression pattern and then use the engine to match text in several ways:</span></span>

- <span data-ttu-id="be03e-149">Puede llamar a un método estático de coincidencia de patrones como <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="be03e-149">You can call a static pattern-matching method, such as <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="be03e-150">Para ello no es necesario crear instancias de un objeto de expresión regular.</span><span class="sxs-lookup"><span data-stu-id="be03e-150">This does not require instantiation of a regular expression object.</span></span>

- <span data-ttu-id="be03e-151">Puede crear instancias de un objeto <xref:System.Text.RegularExpressions.Regex> y llamar a una instancia de un método de coincidencia de modelos de una expresión regular interpretada.</span><span class="sxs-lookup"><span data-stu-id="be03e-151">You can instantiate a <xref:System.Text.RegularExpressions.Regex> object and call an instance pattern-matching method of an interpreted regular expression.</span></span> <span data-ttu-id="be03e-152">Este es el método predeterminado para enlazar el motor de expresiones regulares a un patrón de expresión regular.</span><span class="sxs-lookup"><span data-stu-id="be03e-152">This is the default method for binding the regular expression engine to a regular expression pattern.</span></span> <span data-ttu-id="be03e-153">Se produce cuando se crea una instancia de un objeto <xref:System.Text.RegularExpressions.Regex> sin un argumento `options` que incluya la marca <xref:System.Text.RegularExpressions.RegexOptions.Compiled>.</span><span class="sxs-lookup"><span data-stu-id="be03e-153">It results when a <xref:System.Text.RegularExpressions.Regex> object is instantiated without an `options` argument that includes the <xref:System.Text.RegularExpressions.RegexOptions.Compiled> flag.</span></span>

- <span data-ttu-id="be03e-154">Puede crear instancias de un objeto <xref:System.Text.RegularExpressions.Regex> y llamar a una instancia de un método de coincidencia de modelos de una expresión regular compilada.</span><span class="sxs-lookup"><span data-stu-id="be03e-154">You can instantiate a <xref:System.Text.RegularExpressions.Regex> object and call an instance pattern-matching method of a compiled regular expression.</span></span> <span data-ttu-id="be03e-155">Los objetos de expresiones regulares representan modelos compilados cuando se crea una instancia de un objeto <xref:System.Text.RegularExpressions.Regex> con un argumento `options` que incluye la marca <xref:System.Text.RegularExpressions.RegexOptions.Compiled>.</span><span class="sxs-lookup"><span data-stu-id="be03e-155">Regular expression objects represent compiled patterns when a <xref:System.Text.RegularExpressions.Regex> object is instantiated with an `options` argument that includes the <xref:System.Text.RegularExpressions.RegexOptions.Compiled> flag.</span></span>

- <span data-ttu-id="be03e-156">Puede crear un objeto <xref:System.Text.RegularExpressions.Regex> especial que esté acoplado estrechamente con un determinado patrón de expresión regular, compilarlo y guardarlo en un ensamblado independiente.</span><span class="sxs-lookup"><span data-stu-id="be03e-156">You can create a special-purpose <xref:System.Text.RegularExpressions.Regex> object that is tightly coupled with a particular regular expression pattern, compile it, and save it to a standalone assembly.</span></span> <span data-ttu-id="be03e-157">Puede hacerlo llamando al método <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="be03e-157">You do this by calling the <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="be03e-158">La forma de llamar a los métodos de coincidencia de expresiones regulares puede tener un impacto significativo en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="be03e-158">The particular way in which you call regular expression matching methods can have a significant impact on your application.</span></span> <span data-ttu-id="be03e-159">En las próximas secciones se explica cómo usar llamadas a métodos estáticos, expresiones regulares interpretadas y expresiones regulares compiladas para mejorar el rendimiento de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="be03e-159">The following sections discuss when to use static method calls, interpreted regular expressions, and compiled regular expressions to improve your application's performance.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="be03e-160">El formato de la llamada al método (estático, interpretado o compilado) afecta al rendimiento si la misma expresión regular se usa repetidamente en llamadas a métodos o si una aplicación usa muchos objetos de expresiones regulares.</span><span class="sxs-lookup"><span data-stu-id="be03e-160">The form of the method call (static, interpreted, compiled) affects performance if the same regular expression is used repeatedly in method calls, or if an application makes extensive use of regular expression objects.</span></span>

### <a name="static-regular-expressions"></a><span data-ttu-id="be03e-161">Expresiones regulares estáticas</span><span class="sxs-lookup"><span data-stu-id="be03e-161">Static regular expressions</span></span>

<span data-ttu-id="be03e-162">Se recomienda el uso de métodos de expresiones regulares estáticas como alternativa a crear repetidamente instancias de un objeto de expresión regular con la misma expresión regular.</span><span class="sxs-lookup"><span data-stu-id="be03e-162">Static regular expression methods are recommended as an alternative to repeatedly instantiating a regular expression object with the same regular expression.</span></span> <span data-ttu-id="be03e-163">A diferencia de los patrones de expresiones regulares usados por los objetos de expresiones regulares, el motor de expresiones regulares almacena internamente en memoria caché los códigos de operación o el lenguaje intermedio de Microsoft (MSIL) compilado de los patrones empleados en las llamadas al método estático.</span><span class="sxs-lookup"><span data-stu-id="be03e-163">Unlike regular expression patterns used by regular expression objects, either the operation codes or the compiled Microsoft intermediate language (MSIL) from patterns used in static method calls is cached internally by the regular expression engine.</span></span>

<span data-ttu-id="be03e-164">Por ejemplo, un controlador de eventos llama con frecuencia a otro método para validar los datos proporcionados por el usuario.</span><span class="sxs-lookup"><span data-stu-id="be03e-164">For example, an event handler frequently calls another method to validate user input.</span></span> <span data-ttu-id="be03e-165">Esto se refleja en el código siguiente, en el que se usa el evento <xref:System.Windows.Forms.Button> de un control <xref:System.Windows.Forms.Control.Click> para llamar a un método denominado `IsValidCurrency`, que comprueba si el usuario ha escrito un símbolo de moneda seguido al menos de un dígito decimal.</span><span class="sxs-lookup"><span data-stu-id="be03e-165">This is reflected in the following code, in which a <xref:System.Windows.Forms.Button> control's <xref:System.Windows.Forms.Control.Click> event is used to call a method named `IsValidCurrency`, which checks whether the user has entered a currency symbol followed by at least one decimal digit.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/static1.cs#2)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/static1.vb#2)]

<span data-ttu-id="be03e-166">En el ejemplo siguiente se muestra una implementación muy poco eficaz del método `IsValidCurrency`.</span><span class="sxs-lookup"><span data-stu-id="be03e-166">A very inefficient implementation of the `IsValidCurrency` method is shown in the following example.</span></span> <span data-ttu-id="be03e-167">Observe que cada llamada al método vuelve a crear una instancia de un objeto <xref:System.Text.RegularExpressions.Regex> con el mismo modelo.</span><span class="sxs-lookup"><span data-stu-id="be03e-167">Note that each method call reinstantiates a <xref:System.Text.RegularExpressions.Regex> object with the same pattern.</span></span> <span data-ttu-id="be03e-168">Esto, a su vez, significa que el patrón de expresión regular se debe volver a compilar cada vez que se llama al método.</span><span class="sxs-lookup"><span data-stu-id="be03e-168">This, in turn, means that the regular expression pattern must be recompiled each time the method is called.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/static1.cs#3)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/static1.vb#3)]

<span data-ttu-id="be03e-169">Debe reemplazar este código ineficaz con una llamada al método estático <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="be03e-169">You should replace this inefficient code with a call to the static <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="be03e-170">Esto elimina la necesidad de crear instancias de un objeto <xref:System.Text.RegularExpressions.Regex> cada vez que desea llamar a un método de coincidencia de modelos y permite que el motor de expresiones regulares recupere una versión compilada de la expresión regular de su memoria caché.</span><span class="sxs-lookup"><span data-stu-id="be03e-170">This eliminates the need to instantiate a <xref:System.Text.RegularExpressions.Regex> object each time you want to call a pattern-matching method, and enables the regular expression engine to retrieve a compiled version of the regular expression from its cache.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/static2.cs#4)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/static2.vb#4)]

<span data-ttu-id="be03e-171">De forma predeterminada, se almacenan en caché los 15 últimos patrones de expresiones regulares estáticas usados recientemente.</span><span class="sxs-lookup"><span data-stu-id="be03e-171">By default, the last 15 most recently used static regular expression patterns are cached.</span></span> <span data-ttu-id="be03e-172">En el caso de las aplicaciones que necesitan un mayor número de expresiones regulares estáticas almacenadas en caché, el tamaño de la memoria caché se puede ajustar estableciendo la propiedad <xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="be03e-172">For applications that require a larger number of cached static regular expressions, the size of the cache can be adjusted by setting the <xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType> property.</span></span>

<span data-ttu-id="be03e-173">La expresión regular `\p{Sc}+\s*\d+` que se usa en este ejemplo comprueba que la cadena de entrada consta de un símbolo de moneda y al menos un dígito decimal.</span><span class="sxs-lookup"><span data-stu-id="be03e-173">The regular expression `\p{Sc}+\s*\d+` that is used in this example verifies that the input string consists of a currency symbol and at least one decimal digit.</span></span> <span data-ttu-id="be03e-174">El patrón se define como se muestra en la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="be03e-174">The pattern is defined as shown in the following table.</span></span>

|<span data-ttu-id="be03e-175">Modelo</span><span class="sxs-lookup"><span data-stu-id="be03e-175">Pattern</span></span>|<span data-ttu-id="be03e-176">Descripción</span><span class="sxs-lookup"><span data-stu-id="be03e-176">Description</span></span>|
|-------------|-----------------|
|`\p{Sc}+`|<span data-ttu-id="be03e-177">Buscar coincidencias con uno o más caracteres de la categoría Símbolo Unicode, Moneda.</span><span class="sxs-lookup"><span data-stu-id="be03e-177">Match one or more characters in the Unicode Symbol, Currency category.</span></span>|
|`\s*`|<span data-ttu-id="be03e-178">Busca coincidencias con cero o más caracteres de espacio en blanco.</span><span class="sxs-lookup"><span data-stu-id="be03e-178">Match zero or more white-space characters.</span></span>|
|`\d+`|<span data-ttu-id="be03e-179">Buscar coincidencias con uno o más dígitos decimales.</span><span class="sxs-lookup"><span data-stu-id="be03e-179">Match one or more decimal digits.</span></span>|

### <a name="interpreted-vs-compiled-regular-expressions"></a><span data-ttu-id="be03e-180">Expresiones regulares interpretadas y compiladas</span><span class="sxs-lookup"><span data-stu-id="be03e-180">Interpreted vs. compiled regular expressions</span></span>

<span data-ttu-id="be03e-181">Los patrones de expresiones regulares que no están enlazados al motor de expresiones regulares mediante la especificación de la opción <xref:System.Text.RegularExpressions.RegexOptions.Compiled> se interpretan.</span><span class="sxs-lookup"><span data-stu-id="be03e-181">Regular expression patterns that are not bound to the regular expression engine through the specification of the <xref:System.Text.RegularExpressions.RegexOptions.Compiled> option are interpreted.</span></span> <span data-ttu-id="be03e-182">Cuando se crea una instancia de un objeto de expresión regular, el motor de expresiones regulares convierte la expresión regular en un conjunto de códigos de operación.</span><span class="sxs-lookup"><span data-stu-id="be03e-182">When a regular expression object is instantiated, the regular expression engine converts the regular expression to a set of operation codes.</span></span> <span data-ttu-id="be03e-183">Cuando se llama a un método de instancia, el compilador JIT ejecuta y convierte a MSIL los códigos de operación.</span><span class="sxs-lookup"><span data-stu-id="be03e-183">When an instance method is called, the operation codes are converted to MSIL and executed by the JIT compiler.</span></span> <span data-ttu-id="be03e-184">Del mismo modo, cuando se llama a un método estático de expresión regular y la expresión regular no se encuentra en la memoria caché, el motor de expresiones regulares convierte la expresión regular en un conjunto de códigos de operación y los almacena en memoria caché.</span><span class="sxs-lookup"><span data-stu-id="be03e-184">Similarly, when a static regular expression method is called and the regular expression cannot be found in the cache, the regular expression engine converts the regular expression to a set of operation codes and stores them in the cache.</span></span> <span data-ttu-id="be03e-185">A continuación, convierte estos códigos de operación a MSIL para que el compilador JIT pueda ejecutarlos.</span><span class="sxs-lookup"><span data-stu-id="be03e-185">It then converts these operation codes to MSIL so that the JIT compiler can execute them.</span></span> <span data-ttu-id="be03e-186">Las expresiones regulares interpretadas reducen el tiempo de inicio a costa de un tiempo de ejecución más lento.</span><span class="sxs-lookup"><span data-stu-id="be03e-186">Interpreted regular expressions reduce startup time at the cost of slower execution time.</span></span> <span data-ttu-id="be03e-187">Por eso, son más adecuadas cuando la expresión regular se usa en un número reducido de llamadas a métodos o si el número exacto de llamadas a métodos de expresión regular es desconocido pero se espera que sea pequeño.</span><span class="sxs-lookup"><span data-stu-id="be03e-187">Because of this, they are best used when the regular expression is used in a small number of method calls, or if the exact number of calls to regular expression methods is unknown but is expected to be small.</span></span> <span data-ttu-id="be03e-188">A medida que aumenta el número de llamadas al método, la mejora de rendimiento del tiempo de inicio reducido queda oscurecida por una velocidad de ejecución más lenta.</span><span class="sxs-lookup"><span data-stu-id="be03e-188">As the number of method calls increases, the performance gain from reduced startup time is outstripped by the slower execution speed.</span></span>

<span data-ttu-id="be03e-189">Los patrones de expresiones regulares que están enlazados al motor de expresiones regulares mediante la especificación de la opción <xref:System.Text.RegularExpressions.RegexOptions.Compiled> se compilan.</span><span class="sxs-lookup"><span data-stu-id="be03e-189">Regular expression patterns that are bound to the regular expression engine through the specification of the <xref:System.Text.RegularExpressions.RegexOptions.Compiled> option are compiled.</span></span> <span data-ttu-id="be03e-190">Esto significa que, cuando se crea una instancia de un objeto de expresión regular, o cuando se llama a un método estático de expresión regular y la expresión regular no se encuentra en la memoria caché, el motor de expresiones regulares convierte la expresión regular a un conjunto intermedio de códigos de operación que, a continuación, convierte a MSIL.</span><span class="sxs-lookup"><span data-stu-id="be03e-190">This means that, when a regular expression object is instantiated, or when a static regular expression method is called and the regular expression cannot be found in the cache, the regular expression engine converts the regular expression to an intermediary set of operation codes, which it then converts to MSIL.</span></span> <span data-ttu-id="be03e-191">Cuando se llama a un método, el compilador JIT ejecuta el código MSIL.</span><span class="sxs-lookup"><span data-stu-id="be03e-191">When a method is called, the JIT compiler executes the MSIL.</span></span> <span data-ttu-id="be03e-192">A diferencia de las expresiones regulares interpretadas, las expresiones regulares compiladas aumentan el tiempo de inicio pero ejecutan más deprisa los métodos individuales de coincidencia de patrones.</span><span class="sxs-lookup"><span data-stu-id="be03e-192">In contrast to interpreted regular expressions, compiled regular expressions increase startup time but execute individual pattern-matching methods faster.</span></span> <span data-ttu-id="be03e-193">Por tanto, la ventaja de rendimiento resultante de compilar la expresión regular aumenta en proporción al número de métodos de expresiones regulares llamados.</span><span class="sxs-lookup"><span data-stu-id="be03e-193">As a result, the performance benefit that results from compiling the regular expression increases in proportion to the number of regular expression methods called.</span></span>

<span data-ttu-id="be03e-194">En resumen, se recomienda usar expresiones regulares interpretadas al llamar a métodos de expresión regular con una expresión regular concreta con poca frecuencia relativamente.</span><span class="sxs-lookup"><span data-stu-id="be03e-194">To summarize, we recommend that you use interpreted regular expressions when you call regular expression methods with a specific regular expression relatively infrequently.</span></span> <span data-ttu-id="be03e-195">Debe usar expresiones regulares compiladas al llamar a métodos de expresión regular con una expresión regular concreta con relativa frecuencia.</span><span class="sxs-lookup"><span data-stu-id="be03e-195">You should use compiled regular expressions when you call regular expression methods with a specific regular expression relatively frequently.</span></span> <span data-ttu-id="be03e-196">Es difícil determinar el umbral exacto en el que las velocidades de ejecución más lentas de las expresiones regulares interpretadas superan las mejoras de su menor tiempo de inicio, o el umbral en el que los tiempos de inicio más lentos de las expresiones regulares compiladas superan las mejoras de sus velocidades de ejecución más rápidas.</span><span class="sxs-lookup"><span data-stu-id="be03e-196">The exact threshold at which the slower execution speeds of interpreted regular expressions outweigh gains from their reduced startup time, or the threshold at which the slower startup times of compiled regular expressions outweigh gains from their faster execution speeds, is difficult to determine.</span></span> <span data-ttu-id="be03e-197">Depende de diversos factores, como la complejidad de la expresión regular y los datos específicos que procesa.</span><span class="sxs-lookup"><span data-stu-id="be03e-197">It depends on a variety of factors, including the complexity of the regular expression and the specific data that it processes.</span></span> <span data-ttu-id="be03e-198">Para determinar si las expresiones regulares interpretadas o compiladas ofrecen el mejor rendimiento para su escenario de aplicación concreto, puede usar la clase <xref:System.Diagnostics.Stopwatch> para comparar sus tiempos de ejecución.</span><span class="sxs-lookup"><span data-stu-id="be03e-198">To determine whether interpreted or compiled regular expressions offer the best performance for your particular application scenario, you can use the <xref:System.Diagnostics.Stopwatch> class to compare their execution times.</span></span>

<span data-ttu-id="be03e-199">En el ejemplo siguiente, se compara el rendimiento de las expresiones regulares compiladas e interpretadas al leer las diez primeras frases y al leer todas las frases del texto *The Financier* de Theodore Dreiser.</span><span class="sxs-lookup"><span data-stu-id="be03e-199">The following example compares the performance of compiled and interpreted regular expressions when reading the first ten sentences and when reading all the sentences in the text of Theodore Dreiser's *The Financier*.</span></span> <span data-ttu-id="be03e-200">Como muestra el resultado del ejemplo, cuando solo se realizan diez llamadas a métodos de coincidencia de expresión regular, una expresión regular interpreta proporciona un rendimiento mejor que una expresión regular compilada.</span><span class="sxs-lookup"><span data-stu-id="be03e-200">As the output from the example shows, when only ten calls are made to regular expression matching methods, an interpreted regular expression offers better performance than a compiled regular expression.</span></span> <span data-ttu-id="be03e-201">Sin embargo, una expresión regular compilada ofrece mejor rendimiento cuando se realiza un gran número de llamadas (en este caso, más de 13000).</span><span class="sxs-lookup"><span data-stu-id="be03e-201">However, a compiled regular expression offers better performance when a large number of calls (in this case, over 13,000) are made.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/compare1.cs#5)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/compare1.vb#5)]

<span data-ttu-id="be03e-202">El patrón de expresión regular usado en el ejemplo, `\b(\w+((\r?\n)|,?\s))*\w+[.?:;!]`, se define como se muestra en la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="be03e-202">The regular expression pattern used in the example, `\b(\w+((\r?\n)|,?\s))*\w+[.?:;!]`, is defined as shown in the following table.</span></span>

|<span data-ttu-id="be03e-203">Modelo</span><span class="sxs-lookup"><span data-stu-id="be03e-203">Pattern</span></span>|<span data-ttu-id="be03e-204">Descripción</span><span class="sxs-lookup"><span data-stu-id="be03e-204">Description</span></span>|
|-------------|-----------------|
|`\b`|<span data-ttu-id="be03e-205">Iniciar la búsqueda de coincidencias en un límite de palabras.</span><span class="sxs-lookup"><span data-stu-id="be03e-205">Begin the match at a word boundary.</span></span>|
|`\w+`|<span data-ttu-id="be03e-206">Buscar coincidencias con uno o más caracteres alfabéticos.</span><span class="sxs-lookup"><span data-stu-id="be03e-206">Match one or more word characters.</span></span>|
|<code>(\r?\n)&#124;,?\s)</code>|<span data-ttu-id="be03e-207">Buscar una coincidencia con cero o un retorno de carro seguido de un carácter de nueva línea, o cero o una coma seguida de un carácter de espacio en blanco.</span><span class="sxs-lookup"><span data-stu-id="be03e-207">Match either zero or one carriage return followed by a newline character, or zero or one comma followed by a white-space character.</span></span>|
|<code>(\w+((\r?\n)&#124;,?\s))*</code>|<span data-ttu-id="be03e-208">Buscar coincidencias con cero o más apariciones de uno o más caracteres alfabéticos que van seguidos de cero o un retorno de carro y un carácter de nueva línea, o de cero o una coma seguida de un carácter de espacio en blanco.</span><span class="sxs-lookup"><span data-stu-id="be03e-208">Match zero or more occurrences of one or more word characters that are followed either by zero or one carriage return and a newline character, or by zero or one comma followed by a white-space character.</span></span>|
|`\w+`|<span data-ttu-id="be03e-209">Buscar coincidencias con uno o más caracteres alfabéticos.</span><span class="sxs-lookup"><span data-stu-id="be03e-209">Match one or more word characters.</span></span>|
|`[.?:;!]`|<span data-ttu-id="be03e-210">Buscar una coincidencia con un punto, un signo de interrogación, dos puntos, punto y coma o un signo de exclamación.</span><span class="sxs-lookup"><span data-stu-id="be03e-210">Match a period, question mark, colon, semicolon, or exclamation point.</span></span>|

### <a name="regular-expressions-compiled-to-an-assembly"></a><span data-ttu-id="be03e-211">Expresiones regulares: compiladas en un ensamblado</span><span class="sxs-lookup"><span data-stu-id="be03e-211">Regular expressions: Compiled to an assembly</span></span>

<span data-ttu-id="be03e-212">.NET también permite crear un ensamblado que contenga expresiones regulares compiladas.</span><span class="sxs-lookup"><span data-stu-id="be03e-212">.NET also enables you to create an assembly that contains compiled regular expressions.</span></span> <span data-ttu-id="be03e-213">Esto lleva la merma de rendimiento de la compilación de la expresión regular del tiempo de ejecución al tiempo de diseño.</span><span class="sxs-lookup"><span data-stu-id="be03e-213">This moves the performance hit of regular expression compilation from run time to design time.</span></span> <span data-ttu-id="be03e-214">Aunque también implica cierto trabajo adicional: Hay que definir las expresiones regulares de antemano y compilarlas en un ensamblado.</span><span class="sxs-lookup"><span data-stu-id="be03e-214">However, it also involves some additional work: You must define the regular expressions in advance and compile them to an assembly.</span></span> <span data-ttu-id="be03e-215">El compilador puede hacer referencia a este ensamblado al compilar código fuente que usa expresiones regulares del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="be03e-215">The compiler can then reference this assembly when compiling source code that uses the assembly’s regular expressions.</span></span> <span data-ttu-id="be03e-216">Cada expresión regular compilada del ensamblado está representada por una clase que se deriva de <xref:System.Text.RegularExpressions.Regex>.</span><span class="sxs-lookup"><span data-stu-id="be03e-216">Each compiled regular expression in the assembly is represented by a class that derives from <xref:System.Text.RegularExpressions.Regex>.</span></span>

<span data-ttu-id="be03e-217">Para compilar expresiones regulares en un ensamblado, se llama al método <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29?displayProperty=nameWithType> y se le pasa una matriz de objetos <xref:System.Text.RegularExpressions.RegexCompilationInfo> que representan las expresiones regulares que se van a compilar y un objeto <xref:System.Reflection.AssemblyName> que contiene información sobre el ensamblado que se va a crear.</span><span class="sxs-lookup"><span data-stu-id="be03e-217">To compile regular expressions to an assembly, you call the <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29?displayProperty=nameWithType> method and pass it an array of <xref:System.Text.RegularExpressions.RegexCompilationInfo> objects that represent the regular expressions to be compiled, and an <xref:System.Reflection.AssemblyName> object that contains information about the assembly to be created.</span></span>

<span data-ttu-id="be03e-218">Se recomienda compilar expresiones regulares en un ensamblado en las situaciones siguientes:</span><span class="sxs-lookup"><span data-stu-id="be03e-218">We recommend that you compile regular expressions to an assembly in the following situations:</span></span>

- <span data-ttu-id="be03e-219">Si es un desarrollador de componentes que desea crear una biblioteca de expresiones regulares reutilizables.</span><span class="sxs-lookup"><span data-stu-id="be03e-219">If you are a component developer who wants to create a library of reusable regular expressions.</span></span>

- <span data-ttu-id="be03e-220">Si espera que los métodos de coincidencia de modelos de la expresión regular se llamen un número indeterminado de veces, desde una o dos veces hasta miles o decenas de miles de veces.</span><span class="sxs-lookup"><span data-stu-id="be03e-220">If you expect your regular expression's pattern-matching methods to be called an indeterminate number of times -- anywhere from once or twice to thousands or tens of thousands of times.</span></span> <span data-ttu-id="be03e-221">A diferencia de las expresiones regulares compiladas o interpretadas, las expresiones regulares que se compilan en ensamblados independientes proporcionan un rendimiento coherente independientemente del número de llamadas a métodos.</span><span class="sxs-lookup"><span data-stu-id="be03e-221">Unlike compiled or interpreted regular expressions, regular expressions that are compiled to separate assemblies offer performance that is consistent regardless of the number of method calls.</span></span>

<span data-ttu-id="be03e-222">Si emplea expresiones regulares compiladas para optimizar el rendimiento, no debe usar la reflexión para crear el ensamblado, cargar el motor de expresiones regulares y ejecutar sus métodos de coincidencia con modelos.</span><span class="sxs-lookup"><span data-stu-id="be03e-222">If you are using compiled regular expressions to optimize performance, you should not use reflection to create the assembly, load the regular expression engine, and execute its pattern-matching methods.</span></span> <span data-ttu-id="be03e-223">Para ello es necesario evitar la creación dinámica de expresiones regulares y especificar cualquier opción de coincidencia de modelos (como la coincidencia de modelos sin distinción entre mayúsculas y minúsculas) en el momento en que se crea el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="be03e-223">This requires that you avoid building regular expression patterns dynamically, and that you specify any pattern-matching options (such as case-insensitive pattern matching) at the time the assembly is created.</span></span> <span data-ttu-id="be03e-224">También debe separar el código que crea el ensamblado del código que usa la expresión regular.</span><span class="sxs-lookup"><span data-stu-id="be03e-224">It also requires that you separate the code that creates the assembly from the code that uses the regular expression.</span></span>

<span data-ttu-id="be03e-225">En el ejemplo siguiente se muestra cómo crear un ensamblado que contiene una expresión regular compilada.</span><span class="sxs-lookup"><span data-stu-id="be03e-225">The following example shows how to create an assembly that contains a compiled regular expression.</span></span> <span data-ttu-id="be03e-226">Crea un ensamblado denominado `RegexLib.dll` con una única clase de expresión regular, `SentencePattern`, que contiene el patrón de expresión regular de coincidencia con frases usado en la sección [Expresiones regulares interpretadas frente a expresiones regulares compiladas](#interpreted-vs-compiled-regular-expressions).</span><span class="sxs-lookup"><span data-stu-id="be03e-226">It creates an assembly named `RegexLib.dll` with a single regular expression class, `SentencePattern`, that contains the sentence-matching regular expression pattern used in the [Interpreted vs. Compiled Regular Expressions](#interpreted-vs-compiled-regular-expressions) section.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/compile1.cs#6)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/compile1.vb#6)]

<span data-ttu-id="be03e-227">Cuando el ejemplo se compila en un ejecutable y se ejecuta, crea un ensamblado denominado `RegexLib.dll`.</span><span class="sxs-lookup"><span data-stu-id="be03e-227">When the example is compiled to an executable and run, it creates an assembly named `RegexLib.dll`.</span></span> <span data-ttu-id="be03e-228">La expresión regular se representa mediante una clase denominada `Utilities.RegularExpressions.SentencePattern` que se deriva de <xref:System.Text.RegularExpressions.Regex>.</span><span class="sxs-lookup"><span data-stu-id="be03e-228">The regular expression is represented by a class named `Utilities.RegularExpressions.SentencePattern` that is derived from <xref:System.Text.RegularExpressions.Regex>.</span></span> <span data-ttu-id="be03e-229">En el ejemplo siguiente, se usa después la expresión regular compilada para extraer las frases del texto *The Financier* de Theodore Dreiser.</span><span class="sxs-lookup"><span data-stu-id="be03e-229">The following example then uses the compiled regular expression to extract the sentences from the text of Theodore Dreiser's *The Financier*.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/compile2.cs#7)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/compile2.vb#7)]

## <a name="take-charge-of-backtracking"></a><span data-ttu-id="be03e-230">Controlar el retroceso</span><span class="sxs-lookup"><span data-stu-id="be03e-230">Take charge of backtracking</span></span>

<span data-ttu-id="be03e-231">Normalmente, el motor de expresiones regulares usa la progresión lineal para desplazarse a través de una cadena de entrada y compararla con un patrón de expresión regular.</span><span class="sxs-lookup"><span data-stu-id="be03e-231">Ordinarily, the regular expression engine uses linear progression to move through an input string and compare it to a regular expression pattern.</span></span> <span data-ttu-id="be03e-232">Sin embargo, cuando en un patrón de expresión regular se usan cuantificadores indeterminados como `*`, `+` y`?`, el motor de expresiones regulares puede abandonar una parte de las coincidencias parciales correctas y volver a un estado guardado previamente para buscar una coincidencia correcta de todo el patron.</span><span class="sxs-lookup"><span data-stu-id="be03e-232">However, when indeterminate quantifiers such as `*`, `+`, and `?` are used in a regular expression pattern, the regular expression engine may give up a portion of successful partial matches and return to a previously saved state in order to search for a successful match for the entire pattern.</span></span> <span data-ttu-id="be03e-233">Este proceso se denomina retroceso.</span><span class="sxs-lookup"><span data-stu-id="be03e-233">This process is known as backtracking.</span></span>

> [!NOTE]
> <span data-ttu-id="be03e-234">Para obtener más información acerca del retroceso, consulte [Detalles del comportamiento de expresiones regulares](details-of-regular-expression-behavior.md) y [Retroceso](backtracking-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="be03e-234">For more information on backtracking, see [Details of Regular Expression Behavior](details-of-regular-expression-behavior.md) and [Backtracking](backtracking-in-regular-expressions.md).</span></span> <span data-ttu-id="be03e-235">Para obtener una explicación detallada del retroceso, vea [Optimizing Regular Expression Performance, Part II: (Optimización del rendimiento de expresiones regulares, Parte II: Control del retroceso](/archive/blogs/bclteam/optimizing-regular-expression-performance-part-ii-taking-charge-of-backtracking-ron-petrusha)) en el blog del equipo de BCL.</span><span class="sxs-lookup"><span data-stu-id="be03e-235">For a detailed discussion of backtracking, see [Optimizing Regular Expression Performance, Part II: Taking Charge of Backtracking](/archive/blogs/bclteam/optimizing-regular-expression-performance-part-ii-taking-charge-of-backtracking-ron-petrusha) in the BCL Team blog.</span></span>

<span data-ttu-id="be03e-236">La compatibilidad con el retroceso aporta a las expresiones regulares eficacia y flexibilidad.</span><span class="sxs-lookup"><span data-stu-id="be03e-236">Support for backtracking gives regular expressions power and flexibility.</span></span> <span data-ttu-id="be03e-237">También deja la responsabilidad de controlar el funcionamiento del motor de expresiones regulares en manos de los desarrolladores de expresiones regulares.</span><span class="sxs-lookup"><span data-stu-id="be03e-237">It also places the responsibility for controlling the operation of the regular expression engine in the hands of regular expression developers.</span></span> <span data-ttu-id="be03e-238">Puesto que los desarrolladores no suelen ser conscientes de esta responsabilidad, su uso incorrecto del retroceso o su dependencia de un retroceso excesivo suele desempeñar el rol más significativo en la degradación del rendimiento de las expresiones regulares.</span><span class="sxs-lookup"><span data-stu-id="be03e-238">Because developers are often not aware of this responsibility, their misuse of backtracking or reliance on excessive backtracking often plays the most significant role in degrading regular expression performance.</span></span> <span data-ttu-id="be03e-239">En un escenario de caso peor, el tiempo de ejecución puede duplicarse por cada carácter adicional de la cadena de entrada.</span><span class="sxs-lookup"><span data-stu-id="be03e-239">In a worst-case scenario, execution time can double for each additional character in the input string.</span></span> <span data-ttu-id="be03e-240">De hecho, usando excesivamente el retroceso, es fácil crear el equivalente en programación de un bucle infinito si la entrada coincide casi con el patrón de expresiones regulares; el motor de expresiones regulares puede tardar horas o incluso días en procesar una cadena de entrada relativamente corta.</span><span class="sxs-lookup"><span data-stu-id="be03e-240">In fact, by using backtracking excessively, it is easy to create the programmatic equivalent of an endless loop if input nearly matches the regular expression pattern; the regular expression engine may take hours or even days to process a relatively short input string.</span></span>

<span data-ttu-id="be03e-241">A menudo, las aplicaciones sufren una reducción del rendimiento por usar el retroceso a pesar de que el retroceso no es esencial para una coincidencia.</span><span class="sxs-lookup"><span data-stu-id="be03e-241">Often, applications pay a performance penalty for using backtracking despite the fact that backtracking is not essential for a match.</span></span> <span data-ttu-id="be03e-242">Por ejemplo, la expresión regular `\b\p{Lu}\w*\b` busca una coincidencia con todas las palabras que comienzan por un carácter en mayúsculas, como se muestra en la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="be03e-242">For example, the regular expression `\b\p{Lu}\w*\b` matches all words that begin with an uppercase character, as the following table shows.</span></span>

|<span data-ttu-id="be03e-243">Modelo</span><span class="sxs-lookup"><span data-stu-id="be03e-243">Pattern</span></span>|<span data-ttu-id="be03e-244">Descripción</span><span class="sxs-lookup"><span data-stu-id="be03e-244">Description</span></span>|
|-|-|
|`\b`|<span data-ttu-id="be03e-245">Iniciar la búsqueda de coincidencias en un límite de palabras.</span><span class="sxs-lookup"><span data-stu-id="be03e-245">Begin the match at a word boundary.</span></span>|
|`\p{Lu}`|<span data-ttu-id="be03e-246">Busca una coincidencia con un carácter en mayúsculas.</span><span class="sxs-lookup"><span data-stu-id="be03e-246">Match an uppercase character.</span></span>|
|`\w*`|<span data-ttu-id="be03e-247">Buscar una coincidencia con cero o más caracteres alfabéticos.</span><span class="sxs-lookup"><span data-stu-id="be03e-247">Match zero or more word characters.</span></span>|
|`\b`|<span data-ttu-id="be03e-248">Finalizar la búsqueda de coincidencias en un límite de palabras.</span><span class="sxs-lookup"><span data-stu-id="be03e-248">End the match at a word boundary.</span></span>|

<span data-ttu-id="be03e-249">Puesto que un límite de palabra no es igual, o un subconjunto de, que un carácter alfabético, no hay ninguna posibilidad de que el motor de expresiones regulares cruce un límite de palabra cuando busca coincidencias con caracteres alfabéticos.</span><span class="sxs-lookup"><span data-stu-id="be03e-249">Because a word boundary is not the same as, or a subset of, a word character, there is no possibility that the regular expression engine will cross a word boundary when matching word characters.</span></span> <span data-ttu-id="be03e-250">Esto significa que para esta expresión regular, el retroceso nunca puede contribuir al éxito global de cualquier coincidencia; solo puede degradar el rendimiento, ya que se fuerza que el motor de expresiones regulares guarde su estado para cada coincidencia preliminar correcta de un carácter alfabético.</span><span class="sxs-lookup"><span data-stu-id="be03e-250">This means that for this regular expression, backtracking can never contribute to the overall success of any match -- it can only degrade performance, because the regular expression engine is forced to save its state for each successful preliminary match of a word character.</span></span>

<span data-ttu-id="be03e-251">Si determina que la vuelta atrás (backtracking) no es necesaria, puede deshabilitarla mediante el elemento de lenguaje `(?>subexpression)`, conocido como grupo atómico.</span><span class="sxs-lookup"><span data-stu-id="be03e-251">If you determine that backtracking is not necessary, you can disable it by using the `(?>subexpression)` language element, known as an atomic group.</span></span> <span data-ttu-id="be03e-252">En el ejemplo siguiente se analiza una cadena de entrada usando dos expresiones regulares.</span><span class="sxs-lookup"><span data-stu-id="be03e-252">The following example parses an input string by using two regular expressions.</span></span> <span data-ttu-id="be03e-253">La primera, `\b\p{Lu}\w*\b`, se basa en el retroceso.</span><span class="sxs-lookup"><span data-stu-id="be03e-253">The first, `\b\p{Lu}\w*\b`, relies on backtracking.</span></span> <span data-ttu-id="be03e-254">La segunda, `\b\p{Lu}(?>\w*)\b`, deshabilita el retroceso.</span><span class="sxs-lookup"><span data-stu-id="be03e-254">The second, `\b\p{Lu}(?>\w*)\b`, disables backtracking.</span></span> <span data-ttu-id="be03e-255">Como muestra el resultado del ejemplo, ambas producen el mismo resultado.</span><span class="sxs-lookup"><span data-stu-id="be03e-255">As the output from the example shows, they both produce the same result.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#10](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/backtrack2.cs#10)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/backtrack2.vb#10)]

<span data-ttu-id="be03e-256">En muchos casos, el retroceso es esencial para buscar una coincidencia de un patrón de expresión regular con el texto de entrada.</span><span class="sxs-lookup"><span data-stu-id="be03e-256">In many cases, backtracking is essential for matching a regular expression pattern to input text.</span></span> <span data-ttu-id="be03e-257">Sin embargo, el retroceso excesivo puede degradar gravemente el rendimiento y dar la impresión de que una aplicación ha dejado de responder.</span><span class="sxs-lookup"><span data-stu-id="be03e-257">However, excessive backtracking can severely degrade performance and create the impression that an application has stopped responding.</span></span> <span data-ttu-id="be03e-258">En concreto, esto ocurre cuando se anidan los cuantificadores y el texto que coincide con la subexpresión externa es un subconjunto del texto que coincide con la subexpresión interna.</span><span class="sxs-lookup"><span data-stu-id="be03e-258">In particular, this happens when quantifiers are nested and the text that matches the outer subexpression is a subset of the text that matches the inner subexpression.</span></span>

> [!WARNING]
> <span data-ttu-id="be03e-259">Además de evitar el retroceso excesivo, se debe utilizar la característica de tiempo de espera para garantizar que el retroceso excesivo no reduzca gravemente el rendimiento de la expresión regular.</span><span class="sxs-lookup"><span data-stu-id="be03e-259">In addition to avoiding excessive backtracking, you should use the timeout feature to ensure that excessive backtracking does not severely degrade regular expression performance.</span></span> <span data-ttu-id="be03e-260">Para obtener más información, consulte la sección [Usar valores de tiempo de espera](#use-time-out-values).</span><span class="sxs-lookup"><span data-stu-id="be03e-260">For more information, see the [Use Time-out Values](#use-time-out-values) section.</span></span>

<span data-ttu-id="be03e-261">Por ejemplo, el patrón de expresión regular `^[0-9A-Z]([-.\w]*[0-9A-Z])*\$$` está diseñado para buscar coincidencias con un número de pieza que contiene al menos un carácter alfanumérico.</span><span class="sxs-lookup"><span data-stu-id="be03e-261">For example, the regular expression pattern `^[0-9A-Z]([-.\w]*[0-9A-Z])*\$$` is intended to match a part number that consists of at least one alphanumeric character.</span></span> <span data-ttu-id="be03e-262">Cualquier carácter adicional puede constar de un carácter alfanumérico, un guión, un carácter de subrayado o un punto, aunque el último carácter debe ser alfanumérico.</span><span class="sxs-lookup"><span data-stu-id="be03e-262">Any additional characters can consist of an alphanumeric character, a hyphen, an underscore, or a period, though the last character must be alphanumeric.</span></span> <span data-ttu-id="be03e-263">El número de pieza termina con un signo de dólar.</span><span class="sxs-lookup"><span data-stu-id="be03e-263">A dollar sign terminates the part number.</span></span> <span data-ttu-id="be03e-264">En algunos casos, este patrón de expresión regular puede presentar un rendimiento muy deficiente porque los cuantificadores están anidados y porque la subexpresión `[0-9A-Z]` es un subconjunto de la subexpresión `[-.\w]*`.</span><span class="sxs-lookup"><span data-stu-id="be03e-264">In some cases, this regular expression pattern can exhibit extremely poor performance because quantifiers are nested, and because the subexpression `[0-9A-Z]` is a subset of the subexpression `[-.\w]*`.</span></span>

<span data-ttu-id="be03e-265">En estos casos, puede optimizar el rendimiento de la expresión regular quitando los cuantificadores anidados y reemplazando la subexpresión externa con una aserción de búsqueda anticipada o de búsqueda tardía de ancho cero.</span><span class="sxs-lookup"><span data-stu-id="be03e-265">In these cases, you can optimize regular expression performance by removing the nested quantifiers and replacing the outer subexpression with a zero-width lookahead or lookbehind assertion.</span></span> <span data-ttu-id="be03e-266">Las aserciones de búsqueda anticipada y de búsqueda tardía son delimitadores; no mueven el puntero en la cadena de entrada, sino que realizan una búsqueda hacia delante o hacia atrás para comprobar si se cumple una condición especificada.</span><span class="sxs-lookup"><span data-stu-id="be03e-266">Lookahead and lookbehind assertions are anchors; they do not move the pointer in the input string, but instead look ahead or behind to check whether a specified condition is met.</span></span> <span data-ttu-id="be03e-267">Por ejemplo, la expresión regular de número de pieza se puede volver a escribir como `^[0-9A-Z][-.\w]*(?<=[0-9A-Z])\$$`.</span><span class="sxs-lookup"><span data-stu-id="be03e-267">For example, the part number regular expression can be rewritten as `^[0-9A-Z][-.\w]*(?<=[0-9A-Z])\$$`.</span></span> <span data-ttu-id="be03e-268">Este patrón de expresión regular se define como se muestra en la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="be03e-268">This regular expression pattern is defined as shown in the following table.</span></span>

|<span data-ttu-id="be03e-269">Modelo</span><span class="sxs-lookup"><span data-stu-id="be03e-269">Pattern</span></span>|<span data-ttu-id="be03e-270">Descripción</span><span class="sxs-lookup"><span data-stu-id="be03e-270">Description</span></span>|
|-------------|-----------------|
|`^`|<span data-ttu-id="be03e-271">Iniciar la búsqueda de coincidencias con el principio de la cadena de entrada.</span><span class="sxs-lookup"><span data-stu-id="be03e-271">Begin the match at the beginning of the input string.</span></span>|
|`[0-9A-Z]`|<span data-ttu-id="be03e-272">Buscar coincidencias de un carácter alfanumérico.</span><span class="sxs-lookup"><span data-stu-id="be03e-272">Match an alphanumeric character.</span></span> <span data-ttu-id="be03e-273">El número de pieza debe constar al menos de este carácter.</span><span class="sxs-lookup"><span data-stu-id="be03e-273">The part number must consist of at least this character.</span></span>|
|`[-.\w]*`|<span data-ttu-id="be03e-274">Buscar coincidencias con cero o más apariciones de cualquier carácter alfabético, guión o punto.</span><span class="sxs-lookup"><span data-stu-id="be03e-274">Match zero or more occurrences of any word character, hyphen, or period.</span></span>|
|`\$`|<span data-ttu-id="be03e-275">Buscar coincidencias con un signo de dólar.</span><span class="sxs-lookup"><span data-stu-id="be03e-275">Match a dollar sign.</span></span>|
|`(?<=[0-9A-Z])`|<span data-ttu-id="be03e-276">Realizar una búsqueda anticipada del signo de dólar final para asegurarse de que el carácter anterior es alfanumérico.</span><span class="sxs-lookup"><span data-stu-id="be03e-276">Look ahead of the ending dollar sign to ensure that the previous character is alphanumeric.</span></span>|
|`$`|<span data-ttu-id="be03e-277">Finalizar la búsqueda de coincidencias al final de la cadena de entrada.</span><span class="sxs-lookup"><span data-stu-id="be03e-277">End the match at the end of the input string.</span></span>|

<span data-ttu-id="be03e-278">En el ejemplo siguiente se muestra el uso de esta expresión regular para encontrar una matriz que contiene los números de pieza posibles.</span><span class="sxs-lookup"><span data-stu-id="be03e-278">The following example illustrates the use of this regular expression to match an array containing possible part numbers.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#11](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/backtrack4.cs#11)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#11](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/backtrack4.vb#11)]

<span data-ttu-id="be03e-279">El lenguaje de expresiones regulares de .NET incluye los elementos del lenguaje siguientes, que puede usar para eliminar cuantificadores anidados.</span><span class="sxs-lookup"><span data-stu-id="be03e-279">The regular expression language in .NET includes the following language elements that you can use to eliminate nested quantifiers.</span></span> <span data-ttu-id="be03e-280">Para obtener más información, consulte [Construcciones de agrupamiento](grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="be03e-280">For more information, see [Grouping Constructs](grouping-constructs-in-regular-expressions.md).</span></span>

|<span data-ttu-id="be03e-281">Elemento del lenguaje</span><span class="sxs-lookup"><span data-stu-id="be03e-281">Language element</span></span>|<span data-ttu-id="be03e-282">Descripción</span><span class="sxs-lookup"><span data-stu-id="be03e-282">Description</span></span>|
|----------------------|-----------------|
|<span data-ttu-id="be03e-283">`(?=` `subexpression` `)`</span><span class="sxs-lookup"><span data-stu-id="be03e-283">`(?=` `subexpression` `)`</span></span>|<span data-ttu-id="be03e-284">Búsqueda anticipada positiva de ancho cero.</span><span class="sxs-lookup"><span data-stu-id="be03e-284">Zero-width positive lookahead.</span></span> <span data-ttu-id="be03e-285">Realizar una búsqueda anticipada de la posición actual para determinar si `subexpression` coincide con la cadena de entrada.</span><span class="sxs-lookup"><span data-stu-id="be03e-285">Look ahead of the current position to determine whether `subexpression` matches the input string.</span></span>|
|<span data-ttu-id="be03e-286">`(?!` `subexpression` `)`</span><span class="sxs-lookup"><span data-stu-id="be03e-286">`(?!` `subexpression` `)`</span></span>|<span data-ttu-id="be03e-287">Búsqueda anticipada negativa de ancho cero.</span><span class="sxs-lookup"><span data-stu-id="be03e-287">Zero-width negative lookahead.</span></span> <span data-ttu-id="be03e-288">Realizar una búsqueda anticipada de la posición actual para determinar si `subexpression` no coincide con la cadena de entrada.</span><span class="sxs-lookup"><span data-stu-id="be03e-288">Look ahead of the current position to determine whether `subexpression` does not match the input string.</span></span>|
|<span data-ttu-id="be03e-289">`(?<=` `subexpression` `)`</span><span class="sxs-lookup"><span data-stu-id="be03e-289">`(?<=` `subexpression` `)`</span></span>|<span data-ttu-id="be03e-290">Búsqueda tardía positiva de ancho cero.</span><span class="sxs-lookup"><span data-stu-id="be03e-290">Zero-width positive lookbehind.</span></span> <span data-ttu-id="be03e-291">Realizar una búsqueda tardía de la posición actual para determinar si `subexpression` coincide con la cadena de entrada.</span><span class="sxs-lookup"><span data-stu-id="be03e-291">Look behind the current position to determine whether `subexpression` matches the input string.</span></span>|
|<span data-ttu-id="be03e-292">`(?<!` `subexpression` `)`</span><span class="sxs-lookup"><span data-stu-id="be03e-292">`(?<!` `subexpression` `)`</span></span>|<span data-ttu-id="be03e-293">Búsqueda tardía negativa de ancho cero.</span><span class="sxs-lookup"><span data-stu-id="be03e-293">Zero-width negative lookbehind.</span></span> <span data-ttu-id="be03e-294">Realizar una búsqueda tardía de la posición actual para determinar si `subexpression` no coincide con la cadena de entrada.</span><span class="sxs-lookup"><span data-stu-id="be03e-294">Look behind the current position to determine whether `subexpression` does not match the input string.</span></span>|

## <a name="use-time-out-values"></a><span data-ttu-id="be03e-295">Usar valores de tiempo de espera</span><span class="sxs-lookup"><span data-stu-id="be03e-295">Use time-out values</span></span>

<span data-ttu-id="be03e-296">Si sus expresiones regulares procesan datos de entrada que prácticamente coinciden con el patrón de expresiones regulares, normalmente se puede usar el retroceso excesivo, que afecta enormemente al rendimiento.</span><span class="sxs-lookup"><span data-stu-id="be03e-296">If your regular expressions processes input that nearly matches the regular expression pattern, it can often rely on excessive backtracking, which impacts its performance significantly.</span></span> <span data-ttu-id="be03e-297">Además de analizar cuidadosamente el uso del retroceso y probar la expresión regular en entradas casi coincidentes, debe establecer siempre un valor de tiempo de espera para garantizar que el impacto del retroceso excesivo, si aparece, se reduzca al mínimo.</span><span class="sxs-lookup"><span data-stu-id="be03e-297">In addition to carefully considering your use of backtracking and testing the regular expression against near-matching input, you should always set a time-out value to ensure that the impact of excessive backtracking, if it occurs, is minimized.</span></span>

<span data-ttu-id="be03e-298">El intervalo de tiempo de espera de la expresión regular define el período de tiempo que el motor de expresiones regulares buscará una coincidencia única antes de que el tiempo se agote. El intervalo de tiempo de espera predeterminado es <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, que significa que no se agotará el tiempo de la expresión regular. Puede invalidar este valor y definir un intervalo de tiempo de espera de la siguiente manera:</span><span class="sxs-lookup"><span data-stu-id="be03e-298">The regular expression time-out interval defines the period of time that the regular expression engine will look for a single match before it times out. The default time-out interval is <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, which means that the regular expression will not time out. You can override this value and define a time-out interval as follows:</span></span>

- <span data-ttu-id="be03e-299">Proporcionando un valor de tiempo de espera al crear una instancia del objeto <xref:System.Text.RegularExpressions.Regex> llamando al constructor <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>.</span><span class="sxs-lookup"><span data-stu-id="be03e-299">By providing a time-out value when you instantiate a <xref:System.Text.RegularExpressions.Regex> object by calling the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> constructor.</span></span>

- <span data-ttu-id="be03e-300">Llamando a un método estático de coincidencia de patrones, como <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> o <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>, que incluya un parámetro `matchTimeout`.</span><span class="sxs-lookup"><span data-stu-id="be03e-300">By calling a static pattern matching method, such as <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>, that includes a `matchTimeout` parameter.</span></span>

- <span data-ttu-id="be03e-301">Para las expresiones regulares compiladas que se crean mediante una llamada al método <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType>, llamando al constructor que tiene un parámetro de tipo <xref:System.TimeSpan>.</span><span class="sxs-lookup"><span data-stu-id="be03e-301">For compiled regular expressions that are created by calling the <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType> method, by calling the constructor that has a parameter of type <xref:System.TimeSpan>.</span></span>

<span data-ttu-id="be03e-302">Si ha definido un intervalo de tiempo de espera y no se encuentra ninguna coincidencia al final del intervalo, el método de expresiones regulares produce una excepción <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>.</span><span class="sxs-lookup"><span data-stu-id="be03e-302">If you have defined a time-out interval and a match is not found at the end of that interval, the regular expression method throws a <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception.</span></span> <span data-ttu-id="be03e-303">En el controlador de excepciones, puede elegir reintentar la búsqueda de coincidencias con un intervalo de tiempo de espera más largo, abandonar el intento de búsqueda de coincidencias y asumir que no hay ninguna coincidencia o abandonar el intento de búsqueda de coincidencias y registrar la información de excepción para futuros análisis.</span><span class="sxs-lookup"><span data-stu-id="be03e-303">In your exception handler, you can choose to retry the match with a longer time-out interval, abandon the match attempt and assume that there is no match, or abandon the match attempt and log the exception information for future analysis.</span></span>

<span data-ttu-id="be03e-304">En el ejemplo siguiente se define un método `GetWordData` que crea una instancia de una expresión regular con un tiempo de espera de 350 milisegundos para calcular el número de palabras y el promedio de caracteres de una palabra en un documento de texto.</span><span class="sxs-lookup"><span data-stu-id="be03e-304">The following example defines a `GetWordData` method that instantiates a regular expression with a time-out interval of 350 milliseconds to calculate the number of words and average number of characters in a word in a text document.</span></span> <span data-ttu-id="be03e-305">Si se agota el tiempo de espera de la operación de coincidencia, el intervalo de tiempo de espera aumenta en 350 milisegundos y se vuelve a crear una instancia del objeto <xref:System.Text.RegularExpressions.Regex>.</span><span class="sxs-lookup"><span data-stu-id="be03e-305">If the matching operation times out, the time-out interval is increased by 350 milliseconds and the <xref:System.Text.RegularExpressions.Regex> object is re-instantiated.</span></span> <span data-ttu-id="be03e-306">Si el nuevo intervalo de tiempo de espera es mayor de 1 segundo, el método vuelve a producir la excepción y se la envía al llamador.</span><span class="sxs-lookup"><span data-stu-id="be03e-306">If the new time-out interval exceeds 1 second, the method re-throws the exception to the caller.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#12](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/timeout1.cs#12)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/timeout1.vb#12)]

## <a name="capture-only-when-necessary"></a><span data-ttu-id="be03e-307">Capturar solo cuando sea necesario</span><span class="sxs-lookup"><span data-stu-id="be03e-307">Capture only when necessary</span></span>

<span data-ttu-id="be03e-308">Las expresiones regulares de .NET admiten varias construcciones de agrupación, que permiten agrupar un patrón de expresión regular en una o más subexpresiones.</span><span class="sxs-lookup"><span data-stu-id="be03e-308">Regular expressions in .NET support a number of grouping constructs, which let you group a regular expression pattern into one or more subexpressions.</span></span> <span data-ttu-id="be03e-309">Las construcciones de agrupación que más se usan en el lenguaje de expresiones regulares de .NET son `(`*subexpression*`)`, que define un grupo de captura numerado, y `(?<`*name*`>`*subexpression*`)`, que define un grupo de captura con nombre.</span><span class="sxs-lookup"><span data-stu-id="be03e-309">The most commonly used grouping constructs in .NET regular expression language are `(`*subexpression*`)`, which defines a numbered capturing group, and `(?<`*name*`>`*subexpression*`)`, which defines a named capturing group.</span></span> <span data-ttu-id="be03e-310">Las construcciones de agrupación son esenciales para crear referencias inversas y para definir una subexpresión a la que se aplica un cuantificador.</span><span class="sxs-lookup"><span data-stu-id="be03e-310">Grouping constructs are essential for creating backreferences and for defining a subexpression to which a quantifier is applied.</span></span>

<span data-ttu-id="be03e-311">Sin embargo, el uso de estos elementos de lenguaje tiene un costo.</span><span class="sxs-lookup"><span data-stu-id="be03e-311">However, the use of these language elements has a cost.</span></span> <span data-ttu-id="be03e-312">Hacen que el objeto <xref:System.Text.RegularExpressions.GroupCollection> devuelto por la propiedad <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> se rellene con las capturas sin nombre o con nombre más recientes, y si una única construcción de agrupación ha capturado varias subcadenas en la cadena de entrada, también rellenan el objeto <xref:System.Text.RegularExpressions.CaptureCollection> devuelto por la propiedad <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> de un grupo de captura determinado con varios objetos <xref:System.Text.RegularExpressions.Capture>.</span><span class="sxs-lookup"><span data-stu-id="be03e-312">They cause the <xref:System.Text.RegularExpressions.GroupCollection> object returned by the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property to be populated with the most recent unnamed or named captures, and if a single grouping construct has captured multiple substrings in the input string, they also populate the <xref:System.Text.RegularExpressions.CaptureCollection> object returned by the <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> property of a particular capturing group with multiple <xref:System.Text.RegularExpressions.Capture> objects.</span></span>

<span data-ttu-id="be03e-313">A menudo, las construcciones de agrupación se usan en una expresión regular solo para poder aplicarles cuantificadores y los grupos capturados por estas subexpresiones no se usan posteriormente.</span><span class="sxs-lookup"><span data-stu-id="be03e-313">Often, grouping constructs are used in a regular expression only so that quantifiers can be applied to them, and the groups captured by these subexpressions are not subsequently used.</span></span> <span data-ttu-id="be03e-314">Por ejemplo, la expresión regular `\b(\w+[;,]?\s?)+[.?!]` está diseñada para capturar una frase completa.</span><span class="sxs-lookup"><span data-stu-id="be03e-314">For example, the regular expression `\b(\w+[;,]?\s?)+[.?!]` is designed to capture an entire sentence.</span></span> <span data-ttu-id="be03e-315">En la tabla siguiente se describen los elementos del lenguaje de este patrón de expresión regular y su efecto sobre las colecciones <xref:System.Text.RegularExpressions.Match> y <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> del objeto <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="be03e-315">The following table describes the language elements in this regular expression pattern and their effect on the <xref:System.Text.RegularExpressions.Match> object's <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> and <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> collections.</span></span>

|<span data-ttu-id="be03e-316">Modelo</span><span class="sxs-lookup"><span data-stu-id="be03e-316">Pattern</span></span>|<span data-ttu-id="be03e-317">Descripción</span><span class="sxs-lookup"><span data-stu-id="be03e-317">Description</span></span>|
|-------------|-----------------|
|`\b`|<span data-ttu-id="be03e-318">Iniciar la búsqueda de coincidencias en un límite de palabras.</span><span class="sxs-lookup"><span data-stu-id="be03e-318">Begin the match at a word boundary.</span></span>|
|`\w+`|<span data-ttu-id="be03e-319">Buscar coincidencias con uno o más caracteres alfabéticos.</span><span class="sxs-lookup"><span data-stu-id="be03e-319">Match one or more word characters.</span></span>|
|`[;,]?`|<span data-ttu-id="be03e-320">Buscar coincidencias con cero o una coma o un punto y coma.</span><span class="sxs-lookup"><span data-stu-id="be03e-320">Match zero or one comma or semicolon.</span></span>|
|`\s?`|<span data-ttu-id="be03e-321">Busca coincidencias con cero o un carácter de espacio en blanco.</span><span class="sxs-lookup"><span data-stu-id="be03e-321">Match zero or one white-space character.</span></span>|
|`(\w+[;,]?\s?)+`|<span data-ttu-id="be03e-322">Buscar coincidencias con una o más apariciones de uno o más caracteres alfabéticos seguidos de una coma o un punto y coma opcional, seguido de un carácter opcional de espacio en blanco.</span><span class="sxs-lookup"><span data-stu-id="be03e-322">Match one or more occurrences of one or more word characters followed by an optional comma or semicolon followed by an optional white-space character.</span></span> <span data-ttu-id="be03e-323">Esto define al primer grupo de captura, que es necesario para que la combinación de varios caracteres alfabéticos (es decir, una palabra) seguidos de un signo de puntuación opcional se repita hasta que el motor de expresiones regulares llegue al final de una frase.</span><span class="sxs-lookup"><span data-stu-id="be03e-323">This defines the first capturing group, which is necessary so that the combination of multiple word characters (that is, a word) followed by an optional punctuation symbol will be repeated until the regular expression engine reaches the end of a sentence.</span></span>|
|`[.?!]`|<span data-ttu-id="be03e-324">Buscar coincidencias con un punto, un signo de interrogación o un signo de exclamación.</span><span class="sxs-lookup"><span data-stu-id="be03e-324">Match a period, question mark, or exclamation point.</span></span>|

<span data-ttu-id="be03e-325">Como se muestra en el ejemplo siguiente, cuando se encuentra una coincidencia, los objetos <xref:System.Text.RegularExpressions.GroupCollection> y <xref:System.Text.RegularExpressions.CaptureCollection> se rellenan con capturas de la coincidencia.</span><span class="sxs-lookup"><span data-stu-id="be03e-325">As the following example shows, when a match is found, both the <xref:System.Text.RegularExpressions.GroupCollection> and <xref:System.Text.RegularExpressions.CaptureCollection> objects are populated with captures from the match.</span></span> <span data-ttu-id="be03e-326">En este caso, el grupo de captura `(\w+[;,]?\s?)` existe para que se le pueda aplicar el cuantificador `+`, que permite que el patrón de expresión regular coincida con cada palabra de una frase.</span><span class="sxs-lookup"><span data-stu-id="be03e-326">In this case, the capturing group `(\w+[;,]?\s?)` exists so that the `+` quantifier can be applied to it, which enables the regular expression pattern to match each word in a sentence.</span></span> <span data-ttu-id="be03e-327">De lo contrario, coincidiría con la última palabra de una frase.</span><span class="sxs-lookup"><span data-stu-id="be03e-327">Otherwise, it would match the last word in a sentence.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/group1.cs#8)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/group1.vb#8)]

<span data-ttu-id="be03e-328">Cuando use subexpresiones solo para aplicarles cuantificadores y no le interese el texto capturado, debe deshabilitar las capturas de grupo.</span><span class="sxs-lookup"><span data-stu-id="be03e-328">When you use subexpressions only to apply quantifiers to them, and you are not interested in the captured text, you should disable group captures.</span></span> <span data-ttu-id="be03e-329">Por ejemplo, el elemento de lenguaje `(?:subexpression)` impide al grupo al que se aplica que capture subcadenas coincidentes.</span><span class="sxs-lookup"><span data-stu-id="be03e-329">For example, the `(?:subexpression)` language element prevents the group to which it applies from capturing matched substrings.</span></span> <span data-ttu-id="be03e-330">En el ejemplo siguiente, el patrón de expresión regular del ejemplo anterior se cambia a `\b(?:\w+[;,]?\s?)+[.?!]`.</span><span class="sxs-lookup"><span data-stu-id="be03e-330">In the following example, the regular expression pattern from the previous example is changed to `\b(?:\w+[;,]?\s?)+[.?!]`.</span></span> <span data-ttu-id="be03e-331">Como muestra el resultado, evita que el motor de expresiones regulares rellene las colecciones <xref:System.Text.RegularExpressions.GroupCollection> y <xref:System.Text.RegularExpressions.CaptureCollection>.</span><span class="sxs-lookup"><span data-stu-id="be03e-331">As the output shows, it prevents the regular expression engine from populating the <xref:System.Text.RegularExpressions.GroupCollection> and <xref:System.Text.RegularExpressions.CaptureCollection> collections.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#9](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/group2.cs#9)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/group2.vb#9)]

<span data-ttu-id="be03e-332">Puede deshabilitar las capturas de una de las maneras siguientes:</span><span class="sxs-lookup"><span data-stu-id="be03e-332">You can disable captures in one of the following ways:</span></span>

- <span data-ttu-id="be03e-333">Use el elemento de lenguaje `(?:subexpression)`.</span><span class="sxs-lookup"><span data-stu-id="be03e-333">Use the `(?:subexpression)` language element.</span></span> <span data-ttu-id="be03e-334">Este elemento impide la captura de subcadenas coincidentes en el grupo al que se aplica.</span><span class="sxs-lookup"><span data-stu-id="be03e-334">This element prevents the capture of matched substrings in the group to which it applies.</span></span> <span data-ttu-id="be03e-335">No deshabilita las capturas de subcadenas en ningún grupo anidado.</span><span class="sxs-lookup"><span data-stu-id="be03e-335">It does not disable substring captures in any nested groups.</span></span>

- <span data-ttu-id="be03e-336">Use la opción <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture>.</span><span class="sxs-lookup"><span data-stu-id="be03e-336">Use the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture> option.</span></span> <span data-ttu-id="be03e-337">Deshabilita todas las capturas sin nombre o implícitas en el patrón de expresión regular.</span><span class="sxs-lookup"><span data-stu-id="be03e-337">It disables all unnamed or implicit captures in the regular expression pattern.</span></span> <span data-ttu-id="be03e-338">Cuando se usa esta opción, solo se pueden capturar las subcadenas que coinciden con grupos con nombre definidos con el elemento de lenguaje `(?<name>subexpression)`.</span><span class="sxs-lookup"><span data-stu-id="be03e-338">When you use this option, only substrings that match named groups defined with the `(?<name>subexpression)` language element can be captured.</span></span> <span data-ttu-id="be03e-339">La marca <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture> se puede pasar al parámetro `options` de un constructor de clase <xref:System.Text.RegularExpressions.Regex> o al parámetro `options` de un método coincidente estático <xref:System.Text.RegularExpressions.Regex>.</span><span class="sxs-lookup"><span data-stu-id="be03e-339">The <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture> flag can be passed to the `options` parameter of a <xref:System.Text.RegularExpressions.Regex> class constructor or to the `options` parameter of a <xref:System.Text.RegularExpressions.Regex> static matching method.</span></span>

- <span data-ttu-id="be03e-340">Use la opción `n` del elemento de lenguaje `(?imnsx)`.</span><span class="sxs-lookup"><span data-stu-id="be03e-340">Use the `n` option in the `(?imnsx)` language element.</span></span> <span data-ttu-id="be03e-341">Esta opción deshabilita todas las capturas sin nombre o implícitas desde el punto del patrón de expresión regular en el que aparece el elemento.</span><span class="sxs-lookup"><span data-stu-id="be03e-341">This option disables all unnamed or implicit captures from the point in the regular expression pattern at which the element appears.</span></span> <span data-ttu-id="be03e-342">Las capturas se deshabilitan hasta el final del modelo o hasta que la opción `(-n)` habilita las capturas sin nombre o implícitas.</span><span class="sxs-lookup"><span data-stu-id="be03e-342">Captures are disabled either until the end of the pattern or until the `(-n)` option enables unnamed or implicit captures.</span></span> <span data-ttu-id="be03e-343">Para obtener más información, consulte [Construcciones misceláneas](miscellaneous-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="be03e-343">For more information, see [Miscellaneous Constructs](miscellaneous-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="be03e-344">Use la opción `n` del elemento de lenguaje `(?imnsx:subexpression)`.</span><span class="sxs-lookup"><span data-stu-id="be03e-344">Use the `n` option in the `(?imnsx:subexpression)` language element.</span></span> <span data-ttu-id="be03e-345">Esta opción deshabilita todas las capturas sin nombre o implícitas en `subexpression`.</span><span class="sxs-lookup"><span data-stu-id="be03e-345">This option disables all unnamed or implicit captures in `subexpression`.</span></span> <span data-ttu-id="be03e-346">Las capturas por grupos de captura anidados sin nombre o implícitos también se deshabilitan.</span><span class="sxs-lookup"><span data-stu-id="be03e-346">Captures by any unnamed or implicit nested capturing groups are disabled as well.</span></span>

## <a name="related-topics"></a><span data-ttu-id="be03e-347">Temas relacionados</span><span class="sxs-lookup"><span data-stu-id="be03e-347">Related topics</span></span>

|<span data-ttu-id="be03e-348">Title</span><span class="sxs-lookup"><span data-stu-id="be03e-348">Title</span></span>|<span data-ttu-id="be03e-349">Descripción</span><span class="sxs-lookup"><span data-stu-id="be03e-349">Description</span></span>|
|-----------|-----------------|
|[<span data-ttu-id="be03e-350">Detalles del comportamiento de expresiones regulares</span><span class="sxs-lookup"><span data-stu-id="be03e-350">Details of Regular Expression Behavior</span></span>](details-of-regular-expression-behavior.md)|<span data-ttu-id="be03e-351">Examina la implementación del motor de expresiones regulares de .NET.</span><span class="sxs-lookup"><span data-stu-id="be03e-351">Examines the implementation of the regular expression engine in .NET.</span></span> <span data-ttu-id="be03e-352">El tema se centra en la flexibilidad de las expresiones regulares y explica la responsabilidad del desarrollador para garantizar un funcionamiento eficaz y sólido del motor de expresiones regulares.</span><span class="sxs-lookup"><span data-stu-id="be03e-352">The topic focuses on the flexibility of regular expressions and explains the developer's responsibility for ensuring the efficient and robust operation of the regular expression engine.</span></span>|
|[<span data-ttu-id="be03e-353">Retroceso</span><span class="sxs-lookup"><span data-stu-id="be03e-353">Backtracking</span></span>](backtracking-in-regular-expressions.md)|<span data-ttu-id="be03e-354">Explica qué es el retroceso y cómo afecta al rendimiento de las expresiones regulares, y examine los elementos del lenguaje que proporcionan alternativas al retroceso.</span><span class="sxs-lookup"><span data-stu-id="be03e-354">Explains what backtracking is and how it affects regular expression performance, and examines language elements that provide alternatives to backtracking.</span></span>|
|[<span data-ttu-id="be03e-355">Lenguaje de expresiones regulares: referencia rápida</span><span class="sxs-lookup"><span data-stu-id="be03e-355">Regular Expression Language - Quick Reference</span></span>](regular-expression-language-quick-reference.md)|<span data-ttu-id="be03e-356">Describe los elementos del lenguaje de expresiones regulares de .NET y proporciona vínculos a documentación detallada sobre cada elemento del lenguaje.</span><span class="sxs-lookup"><span data-stu-id="be03e-356">Describes the elements of the regular expression language in .NET and provides links to detailed documentation for each language element.</span></span>|
