---
title: Estrategias para tratar errores parciales
description: Arquitectura de microservicios de .NET para aplicaciones .NET en contenedor | Estrategias para tratar errores parciales
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.openlocfilehash: f1b2b59af96bf28035eeb32eb15eaa4105677cf4
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 05/04/2018
---
# <a name="strategies-for-handling-partial-failure"></a><span data-ttu-id="ace5b-103">Estrategias para tratar errores parciales</span><span class="sxs-lookup"><span data-stu-id="ace5b-103">Strategies for handling partial failure</span></span>

<span data-ttu-id="ace5b-104">Las estrategias para tratar los errores parciales son las siguientes.</span><span class="sxs-lookup"><span data-stu-id="ace5b-104">Strategies for dealing with partial failures include the following.</span></span>

<span data-ttu-id="ace5b-105">**Usar la comunicación asincrónica (por ejemplo, la comunicación basada en mensajes) a través de microservicios internos**.</span><span class="sxs-lookup"><span data-stu-id="ace5b-105">**Use asynchronous communication (for example, message-based communication) across internal microservices**.</span></span> <span data-ttu-id="ace5b-106">Es muy aconsejable no crear cadenas largas de llamadas HTTP sincrónicas a través de microservicios internos, porque ese diseño incorrecto podría convertirse en la principal causa de interrupciones incorrectas.</span><span class="sxs-lookup"><span data-stu-id="ace5b-106">It is highly advisable not to create long chains of synchronous HTTP calls across the internal microservices because that incorrect design will eventually become the main cause of bad outages.</span></span> <span data-ttu-id="ace5b-107">Por el contrario, excepto en el caso de comunicaciones front-end entre las aplicaciones cliente y el primer nivel de microservicios o puertas de enlace de API específicas, se recomienda usar solamente una comunicación asíncrona (basada en mensajes) cuando haya pasado el ciclo inicial de solicitud/respuesta en los microservicios internos.</span><span class="sxs-lookup"><span data-stu-id="ace5b-107">On the contrary, except for the front-end communications between the client applications and the first level of microservices or fine-grained API Gateways, it is recommended to use only asynchronous (message-based) communication once past the initial request/response cycle, across the internal microservices.</span></span> <span data-ttu-id="ace5b-108">La coherencia definitiva y las arquitecturas orientadas a eventos le ayudarán a minimizar el efecto dominó.</span><span class="sxs-lookup"><span data-stu-id="ace5b-108">Eventual consistency and event-driven architectures will help to minimize ripple effects.</span></span> <span data-ttu-id="ace5b-109">Estos enfoques exigen un nivel más alto de autonomía de microservicio y, por lo tanto, evitan el problema que se describe a continuación.</span><span class="sxs-lookup"><span data-stu-id="ace5b-109">These approaches enforce a higher level of microservice autonomy and therefore prevent against the problem noted here.</span></span>

<span data-ttu-id="ace5b-110">**Usar reintentos con retroceso exponencial**.</span><span class="sxs-lookup"><span data-stu-id="ace5b-110">**Use retries with exponential backoff**.</span></span> <span data-ttu-id="ace5b-111">Esta técnica ayuda a evitar fallos cortos e intermitentes mediante la realización de un número determinado de intentos de llamada en caso de que el servicio no esté disponible solo durante un breve período de tiempo.</span><span class="sxs-lookup"><span data-stu-id="ace5b-111">This technique helps to avoid short and intermittent failures by performing call retries a certain number of times, in case the service was not available only for a short time.</span></span> <span data-ttu-id="ace5b-112">Esto puede ocurrir debido a problemas de red intermitentes o cuando un contenedor o microservicio se mueve a otro nodo del clúster.</span><span class="sxs-lookup"><span data-stu-id="ace5b-112">This might occur due to intermittent network issues or when a microservice/container is moved to a different node in a cluster.</span></span> <span data-ttu-id="ace5b-113">Pero si estos intentos no se diseñan correctamente con interruptores, pueden agravar el efecto dominó e incluso pueden llegar a producir un [ataque por denegación de servicio (DoS)](https://en.wikipedia.org/wiki/Denial-of-service_attack).</span><span class="sxs-lookup"><span data-stu-id="ace5b-113">However, if these retries are not designed properly with circuit breakers, it can aggravate the ripple effects, ultimately even causing a [Denial of Service (DoS)](https://en.wikipedia.org/wiki/Denial-of-service_attack).</span></span>

<span data-ttu-id="ace5b-114">**Solucionar los tiempos de expiración de red**.</span><span class="sxs-lookup"><span data-stu-id="ace5b-114">**Work around network timeouts**.</span></span> <span data-ttu-id="ace5b-115">En general, los clientes deben diseñarse para que no se bloqueen indefinidamente y para que usen siempre los tiempos de expiración cuando esperen una respuesta.</span><span class="sxs-lookup"><span data-stu-id="ace5b-115">In general, clients should be designed not to block indefinitely and to always use timeouts when waiting for a response.</span></span> <span data-ttu-id="ace5b-116">Utilizar tiempos de expiración garantiza que los recursos nunca se bloqueen indefinidamente.</span><span class="sxs-lookup"><span data-stu-id="ace5b-116">Using timeouts ensures that resources are never tied up indefinitely.</span></span>

<span data-ttu-id="ace5b-117">**Usar el patrón de interruptor**.</span><span class="sxs-lookup"><span data-stu-id="ace5b-117">**Use the Circuit Breaker pattern**.</span></span> <span data-ttu-id="ace5b-118">En este enfoque, el proceso de cliente supervisa el número de solicitudes con error.</span><span class="sxs-lookup"><span data-stu-id="ace5b-118">In this approach, the client process tracks the number of failed requests.</span></span> <span data-ttu-id="ace5b-119">Si la tasa de errores supera el límite establecido, se activa un "interruptor" para que los intentos adicionales fallen de inmediato.</span><span class="sxs-lookup"><span data-stu-id="ace5b-119">If the error rate exceeds a configured limit, a “circuit breaker” trips so that further attempts fail immediately.</span></span> <span data-ttu-id="ace5b-120">(Si se producen errores en un gran número de solicitudes, esto sugiere que el servicio no está disponible y que enviar solicitudes no sirve de nada.) Tras un período de tiempo de expiración, el cliente debe volver a intentarlo y, si las nuevas solicitudes se realizan correctamente, desactivar el interruptor.</span><span class="sxs-lookup"><span data-stu-id="ace5b-120">(If a large number of requests are failing, that suggests the service is unavailable and that sending requests is pointless.) After a timeout period, the client should try again and, if the new requests are successful, close the circuit breaker.</span></span>

<span data-ttu-id="ace5b-121">**Proporcionar reservas**.</span><span class="sxs-lookup"><span data-stu-id="ace5b-121">**Provide fallbacks**.</span></span> <span data-ttu-id="ace5b-122">En este enfoque, el proceso del cliente realiza una lógica de reserva cuando falla una solicitud, como devolver los datos almacenados en caché o un valor predeterminado.</span><span class="sxs-lookup"><span data-stu-id="ace5b-122">In this approach, the client process performs fallback logic when a request fails, such as returning cached data or a default value.</span></span> <span data-ttu-id="ace5b-123">Este enfoque es adecuado para las consultas, pero es más complejo para las actualizaciones o los comandos.</span><span class="sxs-lookup"><span data-stu-id="ace5b-123">This is an approach suitable for queries, and is more complex for updates or commands.</span></span>

<span data-ttu-id="ace5b-124">**Limitar el número de solicitudes en cola**.</span><span class="sxs-lookup"><span data-stu-id="ace5b-124">**Limit the number of queued requests**.</span></span> <span data-ttu-id="ace5b-125">Los clientes también deben imponer un límite máximo en la cantidad de solicitudes pendientes que un microservicio de cliente puede enviar a un servicio determinado.</span><span class="sxs-lookup"><span data-stu-id="ace5b-125">Clients should also impose an upper bound on the number of outstanding requests that a client microservice can send to a particular service.</span></span> <span data-ttu-id="ace5b-126">Si se alcanza el límite, probablemente no tenga sentido realizar más solicitudes y dichos intentos deben generar error inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="ace5b-126">If the limit has been reached, it is probably pointless to make additional requests, and those attempts should fail immediately.</span></span> <span data-ttu-id="ace5b-127">En cuanto a la implementación, la directiva [Aislamiento con mampara](https://github.com/App-vNext/Polly/wiki/Bulkhead) de Polly puede usarse para cumplir este requisito.</span><span class="sxs-lookup"><span data-stu-id="ace5b-127">In terms of implementation, the Polly [Bulkhead Isolation](https://github.com/App-vNext/Polly/wiki/Bulkhead) policy can be used to fulfil this requirement.</span></span> <span data-ttu-id="ace5b-128">Este enfoque es básicamente una limitación en paralelo con <xref:System.Threading.SemaphoreSlim> como implementación.</span><span class="sxs-lookup"><span data-stu-id="ace5b-128">This approach is essentially a parallelization throttle with <xref:System.Threading.SemaphoreSlim> as the implementation.</span></span> <span data-ttu-id="ace5b-129">También admite una "cola" fuera de la mampara.</span><span class="sxs-lookup"><span data-stu-id="ace5b-129">It also permits a "queue" outside the bulkhead.</span></span> <span data-ttu-id="ace5b-130">Puede perder proactivamente una carga excesiva incluso antes de la ejecución (por ejemplo, porque se considera que ha llegado al límite de su capacidad).</span><span class="sxs-lookup"><span data-stu-id="ace5b-130">You can proactively shed excess load even before execution (for example, because capacity is deemed full).</span></span> <span data-ttu-id="ace5b-131">Esto hace que su respuesta a determinados escenarios de error sea mucho más rápida que la que tendría un interruptor, puesto que el interruptor espera a que se produzcan los errores.</span><span class="sxs-lookup"><span data-stu-id="ace5b-131">This makes its response to certain failure scenarios faster than a circuit breaker would be, since the circuit breaker waits for the failures.</span></span> <span data-ttu-id="ace5b-132">El objeto BulkheadPolicy de Polly expone hasta qué punto están llenos el espacio limitado por la mampara y la cola, y ofrece eventos sobre desbordamiento para que también se puedan utilizar para administrar un escalado horizontal automatizado.</span><span class="sxs-lookup"><span data-stu-id="ace5b-132">The BulkheadPolicy object in Polly exposes how full the bulkhead and queue are, and offers events on overflow so can also be used to drive automated horizontal scaling.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="ace5b-133">Recursos adicionales</span><span class="sxs-lookup"><span data-stu-id="ace5b-133">Additional resources</span></span>

-   <span data-ttu-id="ace5b-134">**Resiliency patterns (Patrones de resistencia)**
    [*https://docs.microsoft.com/azure/architecture/patterns/category/resiliency*](https://docs.microsoft.com/azure/architecture/patterns/category/resiliency)</span><span class="sxs-lookup"><span data-stu-id="ace5b-134">**Resiliency patterns**
[*https://docs.microsoft.com/azure/architecture/patterns/category/resiliency*](https://docs.microsoft.com/azure/architecture/patterns/category/resiliency)</span></span>

-   <span data-ttu-id="ace5b-135">**Adding Resilience and Optimizing Performance (Agregar resistencia y optimizar el rendimiento)**
    [*https://msdn.microsoft.com/library/jj591574.aspx*](https://msdn.microsoft.com/library/jj591574.aspx)</span><span class="sxs-lookup"><span data-stu-id="ace5b-135">**Adding Resilience and Optimizing Performance**
[*https://msdn.microsoft.com/library/jj591574.aspx*](https://msdn.microsoft.com/library/jj591574.aspx)</span></span>

-   <span data-ttu-id="ace5b-136">**Bulkhead** (Mampara).</span><span class="sxs-lookup"><span data-stu-id="ace5b-136">**Bulkhead.**</span></span> <span data-ttu-id="ace5b-137">Repositorio de GitHub.</span><span class="sxs-lookup"><span data-stu-id="ace5b-137">GitHub repo.</span></span> <span data-ttu-id="ace5b-138">Implementación con la directiva de Polly. \\</span><span class="sxs-lookup"><span data-stu-id="ace5b-138">Implementation with Polly policy.\\</span></span>
    [*https://github.com/App-vNext/Polly/wiki/Bulkhead*](https://github.com/App-vNext/Polly/wiki/Bulkhead)

-   <span data-ttu-id="ace5b-139">**Designing resilient applications for Azure (Diseñar aplicaciones resistentes de Azure)**
    [*https://docs.microsoft.com/azure/architecture/resiliency/*](https://docs.microsoft.com/azure/architecture/resiliency/)</span><span class="sxs-lookup"><span data-stu-id="ace5b-139">**Designing resilient applications for Azure**
[*https://docs.microsoft.com/azure/architecture/resiliency/*](https://docs.microsoft.com/azure/architecture/resiliency/)</span></span>

-   <span data-ttu-id="ace5b-140">**Control de errores transitorios**
    <https://docs.microsoft.com/azure/architecture/best-practices/transient-faults></span><span class="sxs-lookup"><span data-stu-id="ace5b-140">**Transient fault handling**
<https://docs.microsoft.com/azure/architecture/best-practices/transient-faults></span></span>


>[!div class="step-by-step"]
<span data-ttu-id="ace5b-141">[Anterior] (handle-partial-failure.md) [Siguiente] (implement-retries-exponential-backoff.md)</span><span class="sxs-lookup"><span data-stu-id="ace5b-141">[Previous] (handle-partial-failure.md) [Next] (implement-retries-exponential-backoff.md)</span></span>
