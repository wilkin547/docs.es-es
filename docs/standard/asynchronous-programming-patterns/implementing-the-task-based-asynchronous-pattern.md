---
title: Implementar el modelo asincrónico basado en tareas
description: En este artículo se explica cómo implementar el patrón asincrónico basado en tareas. Se puede usar para implementar operaciones asincrónicas enlazadas a cálculos y enlazadas a E/S.
ms.date: 06/14/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- .NET Framework, and TAP
- asynchronous design patterns, .NET Framework
- TAP, .NET Framework support for
- Task-based Asynchronous Pattern, .NET Framework support for
- .NET Framework, asynchronous design patterns
ms.assetid: fab6bd41-91bd-44ad-86f9-d8319988aa78
ms.openlocfilehash: 7d031bab6ba0a4420062eff107aeb1262d9b3b40
ms.sourcegitcommit: 9a4488a3625866335e83a20da5e9c5286b1f034c
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 05/15/2020
ms.locfileid: "83421233"
---
# <a name="implementing-the-task-based-asynchronous-pattern"></a><span data-ttu-id="33cc3-104">Implementar el modelo asincrónico basado en tareas</span><span class="sxs-lookup"><span data-stu-id="33cc3-104">Implementing the Task-based Asynchronous Pattern</span></span>
<span data-ttu-id="33cc3-105">Puede implementar el patrón asincrónico basado en tareas (TAP) de tres maneras: mediante los compiladores de C# y Visual Basic en Visual Studio, manualmente o mediante una combinación del compilador y métodos manuales.</span><span class="sxs-lookup"><span data-stu-id="33cc3-105">You can implement the Task-based Asynchronous Pattern (TAP) in three ways: by using the C# and Visual Basic compilers in Visual Studio, manually, or through a combination of the compiler and manual methods.</span></span> <span data-ttu-id="33cc3-106">En las siguientes secciones se describe cada método con detalle.</span><span class="sxs-lookup"><span data-stu-id="33cc3-106">The following sections discuss each method in detail.</span></span> <span data-ttu-id="33cc3-107">Puede usar el modelo TAP para implementar operaciones asincrónicas enlazadas a cálculos y enlazadas a E/S.</span><span class="sxs-lookup"><span data-stu-id="33cc3-107">You can use the TAP pattern to implement both compute-bound and I/O-bound asynchronous operations.</span></span> <span data-ttu-id="33cc3-108">En la sección [Cargas de trabajo](#workloads) se trata cada tipo de operación.</span><span class="sxs-lookup"><span data-stu-id="33cc3-108">The [Workloads](#workloads) section discusses each type of operation.</span></span>

## <a name="generating-tap-methods"></a><span data-ttu-id="33cc3-109">Generación de métodos TAP</span><span class="sxs-lookup"><span data-stu-id="33cc3-109">Generating TAP methods</span></span>

### <a name="using-the-compilers"></a><span data-ttu-id="33cc3-110">Uso de compiladores</span><span class="sxs-lookup"><span data-stu-id="33cc3-110">Using the compilers</span></span>
<span data-ttu-id="33cc3-111">A partir de .NET Framework 4.5, cualquier método que tenga la palabra clave `async` (`Async` en Visual Basic) se considera un método asincrónico, y los compiladores de C# y Visual Basic realizan las transformaciones necesarias para implementar el método de forma asincrónica mediante TAP.</span><span class="sxs-lookup"><span data-stu-id="33cc3-111">Starting with .NET Framework 4.5, any method that is attributed with the `async` keyword (`Async` in Visual Basic) is considered an asynchronous method, and the C# and Visual Basic compilers perform the necessary transformations to implement the method asynchronously by using TAP.</span></span> <span data-ttu-id="33cc3-112">Un método asincrónico debe devolver un objeto <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> o <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="33cc3-112">An asynchronous method should return either a <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> or a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> object.</span></span> <span data-ttu-id="33cc3-113">En el último caso, el cuerpo de la función debe devolver `TResult` y el compilador garantiza que este resultado está disponible a través del objeto de la tarea resultante.</span><span class="sxs-lookup"><span data-stu-id="33cc3-113">For the latter, the body of the function should return a `TResult`, and the compiler ensures that this result is made available through the resulting task object.</span></span> <span data-ttu-id="33cc3-114">Del mismo modo, en la tarea de salida se calculan las referencias de cualquier excepción no controlada dentro del cuerpo del método y esto hace que la tarea resultante finalice en el estado <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="33cc3-114">Similarly, any exceptions that go unhandled within the body of the method are marshaled to the output task and cause the resulting task to end in the <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> state.</span></span> <span data-ttu-id="33cc3-115">La excepción a esta regla es cuando un objeto <xref:System.OperationCanceledException> (o un tipo derivado) no está controlado, en cuyo caso la tarea resultante finaliza en el estado <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="33cc3-115">The exception to this rule is when an <xref:System.OperationCanceledException> (or derived type) goes unhandled, in which case the resulting task ends in the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> state.</span></span>

### <a name="generating-tap-methods-manually"></a><span data-ttu-id="33cc3-116">Generar métodos de TAP manualmente</span><span class="sxs-lookup"><span data-stu-id="33cc3-116">Generating TAP methods manually</span></span>
<span data-ttu-id="33cc3-117">Puede implementar el patrón TAP manualmente para tener un mejor control sobre la implementación.</span><span class="sxs-lookup"><span data-stu-id="33cc3-117">You may implement the TAP pattern manually for better control over implementation.</span></span> <span data-ttu-id="33cc3-118">El compilador se basa en el área de superficie pública expuesta del espacio de nombres <xref:System.Threading.Tasks?displayProperty=nameWithType> y los tipos auxiliares del espacio de nombres <xref:System.Runtime.CompilerServices?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="33cc3-118">The compiler relies on the public surface area exposed from the <xref:System.Threading.Tasks?displayProperty=nameWithType> namespace and supporting types in the <xref:System.Runtime.CompilerServices?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="33cc3-119">Para implementar TAP, cree un objeto <xref:System.Threading.Tasks.TaskCompletionSource%601>, realice la operación asincrónica y, cuando se complete, llame al método <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A> o <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A>, o a la versión `Try` de uno de estos métodos.</span><span class="sxs-lookup"><span data-stu-id="33cc3-119">To implement the TAP yourself, you create a <xref:System.Threading.Tasks.TaskCompletionSource%601> object, perform the asynchronous operation, and when it completes, call the <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A>, or <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A> method, or the `Try` version of one of these methods.</span></span> <span data-ttu-id="33cc3-120">Cuando implementa un método de TAP manualmente, debe completar la tarea resultante cuando la operación asincrónica representada se complete.</span><span class="sxs-lookup"><span data-stu-id="33cc3-120">When you implement a TAP method manually, you must complete the resulting task when the represented asynchronous operation completes.</span></span> <span data-ttu-id="33cc3-121">Por ejemplo:</span><span class="sxs-lookup"><span data-stu-id="33cc3-121">For example:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#1)]
[!code-vb[Conceptual.TAP_Patterns#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#1)]

### <a name="hybrid-approach"></a><span data-ttu-id="33cc3-122">Enfoque híbrido</span><span class="sxs-lookup"><span data-stu-id="33cc3-122">Hybrid approach</span></span>
 <span data-ttu-id="33cc3-123">Puede resultar útil implementar el patrón TAP manualmente pero delegar la lógica básica de la implementación en el compilador.</span><span class="sxs-lookup"><span data-stu-id="33cc3-123">You may find it useful to implement the TAP pattern manually but to delegate the core logic for the implementation to the compiler.</span></span> <span data-ttu-id="33cc3-124">Por ejemplo, quizás desee usar el enfoque híbrido para comprobar argumentos fuera de un método asincrónico generado por el compilador de forma que las excepciones puedan salir del llamador directo del método en lugar de exponerse a través del objeto <xref:System.Threading.Tasks.Task?displayProperty=nameWithType>:</span><span class="sxs-lookup"><span data-stu-id="33cc3-124">For example, you may want to use the hybrid approach when you want to verify arguments outside a compiler-generated asynchronous method so that exceptions can escape to the method’s direct caller rather than being exposed through the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> object:</span></span>

 [!code-csharp[Conceptual.TAP_Patterns#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#2)]
 [!code-vb[Conceptual.TAP_Patterns#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#2)]

 <span data-ttu-id="33cc3-125">Otro caso donde es útil esa delegación es cuando implementa la optimización de acceso rápido y desea devolver una tarea almacenada en memoria caché.</span><span class="sxs-lookup"><span data-stu-id="33cc3-125">Another case where such delegation is useful is when you're implementing fast-path optimization and want to return a cached task.</span></span>

## <a name="workloads"></a><span data-ttu-id="33cc3-126">Cargas de trabajo</span><span class="sxs-lookup"><span data-stu-id="33cc3-126">Workloads</span></span>
<span data-ttu-id="33cc3-127">Puede implementar operaciones asincrónicas enlazadas a cálculos y enlazadas a E/S como métodos de TAP.</span><span class="sxs-lookup"><span data-stu-id="33cc3-127">You may implement both compute-bound and I/O-bound asynchronous operations as TAP methods.</span></span> <span data-ttu-id="33cc3-128">Sin embargo, cuando los métodos de TAP se exponen públicamente desde una biblioteca, solo se deben suministrar para cargas de trabajo que impliquen operaciones enlazadas a E/S (también pueden implicar cálculos, pero no deben ser estrictamente de cálculo).</span><span class="sxs-lookup"><span data-stu-id="33cc3-128">However, when TAP methods are exposed publicly from a library, they should be provided only for workloads that involve I/O-bound operations (they may also involve computation, but should not be purely computational).</span></span> <span data-ttu-id="33cc3-129">Si un método está totalmente enlazado a cálculos, se debe exponer solo como una implementación sincrónica.</span><span class="sxs-lookup"><span data-stu-id="33cc3-129">If a method is purely compute-bound, it should be exposed only as a synchronous implementation.</span></span> <span data-ttu-id="33cc3-130">El código que lo usa puede elegir si ajustar una invocación de ese método sincrónico en una tarea para descargar el trabajo en otro subproceso o para lograr el paralelismo.</span><span class="sxs-lookup"><span data-stu-id="33cc3-130">The code that consumes it may then choose whether to wrap an invocation of that synchronous method into a task to offload the work to another thread or to achieve parallelism.</span></span> <span data-ttu-id="33cc3-131">Si un método está enlazado a E/S, se debe exponer solo como una implementación asincrónica.</span><span class="sxs-lookup"><span data-stu-id="33cc3-131">And if a method is I/O-bound, it should be exposed only as an asynchronous implementation.</span></span>

### <a name="compute-bound-tasks"></a><span data-ttu-id="33cc3-132">Tareas enlazadas a cálculos</span><span class="sxs-lookup"><span data-stu-id="33cc3-132">Compute-bound tasks</span></span>
<span data-ttu-id="33cc3-133">La clase <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> es idónea para representar operaciones de cálculo intensivas.</span><span class="sxs-lookup"><span data-stu-id="33cc3-133">The <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> class is ideally suited for representing computationally intensive operations.</span></span> <span data-ttu-id="33cc3-134">De forma predeterminada, se beneficia de la compatibilidad especial dentro de la clase <xref:System.Threading.ThreadPool> para proporcionar una ejecución eficaz, y también proporciona un buen control sobre cuándo, dónde y cómo se ejecutan los cálculos asincrónicos.</span><span class="sxs-lookup"><span data-stu-id="33cc3-134">By default, it takes advantage of special support within the <xref:System.Threading.ThreadPool> class to provide efficient execution, and it also provides significant control over when, where, and how asynchronous computations execute.</span></span>

<span data-ttu-id="33cc3-135">Puede generar tareas enlazadas a cálculos de las maneras siguientes:</span><span class="sxs-lookup"><span data-stu-id="33cc3-135">You can generate compute-bound tasks in the following ways:</span></span>

- <span data-ttu-id="33cc3-136">En .NET Framework 4, use el método <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>, que acepta un delegado (normalmente <xref:System.Action%601> o <xref:System.Func%601>) que se va a ejecutar de forma asincrónica.</span><span class="sxs-lookup"><span data-stu-id="33cc3-136">In the .NET Framework 4, use the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method, which accepts a delegate (typically an <xref:System.Action%601> or a <xref:System.Func%601>) to be executed asynchronously.</span></span> <span data-ttu-id="33cc3-137">Si proporciona un delegado de <xref:System.Action%601>, el método devuelve un objeto <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> que representa la ejecución asincrónica de ese delegado.</span><span class="sxs-lookup"><span data-stu-id="33cc3-137">If you provide an <xref:System.Action%601> delegate, the method returns a <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> object that represents the asynchronous execution of that delegate.</span></span> <span data-ttu-id="33cc3-138">Si proporciona un delegado de <xref:System.Func%601>, el método devuelve un objeto <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="33cc3-138">If you provide a <xref:System.Func%601> delegate, the method returns a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> object.</span></span> <span data-ttu-id="33cc3-139">Las sobrecargas del método <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> aceptan un token de cancelación (<xref:System.Threading.CancellationToken>), las opciones de creación de la tarea (<xref:System.Threading.Tasks.TaskCreationOptions>) y un programador de tareas (<xref:System.Threading.Tasks.TaskScheduler>), todo lo cual proporciona un control específico sobre la programación y la ejecución de la tarea.</span><span class="sxs-lookup"><span data-stu-id="33cc3-139">Overloads of the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> method accept a cancellation token (<xref:System.Threading.CancellationToken>), task creation options (<xref:System.Threading.Tasks.TaskCreationOptions>), and a task scheduler (<xref:System.Threading.Tasks.TaskScheduler>), all of which provide fine-grained control over the scheduling and execution of the task.</span></span> <span data-ttu-id="33cc3-140">Una instancia de generador que tiene como destino el programador de tareas actual está disponible como una propiedad estática (<xref:System.Threading.Tasks.Task.Factory%2A>) de la clase <xref:System.Threading.Tasks.Task>; por ejemplo: `Task.Factory.StartNew(…)`.</span><span class="sxs-lookup"><span data-stu-id="33cc3-140">A factory instance that targets the current task scheduler is available as a static property (<xref:System.Threading.Tasks.Task.Factory%2A>) of the <xref:System.Threading.Tasks.Task> class; for example: `Task.Factory.StartNew(…)`.</span></span>

- <span data-ttu-id="33cc3-141">En .NET Framework 4.5 y versiones posteriores (incluidos .NET Core y .NET Standard), use el método <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> estático como un acceso directo a <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="33cc3-141">In the .NET Framework 4.5 and later versions (including .NET Core and .NET Standard), use the static <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> method as a shortcut to <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="33cc3-142">Puede usar <xref:System.Threading.Tasks.Task.Run%2A> para iniciar fácilmente una tarea enlazada a cálculos destinada al grupo de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="33cc3-142">You may use <xref:System.Threading.Tasks.Task.Run%2A> to easily launch a compute-bound task that targets the thread pool.</span></span> <span data-ttu-id="33cc3-143">En .NET Framework 4.5 y versiones posteriores, este es el mecanismo preferido para iniciar una tarea enlazada a procesos.</span><span class="sxs-lookup"><span data-stu-id="33cc3-143">In the .NET Framework 4.5 and later versions, this is the preferred mechanism for launching a compute-bound task.</span></span> <span data-ttu-id="33cc3-144">Use `StartNew` directamente solo cuando desee un mayor control sobre la tarea.</span><span class="sxs-lookup"><span data-stu-id="33cc3-144">Use `StartNew` directly only when you want more fine-grained control over the task.</span></span>

- <span data-ttu-id="33cc3-145">Use los constructores del tipo `Task` o el método `Start` si desea generar y programar la tarea por separado.</span><span class="sxs-lookup"><span data-stu-id="33cc3-145">Use the constructors of the `Task` type or the `Start` method if you want to generate and schedule the task separately.</span></span> <span data-ttu-id="33cc3-146">Los métodos públicos solo deben devolver tareas que ya se han iniciado.</span><span class="sxs-lookup"><span data-stu-id="33cc3-146">Public methods must only return tasks that have already been started.</span></span>

- <span data-ttu-id="33cc3-147">Use las sobrecargas del método <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="33cc3-147">Use the overloads of the <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="33cc3-148">Este método crea una nueva tarea que se programa cuando se completa otra tarea.</span><span class="sxs-lookup"><span data-stu-id="33cc3-148">This method creates a new task that is scheduled when another task completes.</span></span> <span data-ttu-id="33cc3-149">Algunas de las sobrecargas de <xref:System.Threading.Tasks.Task.ContinueWith%2A> aceptan un token de cancelación, opciones de continuación y un programador de tareas para tener un mejor control sobre la programación y la ejecución de la tarea de continuación.</span><span class="sxs-lookup"><span data-stu-id="33cc3-149">Some of the <xref:System.Threading.Tasks.Task.ContinueWith%2A> overloads accept a cancellation token, continuation options, and a task scheduler for better control over the scheduling and execution of the continuation task.</span></span>

- <span data-ttu-id="33cc3-150">Use los métodos <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> y <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="33cc3-150">Use the <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="33cc3-151">Estos métodos crean una nueva tarea que se programa cuando se completa una parte o la totalidad del conjunto de tareas proporcionado.</span><span class="sxs-lookup"><span data-stu-id="33cc3-151">These methods create a new task that is scheduled when all or any of a supplied set of tasks completes.</span></span> <span data-ttu-id="33cc3-152">Estos métodos también proporcionan sobrecargas para controlar la programación y la ejecución de estas tareas.</span><span class="sxs-lookup"><span data-stu-id="33cc3-152">These methods also provide overloads to control the scheduling and execution of these tasks.</span></span>

<span data-ttu-id="33cc3-153">En las tareas enlazadas a cálculos, el sistema puede evitar la ejecución de una tarea programada si recibe una solicitud de cancelación antes de que comience la ejecución de la tarea.</span><span class="sxs-lookup"><span data-stu-id="33cc3-153">In compute-bound tasks, the system can prevent the execution of a scheduled task if it receives a cancellation request before it starts running the task.</span></span> <span data-ttu-id="33cc3-154">Por tanto, si proporciona un token de cancelación (objeto <xref:System.Threading.CancellationToken>), puede pasar ese token al código asincrónico que lo supervisa.</span><span class="sxs-lookup"><span data-stu-id="33cc3-154">As such, if you provide a cancellation token (<xref:System.Threading.CancellationToken> object), you can pass that token to the asynchronous code that monitors the token.</span></span> <span data-ttu-id="33cc3-155">También puede proporcionar el token a uno de los métodos mencionados previamente, como `StartNew` o `Run`, para que el runtime de `Task` también supervise el token.</span><span class="sxs-lookup"><span data-stu-id="33cc3-155">You can also provide the token to one of the previously mentioned methods such as `StartNew` or `Run` so that the `Task` runtime may also monitor the token.</span></span>

<span data-ttu-id="33cc3-156">Por ejemplo, considere un método asincrónico que presenta una imagen.</span><span class="sxs-lookup"><span data-stu-id="33cc3-156">For example, consider an asynchronous method that renders an image.</span></span> <span data-ttu-id="33cc3-157">El cuerpo de la tarea puede sondear el token de cancelación para que el código pueda salir pronto si llega una solicitud de cancelación durante la representación.</span><span class="sxs-lookup"><span data-stu-id="33cc3-157">The body of the task can poll the cancellation token so that the code may exit early if a cancellation request arrives during rendering.</span></span> <span data-ttu-id="33cc3-158">Además, si la solicitud de cancelación llega antes de que se inicie la representación, deseará evitar la operación de representación:</span><span class="sxs-lookup"><span data-stu-id="33cc3-158">In addition, if the cancellation request arrives before rendering starts, you'll want to prevent the rendering operation:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#3)]
[!code-vb[Conceptual.TAP_Patterns#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#3)]

<span data-ttu-id="33cc3-159">Las tareas enlazadas a cálculos finalizan en un estado <xref:System.Threading.Tasks.TaskStatus.Canceled> si se cumple al menos una de las condiciones siguientes:</span><span class="sxs-lookup"><span data-stu-id="33cc3-159">Compute-bound tasks end in a <xref:System.Threading.Tasks.TaskStatus.Canceled> state if at least one of the following conditions is true:</span></span>

- <span data-ttu-id="33cc3-160">Llega una solicitud de cancelación a través del objeto <xref:System.Threading.CancellationToken>, que se proporciona como argumento al método de creación (por ejemplo, `StartNew` o `Run`) antes de que la tarea cambie al estado <xref:System.Threading.Tasks.TaskStatus.Running>.</span><span class="sxs-lookup"><span data-stu-id="33cc3-160">A cancellation request arrives through the <xref:System.Threading.CancellationToken> object, which is provided as an argument to the creation method (for example, `StartNew` or `Run`) before the task transitions to the <xref:System.Threading.Tasks.TaskStatus.Running> state.</span></span>

- <span data-ttu-id="33cc3-161">Una excepción <xref:System.OperationCanceledException> no está controlada dentro del cuerpo de esta tarea, esa excepción contiene el mismo objeto <xref:System.Threading.CancellationToken> que se pasa a la tarea y ese token muestra que se solicitó la cancelación.</span><span class="sxs-lookup"><span data-stu-id="33cc3-161">An <xref:System.OperationCanceledException> exception goes unhandled within the body of such a task, that exception contains the same <xref:System.Threading.CancellationToken> that is passed to the task, and that token shows that cancellation is requested.</span></span>

<span data-ttu-id="33cc3-162">Si hay otra excepción no controlada en el cuerpo de la tarea, la tarea finaliza en el estado <xref:System.Threading.Tasks.TaskStatus.Faulted> y cualquier intento de esperar en la tarea u obtener acceso a su resultado produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="33cc3-162">If another exception goes unhandled within the body of the task, the task ends in the <xref:System.Threading.Tasks.TaskStatus.Faulted> state, and any attempts to wait on the task or access its result causes an exception to be thrown.</span></span>

### <a name="io-bound-tasks"></a><span data-ttu-id="33cc3-163">Tareas enlazadas a E/S</span><span class="sxs-lookup"><span data-stu-id="33cc3-163">I/O-bound tasks</span></span>
<span data-ttu-id="33cc3-164">Para crear una tarea a la que no deba respaldar directamente un subproceso durante toda su ejecución, use el tipo <xref:System.Threading.Tasks.TaskCompletionSource%601>.</span><span class="sxs-lookup"><span data-stu-id="33cc3-164">To create a task that should not be directly backed by a thread for the entirety of its execution, use the <xref:System.Threading.Tasks.TaskCompletionSource%601> type.</span></span> <span data-ttu-id="33cc3-165">Este tipo expone una propiedad <xref:System.Threading.Tasks.TaskCompletionSource%601.Task%2A> que devuelve una instancia asociada de <xref:System.Threading.Tasks.Task%601>.</span><span class="sxs-lookup"><span data-stu-id="33cc3-165">This type exposes a <xref:System.Threading.Tasks.TaskCompletionSource%601.Task%2A> property that returns an associated <xref:System.Threading.Tasks.Task%601> instance.</span></span> <span data-ttu-id="33cc3-166">El ciclo de vida de esta tarea se controla mediante métodos <xref:System.Threading.Tasks.TaskCompletionSource%601> como <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A> y sus variantes de `TrySet`.</span><span class="sxs-lookup"><span data-stu-id="33cc3-166">The life cycle of this task is controlled by <xref:System.Threading.Tasks.TaskCompletionSource%601> methods such as <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A>, and their `TrySet` variants.</span></span>

<span data-ttu-id="33cc3-167">Suponga que desea crear una tarea que se completará después de un período de tiempo especificado.</span><span class="sxs-lookup"><span data-stu-id="33cc3-167">Let's say that you want to create a task that will complete after a specified period of time.</span></span> <span data-ttu-id="33cc3-168">Por ejemplo, puede que desee retrasar una actividad en la interfaz de usuario.</span><span class="sxs-lookup"><span data-stu-id="33cc3-168">For example, you may want to delay an activity in the user interface.</span></span> <span data-ttu-id="33cc3-169">La clase <xref:System.Threading.Timer?displayProperty=nameWithType> ya proporciona la capacidad de invocar de forma asincrónica un delegado después de un período de tiempo especificado, y <xref:System.Threading.Tasks.TaskCompletionSource%601> le permite colocar un objeto <xref:System.Threading.Tasks.Task%601> delante del temporizador, por ejemplo:</span><span class="sxs-lookup"><span data-stu-id="33cc3-169">The <xref:System.Threading.Timer?displayProperty=nameWithType> class already provides the ability to asynchronously invoke a delegate after a specified period of time, and by using <xref:System.Threading.Tasks.TaskCompletionSource%601> you can put a <xref:System.Threading.Tasks.Task%601> front on the timer, for example:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#4)]
[!code-vb[Conceptual.TAP_Patterns#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#4)]

<span data-ttu-id="33cc3-170">A partir de .NET Framework 4.5, el método <xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType> se proporciona con este propósito y puede usarlo dentro de otro método asincrónico, por ejemplo, para implementar un bucle asincrónico de sondeo:</span><span class="sxs-lookup"><span data-stu-id="33cc3-170">Starting with the .NET Framework 4.5, the <xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType> method is provided for this purpose, and you can use it inside another asynchronous method, for example, to implement an asynchronous polling loop:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#5)]
[!code-vb[Conceptual.TAP_Patterns#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#5)]

<span data-ttu-id="33cc3-171">La clase <xref:System.Threading.Tasks.TaskCompletionSource%601> no tiene ningún homólogo no genérico.</span><span class="sxs-lookup"><span data-stu-id="33cc3-171">The <xref:System.Threading.Tasks.TaskCompletionSource%601> class doesn't have a non-generic counterpart.</span></span> <span data-ttu-id="33cc3-172">Sin embargo, <xref:System.Threading.Tasks.Task%601> deriva de <xref:System.Threading.Tasks.Task>, por lo que puede usar el objeto genérico <xref:System.Threading.Tasks.TaskCompletionSource%601> para los métodos enlazados a E/S que simplemente devuelven una tarea.</span><span class="sxs-lookup"><span data-stu-id="33cc3-172">However, <xref:System.Threading.Tasks.Task%601> derives from <xref:System.Threading.Tasks.Task>, so you can use the generic <xref:System.Threading.Tasks.TaskCompletionSource%601> object for I/O-bound methods that simply return a task.</span></span> <span data-ttu-id="33cc3-173">Para ello, puede usar un origen con un `TResult` ficticio (<xref:System.Boolean> es una buena opción predeterminada, pero si le preocupa que el usuario de <xref:System.Threading.Tasks.Task> lo convierta en tipos inferiores a un objeto <xref:System.Threading.Tasks.Task%601>, puede usar un tipo `TResult` privado en su lugar).</span><span class="sxs-lookup"><span data-stu-id="33cc3-173">To do this, you can use a source with a dummy `TResult` (<xref:System.Boolean> is a good default choice, but if you're concerned about the user of the <xref:System.Threading.Tasks.Task> downcasting it to a <xref:System.Threading.Tasks.Task%601>, you can use a private `TResult` type instead).</span></span> <span data-ttu-id="33cc3-174">Por ejemplo, el método `Delay` del ejemplo anterior devuelve la hora actual junto con el desplazamiento resultante (`Task<DateTimeOffset>`).</span><span class="sxs-lookup"><span data-stu-id="33cc3-174">For example, the `Delay` method in the previous example returns the current time along with the resulting offset (`Task<DateTimeOffset>`).</span></span> <span data-ttu-id="33cc3-175">Si este valor de resultado es innecesario, el método podría codificarse como sigue (observe el cambio del tipo de valor devuelto y el cambio del argumento a <xref:System.Threading.Tasks.TaskCompletionSource%601.TrySetResult%2A>):</span><span class="sxs-lookup"><span data-stu-id="33cc3-175">If such a result value is unnecessary, the method could instead be coded as follows (note the change of return type and the change of argument to <xref:System.Threading.Tasks.TaskCompletionSource%601.TrySetResult%2A>):</span></span>

[!code-csharp[Conceptual.TAP_Patterns#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#6)]
[!code-vb[Conceptual.TAP_Patterns#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#6)]

### <a name="mixed-compute-bound-and-io-bound-tasks"></a><span data-ttu-id="33cc3-176">Tareas enlazadas a cálculos y enlazadas a E/S mixtas</span><span class="sxs-lookup"><span data-stu-id="33cc3-176">Mixed compute-bound and I/O-bound tasks</span></span>
<span data-ttu-id="33cc3-177">Los métodos asincrónicos no se limitan solo a operaciones enlazadas a cálculos o enlazadas a E/S, sino que pueden representar una combinación de ambas.</span><span class="sxs-lookup"><span data-stu-id="33cc3-177">Asynchronous methods are not limited to just compute-bound or I/O-bound operations but may represent a mixture of the two.</span></span> <span data-ttu-id="33cc3-178">De hecho, se suelen combinar varias operaciones asincrónicas en operaciones mixtas mayores.</span><span class="sxs-lookup"><span data-stu-id="33cc3-178">In fact, multiple asynchronous operations are often combined into larger mixed operations.</span></span> <span data-ttu-id="33cc3-179">Por ejemplo, el método `RenderAsync` de un ejemplo anterior realizaba una operación de cálculo intensiva para presentar una imagen basada en `imageData` de entrada.</span><span class="sxs-lookup"><span data-stu-id="33cc3-179">For example, the `RenderAsync` method in a previous example performed a computationally intensive operation to render an image based on some input `imageData`.</span></span> <span data-ttu-id="33cc3-180">Este `imageData` podría proceder de un servicio Web al que tiene acceso de forma asincrónica:</span><span class="sxs-lookup"><span data-stu-id="33cc3-180">This `imageData` could come from a web service that you asynchronously access:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#7)]
[!code-vb[Conceptual.TAP_Patterns#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#7)]

<span data-ttu-id="33cc3-181">En este ejemplo también se muestra cómo se puede incluir en un subproceso un único token de cancelación mediante varias operaciones asincrónicas.</span><span class="sxs-lookup"><span data-stu-id="33cc3-181">This example also demonstrates how a single cancellation token may be threaded through multiple asynchronous operations.</span></span> <span data-ttu-id="33cc3-182">Para más información, vea la sección de uso de la cancelación en [Utilizar el modelo asincrónico basado en tareas](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="33cc3-182">For more information, see the cancellation usage section in [Consuming the Task-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="33cc3-183">Vea también</span><span class="sxs-lookup"><span data-stu-id="33cc3-183">See also</span></span>

- [<span data-ttu-id="33cc3-184">Modelo asincrónico basado en tareas (TAP)</span><span class="sxs-lookup"><span data-stu-id="33cc3-184">Task-based Asynchronous Pattern (TAP)</span></span>](../../../docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md)
- [<span data-ttu-id="33cc3-185">Modelo asincrónico basado en tareas (TAP)</span><span class="sxs-lookup"><span data-stu-id="33cc3-185">Consuming the Task-based Asynchronous Pattern</span></span>](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md)
- [<span data-ttu-id="33cc3-186">Interoperabilidad con otros tipos y patrones asincrónicos</span><span class="sxs-lookup"><span data-stu-id="33cc3-186">Interop with Other Asynchronous Patterns and Types</span></span>](../../../docs/standard/asynchronous-programming-patterns/interop-with-other-asynchronous-patterns-and-types.md)
