---
description: 'Más información acerca de: Automatic Memory Management'
title: Automatic Memory Management
ms.date: 03/30/2017
helpviewer_keywords:
- garbage collection, automatic memory management
- memory, allocating
- memory, automatic memory management
- memory, releasing
- common language runtime, automatic memory management
- automatic memory management
- managed heap
- runtime, automatic memory management
ms.assetid: d4850de5-fa63-4936-a250-5678d118acba
ms.openlocfilehash: 1897167faecb112ffa4aa7b0dd0c8bb55b8d9459
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 02/06/2021
ms.locfileid: "99629973"
---
# <a name="automatic-memory-management"></a><span data-ttu-id="af0fb-103">Automatic Memory Management</span><span class="sxs-lookup"><span data-stu-id="af0fb-103">Automatic Memory Management</span></span>

<span data-ttu-id="af0fb-104">La administración de memoria automática es uno de los servicios que proporciona Common Language Runtime durante la [ejecución administrada](managed-execution-process.md).</span><span class="sxs-lookup"><span data-stu-id="af0fb-104">Automatic memory management is one of the services that the Common Language Runtime provides during [Managed Execution](managed-execution-process.md).</span></span> <span data-ttu-id="af0fb-105">El recolector de elementos no utilizados de Common Language Runtime administra la asignación y liberación de la memoria de una aplicación.</span><span class="sxs-lookup"><span data-stu-id="af0fb-105">The Common Language Runtime's garbage collector manages the allocation and release of memory for an application.</span></span> <span data-ttu-id="af0fb-106">Esto significa que los programadores no tienen que escribir código para realizar tareas de administración de memoria al programar aplicaciones administradas.</span><span class="sxs-lookup"><span data-stu-id="af0fb-106">For developers, this means that you do not have to write code to perform memory management tasks when you develop managed applications.</span></span> <span data-ttu-id="af0fb-107">La administración automática de la memoria puede eliminar problemas frecuentes, como olvidar liberar un objeto y causar una pérdida de memoria, o intentar tener acceso a la memoria de un objeto que ya se ha liberado.</span><span class="sxs-lookup"><span data-stu-id="af0fb-107">Automatic memory management can eliminate common problems, such as forgetting to free an object and causing a memory leak, or attempting to access memory for an object that has already been freed.</span></span> <span data-ttu-id="af0fb-108">En esta sección se describe cómo asigna y libera memoria el recolector de elementos no utilizados.</span><span class="sxs-lookup"><span data-stu-id="af0fb-108">This section describes how the garbage collector allocates and releases memory.</span></span>  
  
## <a name="allocating-memory"></a><span data-ttu-id="af0fb-109">Asignar memoria</span><span class="sxs-lookup"><span data-stu-id="af0fb-109">Allocating Memory</span></span>  

 <span data-ttu-id="af0fb-110">Cuando se inicializa un nuevo proceso, el motor en tiempo de ejecución reserva una región contigua de espacio de direcciones para el proceso.</span><span class="sxs-lookup"><span data-stu-id="af0fb-110">When you initialize a new process, the runtime reserves a contiguous region of address space for the process.</span></span> <span data-ttu-id="af0fb-111">Este espacio de direcciones reservado se denomina montón administrado.</span><span class="sxs-lookup"><span data-stu-id="af0fb-111">This reserved address space is called the managed heap.</span></span> <span data-ttu-id="af0fb-112">El montón administrado mantiene un puntero a la dirección a la que se asignará el siguiente objeto del montón.</span><span class="sxs-lookup"><span data-stu-id="af0fb-112">The managed heap maintains a pointer to the address where the next object in the heap will be allocated.</span></span> <span data-ttu-id="af0fb-113">Inicialmente, este puntero se establece en la dirección base del montón administrado.</span><span class="sxs-lookup"><span data-stu-id="af0fb-113">Initially, this pointer is set to the managed heap's base address.</span></span> <span data-ttu-id="af0fb-114">Todos los [tipos de referencia](base-types/common-type-system.md) se asignan en el montón administrado.</span><span class="sxs-lookup"><span data-stu-id="af0fb-114">All [reference types](base-types/common-type-system.md) are allocated on the managed heap.</span></span> <span data-ttu-id="af0fb-115">Cuando una aplicación crea el primer tipo de referencia, se le asigna memoria en la dirección base del montón administrado.</span><span class="sxs-lookup"><span data-stu-id="af0fb-115">When an application creates the first reference type, memory is allocated for the type at the base address of the managed heap.</span></span> <span data-ttu-id="af0fb-116">Cuando la aplicación crea el siguiente objeto, el recolector de elementos no utilizados le asigna memoria en el espacio de direcciones que sigue inmediatamente al primer objeto.</span><span class="sxs-lookup"><span data-stu-id="af0fb-116">When the application creates the next object, the garbage collector allocates memory for it in the address space immediately following the first object.</span></span> <span data-ttu-id="af0fb-117">Siempre que haya espacio de direcciones disponible, el recolector de elementos no utilizados continúa asignando espacio a los objetos nuevos de este modo.</span><span class="sxs-lookup"><span data-stu-id="af0fb-117">As long as address space is available, the garbage collector continues to allocate space for new objects in this manner.</span></span>  
  
 <span data-ttu-id="af0fb-118">La asignación de memoria desde el montón administrado es más rápida que la asignación de memoria no administrada.</span><span class="sxs-lookup"><span data-stu-id="af0fb-118">Allocating memory from the managed heap is faster than unmanaged memory allocation.</span></span> <span data-ttu-id="af0fb-119">Como el tiempo de ejecución asigna memoria a los objetos agregando un valor a un puntero, este método es casi tan rápido como la asignación de memoria desde la pila.</span><span class="sxs-lookup"><span data-stu-id="af0fb-119">Because the runtime allocates memory for an object by adding a value to a pointer, it is almost as fast as allocating memory from the stack.</span></span> <span data-ttu-id="af0fb-120">Además, puesto que los nuevos objetos que se asignan consecutivamente se almacenan uno junto a otro en el montón administrado, la aplicación puede tener un acceso muy rápido a los objetos.</span><span class="sxs-lookup"><span data-stu-id="af0fb-120">In addition, because new objects that are allocated consecutively are stored contiguously in the managed heap, an application can access the objects very quickly.</span></span>  
  
<a name="cpconautomaticmemorymanagementreleasingmemoryanchor1"></a>

## <a name="releasing-memory"></a><span data-ttu-id="af0fb-121">Liberar memoria</span><span class="sxs-lookup"><span data-stu-id="af0fb-121">Releasing Memory</span></span>  

 <span data-ttu-id="af0fb-122">El motor de optimización del recolector de elementos no utilizados determina cuál es el mejor momento para realizar una recolección basándose en las asignaciones realizadas.</span><span class="sxs-lookup"><span data-stu-id="af0fb-122">The garbage collector's optimizing engine determines the best time to perform a collection based on the allocations being made.</span></span> <span data-ttu-id="af0fb-123">Cuando el recolector de elementos no utilizados lleva a cabo una recolección, libera la memoria de los objetos que ya no usa la aplicación.</span><span class="sxs-lookup"><span data-stu-id="af0fb-123">When the garbage collector performs a collection, it releases the memory for objects that are no longer being used by the application.</span></span> <span data-ttu-id="af0fb-124">Determina qué objetos ya no se usan examinando las raíces de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="af0fb-124">It determines which objects are no longer being used by examining the application's roots.</span></span> <span data-ttu-id="af0fb-125">Todas las aplicaciones tienen un conjunto de raíces.</span><span class="sxs-lookup"><span data-stu-id="af0fb-125">Every application has a set of roots.</span></span> <span data-ttu-id="af0fb-126">Cada raíz hace referencia a un objeto del montón administrado, o bien se establece en null.</span><span class="sxs-lookup"><span data-stu-id="af0fb-126">Each root either refers to an object on the managed heap or is set to null.</span></span> <span data-ttu-id="af0fb-127">Las raíces de una aplicación incluyen campos estáticos, variables locales y parámetros de pila de un subproceso y registros de la CPU.</span><span class="sxs-lookup"><span data-stu-id="af0fb-127">An application's roots include static fields, local variables and parameters on a thread's stack, and CPU registers.</span></span> <span data-ttu-id="af0fb-128">El recolector de elementos no utilizados tiene acceso a la lista de raíces activas que el [compilador Just-In-Time (JIT)](managed-execution-process.md) y el runtime mantienen.</span><span class="sxs-lookup"><span data-stu-id="af0fb-128">The garbage collector has access to the list of active roots that the [just-in-time (JIT) compiler](managed-execution-process.md) and the runtime maintain.</span></span> <span data-ttu-id="af0fb-129">Con esta lista examina las raíces de la aplicación y, durante este proceso, crea un gráfico que contiene todos los objetos que no se pueden alcanzar desde las raíces.</span><span class="sxs-lookup"><span data-stu-id="af0fb-129">Using this list, it examines an application's roots, and in the process creates a graph that contains all the objects that are reachable from the roots.</span></span>  
  
 <span data-ttu-id="af0fb-130">Los objetos que no están en el gráfico no se pueden alcanzar desde las raíces de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="af0fb-130">Objects that are not in the graph are unreachable from the application's roots.</span></span> <span data-ttu-id="af0fb-131">El recolector de elementos no utilizados considera elementos no utilizados a los objetos inalcanzables y libera la memoria que tienen asignada.</span><span class="sxs-lookup"><span data-stu-id="af0fb-131">The garbage collector considers unreachable objects garbage and will release the memory allocated for them.</span></span> <span data-ttu-id="af0fb-132">Durante una recolección, el recolector de elementos no utilizados examina el montón administrado y busca los bloques de espacio de direcciones que ocupan los objetos que no se pueden alcanzar.</span><span class="sxs-lookup"><span data-stu-id="af0fb-132">During a collection, the garbage collector examines the managed heap, looking for the blocks of address space occupied by unreachable objects.</span></span> <span data-ttu-id="af0fb-133">Cuando detecta cada uno de los objetos inalcanzables, usa una función de copia de memoria para compactar los objetos alcanzables en la memoria y libera los bloques de espacios de direcciones asignados a los objetos no alcanzables.</span><span class="sxs-lookup"><span data-stu-id="af0fb-133">As it discovers each unreachable object, it uses a memory-copying function to compact the reachable objects in memory, freeing up the blocks of address spaces allocated to unreachable objects.</span></span> <span data-ttu-id="af0fb-134">Una vez que se ha compactado la memoria de los objetos alcanzables, el recolector de elementos no utilizados hace las correcciones de puntero necesarias para que las raíces de la aplicación señalen a los objetos en sus nuevas ubicaciones.</span><span class="sxs-lookup"><span data-stu-id="af0fb-134">Once the memory for the reachable objects has been compacted, the garbage collector makes the necessary pointer corrections so that the application's roots point to the objects in their new locations.</span></span> <span data-ttu-id="af0fb-135">También sitúa el puntero del montón administrado después del último objeto alcanzable.</span><span class="sxs-lookup"><span data-stu-id="af0fb-135">It also positions the managed heap's pointer after the last reachable object.</span></span> <span data-ttu-id="af0fb-136">Tenga en cuenta que la memoria sólo se compacta si, durante una recolección, se detecta un número significativo de objetos inalcanzables.</span><span class="sxs-lookup"><span data-stu-id="af0fb-136">Note that memory is compacted only if a collection discovers a significant number of unreachable objects.</span></span> <span data-ttu-id="af0fb-137">Si todos los objetos del montón administrado sobreviven a una recolección, no hay necesidad de comprimir la memoria.</span><span class="sxs-lookup"><span data-stu-id="af0fb-137">If all the objects in the managed heap survive a collection, then there is no need for memory compaction.</span></span>  
  
 <span data-ttu-id="af0fb-138">Para mejorar el rendimiento, el tiempo de ejecución asigna memoria a los objetos grandes en un montón aparte.</span><span class="sxs-lookup"><span data-stu-id="af0fb-138">To improve performance, the runtime allocates memory for large objects in a separate heap.</span></span> <span data-ttu-id="af0fb-139">El recolector de elementos no utilizados libera la memoria para los objetos grandes automáticamente.</span><span class="sxs-lookup"><span data-stu-id="af0fb-139">The garbage collector automatically releases the memory for large objects.</span></span> <span data-ttu-id="af0fb-140">Sin embargo, para no mover objetos grandes en la memoria, dicha memoria no se compacta.</span><span class="sxs-lookup"><span data-stu-id="af0fb-140">However, to avoid moving large objects in memory, this memory is not compacted.</span></span>  
  
## <a name="generations-and-performance"></a><span data-ttu-id="af0fb-141">Generaciones y rendimiento</span><span class="sxs-lookup"><span data-stu-id="af0fb-141">Generations and Performance</span></span>  

 <span data-ttu-id="af0fb-142">Para optimizar el rendimiento del recolector de elementos no utilizados, el montón administrado se divide en tres generaciones: 0, 1 y 2.</span><span class="sxs-lookup"><span data-stu-id="af0fb-142">To optimize the performance of the garbage collector, the managed heap is divided into three generations: 0, 1, and 2.</span></span> <span data-ttu-id="af0fb-143">El algoritmo de recolección de elementos no utilizados del runtime se basa en diversas generalizaciones que la industria de software informático ha detectado como ciertas al experimentar con esquemas de recolección de elementos no utilizados.</span><span class="sxs-lookup"><span data-stu-id="af0fb-143">The runtime's garbage collection algorithm is based on several generalizations that the computer software industry has discovered to be true by experimenting with garbage collection schemes.</span></span> <span data-ttu-id="af0fb-144">Primero, es más rápido compactar la memoria de una parte del montón administrado que la de todo el montón.</span><span class="sxs-lookup"><span data-stu-id="af0fb-144">First, it is faster to compact the memory for a portion of the managed heap than for the entire managed heap.</span></span> <span data-ttu-id="af0fb-145">En segundo lugar, los objetos más recientes tienen una duración más corta y los objetos antiguos tienen una duración más larga.</span><span class="sxs-lookup"><span data-stu-id="af0fb-145">Secondly, newer objects will have shorter lifetimes and older objects will have longer lifetimes.</span></span> <span data-ttu-id="af0fb-146">Por último, los objetos más recientes suelen estar relacionados unos con otros y la aplicación tiene acceso a ellos más o menos al mismo tiempo.</span><span class="sxs-lookup"><span data-stu-id="af0fb-146">Lastly, newer objects tend to be related to each other and accessed by the application around the same time.</span></span>  
  
 <span data-ttu-id="af0fb-147">El recolector de elementos no utilizados del runtime almacena los nuevos objetos en la generación 0.</span><span class="sxs-lookup"><span data-stu-id="af0fb-147">The runtime's garbage collector stores new objects in generation 0.</span></span> <span data-ttu-id="af0fb-148">Los objetos creados en las primeras etapas de la duración de la aplicación y que sobreviven a las recolecciones se promueven y se almacenan en las generaciones 1 y 2.</span><span class="sxs-lookup"><span data-stu-id="af0fb-148">Objects created early in the application's lifetime that survive collections are promoted and stored in generations 1 and 2.</span></span> <span data-ttu-id="af0fb-149">El proceso de promoción de objetos se describe más adelante en este tema.</span><span class="sxs-lookup"><span data-stu-id="af0fb-149">The process of object promotion is described later in this topic.</span></span> <span data-ttu-id="af0fb-150">Como es más rápido compactar una parte del montón administrado que todo el montón, este esquema permite que el recolector de elementos no utilizados libere la memoria en una generación específica en lugar de liberarla para todo el montón administrado cada vez que realiza una recolección.</span><span class="sxs-lookup"><span data-stu-id="af0fb-150">Because it is faster to compact a portion of the managed heap than the entire heap, this scheme allows the garbage collector to release the memory in a specific generation rather than release the memory for the entire managed heap each time it performs a collection.</span></span>  
  
 <span data-ttu-id="af0fb-151">En realidad, el recolector de elementos no utilizados realiza una recolección cuando se llena la generación 0.</span><span class="sxs-lookup"><span data-stu-id="af0fb-151">In reality, the garbage collector performs a collection when generation 0 is full.</span></span> <span data-ttu-id="af0fb-152">Si una aplicación trata de crear un nuevo objeto cuando la generación 0 está llena, el recolector de elementos no utilizados detecta que no queda espacio de direcciones en la generación 0 para asignárselo.</span><span class="sxs-lookup"><span data-stu-id="af0fb-152">If an application attempts to create a new object when generation 0 is full, the garbage collector discovers that there is no address space remaining in generation 0 to allocate for the object.</span></span> <span data-ttu-id="af0fb-153">El recolector de elementos no utilizados realiza una recolección, en un intento de liberar espacio de direcciones para el objeto en la generación 0.</span><span class="sxs-lookup"><span data-stu-id="af0fb-153">The garbage collector performs a collection in an attempt to free address space in generation 0 for the object.</span></span> <span data-ttu-id="af0fb-154">Primero examina los objetos de la generación 0 y no todos los objetos del montón administrado.</span><span class="sxs-lookup"><span data-stu-id="af0fb-154">The garbage collector starts by examining the objects in generation 0 rather than all objects in the managed heap.</span></span> <span data-ttu-id="af0fb-155">Éste es un enfoque más eficaz, ya que los objetos nuevos suelen tener una duración más corta y se espera que la aplicación no utilice muchos de los objetos de la generación 0 cuando se realice una recolección.</span><span class="sxs-lookup"><span data-stu-id="af0fb-155">This is the most efficient approach, because new objects tend to have short lifetimes, and it is expected that many of the objects in generation 0 will no longer be in use by the application when a collection is performed.</span></span> <span data-ttu-id="af0fb-156">Además, una recolección de tan sólo la generación 0 a menudo recupera suficiente memoria para que la aplicación pueda continuar creando nuevos objetos.</span><span class="sxs-lookup"><span data-stu-id="af0fb-156">In addition, a collection of generation 0 alone often reclaims enough memory to allow the application to continue creating new objects.</span></span>  
  
 <span data-ttu-id="af0fb-157">Una vez que el recolector de elementos no utilizados realiza una recolección de la generación 0, compacta la memoria de los objetos que se pueden alcanzar como se ha explicado antes en este tema, en [Liberar memoria](#cpconautomaticmemorymanagementreleasingmemoryanchor1).</span><span class="sxs-lookup"><span data-stu-id="af0fb-157">After the garbage collector performs a collection of generation 0, it compacts the memory for the reachable objects as explained in [Releasing Memory](#cpconautomaticmemorymanagementreleasingmemoryanchor1) earlier in this topic.</span></span> <span data-ttu-id="af0fb-158">A continuación, el recolector de elementos no utilizados promueve estos objetos y considera que esta parte del montón administrado está en la generación 1.</span><span class="sxs-lookup"><span data-stu-id="af0fb-158">The garbage collector then promotes these objects and considers this portion of the managed heap generation 1.</span></span> <span data-ttu-id="af0fb-159">Dado que los objetos que sobreviven a las recolecciones suelen tener una duración más larga, es lógico promoverlos a una generación superior.</span><span class="sxs-lookup"><span data-stu-id="af0fb-159">Because objects that survive collections tend to have longer lifetimes, it makes sense to promote them to a higher generation.</span></span> <span data-ttu-id="af0fb-160">En consecuencia, el recolector de elementos no utilizados no tiene que volver a examinar los objetos de las generaciones 1 y 2 cada vez que realiza una recolección en la generación 0.</span><span class="sxs-lookup"><span data-stu-id="af0fb-160">As a result, the garbage collector does not have to reexamine the objects in generations 1 and 2 each time it performs a collection of generation 0.</span></span>  
  
 <span data-ttu-id="af0fb-161">Una vez que el recolector de elementos no utilizados realiza su primera recolección de la generación 0 y promueve los objetos que se pueden alcanzar a la generación 1, considera que lo que queda del montón administrado forma parte de la generación 0.</span><span class="sxs-lookup"><span data-stu-id="af0fb-161">After the garbage collector performs its first collection of generation 0 and promotes the reachable objects to generation 1, it considers the remainder of the managed heap generation 0.</span></span> <span data-ttu-id="af0fb-162">Continúa asignando memoria a los nuevos objetos de la generación 0 hasta que la generación 0 está completa y es necesario realizar otra recolección.</span><span class="sxs-lookup"><span data-stu-id="af0fb-162">It continues to allocate memory for new objects in generation 0 until generation 0 is full and it is necessary to perform another collection.</span></span> <span data-ttu-id="af0fb-163">En este momento, el motor de optimización del recolector de elementos no utilizados determina si es necesario examinar los objetos de generaciones más antiguas.</span><span class="sxs-lookup"><span data-stu-id="af0fb-163">At this point, the garbage collector's optimizing engine determines whether it is necessary to examine the objects in older generations.</span></span> <span data-ttu-id="af0fb-164">Por ejemplo, si una recolección de la generación 0 no recupera memoria suficiente para que la aplicación pueda completar correctamente su intento de crear un nuevo objeto, el recolector de elementos no utilizados puede realizar una recolección de la generación 1 y, a continuación, de la generación 2.</span><span class="sxs-lookup"><span data-stu-id="af0fb-164">For example, if a collection of generation 0 does not reclaim enough memory for the application to successfully complete its attempt to create a new object, the garbage collector can perform a collection of generation 1, then generation 2.</span></span> <span data-ttu-id="af0fb-165">Si con ello no recupera suficiente memoria, el recolector de elementos no utilizados puede realizar una recolección de las generaciones 2, 1 y 0.</span><span class="sxs-lookup"><span data-stu-id="af0fb-165">If this does not reclaim enough memory, the garbage collector can perform a collection of generations 2, 1, and 0.</span></span> <span data-ttu-id="af0fb-166">Después de cada recolección, el recolector de elementos no utilizados compacta los objetos que puede alcanzar en la generación 0 y los promueve a la generación 1.</span><span class="sxs-lookup"><span data-stu-id="af0fb-166">After each collection, the garbage collector compacts the reachable objects in generation 0 and promotes them to generation 1.</span></span> <span data-ttu-id="af0fb-167">Los objetos de la generación 1 que sobreviven a las recolecciones se promueven a la generación 2.</span><span class="sxs-lookup"><span data-stu-id="af0fb-167">Objects in generation 1 that survive collections are promoted to generation 2.</span></span> <span data-ttu-id="af0fb-168">Como el recolector de elementos no utilizados solo admite tres generaciones, los objetos de la generación 2 que sobreviven a una recolección se mantienen en esta generación hasta que en una recolección posterior se determina que no se pueden alcanzar.</span><span class="sxs-lookup"><span data-stu-id="af0fb-168">Because the garbage collector supports only three generations, objects in generation 2 that survive a collection remain in generation 2 until they are determined to be unreachable in a future collection.</span></span>  
  
## <a name="releasing-memory-for-unmanaged-resources"></a><span data-ttu-id="af0fb-169">Liberar memoria para recursos no administrados</span><span class="sxs-lookup"><span data-stu-id="af0fb-169">Releasing Memory for Unmanaged Resources</span></span>  

 <span data-ttu-id="af0fb-170">En el caso de la mayoría de los objetos creados por la aplicación, puede utilizar el recolector de elementos no utilizados para realizar automáticamente las tareas de administración de memoria.</span><span class="sxs-lookup"><span data-stu-id="af0fb-170">For the majority of the objects that your application creates, you can rely on the garbage collector to automatically perform the necessary memory management tasks.</span></span> <span data-ttu-id="af0fb-171">Sin embargo, los recursos no administrados requieren una limpieza explícita.</span><span class="sxs-lookup"><span data-stu-id="af0fb-171">However, unmanaged resources require explicit cleanup.</span></span> <span data-ttu-id="af0fb-172">El tipo más habitual de recurso no administrado es un objeto que contiene un recurso del sistema operativo, como un identificador de archivo, identificador de ventana o conexión de red.</span><span class="sxs-lookup"><span data-stu-id="af0fb-172">The most common type of unmanaged resource is an object that wraps an operating system resource, such as a file handle, window handle, or network connection.</span></span> <span data-ttu-id="af0fb-173">Aunque el recolector de elementos no utilizados puede realizar el seguimiento del período de duración de un objeto administrado que encapsula un recurso no administrado, no tiene un conocimiento específico de cómo limpiar el recurso.</span><span class="sxs-lookup"><span data-stu-id="af0fb-173">Although the garbage collector is able to track the lifetime of a managed object that encapsulates an unmanaged resource, it does not have specific knowledge about how to clean up the resource.</span></span> <span data-ttu-id="af0fb-174">Cuando se crea un objeto que encapsula un recurso no administrado, es recomendable proporcionar el código necesario para limpiar dicho recurso en un método público **Dispose**.</span><span class="sxs-lookup"><span data-stu-id="af0fb-174">When you create an object that encapsulates an unmanaged resource, it is recommended that you provide the necessary code to clean up the unmanaged resource in a public **Dispose** method.</span></span> <span data-ttu-id="af0fb-175">Si se proporciona un método **Dispose**, se permite que los usuarios del objeto liberen su memoria de manera explícita cuando hayan terminado de usarlo.</span><span class="sxs-lookup"><span data-stu-id="af0fb-175">By providing a **Dispose** method, you enable users of your object to explicitly free its memory when they are finished with the object.</span></span> <span data-ttu-id="af0fb-176">Si se utiliza un objeto que encapsula un recurso no administrado, se debe conocer la existencia de **Dispose** y llamarlo cuando sea necesario.</span><span class="sxs-lookup"><span data-stu-id="af0fb-176">When you use an object that encapsulates an unmanaged resource, you should be aware of **Dispose** and call it as necessary.</span></span> <span data-ttu-id="af0fb-177">Para más información sobre la limpieza de recursos no administrados y el ejemplo de un modelo de diseño para implementar **Dispose**, consulte [Recolección de elementos no utilizados](garbage-collection/index.md).</span><span class="sxs-lookup"><span data-stu-id="af0fb-177">For more information about cleaning up unmanaged resources and an example of a design pattern for implementing **Dispose**, see [Garbage Collection](garbage-collection/index.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="af0fb-178">Vea también</span><span class="sxs-lookup"><span data-stu-id="af0fb-178">See also</span></span>

- <xref:System.GC>
- [<span data-ttu-id="af0fb-179">Recolección de elementos no utilizados</span><span class="sxs-lookup"><span data-stu-id="af0fb-179">Garbage Collection</span></span>](garbage-collection/index.md)
- [<span data-ttu-id="af0fb-180">Proceso de ejecución administrada</span><span class="sxs-lookup"><span data-stu-id="af0fb-180">Managed Execution Process</span></span>](managed-execution-process.md)
