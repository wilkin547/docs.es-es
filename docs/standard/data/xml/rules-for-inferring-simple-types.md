---
title: Reglas para deducir tipos simples
ms.date: 03/30/2017
ms.technology: dotnet-standard
ms.assetid: 394624d6-4da0-430a-8a88-46efe40f14de
ms.openlocfilehash: 17429e77f7764873e607a8feaa62da1cc6e014a4
ms.sourcegitcommit: 5f236cd78cf09593c8945a7d753e0850e96a0b80
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 01/07/2020
ms.locfileid: "75710237"
---
# <a name="rules-for-inferring-simple-types"></a><span data-ttu-id="2dc7a-102">Reglas para deducir tipos simples</span><span class="sxs-lookup"><span data-stu-id="2dc7a-102">Rules for Inferring Simple Types</span></span>
<span data-ttu-id="2dc7a-103">Describe cómo la clase <xref:System.Xml.Schema.XmlSchemaInference> deduce el tipo de datos para atributos y elementos.</span><span class="sxs-lookup"><span data-stu-id="2dc7a-103">Describes how the <xref:System.Xml.Schema.XmlSchemaInference> class infers the data type for attributes and elements.</span></span>  
  
 <span data-ttu-id="2dc7a-104">La clase <xref:System.Xml.Schema.XmlSchemaInference> deduce el tipo de datos para atributos y elementos como tipos simples.</span><span class="sxs-lookup"><span data-stu-id="2dc7a-104">The <xref:System.Xml.Schema.XmlSchemaInference> class infers the data type for attributes and elements as simple types.</span></span> <span data-ttu-id="2dc7a-105">Esta sección describe los tipos deducidos potenciales, cómo se reconcilian varios valores diferentes en un tipo único y cómo se controlan los atributos de definición de esquema `xsi`.</span><span class="sxs-lookup"><span data-stu-id="2dc7a-105">This section describes the potential inferred types, how multiple differing values are reconciled to a single type, and how schema-defining `xsi` attributes are handled.</span></span>  
  
## <a name="inferred-types"></a><span data-ttu-id="2dc7a-106">Tipos deducidos</span><span class="sxs-lookup"><span data-stu-id="2dc7a-106">Inferred Types</span></span>  
 <span data-ttu-id="2dc7a-107">La clase <xref:System.Xml.Schema.XmlSchemaInference> deduce valores de elemento y atributo como tipos simples e incluye un atributo de tipo en el esquema resultante.</span><span class="sxs-lookup"><span data-stu-id="2dc7a-107">The <xref:System.Xml.Schema.XmlSchemaInference> class infers element and attribute values as simple types and includes a type attribute in the resulting schema.</span></span> <span data-ttu-id="2dc7a-108">Todos los tipos deducidos son tipos simples.</span><span class="sxs-lookup"><span data-stu-id="2dc7a-108">All inferred types are simple types.</span></span> <span data-ttu-id="2dc7a-109">No se incluyen tipos ni facetas base como parte del esquema resultante.</span><span class="sxs-lookup"><span data-stu-id="2dc7a-109">No base types or facets are included as part of the resulting schema.</span></span>  
  
 <span data-ttu-id="2dc7a-110">Los valores se examinan individualmente a medida que se encuentran en el documento XML.</span><span class="sxs-lookup"><span data-stu-id="2dc7a-110">Values are examined individually as they are encountered in the XML document.</span></span> <span data-ttu-id="2dc7a-111">El tipo se deduce para un valor en el momento que se examina.</span><span class="sxs-lookup"><span data-stu-id="2dc7a-111">The type is inferred for a value at the time it is examined.</span></span> <span data-ttu-id="2dc7a-112">Si un tipo ha sido deducido para un atributo o elemento y se encuentra un valor para el atributo o elemento que no coincide con el tipo deducido actual, la clase <xref:System.Xml.Schema.XmlSchemaInference> promueve el tipo de cada conjunto de reglas.</span><span class="sxs-lookup"><span data-stu-id="2dc7a-112">If a type has been inferred for an attribute or element, and a value for the attribute or element is encountered that does not match the currently inferred type, the <xref:System.Xml.Schema.XmlSchemaInference> class promotes the type for each of a set of rules.</span></span> <span data-ttu-id="2dc7a-113">Estas reglas se discuten en la sección Promoción de tipos, más adelante en este tema.</span><span class="sxs-lookup"><span data-stu-id="2dc7a-113">These rules are discussed in the Type Promotion section, later in this topic.</span></span>  
  
 <span data-ttu-id="2dc7a-114">La siguiente tabla enumera los tipos deducidos posibles para el esquema resultante.</span><span class="sxs-lookup"><span data-stu-id="2dc7a-114">The following table lists the possible inferred types for the resulting schema.</span></span>  
  
|<span data-ttu-id="2dc7a-115">Tipo simple</span><span class="sxs-lookup"><span data-stu-id="2dc7a-115">Simple Type</span></span>|<span data-ttu-id="2dc7a-116">Descripción</span><span class="sxs-lookup"><span data-stu-id="2dc7a-116">Description</span></span>|  
|-----------------|-----------------|  
|<span data-ttu-id="2dc7a-117">booleano</span><span class="sxs-lookup"><span data-stu-id="2dc7a-117">boolean</span></span>|<span data-ttu-id="2dc7a-118">True, false, 0, 1.</span><span class="sxs-lookup"><span data-stu-id="2dc7a-118">True, false, 0, 1.</span></span>|  
|<span data-ttu-id="2dc7a-119">byte</span><span class="sxs-lookup"><span data-stu-id="2dc7a-119">byte</span></span>|<span data-ttu-id="2dc7a-120">Enteros en un intervalo de -128 a 127.</span><span class="sxs-lookup"><span data-stu-id="2dc7a-120">Integers in the range of –128 to 127.</span></span>|  
|<span data-ttu-id="2dc7a-121">unsignedByte</span><span class="sxs-lookup"><span data-stu-id="2dc7a-121">unsignedByte</span></span>|<span data-ttu-id="2dc7a-122">Enteros en un intervalo de 0 a 255.</span><span class="sxs-lookup"><span data-stu-id="2dc7a-122">Integers in the range of 0 to 255.</span></span>|  
|<span data-ttu-id="2dc7a-123">short</span><span class="sxs-lookup"><span data-stu-id="2dc7a-123">short</span></span>|<span data-ttu-id="2dc7a-124">Enteros en un intervalo de –32768 a 32767.</span><span class="sxs-lookup"><span data-stu-id="2dc7a-124">Integers in the range of –32768 to 32767.</span></span>|  
|<span data-ttu-id="2dc7a-125">unsignedShort</span><span class="sxs-lookup"><span data-stu-id="2dc7a-125">unsignedShort</span></span>|<span data-ttu-id="2dc7a-126">Enteros en un intervalo de 0 a 65535.</span><span class="sxs-lookup"><span data-stu-id="2dc7a-126">Integers in the range of 0 to 65535.</span></span>|  
|<span data-ttu-id="2dc7a-127">int</span><span class="sxs-lookup"><span data-stu-id="2dc7a-127">int</span></span>|<span data-ttu-id="2dc7a-128">Enteros en un intervalo de –2147483648 a 2147483647.</span><span class="sxs-lookup"><span data-stu-id="2dc7a-128">Integers in the range of –2147483648 to 2147483647.</span></span>|  
|<span data-ttu-id="2dc7a-129">unsignedInt</span><span class="sxs-lookup"><span data-stu-id="2dc7a-129">unsignedInt</span></span>|<span data-ttu-id="2dc7a-130">Enteros en un intervalo de 0 a 4294967295.</span><span class="sxs-lookup"><span data-stu-id="2dc7a-130">Integers in the range of 0 to 4294967295.</span></span>|  
|<span data-ttu-id="2dc7a-131">long</span><span class="sxs-lookup"><span data-stu-id="2dc7a-131">long</span></span>|<span data-ttu-id="2dc7a-132">Enteros en un intervalo de –9223372036854775808 a 9223372036854775807.</span><span class="sxs-lookup"><span data-stu-id="2dc7a-132">Integers in the range of –9223372036854775808 to 9223372036854775807.</span></span>|  
|<span data-ttu-id="2dc7a-133">unsignedLong</span><span class="sxs-lookup"><span data-stu-id="2dc7a-133">unsignedLong</span></span>|<span data-ttu-id="2dc7a-134">Enteros en un intervalo de 0 a 18446744073709551615.</span><span class="sxs-lookup"><span data-stu-id="2dc7a-134">Integers in the range of 0 to 18446744073709551615.</span></span>|  
|<span data-ttu-id="2dc7a-135">enteros</span><span class="sxs-lookup"><span data-stu-id="2dc7a-135">integer</span></span>|<span data-ttu-id="2dc7a-136">Un número finito de dígitos posiblemente prefijado con "-".</span><span class="sxs-lookup"><span data-stu-id="2dc7a-136">A finite number of digits possibly prefixed with "-".</span></span>|  
|<span data-ttu-id="2dc7a-137">decimal</span><span class="sxs-lookup"><span data-stu-id="2dc7a-137">decimal</span></span>|<span data-ttu-id="2dc7a-138">Valores numéricos que contienen dígitos de precisión del 0 a 28.</span><span class="sxs-lookup"><span data-stu-id="2dc7a-138">Numerical values that contain from 0 to 28 digits of precision.</span></span>|  
|<span data-ttu-id="2dc7a-139">float</span><span class="sxs-lookup"><span data-stu-id="2dc7a-139">float</span></span>|<span data-ttu-id="2dc7a-140">Decimales opcionalmente seguidos por "E" o "e" seguidos de un valor entero representando el exponente.</span><span class="sxs-lookup"><span data-stu-id="2dc7a-140">Decimals optionally followed by "E" or "e" followed by an integer value representing the exponent.</span></span> <span data-ttu-id="2dc7a-141">Los valores decimales pueden estar en el intervalo de -16777216 a 16777216.</span><span class="sxs-lookup"><span data-stu-id="2dc7a-141">Decimal values can be in the range of -16777216 to 16777216.</span></span> <span data-ttu-id="2dc7a-142">Los valores del exponente pueden estar en el intervalo de –149 a 104.</span><span class="sxs-lookup"><span data-stu-id="2dc7a-142">Exponent values can be in the range of –149 to 104.</span></span><br /><br /> <span data-ttu-id="2dc7a-143">Float permite que valores especiales representen valores infinitos y no numéricos.</span><span class="sxs-lookup"><span data-stu-id="2dc7a-143">Float allows for special values to represent infinity and non-numeric values.</span></span> <span data-ttu-id="2dc7a-144">Los valores especiales para float son: 0, -0, INF, -INF, NaN.</span><span class="sxs-lookup"><span data-stu-id="2dc7a-144">Special values for float are: 0, -0, INF, -INF, NaN.</span></span>|  
|<span data-ttu-id="2dc7a-145">double</span><span class="sxs-lookup"><span data-stu-id="2dc7a-145">double</span></span>|<span data-ttu-id="2dc7a-146">Lo mismo que float excepto que los valores decimales pueden estar en el intervalo de -9007199254740992 a 9007199254740992, y los valores del exponente pueden estar en el intervalo de –1075 a 970.</span><span class="sxs-lookup"><span data-stu-id="2dc7a-146">The same as float except decimal values can be in the range of -9007199254740992 to 9007199254740992, and exponent values can be in the range of –1075 to 970.</span></span><br /><br /> <span data-ttu-id="2dc7a-147">Double permite que valores especiales representen valores infinitos y no numéricos.</span><span class="sxs-lookup"><span data-stu-id="2dc7a-147">Double allows for special values to represent infinity and non-numeric values.</span></span> <span data-ttu-id="2dc7a-148">Los valores especiales para float son: 0, -0, INF, -INF, NaN.</span><span class="sxs-lookup"><span data-stu-id="2dc7a-148">Special values for float are: 0, -0, INF, -INF, NaN.</span></span>|  
|<span data-ttu-id="2dc7a-149">duration</span><span class="sxs-lookup"><span data-stu-id="2dc7a-149">duration</span></span>|<span data-ttu-id="2dc7a-150">El formato de duración W3C.</span><span class="sxs-lookup"><span data-stu-id="2dc7a-150">The W3C duration format.</span></span>|  
|<span data-ttu-id="2dc7a-151">dateTime</span><span class="sxs-lookup"><span data-stu-id="2dc7a-151">dateTime</span></span>|<span data-ttu-id="2dc7a-152">El formato dateTime W3C.</span><span class="sxs-lookup"><span data-stu-id="2dc7a-152">The W3C dateTime format.</span></span>|  
|<span data-ttu-id="2dc7a-153">hora</span><span class="sxs-lookup"><span data-stu-id="2dc7a-153">time</span></span>|<span data-ttu-id="2dc7a-154">El formato time W3C.</span><span class="sxs-lookup"><span data-stu-id="2dc7a-154">The W3C time format.</span></span>|  
|<span data-ttu-id="2dc7a-155">date</span><span class="sxs-lookup"><span data-stu-id="2dc7a-155">date</span></span>|<span data-ttu-id="2dc7a-156">Los valores de años están restringidos de 0001 a 9999.</span><span class="sxs-lookup"><span data-stu-id="2dc7a-156">Year values are restricted from 0001 to 9999.</span></span>|  
|<span data-ttu-id="2dc7a-157">gYearMonth</span><span class="sxs-lookup"><span data-stu-id="2dc7a-157">gYearMonth</span></span>|<span data-ttu-id="2dc7a-158">El formato W3C de mes y año gregoriano.</span><span class="sxs-lookup"><span data-stu-id="2dc7a-158">The W3C Gregorian month and year format.</span></span>|  
|<span data-ttu-id="2dc7a-159">cadena</span><span class="sxs-lookup"><span data-stu-id="2dc7a-159">string</span></span>|<span data-ttu-id="2dc7a-160">Uno o más caracteres Unicode.</span><span class="sxs-lookup"><span data-stu-id="2dc7a-160">One or more Unicode characters.</span></span>|  
  
## <a name="type-promotion"></a><span data-ttu-id="2dc7a-161">Promoción de tipos</span><span class="sxs-lookup"><span data-stu-id="2dc7a-161">Type Promotion</span></span>  
 <span data-ttu-id="2dc7a-162">La clase <xref:System.Xml.Schema.XmlSchemaInference> examina los valores de atributo y elemento uno por uno.</span><span class="sxs-lookup"><span data-stu-id="2dc7a-162">The <xref:System.Xml.Schema.XmlSchemaInference> class examines attribute and element values one at a time.</span></span> <span data-ttu-id="2dc7a-163">A medida que se encuentran valores, se deduce el tipo sin signo más restrictivo.</span><span class="sxs-lookup"><span data-stu-id="2dc7a-163">As values are encountered, the most restrictive, unsigned type is inferred.</span></span> <span data-ttu-id="2dc7a-164">Si un tipo ha sido deducido para un atributo o elemento y se encuentra un nuevo valor que no coincide con el tipo deducido actual, el tipo deducido se promueve a un nuevo tipo que se aplica al tipo deducido actualmente y al nuevo valor.</span><span class="sxs-lookup"><span data-stu-id="2dc7a-164">If a type has been inferred for an attribute or element, and a new value is encountered that does not match the currently inferred type, the inferred type is promoted to a new type that applies to both the currently inferred type and the new value.</span></span> <span data-ttu-id="2dc7a-165">La clase <xref:System.Xml.Schema.XmlSchemaInference> considera valores anteriores cuando promueve el tipo deducido.</span><span class="sxs-lookup"><span data-stu-id="2dc7a-165">The <xref:System.Xml.Schema.XmlSchemaInference> class does consider previous values when promoting the inferred type.</span></span>  
  
 <span data-ttu-id="2dc7a-166">Por ejemplo, considere los siguientes fragmentos XML de dos documentos XML:</span><span class="sxs-lookup"><span data-stu-id="2dc7a-166">For example, consider the following XML fragments from two XML documents:</span></span>  
  
 `<MyElement1 attr1="12" />`  
  
 `<MyElement1 attr1="52344" />`  
  
 <span data-ttu-id="2dc7a-167">Cuando se encuentra el primer valor `attr1`, el tipo de `attr1` se deduce como `unsignedByte` basado en el valor `12`.</span><span class="sxs-lookup"><span data-stu-id="2dc7a-167">When the first `attr1` value is encountered, the type of `attr1` is inferred as `unsignedByte` based on the value `12`.</span></span> <span data-ttu-id="2dc7a-168">Cuando se encuentra el segundo `attr1`, el tipo se promueve a `unsignedShort` basado en el tipo deducido actualmente de `unsignedByte` y el valor actual `52344`.</span><span class="sxs-lookup"><span data-stu-id="2dc7a-168">When the second `attr1` is encountered, the type is promoted to `unsignedShort` based on the currently inferred type of `unsignedByte` and the current value `52344`.</span></span>  
  
 <span data-ttu-id="2dc7a-169">A continuación, considere el siguiente XML de dos documentos XML:</span><span class="sxs-lookup"><span data-stu-id="2dc7a-169">Now, consider the following XML from two XML documents:</span></span>  
  
 `<MyElement2 attr2="0" />`  
  
 `<MyElement2 attr2="true" />`  
  
 <span data-ttu-id="2dc7a-170">Cuando se encuentra el primer valor `attr2`, el tipo de `attr2` se deduce como `unsignedByte` basado en el valor `0`.</span><span class="sxs-lookup"><span data-stu-id="2dc7a-170">When the first `attr2` value is encountered, the type of `attr2` is inferred as `unsignedByte` based on the value `0`.</span></span> <span data-ttu-id="2dc7a-171">Cuando se encuentra el segundo `attr2`, el tipo se promueve a `string` basado en el tipo deducido actualmente de `unsignedByte` y el valor actual `true` ya que la clase <xref:System.Xml.Schema.XmlSchemaInference> tiene en cuenta valores anteriores cuando promueve el tipo deducido.</span><span class="sxs-lookup"><span data-stu-id="2dc7a-171">When the second `attr2` is encountered, the type is promoted to `string` based on the currently inferred type of `unsignedByte` and the current value `true` because the <xref:System.Xml.Schema.XmlSchemaInference> class does consider previous values when promoting the inferred type.</span></span> <span data-ttu-id="2dc7a-172">No obstante, si ambas instancias de `attr2` se encuentran en el mismo documento XML y no en dos documentos XML diferentes, tal como se ilustra arriba, `attr2` hubiese sido deducido como `boolean`.</span><span class="sxs-lookup"><span data-stu-id="2dc7a-172">However, if both instances of `attr2` were encountered in the same XML document and not in two different XML documents as illustrated above, `attr2` would have been inferred as `boolean`.</span></span>  
  
### <a name="ignored-attributes-from-the-httpswwww3org2001xmlschema-instance-namespace"></a><span data-ttu-id="2dc7a-173">Atributos omitidos del espacio de nombres <https://www.w3.org/2001/XMLSchema-instance></span><span class="sxs-lookup"><span data-stu-id="2dc7a-173">Ignored attributes from the <https://www.w3.org/2001/XMLSchema-instance> namespace</span></span>

<span data-ttu-id="2dc7a-174">Los siguientes son atributos que definen el esquema que son omitidos durante la deducción del sistema.</span><span class="sxs-lookup"><span data-stu-id="2dc7a-174">The following are schema-defining attributes that are ignored during schema inference.</span></span>  
  
|<span data-ttu-id="2dc7a-175">Atributo</span><span class="sxs-lookup"><span data-stu-id="2dc7a-175">Attribute</span></span>|<span data-ttu-id="2dc7a-176">Descripción</span><span class="sxs-lookup"><span data-stu-id="2dc7a-176">Description</span></span>|  
|---------------|-----------------|  
|`xsi:type`|<span data-ttu-id="2dc7a-177">Si un elemento se encuentra con tipo `xsi:type` especificado, el `xsi:type` es omitido.</span><span class="sxs-lookup"><span data-stu-id="2dc7a-177">If an element is encountered with `xsi:type` specified, the `xsi:type` is ignored.</span></span>|  
|`xsi:nil`|<span data-ttu-id="2dc7a-178">Si se encuentra un elemento con un atributo `xsi:nil`, su declaración de elemento en el esquema deducido tiene el valor de `nillable="true"`.</span><span class="sxs-lookup"><span data-stu-id="2dc7a-178">If an element with an `xsi:nil` attribute is encountered, its element declaration in the inferred schema has the value of `nillable="true"`.</span></span> <span data-ttu-id="2dc7a-179">Un elemento con un atributo `xsi:nil` establecido en `true` no puede tener elementos secundarios.</span><span class="sxs-lookup"><span data-stu-id="2dc7a-179">An element with an `xsi:nil` attribute set to `true` cannot have child elements.</span></span>|  
|`xsi:schemaLocation`|<span data-ttu-id="2dc7a-180">Si se encuentra `xsi:schemaLocation`, se omite.</span><span class="sxs-lookup"><span data-stu-id="2dc7a-180">If `xsi:schemaLocation` is encountered, it is ignored.</span></span>|  
|`xsi:noNamespaceSchemaLocation`|<span data-ttu-id="2dc7a-181">Si se encuentra `xsi:noNamespaceSchemaLocation`, se omite.</span><span class="sxs-lookup"><span data-stu-id="2dc7a-181">If `xsi:noNamespaceSchemaLocation` is encountered, it is ignored.</span></span>|  
  
## <a name="see-also"></a><span data-ttu-id="2dc7a-182">Vea también</span><span class="sxs-lookup"><span data-stu-id="2dc7a-182">See also</span></span>

- [<span data-ttu-id="2dc7a-183">Modelo de objetos de esquema XML (SOM)</span><span class="sxs-lookup"><span data-stu-id="2dc7a-183">XML Schema Object Model (SOM)</span></span>](../../../../docs/standard/data/xml/xml-schema-object-model-som.md)
- [<span data-ttu-id="2dc7a-184">Deducción de esquemas a partir de documentos XML</span><span class="sxs-lookup"><span data-stu-id="2dc7a-184">Inferring Schemas from XML Documents</span></span>](../../../../docs/standard/data/xml/inferring-schemas-from-xml-documents.md)
- [<span data-ttu-id="2dc7a-185">Reglas para deducir los tipos de nodo de esquema y estructura</span><span class="sxs-lookup"><span data-stu-id="2dc7a-185">Rules for Inferring Schema Node Types and Structure</span></span>](../../../../docs/standard/data/xml/rules-for-inferring-schema-node-types-and-structure.md)
