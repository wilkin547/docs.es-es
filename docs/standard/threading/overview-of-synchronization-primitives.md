---
title: Información general sobre las primitivas de sincronización
description: Obtenga información sobre las primitivas de sincronización de subprocesos .NET utilizadas para sincronizar el acceso a un recurso compartido o controlar la interacción de subprocesos
ms.date: 10/01/2018
ms.technology: dotnet-standard
helpviewer_keywords:
- synchronization, threads
- threading [.NET],synchronizing threads
- managed threading
ms.assetid: b782bcb8-da6a-4c6a-805f-2eb46d504309
ms.openlocfilehash: 43f78c914b7cb01f9b0de4c258d5882548e52790
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 03/15/2020
ms.locfileid: "73106590"
---
# <a name="overview-of-synchronization-primitives"></a><span data-ttu-id="9f329-103">Información general sobre las primitivas de sincronización</span><span class="sxs-lookup"><span data-stu-id="9f329-103">Overview of synchronization primitives</span></span>

<span data-ttu-id="9f329-104">.NET proporciona una variedad de tipos que puede usar para sincronizar el acceso a un recurso compartido o coordinar la interacción de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="9f329-104">.NET provides a range of types that you can use to synchronize access to a shared resource or coordinate thread interaction.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="9f329-105">Use la misma instancia primitiva de sincronización para proteger el acceso de un recurso compartido.</span><span class="sxs-lookup"><span data-stu-id="9f329-105">Use the same synchronization primitive instance to protect access of a shared resource.</span></span> <span data-ttu-id="9f329-106">Si usa instancias primitivas de sincronización distintas para proteger el mismo recurso, se evitará la protección proporcionada por una primitiva de sincronización.</span><span class="sxs-lookup"><span data-stu-id="9f329-106">If you use different synchronization primitive instances to protect the same resource, you'll circumvent the protection provided by a synchronization primitive.</span></span>

## <a name="waithandle-class-and-lightweight-synchronization-types"></a><span data-ttu-id="9f329-107">Clase WaitHandle y tipos de sincronización ligeros</span><span class="sxs-lookup"><span data-stu-id="9f329-107">WaitHandle class and lightweight synchronization types</span></span>

<span data-ttu-id="9f329-108">Varias primitivas de sincronización de .NET derivan de la clase <xref:System.Threading.WaitHandle?displayProperty=nameWithType>, que encapsula un controlador de sincronización del sistema operativo nativo y usa un mecanismo de señalización para la interacción de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="9f329-108">Multiple .NET synchronization primitives derive from the <xref:System.Threading.WaitHandle?displayProperty=nameWithType> class, which encapsulates a native operating system synchronization handle and uses a signaling mechanism for thread interaction.</span></span> <span data-ttu-id="9f329-109">Esas clases incluyen:</span><span class="sxs-lookup"><span data-stu-id="9f329-109">Those classes include:</span></span>

- <span data-ttu-id="9f329-110"><xref:System.Threading.Mutex?displayProperty=nameWithType>, que concede acceso exclusivo a un recurso compartido.</span><span class="sxs-lookup"><span data-stu-id="9f329-110"><xref:System.Threading.Mutex?displayProperty=nameWithType>, which grants exclusive access to a shared resource.</span></span> <span data-ttu-id="9f329-111">El estado de una exclusión mutua se señala si no es propiedad de ningún subproceso.</span><span class="sxs-lookup"><span data-stu-id="9f329-111">The state of a mutex is signaled if no thread owns it.</span></span>
- <span data-ttu-id="9f329-112"><xref:System.Threading.Semaphore?displayProperty=nameWithType>, que limita el número de subprocesos que pueden tener acceso a un recurso compartido o grupo de recursos simultáneamente.</span><span class="sxs-lookup"><span data-stu-id="9f329-112"><xref:System.Threading.Semaphore?displayProperty=nameWithType>, which limits the number of threads that can access a shared resource or a pool of resources concurrently.</span></span> <span data-ttu-id="9f329-113">El estado de un semáforo se establece como señalizado cuando su recuento es mayor que cero y como no señalizado cuando su recuento es cero.</span><span class="sxs-lookup"><span data-stu-id="9f329-113">The state of a semaphore is set to signaled when its count is greater than zero, and nonsignaled when its count is zero.</span></span>
- <span data-ttu-id="9f329-114"><xref:System.Threading.EventWaitHandle?displayProperty=nameWithType>, que representa un evento de sincronización de subprocesos y puede estar en un estado señalizado o no señalizado.</span><span class="sxs-lookup"><span data-stu-id="9f329-114"><xref:System.Threading.EventWaitHandle?displayProperty=nameWithType>, which represents a thread synchronization event and can be either in a signaled or unsignaled state.</span></span>
- <span data-ttu-id="9f329-115"><xref:System.Threading.AutoResetEvent?displayProperty=nameWithType>, que se deriva de <xref:System.Threading.EventWaitHandle> y, cuando está señalizada, se restablece automáticamente a un estado no señalizado después de liberar un subproceso en espera único.</span><span class="sxs-lookup"><span data-stu-id="9f329-115"><xref:System.Threading.AutoResetEvent?displayProperty=nameWithType>, which derives from <xref:System.Threading.EventWaitHandle> and, when signaled, resets automatically to an unsignaled state after releasing a single waiting thread.</span></span>
- <span data-ttu-id="9f329-116"><xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>, que se deriva de <xref:System.Threading.EventWaitHandle> y, cuando está señalizado, permanece en un estado señalizado hasta que se llama al método <xref:System.Threading.EventWaitHandle.Reset%2A>.</span><span class="sxs-lookup"><span data-stu-id="9f329-116"><xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>, which derives from <xref:System.Threading.EventWaitHandle> and, when signaled, stays in a signaled state until the <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>

<span data-ttu-id="9f329-117">En .NET Framework, dado que <xref:System.Threading.WaitHandle> deriva de <xref:System.MarshalByRefObject?displayProperty=nameWithType>, estos tipos se pueden usar para sincronizar las actividades de subprocesos en los límites del dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="9f329-117">In the .NET Framework, because <xref:System.Threading.WaitHandle> derives from <xref:System.MarshalByRefObject?displayProperty=nameWithType>, these types can be used to synchronize the activities of threads across application domain boundaries.</span></span>

<span data-ttu-id="9f329-118">En .NET Framework y .NET Core, algunos de estos tipos pueden representar los controladores de sincronización del sistema con nombre, que son visibles en todo el sistema operativo y se pueden usar para la sincronización entre procesos:</span><span class="sxs-lookup"><span data-stu-id="9f329-118">In the .NET Framework and .NET Core, some of these types can represent named system synchronization handles, which are visible throughout the operating system and can be used for the inter-process synchronization:</span></span>

- <span data-ttu-id="9f329-119"><xref:System.Threading.Mutex> (.NET Framework y .NET Core),</span><span class="sxs-lookup"><span data-stu-id="9f329-119"><xref:System.Threading.Mutex> (.NET Framework and .NET Core),</span></span>
- <span data-ttu-id="9f329-120"><xref:System.Threading.Semaphore> (.NET Framework y .NET Core en Windows),</span><span class="sxs-lookup"><span data-stu-id="9f329-120"><xref:System.Threading.Semaphore> (.NET Framework and .NET Core on Windows),</span></span>
- <span data-ttu-id="9f329-121"><xref:System.Threading.EventWaitHandle> (.NET Framework y .NET Core en Windows).</span><span class="sxs-lookup"><span data-stu-id="9f329-121"><xref:System.Threading.EventWaitHandle> (.NET Framework and .NET Core on Windows).</span></span>

<span data-ttu-id="9f329-122">Para más información, vea la referencia de API <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="9f329-122">For more information, see the <xref:System.Threading.WaitHandle> API reference.</span></span>

<span data-ttu-id="9f329-123">Los tipos de sincronización ligeros no se basan en los controladores del sistema operativo subyacentes y suelen proporcionar un mejor rendimiento.</span><span class="sxs-lookup"><span data-stu-id="9f329-123">Lightweight synchronization types don't rely on underlying operating system handles and typically provide better performance.</span></span> <span data-ttu-id="9f329-124">Sin embargo, no se pueden usar para la sincronización entre procesos.</span><span class="sxs-lookup"><span data-stu-id="9f329-124">However, they cannot be used for the inter-process synchronization.</span></span> <span data-ttu-id="9f329-125">Utilice esos tipos para la sincronización de subprocesos dentro de una aplicación.</span><span class="sxs-lookup"><span data-stu-id="9f329-125">Use those types for thread synchronization within one application.</span></span>

<span data-ttu-id="9f329-126">Algunos de esos tipos son alternativas a los tipos derivados de <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="9f329-126">Some of those types are alternatives to the types derived from <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="9f329-127">Por ejemplo, <xref:System.Threading.SemaphoreSlim> es una alternativa ligera a <xref:System.Threading.Semaphore>.</span><span class="sxs-lookup"><span data-stu-id="9f329-127">For example, <xref:System.Threading.SemaphoreSlim> is a lightweight alternative to <xref:System.Threading.Semaphore>.</span></span>

## <a name="synchronization-of-access-to-a-shared-resource"></a><span data-ttu-id="9f329-128">Sincronización del acceso a un recurso compartido</span><span class="sxs-lookup"><span data-stu-id="9f329-128">Synchronization of access to a shared resource</span></span>

<span data-ttu-id="9f329-129">.NET proporciona un intervalo de primitivas de sincronización para controlar el acceso a un recurso compartido por varios subprocesos.</span><span class="sxs-lookup"><span data-stu-id="9f329-129">.NET provides a range of synchronization primitives to control access to a shared resource by multiple threads.</span></span>

### <a name="monitor-class"></a><span data-ttu-id="9f329-130">Monitor (clase)</span><span class="sxs-lookup"><span data-stu-id="9f329-130">Monitor class</span></span>

<span data-ttu-id="9f329-131">La clase <xref:System.Threading.Monitor?displayProperty=nameWithType> concede acceso mutuamente exclusivo a un recurso compartido mediante la adquisición o liberación de un bloqueo en el objeto que identifica el recurso.</span><span class="sxs-lookup"><span data-stu-id="9f329-131">The <xref:System.Threading.Monitor?displayProperty=nameWithType> class grants mutually exclusive access to a shared resource by acquiring or releasing a lock on the object that identifies the resource.</span></span> <span data-ttu-id="9f329-132">Mientras se mantiene un bloqueo, el subproceso que lo mantiene puede volver a adquirir y liberar dicho bloqueo.</span><span class="sxs-lookup"><span data-stu-id="9f329-132">While a lock is held, the thread that holds the lock can again acquire and release the lock.</span></span> <span data-ttu-id="9f329-133">Ningún otro subproceso puede adquirir el bloqueo y el método <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> espera hasta que el bloqueo se libera.</span><span class="sxs-lookup"><span data-stu-id="9f329-133">Any other thread is blocked from acquiring the lock and the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> method waits until the lock is released.</span></span> <span data-ttu-id="9f329-134">El método <xref:System.Threading.Monitor.Enter%2A> adquiere un bloqueo liberado.</span><span class="sxs-lookup"><span data-stu-id="9f329-134">The <xref:System.Threading.Monitor.Enter%2A> method acquires a released lock.</span></span> <span data-ttu-id="9f329-135">También puede usar el método <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType> para especificar la cantidad de tiempo durante el cual un subproceso intenta adquirir un bloqueo.</span><span class="sxs-lookup"><span data-stu-id="9f329-135">You can also use the <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType> method to specify the amount of time during which a thread attempts to acquire a lock.</span></span> <span data-ttu-id="9f329-136">Dado que la clase <xref:System.Threading.Monitor> tiene afinidad de subproceso, el subproceso que adquirió un bloqueo debe liberarlo mediante una llamada al método <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9f329-136">Because the <xref:System.Threading.Monitor> class has thread affinity, the thread that acquired a lock must release the lock by calling the <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="9f329-137">Puede coordinar la interacción de subprocesos que adquieren un bloqueo en el mismo objeto mediante los métodos <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType> y <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9f329-137">You can coordinate the interaction of threads that acquire a lock on the same object by using the <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>, and <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> methods.</span></span>

<span data-ttu-id="9f329-138">Para más información, vea la referencia de API <xref:System.Threading.Monitor>.</span><span class="sxs-lookup"><span data-stu-id="9f329-138">For more information, see the <xref:System.Threading.Monitor> API reference.</span></span>

> [!NOTE]
> <span data-ttu-id="9f329-139">Use la instrucción [lock](../../csharp/language-reference/keywords/lock-statement.md) en C# y la instrucción [SyncLock](../../visual-basic/language-reference/statements/synclock-statement.md) en Visual Basic para sincronizar el acceso a un recurso compartido en lugar de usar la clase <xref:System.Threading.Monitor> directamente.</span><span class="sxs-lookup"><span data-stu-id="9f329-139">Use the [lock](../../csharp/language-reference/keywords/lock-statement.md) statement in C# and the [SyncLock](../../visual-basic/language-reference/statements/synclock-statement.md) statement in Visual Basic to synchronize access to a shared resource instead of using the <xref:System.Threading.Monitor> class directly.</span></span> <span data-ttu-id="9f329-140">Esas instrucciones se implementan mediante los métodos <xref:System.Threading.Monitor.Enter%2A> y <xref:System.Threading.Monitor.Exit%2A>, y usa un bloqueo `try…finally` para asegurarse de que se libere el bloqueo.</span><span class="sxs-lookup"><span data-stu-id="9f329-140">Those statements are implemented by using the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods and a `try…finally` block to ensure that the acquired lock is always released.</span></span>

### <a name="mutex-class"></a><span data-ttu-id="9f329-141">Mutex (clase)</span><span class="sxs-lookup"><span data-stu-id="9f329-141">Mutex class</span></span>

<span data-ttu-id="9f329-142">La clase <xref:System.Threading.Mutex?displayProperty=nameWithType>, como <xref:System.Threading.Monitor>, concede acceso exclusivo a un recurso compartido.</span><span class="sxs-lookup"><span data-stu-id="9f329-142">The <xref:System.Threading.Mutex?displayProperty=nameWithType> class, like <xref:System.Threading.Monitor>, grants exclusive access to a shared resource.</span></span> <span data-ttu-id="9f329-143">Utilice una de las sobrecargas del método [Mutex.WaitOne](<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>) para solicitar la propiedad de una exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="9f329-143">Use one of the [Mutex.WaitOne](<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>) method overloads to request the ownership of a mutex.</span></span> <span data-ttu-id="9f329-144">Al igual que <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> tiene afinidad de subproceso y el subproceso que adquirió una exclusión mutua debe liberarlo llamando al método <xref:System.Threading.Mutex.ReleaseMutex%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9f329-144">Like <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> has thread affinity and the thread that acquired a mutex must release it by calling the <xref:System.Threading.Mutex.ReleaseMutex%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="9f329-145">A diferencia de <xref:System.Threading.Monitor>, la clase <xref:System.Threading.Mutex> puede usarse para la sincronización entre procesos.</span><span class="sxs-lookup"><span data-stu-id="9f329-145">Unlike <xref:System.Threading.Monitor>, the <xref:System.Threading.Mutex> class can be used for inter-process synchronization.</span></span> <span data-ttu-id="9f329-146">Para ello, use una exclusión mutua con nombre, que es visible en todo el sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="9f329-146">To do that, use a named mutex, which is visible throughout the operating system.</span></span> <span data-ttu-id="9f329-147">Para crear una instancia de la exclusión mutua con nombre, use un [constructor de exclusión mutua](<xref:System.Threading.Mutex.%23ctor%2A>) que especifica un nombre.</span><span class="sxs-lookup"><span data-stu-id="9f329-147">To create a named mutex instance, use a [Mutex constructor](<xref:System.Threading.Mutex.%23ctor%2A>) that specifies a name.</span></span> <span data-ttu-id="9f329-148">También se puede llamar al método <xref:System.Threading.Mutex.OpenExisting%2A?displayProperty=nameWithType> para abrir una exclusión mutua del sistema existente.</span><span class="sxs-lookup"><span data-stu-id="9f329-148">You also can call the <xref:System.Threading.Mutex.OpenExisting%2A?displayProperty=nameWithType> method to open an existing named system mutex.</span></span>
  
<span data-ttu-id="9f329-149">Para más información, vea el artículo [Mutexes](mutexes.md) y la referencia de API <xref:System.Threading.Mutex>.</span><span class="sxs-lookup"><span data-stu-id="9f329-149">For more information, see the [Mutexes](mutexes.md) article and the <xref:System.Threading.Mutex> API reference.</span></span>

### <a name="spinlock-structure"></a><span data-ttu-id="9f329-150">SpinLock (estructura)</span><span class="sxs-lookup"><span data-stu-id="9f329-150">SpinLock structure</span></span>

<span data-ttu-id="9f329-151">La estructura <xref:System.Threading.SpinLock?displayProperty=nameWithType>, como <xref:System.Threading.Monitor>, concede acceso exclusivo a un recurso compartido en función de la disponibilidad de un bloqueo.</span><span class="sxs-lookup"><span data-stu-id="9f329-151">The <xref:System.Threading.SpinLock?displayProperty=nameWithType> structure, like <xref:System.Threading.Monitor>, grants exclusive access to a shared resource based on the availability of a lock.</span></span> <span data-ttu-id="9f329-152">Cuando <xref:System.Threading.SpinLock> intenta adquirir un bloqueo que no está disponible, espera en un bucle, y realiza comprobaciones repetidamente hasta que dicho bloqueo esté disponible.</span><span class="sxs-lookup"><span data-stu-id="9f329-152">When <xref:System.Threading.SpinLock> attempts to acquire a lock that is unavailable, it waits in a loop, repeatedly checking until the lock becomes available.</span></span>

<span data-ttu-id="9f329-153">Para más información sobre las ventajas e inconvenientes del uso de un bloqueo de giro, vea el artículo [SpinLock](spinlock.md) y la referencia de API <xref:System.Threading.SpinLock>.</span><span class="sxs-lookup"><span data-stu-id="9f329-153">For more information about the benefits and drawbacks of using spin lock, see the [SpinLock](spinlock.md) article and the <xref:System.Threading.SpinLock> API reference.</span></span>

### <a name="readerwriterlockslim-class"></a><span data-ttu-id="9f329-154">ReaderWriterLockSlim (clase)</span><span class="sxs-lookup"><span data-stu-id="9f329-154">ReaderWriterLockSlim class</span></span>

<span data-ttu-id="9f329-155">La clase <xref:System.Threading.ReaderWriterLockSlim?displayProperty=nameWithType> concede acceso exclusivo a un recurso compartido para escritura y permite que varios subprocesos accedan al recurso simultáneamente para lectura.</span><span class="sxs-lookup"><span data-stu-id="9f329-155">The <xref:System.Threading.ReaderWriterLockSlim?displayProperty=nameWithType> class grants exclusive access to a shared resource for writing and allows multiple threads to access the resource simultaneously for reading.</span></span> <span data-ttu-id="9f329-156">Es posible que desee utilizar <xref:System.Threading.ReaderWriterLockSlim> para sincronizar el acceso a una estructura de datos compartida que admita operaciones de lectura seguras para subprocesos, pero que requiera acceso exclusivo para realizar la operación de escritura.</span><span class="sxs-lookup"><span data-stu-id="9f329-156">You might want to use <xref:System.Threading.ReaderWriterLockSlim> to synchronize access to a shared data structure that supports thread-safe read operations, but requires exclusive access to perform write operation.</span></span> <span data-ttu-id="9f329-157">Cuando un subproceso solicita acceso exclusivo (por ejemplo, llamando al método <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A?displayProperty=nameWithType>), las solicitudes posteriores del lector y el escritor se bloquean hasta que todos los lectores existentes han salido del bloqueo y el escritor ha entrado y salido de dicho bloqueo.</span><span class="sxs-lookup"><span data-stu-id="9f329-157">When a thread requests exclusive access (for example, by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A?displayProperty=nameWithType> method), subsequent reader and writer requests block until all existing readers have exited the lock, and the writer has entered and exited the lock.</span></span>
  
<span data-ttu-id="9f329-158">Para más información, vea la referencia de API <xref:System.Threading.ReaderWriterLockSlim>.</span><span class="sxs-lookup"><span data-stu-id="9f329-158">For more information, see the <xref:System.Threading.ReaderWriterLockSlim> API reference.</span></span>

### <a name="semaphore-and-semaphoreslim-classes"></a><span data-ttu-id="9f329-159">Semaphore y SemaphoreSlim (clases)</span><span class="sxs-lookup"><span data-stu-id="9f329-159">Semaphore and SemaphoreSlim classes</span></span>

<span data-ttu-id="9f329-160">Las clases <xref:System.Threading.Semaphore?displayProperty=nameWithType> y <xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> limitan el número de subprocesos que pueden tener acceso a un recurso compartido o grupo de recursos simultáneamente.</span><span class="sxs-lookup"><span data-stu-id="9f329-160">The <xref:System.Threading.Semaphore?displayProperty=nameWithType> and <xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> classes limit the number of threads that can access a shared resource or a pool of resources concurrently.</span></span> <span data-ttu-id="9f329-161">Los demás subprocesos que soliciten el recurso esperarán hasta que un subproceso libere el semáforo.</span><span class="sxs-lookup"><span data-stu-id="9f329-161">Additional threads that request the resource wait until any thread releases the semaphore.</span></span> <span data-ttu-id="9f329-162">Dado que el semáforo no tiene afinidad de subproceso, un subproceso puede adquirir el semáforo y otro puede liberarlo.</span><span class="sxs-lookup"><span data-stu-id="9f329-162">Because the semaphore doesn't have thread affinity, a thread can acquire the semaphore and another one can release it.</span></span>

<span data-ttu-id="9f329-163"><xref:System.Threading.SemaphoreSlim> es una alternativa ligera a <xref:System.Threading.Semaphore> y solo se puede usar para la sincronización dentro de un límite de un único proceso.</span><span class="sxs-lookup"><span data-stu-id="9f329-163"><xref:System.Threading.SemaphoreSlim> is a lightweight alternative to <xref:System.Threading.Semaphore> and can be used only for synchronization within a single process boundary.</span></span>

<span data-ttu-id="9f329-164">En Windows, puede usar <xref:System.Threading.Semaphore> para la sincronización entre procesos.</span><span class="sxs-lookup"><span data-stu-id="9f329-164">On Windows, you can use <xref:System.Threading.Semaphore> for the inter-process synchronization.</span></span> <span data-ttu-id="9f329-165">Para hacerlo, cree una instancia de <xref:System.Threading.Semaphore> que represente un semáforo de sistema con nombre mediante el uso de uno de los [constructores Semaphore](<xref:System.Threading.Semaphore.%23ctor%2A>) que especifica un nombre o el método <xref:System.Threading.Semaphore.OpenExisting%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9f329-165">To do that, create a <xref:System.Threading.Semaphore> instance that represents a named system semaphore by using one of the [Semaphore constructors](<xref:System.Threading.Semaphore.%23ctor%2A>) that specifies a name or the <xref:System.Threading.Semaphore.OpenExisting%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="9f329-166"><xref:System.Threading.SemaphoreSlim> no es compatible con los semáforos con nombre del sistema.</span><span class="sxs-lookup"><span data-stu-id="9f329-166"><xref:System.Threading.SemaphoreSlim> doesn't support named system semaphores.</span></span>

<span data-ttu-id="9f329-167">Para más información, consulte el artículo [Semaphore y SemaphoreSlim](semaphore-and-semaphoreslim.md) y la referencia de API <xref:System.Threading.Semaphore> o <xref:System.Threading.SemaphoreSlim>.</span><span class="sxs-lookup"><span data-stu-id="9f329-167">For more information, see the [Semaphore and SemaphoreSlim](semaphore-and-semaphoreslim.md) article and the <xref:System.Threading.Semaphore> or <xref:System.Threading.SemaphoreSlim> API reference.</span></span>

## <a name="thread-interaction-or-signaling"></a><span data-ttu-id="9f329-168">Interacción de subprocesos o señalización</span><span class="sxs-lookup"><span data-stu-id="9f329-168">Thread interaction, or signaling</span></span>

<span data-ttu-id="9f329-169">Interacción de subprocesos (o señalización de subprocesos) significa que un subproceso debe esperar la notificación o una señal de uno o varios subprocesos para poder continuar.</span><span class="sxs-lookup"><span data-stu-id="9f329-169">Thread interaction (or thread signaling) means that a thread must wait for notification, or a signal, from one or more threads in order to proceed.</span></span> <span data-ttu-id="9f329-170">Por ejemplo, si un subproceso A llama al método <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType> del subproceso B, un subproceso A se bloquea hasta que el subproceso B finaliza.</span><span class="sxs-lookup"><span data-stu-id="9f329-170">For example, if thread A calls the <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType> method of thread B, thread A is blocked until thread B completes.</span></span> <span data-ttu-id="9f329-171">Las primitivas de sincronización descritas en la sección anterior proporcionan un mecanismo diferente para la señalización: al liberar un bloqueo, un subproceso notifica a otro subproceso que puede continuar adquiriendo el bloqueo.</span><span class="sxs-lookup"><span data-stu-id="9f329-171">The synchronization primitives described in the preceding section provide a different mechanism for signaling: by releasing a lock, a thread notifies another thread that it can proceed by acquiring the lock.</span></span>

<span data-ttu-id="9f329-172">En esta sección se describen construcciones adicionales de señalización proporcionados por. NET.</span><span class="sxs-lookup"><span data-stu-id="9f329-172">This section describes additional signaling constructs provided by .NET.</span></span>

### <a name="eventwaithandle-autoresetevent-manualresetevent-and-manualreseteventslim-classes"></a><span data-ttu-id="9f329-173">EventWaitHandle, AutoResetEvent, ManualResetEvent y ManualResetEventSlim (clases)</span><span class="sxs-lookup"><span data-stu-id="9f329-173">EventWaitHandle, AutoResetEvent, ManualResetEvent, and ManualResetEventSlim classes</span></span>

<span data-ttu-id="9f329-174">La clase <xref:System.Threading.EventWaitHandle?displayProperty=nameWithType> representa un evento de sincronización de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="9f329-174">The <xref:System.Threading.EventWaitHandle?displayProperty=nameWithType> class represents a thread synchronization event.</span></span>

<span data-ttu-id="9f329-175">Un evento de sincronización puede estar en un estado de no señalizado o señalizado.</span><span class="sxs-lookup"><span data-stu-id="9f329-175">A synchronization event can be either in an unsignaled or signaled state.</span></span> <span data-ttu-id="9f329-176">Cuando el estado de un evento es señalizado, un subproceso que llama a la sobrecarga <xref:System.Threading.WaitHandle.WaitOne%2A?> del evento se bloquea hasta que un evento se señaliza.</span><span class="sxs-lookup"><span data-stu-id="9f329-176">When the state of an event is unsignaled, a thread that calls the event's <xref:System.Threading.WaitHandle.WaitOne%2A?> overload is blocked until an event is signaled.</span></span> <span data-ttu-id="9f329-177">El método <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> establece el estado de un evento en señalizado.</span><span class="sxs-lookup"><span data-stu-id="9f329-177">The <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> method sets the state of an event to signaled.</span></span>

<span data-ttu-id="9f329-178">El comportamiento de una clase <xref:System.Threading.EventWaitHandle> que se haya señalizado depende de su modo de restablecimiento:</span><span class="sxs-lookup"><span data-stu-id="9f329-178">The behavior of an <xref:System.Threading.EventWaitHandle> that has been signaled depends on its reset mode:</span></span>

- <span data-ttu-id="9f329-179">Una clase <xref:System.Threading.EventWaitHandle> creada con la marca <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> se restablece automáticamente después de liberar un subproceso en espera único.</span><span class="sxs-lookup"><span data-stu-id="9f329-179">An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag resets automatically after releasing a single waiting thread.</span></span> <span data-ttu-id="9f329-180">Es como un torniquete que permite solo un subproceso cada vez que se señaliza.</span><span class="sxs-lookup"><span data-stu-id="9f329-180">It's like a turnstile that allows only one thread through each time it's signaled.</span></span> <span data-ttu-id="9f329-181">La clase <xref:System.Threading.AutoResetEvent?displayProperty=nameWithType>, que deriva de <xref:System.Threading.EventWaitHandle>, representa ese comportamiento.</span><span class="sxs-lookup"><span data-stu-id="9f329-181">The <xref:System.Threading.AutoResetEvent?displayProperty=nameWithType> class, which derives from <xref:System.Threading.EventWaitHandle>, represents that behavior.</span></span>
- <span data-ttu-id="9f329-182">Una clase <xref:System.Threading.EventWaitHandle> creada con la marca <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> permanece señalizada hasta que se llama a su método <xref:System.Threading.EventWaitHandle.Reset%2A>.</span><span class="sxs-lookup"><span data-stu-id="9f329-182">An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span> <span data-ttu-id="9f329-183">Es como una puerta que está cerrada hasta que se señaliza y a partir de entonces permanece abierta hasta que alguien la cierra.</span><span class="sxs-lookup"><span data-stu-id="9f329-183">It's like a gate that is closed until signaled and then stays open until someone closes it.</span></span> <span data-ttu-id="9f329-184">La clase <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>, que deriva de <xref:System.Threading.EventWaitHandle>, representa ese comportamiento.</span><span class="sxs-lookup"><span data-stu-id="9f329-184">The <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType> class, which derives from <xref:System.Threading.EventWaitHandle>, represents that behavior.</span></span> <span data-ttu-id="9f329-185">La clase <xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> es una alternativa ligera a <xref:System.Threading.ManualResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="9f329-185">The <xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> class is a lightweight alternative to <xref:System.Threading.ManualResetEvent>.</span></span>

<span data-ttu-id="9f329-186">En Windows, puede usar <xref:System.Threading.EventWaitHandle> para la sincronización entre procesos.</span><span class="sxs-lookup"><span data-stu-id="9f329-186">On Windows, you can use <xref:System.Threading.EventWaitHandle> for the inter-process synchronization.</span></span> <span data-ttu-id="9f329-187">Para hacerlo, cree una instancia de <xref:System.Threading.EventWaitHandle> que represente un semáforo de sincronización del sistema con nombre mediante el uso de uno de los [constructores EventWaitHandle](<xref:System.Threading.EventWaitHandle.%23ctor%2A>) que especifica un nombre o el método <xref:System.Threading.EventWaitHandle.OpenExisting%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9f329-187">To do that, create a <xref:System.Threading.EventWaitHandle> instance that represents a named system synchronization event by using one of the [EventWaitHandle constructors](<xref:System.Threading.EventWaitHandle.%23ctor%2A>) that specifies a name or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="9f329-188">Para obtener más información, consulte el artículo [EventWaitHandle](eventwaithandle.md).</span><span class="sxs-lookup"><span data-stu-id="9f329-188">For more information, see the [EventWaitHandle](eventwaithandle.md) article.</span></span> <span data-ttu-id="9f329-189">Para la referencia de API, consulte <xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, <xref:System.Threading.ManualResetEvent> y <xref:System.Threading.ManualResetEventSlim>.</span><span class="sxs-lookup"><span data-stu-id="9f329-189">For the API reference, see <xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, <xref:System.Threading.ManualResetEvent>, and <xref:System.Threading.ManualResetEventSlim>.</span></span>

### <a name="countdownevent-class"></a><span data-ttu-id="9f329-190">Clase CountdownEvent</span><span class="sxs-lookup"><span data-stu-id="9f329-190">CountdownEvent class</span></span>

<span data-ttu-id="9f329-191">La clase <xref:System.Threading.CountdownEvent?displayProperty=nameWithType> representa un evento que se establece cuando su recuento es cero.</span><span class="sxs-lookup"><span data-stu-id="9f329-191">The <xref:System.Threading.CountdownEvent?displayProperty=nameWithType> class represents an event that becomes set when its count is zero.</span></span> <span data-ttu-id="9f329-192">Mientras <xref:System.Threading.CountdownEvent.CurrentCount?displayProperty=nameWithType> sea mayor que cero, un subproceso que llama a <xref:System.Threading.CountdownEvent.Wait%2A?displayProperty=nameWithType> está bloqueado.</span><span class="sxs-lookup"><span data-stu-id="9f329-192">While <xref:System.Threading.CountdownEvent.CurrentCount?displayProperty=nameWithType> is greater than zero, a thread that calls <xref:System.Threading.CountdownEvent.Wait%2A?displayProperty=nameWithType> is blocked.</span></span> <span data-ttu-id="9f329-193">Llame a <xref:System.Threading.CountdownEvent.Signal%2A?displayProperty=nameWithType> para reducir el recuento de un evento.</span><span class="sxs-lookup"><span data-stu-id="9f329-193">Call <xref:System.Threading.CountdownEvent.Signal%2A?displayProperty=nameWithType> to decrement an event's count.</span></span>

<span data-ttu-id="9f329-194">En contraposición a <xref:System.Threading.ManualResetEvent> o <xref:System.Threading.ManualResetEventSlim>, que puede usar para desbloquear varios subprocesos con una señal de un subproceso, puede usar <xref:System.Threading.CountdownEvent> para desbloquear uno o varios subprocesos con las señales de varios subprocesos.</span><span class="sxs-lookup"><span data-stu-id="9f329-194">In contrast to <xref:System.Threading.ManualResetEvent> or <xref:System.Threading.ManualResetEventSlim>, which you can use to unblock multiple threads with a signal from one thread, you can use <xref:System.Threading.CountdownEvent> to unblock one or more threads with signals from multiple threads.</span></span>

<span data-ttu-id="9f329-195">Para más información, vea el artículo [CountdownEvent](countdownevent.md) y la referencia de API <xref:System.Threading.CountdownEvent>.</span><span class="sxs-lookup"><span data-stu-id="9f329-195">For more information, see the [CountdownEvent](countdownevent.md) article and the <xref:System.Threading.CountdownEvent> API reference.</span></span>

### <a name="barrier-class"></a><span data-ttu-id="9f329-196">Barrier (clase)</span><span class="sxs-lookup"><span data-stu-id="9f329-196">Barrier class</span></span>

<span data-ttu-id="9f329-197">La clase <xref:System.Threading.Barrier?displayProperty=nameWithType> representa una barrera de ejecución de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="9f329-197">The <xref:System.Threading.Barrier?displayProperty=nameWithType> class represents a thread execution barrier.</span></span> <span data-ttu-id="9f329-198">Un subproceso que llama al método <xref:System.Threading.Barrier.SignalAndWait%2A?displayProperty=nameWithType> indica que ha alcanzado la barrera y espera hasta que otros subprocesos participantes alcancen la barrera.</span><span class="sxs-lookup"><span data-stu-id="9f329-198">A thread that calls the <xref:System.Threading.Barrier.SignalAndWait%2A?displayProperty=nameWithType> method signals that it reached the barrier and waits until other participant threads reach the barrier.</span></span> <span data-ttu-id="9f329-199">Cuando todos los subprocesos participantes alcancen la barrera, continúan y la barrera se restablece y se puede volver a usar.</span><span class="sxs-lookup"><span data-stu-id="9f329-199">When all participant threads reach the barrier, they proceed and the barrier is reset and can be used again.</span></span>

<span data-ttu-id="9f329-200">Puede usar <xref:System.Threading.Barrier> cuando uno o más subprocesos requieren los resultados de otros subprocesos antes de continuar con la siguiente fase del cálculo.</span><span class="sxs-lookup"><span data-stu-id="9f329-200">You might use <xref:System.Threading.Barrier> when one or more threads require the results of other threads before proceeding to the next computation phase.</span></span>

<span data-ttu-id="9f329-201">Para más información, vea el artículo [Barrier](barrier.md) y la referencia de API <xref:System.Threading.Barrier>.</span><span class="sxs-lookup"><span data-stu-id="9f329-201">For more information, see the [Barrier](barrier.md) article and the <xref:System.Threading.Barrier> API reference.</span></span>

## <a name="interlocked-class"></a><span data-ttu-id="9f329-202">Interlocked (clase)</span><span class="sxs-lookup"><span data-stu-id="9f329-202">Interlocked class</span></span>

<span data-ttu-id="9f329-203">La clase <xref:System.Threading.Interlocked?displayProperty=nameWithType> proporciona métodos estáticos que realizan operaciones atómicas simples en una variable.</span><span class="sxs-lookup"><span data-stu-id="9f329-203">The <xref:System.Threading.Interlocked?displayProperty=nameWithType> class provides static methods that perform simple atomic operations on a variable.</span></span> <span data-ttu-id="9f329-204">Esas operaciones atómicas incluyen la adición, el incremento y el decremento, el intercambio y el intercambio condicional que depende de una comparación, y la operación de lectura de un valor entero de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="9f329-204">Those atomic operations include addition, increment and decrement, exchange and conditional exchange that depends on a comparison, and read operation of a 64-bit integer value.</span></span>

<span data-ttu-id="9f329-205">Para más información, vea la referencia de API <xref:System.Threading.Interlocked>.</span><span class="sxs-lookup"><span data-stu-id="9f329-205">For more information, see the <xref:System.Threading.Interlocked> API reference.</span></span>

## <a name="spinwait-structure"></a><span data-ttu-id="9f329-206">SpinWait (estructura)</span><span class="sxs-lookup"><span data-stu-id="9f329-206">SpinWait structure</span></span>

<span data-ttu-id="9f329-207">La estructura <xref:System.Threading.SpinWait?displayProperty=nameWithType> proporciona compatibilidad para la espera basada en ciclos.</span><span class="sxs-lookup"><span data-stu-id="9f329-207">The <xref:System.Threading.SpinWait?displayProperty=nameWithType> structure provides support for spin-based waiting.</span></span> <span data-ttu-id="9f329-208">Puede que le interese utilizarla cuando un subproceso tiene que esperar a que se señalice un evento o se cumpla una condición, pero cuando el tiempo de espera real deba ser menor que el tiempo de espera necesario usando un identificador de espera o bloqueando de otro modo el subproceso.</span><span class="sxs-lookup"><span data-stu-id="9f329-208">You might want to use it when a thread has to wait for an event to be signaled or a condition to be met, but when the actual wait time is expected to be less than the waiting time required by using a wait handle or by otherwise blocking the thread.</span></span> <span data-ttu-id="9f329-209">Si usa <xref:System.Threading.SpinWait>, puede especificar un breve período de tiempo para girar durante la espera y después ceder (por ejemplo, esperando o entrando en modo de suspensión) solo si la condición no se cumplió en el tiempo especificado.</span><span class="sxs-lookup"><span data-stu-id="9f329-209">By using <xref:System.Threading.SpinWait>, you can specify a short period of time to spin while waiting, and then yield (for example, by waiting or sleeping) only if the condition was not met in the specified time.</span></span>

<span data-ttu-id="9f329-210">Para más información, vea el artículo [SpinWait](spinwait.md) y la referencia de API <xref:System.Threading.SpinWait>.</span><span class="sxs-lookup"><span data-stu-id="9f329-210">For more information, see the [SpinWait](spinwait.md) article and the <xref:System.Threading.SpinWait> API reference.</span></span>

## <a name="see-also"></a><span data-ttu-id="9f329-211">Vea también</span><span class="sxs-lookup"><span data-stu-id="9f329-211">See also</span></span>

- <xref:System.Collections.Concurrent?displayProperty=nameWithType>
- [<span data-ttu-id="9f329-212">Colecciones seguras para subprocesos</span><span class="sxs-lookup"><span data-stu-id="9f329-212">Thread-safe collections</span></span>](../collections/thread-safe/index.md)
- [<span data-ttu-id="9f329-213">Objetos y características de subprocesos</span><span class="sxs-lookup"><span data-stu-id="9f329-213">Threading objects and features</span></span>](threading-objects-and-features.md)
