---
title: Subprocesamiento administrado y no administrado en Windows
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- threading [.NET Framework], unmanaged
- threading [.NET Framework], managed
- managed threading
ms.assetid: 4fb6452f-c071-420d-9e71-da16dee7a1eb
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 50e709c8b5de505b17efea8ddf333633b2bd7400
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 05/04/2018
ms.locfileid: "33591695"
---
# <a name="managed-and-unmanaged-threading-in-windows"></a><span data-ttu-id="4a029-102">Subprocesamiento administrado y no administrado en Windows</span><span class="sxs-lookup"><span data-stu-id="4a029-102">Managed and Unmanaged Threading in Windows</span></span>
<span data-ttu-id="4a029-103">La administración de todos los subprocesos se realiza mediante la clase <xref:System.Threading.Thread> , incluidos los subprocesos creados por Common Language Runtime y los creados fuera del runtime que entran en el entorno administrado para ejecutar código.</span><span class="sxs-lookup"><span data-stu-id="4a029-103">Management of all threads is done through the <xref:System.Threading.Thread> class, including threads created by the common language runtime and those created outside the runtime that enter the managed environment to execute code.</span></span> <span data-ttu-id="4a029-104">El runtime supervisa todos los subprocesos del proceso que han ejecutado alguna vez código en el entorno de ejecución administrado.</span><span class="sxs-lookup"><span data-stu-id="4a029-104">The runtime monitors all the threads in its process that have ever executed code within the managed execution environment.</span></span> <span data-ttu-id="4a029-105">No realiza un seguimiento de ningún otro subproceso.</span><span class="sxs-lookup"><span data-stu-id="4a029-105">It does not track any other threads.</span></span> <span data-ttu-id="4a029-106">Los subprocesos pueden acceder al entorno de ejecución administrado a través de la interoperabilidad COM (porque el runtime expone los objetos administrados como objetos COM a los entornos no administrados), la función COM [DllGetClassObject](https://msdn.microsoft.com/library/ms680760.aspx) y la invocación de plataforma.</span><span class="sxs-lookup"><span data-stu-id="4a029-106">Threads can enter the managed execution environment through COM interop (because the runtime exposes managed objects as COM objects to the unmanaged world), the COM [DllGetClassObject](https://msdn.microsoft.com/library/ms680760.aspx) function, and platform invoke.</span></span>  
  
 <span data-ttu-id="4a029-107">Cuando un subproceso no administrado entra en el runtime a través de, por ejemplo, un contenedor CCW, el sistema comprueba el almacén local del subproceso para buscar un objeto <xref:System.Threading.Thread> administrado interno.</span><span class="sxs-lookup"><span data-stu-id="4a029-107">When an unmanaged thread enters the runtime through, for example, a COM callable wrapper, the system checks the thread-local store of that thread to look for an internal managed <xref:System.Threading.Thread> object.</span></span> <span data-ttu-id="4a029-108">Si se encuentra uno, el runtime ya tiene en cuenta este subproceso.</span><span class="sxs-lookup"><span data-stu-id="4a029-108">If one is found, the runtime is already aware of this thread.</span></span> <span data-ttu-id="4a029-109">Si no lo encuentra, el runtime compila un nuevo objeto <xref:System.Threading.Thread> y lo instala en el almacén local de ese subproceso.</span><span class="sxs-lookup"><span data-stu-id="4a029-109">If it cannot find one, however, the runtime builds a new <xref:System.Threading.Thread> object and installs it in the thread-local store of that thread.</span></span>  
  
 <span data-ttu-id="4a029-110">En los subprocesos administrados, <xref:System.Threading.Thread.GetHashCode%2A?displayProperty=nameWithType> es la identificación del subproceso administrado estable.</span><span class="sxs-lookup"><span data-stu-id="4a029-110">In managed threading, <xref:System.Threading.Thread.GetHashCode%2A?displayProperty=nameWithType> is the stable managed thread identification.</span></span> <span data-ttu-id="4a029-111">En cuanto a la duración de su subproceso, no estará en conflicto con el valor de ningún otro subproceso, independientemente del dominio de la aplicación del que obtiene este valor.</span><span class="sxs-lookup"><span data-stu-id="4a029-111">For the lifetime of your thread, it will not collide with the value from any other thread, regardless of the application domain from which you obtain this value.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4a029-112">Un **ThreadId** de sistema operativo no tiene una relación fija con un subproceso administrado, ya que un host no administrado puede controlar la relación entre subprocesos administrados y no administrados.</span><span class="sxs-lookup"><span data-stu-id="4a029-112">An operating-system **ThreadId** has no fixed relationship to a managed thread, because an unmanaged host can control the relationship between managed and unmanaged threads.</span></span> <span data-ttu-id="4a029-113">En concreto, un host sofisticado puede usar la API de fibras para programar muchos subprocesos administrados en el mismo subproceso de sistema operativo o para mover un subproceso administrado entre distintos subprocesos de sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="4a029-113">Specifically, a sophisticated host can use the Fiber API to schedule many managed threads against the same operating system thread, or to move a managed thread among different operating system threads.</span></span>  
  
## <a name="mapping-from-win32-threading-to-managed-threading"></a><span data-ttu-id="4a029-114">Asignación de subprocesos de Win32 a subprocesos administrados</span><span class="sxs-lookup"><span data-stu-id="4a029-114">Mapping from Win32 Threading to Managed Threading</span></span>  
 <span data-ttu-id="4a029-115">En la tabla siguiente se asignan elementos de subproceso de Win32 a sus equivalentes de runtime aproximados.</span><span class="sxs-lookup"><span data-stu-id="4a029-115">The following table maps Win32 threading elements to their approximate runtime equivalent.</span></span> <span data-ttu-id="4a029-116">Tenga en cuenta que esta asignación no representa una funcionalidad idéntica.</span><span class="sxs-lookup"><span data-stu-id="4a029-116">Note that this mapping does not represent identical functionality.</span></span> <span data-ttu-id="4a029-117">Por ejemplo, **TerminateThread** no ejecuta cláusulas **finally** ni libera recursos, y no se puede evitar.</span><span class="sxs-lookup"><span data-stu-id="4a029-117">For example, **TerminateThread** does not execute **finally** clauses or free up resources, and cannot be prevented.</span></span> <span data-ttu-id="4a029-118">No obstante, <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> ejecuta todo su código de reversión, recupera todos los recursos y se puede denegar con <xref:System.Threading.Thread.ResetAbort%2A>.</span><span class="sxs-lookup"><span data-stu-id="4a029-118">However, <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> executes all your rollback code, reclaims all the resources, and can be denied using <xref:System.Threading.Thread.ResetAbort%2A>.</span></span> <span data-ttu-id="4a029-119">Asegúrese de leer detenidamente la documentación y no realice suposiciones sobre la funcionalidad.</span><span class="sxs-lookup"><span data-stu-id="4a029-119">Be sure to read the documentation closely before making assumptions about functionality.</span></span>  
  
|<span data-ttu-id="4a029-120">En Win32</span><span class="sxs-lookup"><span data-stu-id="4a029-120">In Win32</span></span>|<span data-ttu-id="4a029-121">En Common Language Runtime</span><span class="sxs-lookup"><span data-stu-id="4a029-121">In the common language runtime</span></span>|  
|--------------|------------------------------------|  
|<span data-ttu-id="4a029-122">**CreateThread**</span><span class="sxs-lookup"><span data-stu-id="4a029-122">**CreateThread**</span></span>|<span data-ttu-id="4a029-123">Combinación de **Thread** y <xref:System.Threading.ThreadStart></span><span class="sxs-lookup"><span data-stu-id="4a029-123">Combination of **Thread** and <xref:System.Threading.ThreadStart></span></span>|  
|<span data-ttu-id="4a029-124">**TerminateThread**</span><span class="sxs-lookup"><span data-stu-id="4a029-124">**TerminateThread**</span></span>|<xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="4a029-125">**SuspendThread**</span><span class="sxs-lookup"><span data-stu-id="4a029-125">**SuspendThread**</span></span>|<xref:System.Threading.Thread.Suspend%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="4a029-126">**ResumeThread**</span><span class="sxs-lookup"><span data-stu-id="4a029-126">**ResumeThread**</span></span>|<xref:System.Threading.Thread.Resume%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="4a029-127">**Sleep**</span><span class="sxs-lookup"><span data-stu-id="4a029-127">**Sleep**</span></span>|<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="4a029-128">**WaitForSingleObject** en el identificador de subproceso</span><span class="sxs-lookup"><span data-stu-id="4a029-128">**WaitForSingleObject** on the thread handle</span></span>|<xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="4a029-129">**ExitThread**</span><span class="sxs-lookup"><span data-stu-id="4a029-129">**ExitThread**</span></span>|<span data-ttu-id="4a029-130">No equivalente</span><span class="sxs-lookup"><span data-stu-id="4a029-130">No equivalent</span></span>|  
|<span data-ttu-id="4a029-131">**GetCurrentThread**</span><span class="sxs-lookup"><span data-stu-id="4a029-131">**GetCurrentThread**</span></span>|<xref:System.Threading.Thread.CurrentThread%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="4a029-132">**SetThreadPriority**</span><span class="sxs-lookup"><span data-stu-id="4a029-132">**SetThreadPriority**</span></span>|<xref:System.Threading.Thread.Priority%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="4a029-133">No equivalente</span><span class="sxs-lookup"><span data-stu-id="4a029-133">No equivalent</span></span>|<xref:System.Threading.Thread.Name%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="4a029-134">No equivalente</span><span class="sxs-lookup"><span data-stu-id="4a029-134">No equivalent</span></span>|<xref:System.Threading.Thread.IsBackground%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="4a029-135">Cercano a **CoInitializeEx** (OLE32.DLL)</span><span class="sxs-lookup"><span data-stu-id="4a029-135">Close to **CoInitializeEx** (OLE32.DLL)</span></span>|<xref:System.Threading.Thread.ApartmentState%2A?displayProperty=nameWithType>|  
  
## <a name="managed-threads-and-com-apartments"></a><span data-ttu-id="4a029-136">Subprocesos administrados y apartamentos COM</span><span class="sxs-lookup"><span data-stu-id="4a029-136">Managed Threads and COM Apartments</span></span>  
 <span data-ttu-id="4a029-137">Un subproceso administrado se puede marcar para indicar que hospedará un contenedor [uniproceso](https://msdn.microsoft.com/library/windows/desktop/ms680112.aspx) o [multiproceso](https://msdn.microsoft.com/library/windows/desktop/ms693421.aspx).</span><span class="sxs-lookup"><span data-stu-id="4a029-137">A managed thread can be marked to indicate that it will host a [single-threaded](https://msdn.microsoft.com/library/windows/desktop/ms680112.aspx) or [multithreaded](https://msdn.microsoft.com/library/windows/desktop/ms693421.aspx) apartment.</span></span> <span data-ttu-id="4a029-138">(Para más información sobre la arquitectura de subprocesos COM, consulte [Procesos, subprocesos y contenedores](https://msdn.microsoft.com/library/windows/desktop/ms693344.aspx)). Los métodos <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A> y <xref:System.Threading.Thread.TrySetApartmentState%2A> de la clase <xref:System.Threading.Thread> devuelven y asignan el estado de contenedor de un subproceso.</span><span class="sxs-lookup"><span data-stu-id="4a029-138">(For more information on the COM threading architecture, see [Processes, threads, and Apartments](https://msdn.microsoft.com/library/windows/desktop/ms693344.aspx).) The <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods of the <xref:System.Threading.Thread> class return and assign the apartment state of a thread.</span></span> <span data-ttu-id="4a029-139">Si el estado no se ha establecido, <xref:System.Threading.Thread.GetApartmentState%2A> devuelve <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4a029-139">If the state has not been set, <xref:System.Threading.Thread.GetApartmentState%2A> returns <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="4a029-140">La propiedad solo se puede establecer cuando el estado del subproceso es <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> y únicamente una vez por subproceso.</span><span class="sxs-lookup"><span data-stu-id="4a029-140">The property can be set only when the thread is in the <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> state; it can be set only once for a thread.</span></span>  
  
 <span data-ttu-id="4a029-141">Si el estado de contenedor no se establece antes de que se inicie el subproceso, el subproceso se inicializa como un contenedor multiproceso (MTA).</span><span class="sxs-lookup"><span data-stu-id="4a029-141">If the apartment state is not set before the thread is started, the thread is initialized as a multithreaded apartment (MTA).</span></span> <span data-ttu-id="4a029-142">El subproceso de finalizador y todos los subprocesos controlados por <xref:System.Threading.ThreadPool> son MTA.</span><span class="sxs-lookup"><span data-stu-id="4a029-142">The finalizer thread and all threads controlled by <xref:System.Threading.ThreadPool> are MTA.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="4a029-143">Para el código de inicio de aplicación, la única manera de controlar el estado de contenedor es aplicar <xref:System.MTAThreadAttribute> o <xref:System.STAThreadAttribute> al procedimiento de punto de entrada.</span><span class="sxs-lookup"><span data-stu-id="4a029-143">For application startup code, the only way to control apartment state is to apply the <xref:System.MTAThreadAttribute> or the <xref:System.STAThreadAttribute> to the entry point procedure.</span></span> <span data-ttu-id="4a029-144">En .NET Framework 1.0 y 1.1, la propiedad <xref:System.Threading.Thread.ApartmentState%2A> se puede establecer como la primera línea de código.</span><span class="sxs-lookup"><span data-stu-id="4a029-144">In the .NET Framework 1.0 and 1.1, the <xref:System.Threading.Thread.ApartmentState%2A> property can be set as the first line of code.</span></span> <span data-ttu-id="4a029-145">Esto no está permitido en .NET Framework 2.0.</span><span class="sxs-lookup"><span data-stu-id="4a029-145">This is not permitted in the .NET Framework 2.0.</span></span>  
  
 <span data-ttu-id="4a029-146">Los objetos administrados que están expuestos a COM se comportan como si tuviesen agregado el cálculo de referencias con subprocesamiento libre.</span><span class="sxs-lookup"><span data-stu-id="4a029-146">Managed objects that are exposed to COM behave as if they had aggregated the free-threaded marshaler.</span></span> <span data-ttu-id="4a029-147">En otras palabras, se pueden llamar desde cualquier apartamento COM en un modo de subprocesamiento libre.</span><span class="sxs-lookup"><span data-stu-id="4a029-147">In other words, they can be called from any COM apartment in a free-threaded manner.</span></span> <span data-ttu-id="4a029-148">Los únicos objetos administrados que no muestran este comportamiento de subprocesamiento libre son aquellos que derivan de <xref:System.EnterpriseServices.ServicedComponent> o <xref:System.Runtime.InteropServices.StandardOleMarshalObject>.</span><span class="sxs-lookup"><span data-stu-id="4a029-148">The only managed objects that do not exhibit this free-threaded behavior are those objects that derive from <xref:System.EnterpriseServices.ServicedComponent> or <xref:System.Runtime.InteropServices.StandardOleMarshalObject>.</span></span>  
  
 <span data-ttu-id="4a029-149">En el ámbito de recursos administrados, <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> no se admite a menos que se usen contextos e instancias administradas asociadas a un contexto.</span><span class="sxs-lookup"><span data-stu-id="4a029-149">In the managed world, there is no support for the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> unless you use contexts and context-bound managed instances.</span></span> <span data-ttu-id="4a029-150">Si usa Enterprise Services, entonces su objeto debe derivarse de <xref:System.EnterpriseServices.ServicedComponent> (que a su vez se deriva de <xref:System.ContextBoundObject>).</span><span class="sxs-lookup"><span data-stu-id="4a029-150">If you are using Enterprise Services, then your object must derive from <xref:System.EnterpriseServices.ServicedComponent> (which is itself derived from <xref:System.ContextBoundObject>).</span></span>  
  
 <span data-ttu-id="4a029-151">Cuando el código administrado llama a objetos COM, siempre sigue reglas COM.</span><span class="sxs-lookup"><span data-stu-id="4a029-151">When managed code calls out to COM objects, it always follows COM rules.</span></span> <span data-ttu-id="4a029-152">En otras palabras, el código llama a través de los proxy de apartamentos COM y contenedores de contexto COM+ 1.0, según lo dictado por OLE32.</span><span class="sxs-lookup"><span data-stu-id="4a029-152">In other words, it calls through COM apartment proxies and COM+ 1.0 context wrappers as dictated by OLE32.</span></span>  
  
## <a name="blocking-issues"></a><span data-ttu-id="4a029-153">Problemas de bloqueo</span><span class="sxs-lookup"><span data-stu-id="4a029-153">Blocking Issues</span></span>  
 <span data-ttu-id="4a029-154">Si un subproceso realiza una llamada no administrada al sistema operativo que ha bloqueado el subproceso en código no administrado, el runtime no tomará el control de él para <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> ni <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4a029-154">If a thread makes an unmanaged call into the operating system that has blocked the thread in unmanaged code, the runtime will not take control of it for <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> or <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4a029-155">En el caso de <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>, el tiempo de ejecución marca el subproceso para **Abort** y toma el control de él cuando vuelve a introducir código administrado.</span><span class="sxs-lookup"><span data-stu-id="4a029-155">In the case of <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>, the runtime marks the thread for **Abort** and takes control of it when it re-enters managed code.</span></span> <span data-ttu-id="4a029-156">Lo preferible para usted es usar un bloqueo administrado en vez de no administrado.</span><span class="sxs-lookup"><span data-stu-id="4a029-156">It is preferable for you to use managed blocking rather than unmanaged blocking.</span></span> <span data-ttu-id="4a029-157"><xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>,<xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType>, <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>, <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType>, <xref:System.GC.WaitForPendingFinalizers%2A?displayProperty=nameWithType> y demás responden todos a <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> y <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4a029-157"><xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>,<xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType>, <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>, <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType>, <xref:System.GC.WaitForPendingFinalizers%2A?displayProperty=nameWithType>, and so on are all responsive to <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> and to <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4a029-158">Además, si su subproceso está en un contenedor uniproceso, todas estas operaciones de bloqueo administrado suministrarán correctamente mensajes en su contenedor mientras el subproceso está bloqueado.</span><span class="sxs-lookup"><span data-stu-id="4a029-158">Also, if your thread is in a single-threaded apartment, all these managed blocking operations will correctly pump messages in your apartment while your thread is blocked.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="4a029-159">Vea también</span><span class="sxs-lookup"><span data-stu-id="4a029-159">See Also</span></span>  
 <xref:System.Threading.Thread.ApartmentState%2A?displayProperty=nameWithType>  
 <xref:System.Threading.ThreadState>  
 <xref:System.EnterpriseServices.ServicedComponent>  
 <xref:System.Threading.Thread>  
 <xref:System.Threading.Monitor>
