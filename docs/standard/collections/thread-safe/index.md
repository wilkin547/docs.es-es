---
title: Colecciones seguras para subprocesos
description: Empiece a usar colecciones seguras para subprocesos mediante el espacio de nombres System.Collections.Concurrent en .NET, que incluye clases de colección escalables y seguras para subprocesos.
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- thread-safe collections, overview
ms.assetid: 2e7ca21f-786c-4367-96be-0cf3f3dcc6bd
ms.openlocfilehash: 3a252124ade4c43961c06697367bbc4ca5d0c9cb
ms.sourcegitcommit: 5fd4696a3e5791b2a8c449ccffda87f2cc2d4894
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 06/15/2020
ms.locfileid: "84768591"
---
# <a name="thread-safe-collections"></a><span data-ttu-id="48e5e-103">Colecciones seguras para subprocesos</span><span class="sxs-lookup"><span data-stu-id="48e5e-103">Thread-Safe Collections</span></span>
<span data-ttu-id="48e5e-104">.NET Framework 4 introduce el espacio de nombres <xref:System.Collections.Concurrent?displayProperty=nameWithType>, que incluye varias clases de colección que son a la vez seguras para subprocesos y escalables.</span><span class="sxs-lookup"><span data-stu-id="48e5e-104">The .NET Framework 4 introduces the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace, which includes several collection classes that are both thread-safe and scalable.</span></span> <span data-ttu-id="48e5e-105">Varios subprocesos pueden agregar o quitar elementos de estas colecciones sin ningún riesgo y de un modo eficaz, sin requerir una sincronización adicional en código de usuario.</span><span class="sxs-lookup"><span data-stu-id="48e5e-105">Multiple threads can safely and efficiently add or remove items from these collections, without requiring additional synchronization in user code.</span></span> <span data-ttu-id="48e5e-106">Al escribir un código nuevo, utilice las clases de colección simultáneas siempre que varios subprocesos se vayan a escribir en la colección de forma simultánea.</span><span class="sxs-lookup"><span data-stu-id="48e5e-106">When you write new code, use the concurrent collection classes whenever multiple threads will write to the collection concurrently.</span></span> <span data-ttu-id="48e5e-107">Si solo está leyendo en una colección compartida, puede utilizar las clases en el espacio de nombres <xref:System.Collections.Generic?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="48e5e-107">If you are only reading from a shared collection, then you can use the classes in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="48e5e-108">Recomendamos no utilizar clases de colección 1.0 a menos que estén destinadas a .NET Framework 1.1. o un runtime de una versión anterior.</span><span class="sxs-lookup"><span data-stu-id="48e5e-108">We recommend that you do not use 1.0 collection classes unless you are required to target the .NET Framework 1.1 or earlier runtime.</span></span>  
  
## <a name="thread-synchronization-in-the-net-framework-10-and-20-collections"></a><span data-ttu-id="48e5e-109">Sincronización de subprocesos en las colecciones de .NET Framework 1.0 y 2.0</span><span class="sxs-lookup"><span data-stu-id="48e5e-109">Thread Synchronization in the .NET Framework 1.0 and 2.0 Collections</span></span>  
 <span data-ttu-id="48e5e-110">Las colecciones introducidas en .NET Framework 1.0 se encuentran en el espacio de nombres <xref:System.Collections?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="48e5e-110">The collections introduced in the .NET Framework 1.0 are found in the <xref:System.Collections?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="48e5e-111">Estas colecciones, que incluyen <xref:System.Collections.ArrayList> y <xref:System.Collections.Hashtable> utilizados habitualmente, proporcionan cierta seguridad para subprocesos mediante la propiedad `Synchronized`, que devuelve un contenedor seguro para subprocesos en torno a la colección.</span><span class="sxs-lookup"><span data-stu-id="48e5e-111">These collections, which include the commonly used <xref:System.Collections.ArrayList> and <xref:System.Collections.Hashtable>, provide some thread-safety through the `Synchronized` property, which returns a thread-safe wrapper around the collection.</span></span> <span data-ttu-id="48e5e-112">El contenedor funciona bloqueando toda la colección en cada operación de agregar o quitar.</span><span class="sxs-lookup"><span data-stu-id="48e5e-112">The wrapper works by locking the entire collection on every add or remove operation.</span></span> <span data-ttu-id="48e5e-113">Por consiguiente, cada subproceso que intenta tener acceso a la colección debe esperar su turno para tomar el único bloqueo.</span><span class="sxs-lookup"><span data-stu-id="48e5e-113">Therefore, each thread that is attempting to access the collection must wait for its turn to take the one lock.</span></span> <span data-ttu-id="48e5e-114">Esto no es escalable y puede producir una degradación significativa del rendimiento en las colecciones grandes.</span><span class="sxs-lookup"><span data-stu-id="48e5e-114">This is not scalable and can cause significant performance degradation for large collections.</span></span> <span data-ttu-id="48e5e-115">Asimismo, el diseño no está totalmente protegido de las condiciones de carrera.</span><span class="sxs-lookup"><span data-stu-id="48e5e-115">Also, the design is not completely protected from race conditions.</span></span> <span data-ttu-id="48e5e-116">Para obtener más información, vea [Synchronization in Generic Collections](https://docs.microsoft.com/archive/blogs/bclteam/synchronization-in-generic-collections-brian-grunkemeyer) (Sincronización de colecciones genéricas).</span><span class="sxs-lookup"><span data-stu-id="48e5e-116">For more information, see [Synchronization in Generic Collections](https://docs.microsoft.com/archive/blogs/bclteam/synchronization-in-generic-collections-brian-grunkemeyer).</span></span>  
  
 <span data-ttu-id="48e5e-117">Las clases de colección introducidas en .NET Framework 2.0 se encuentran en el espacio de nombres <xref:System.Collections.Generic?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="48e5e-117">The collection classes introduced in the .NET Framework 2.0 are found in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="48e5e-118">Éstas incluyen <xref:System.Collections.Generic.List%601>, <xref:System.Collections.Generic.Dictionary%602>, etc.</span><span class="sxs-lookup"><span data-stu-id="48e5e-118">These include <xref:System.Collections.Generic.List%601>, <xref:System.Collections.Generic.Dictionary%602>, and so on.</span></span> <span data-ttu-id="48e5e-119">Estas clases proporcionan una seguridad de tipos y un rendimiento mejorados comparados con las clases de .NET Framework 1.0.</span><span class="sxs-lookup"><span data-stu-id="48e5e-119">These classes provide improved type safety and performance compared to the .NET Framework 1.0 classes.</span></span> <span data-ttu-id="48e5e-120">Sin embargo, las clases de colección de .NET Framework 2.0 no proporcionan ninguna sincronización de subprocesos; el código de usuario debe proporcionar toda la sincronización cuando se agregan o quitan elementos en varios subprocesos simultáneamente.</span><span class="sxs-lookup"><span data-stu-id="48e5e-120">However, the .NET Framework 2.0 collection classes do not provide any thread synchronization; user code must provide all synchronization when items are added or removed on multiple threads concurrently.</span></span>  
  
 <span data-ttu-id="48e5e-121">Se recomiendan las clases de colección simultáneas en .NET Framework 4 porque proporcionan no solo la seguridad de tipos de las clases de colección de .NET Framework 2.0, sino también una seguridad de subprocesos más eficaz y completa que las colecciones de .NET Framework 1.0.</span><span class="sxs-lookup"><span data-stu-id="48e5e-121">We recommend the concurrent collections classes in the .NET Framework 4 because they provide not only the type safety of the .NET Framework 2.0 collection classes, but also more efficient and more complete thread safety than the .NET Framework 1.0 collections provide.</span></span>  
  
## <a name="fine-grained-locking-and-lock-free-mechanisms"></a><span data-ttu-id="48e5e-122">Mecanismos de bloqueo específico y sin bloqueos</span><span class="sxs-lookup"><span data-stu-id="48e5e-122">Fine-Grained Locking and Lock-Free Mechanisms</span></span>  
 <span data-ttu-id="48e5e-123">Algunos de los tipos de colección simultáneos utilizan mecanismos de sincronización ligeros como <xref:System.Threading.SpinLock>, <xref:System.Threading.SpinWait>, <xref:System.Threading.SemaphoreSlim> y <xref:System.Threading.CountdownEvent>, que son nuevos en .NET Framework 4.</span><span class="sxs-lookup"><span data-stu-id="48e5e-123">Some of the concurrent collection types use lightweight synchronization mechanisms such as <xref:System.Threading.SpinLock>, <xref:System.Threading.SpinWait>, <xref:System.Threading.SemaphoreSlim>, and <xref:System.Threading.CountdownEvent>, which are new in the .NET Framework 4.</span></span> <span data-ttu-id="48e5e-124">Estos tipos de sincronización utilizan normalmente *giro de ocupado* durante breves períodos antes de colocar el subproceso en un verdadero estado de espera.</span><span class="sxs-lookup"><span data-stu-id="48e5e-124">These synchronization types typically use *busy spinning* for brief periods before they put the thread into a true Wait state.</span></span> <span data-ttu-id="48e5e-125">Cuando se prevé que los tiempos de espera sean muy cortos, el giro es técnicamente menos costoso que la espera, que implica una costosa transición del kernel.</span><span class="sxs-lookup"><span data-stu-id="48e5e-125">When wait times are expected to be very short, spinning is far less computationally expensive than waiting, which involves an expensive kernel transition.</span></span> <span data-ttu-id="48e5e-126">Para las clases de colección que utilizan el giro, esta eficacia significa que se pueden agregar y quitar varios subprocesos con una tasa muy alta.</span><span class="sxs-lookup"><span data-stu-id="48e5e-126">For collection classes that use spinning, this efficiency means that multiple threads can add and remove items at a very high rate.</span></span> <span data-ttu-id="48e5e-127">Para más información sobre la comparación del giro y el bloque, consulte [SpinLock](../../threading/spinlock.md) y [SpinWait](../../threading/spinwait.md).</span><span class="sxs-lookup"><span data-stu-id="48e5e-127">For more information about spinning vs. blocking, see [SpinLock](../../threading/spinlock.md) and [SpinWait](../../threading/spinwait.md).</span></span>  
  
 <span data-ttu-id="48e5e-128">Las clases <xref:System.Collections.Concurrent.ConcurrentQueue%601> y <xref:System.Collections.Concurrent.ConcurrentStack%601> no utilizan bloqueos en absoluto.</span><span class="sxs-lookup"><span data-stu-id="48e5e-128">The <xref:System.Collections.Concurrent.ConcurrentQueue%601> and <xref:System.Collections.Concurrent.ConcurrentStack%601> classes do not use locks at all.</span></span> <span data-ttu-id="48e5e-129">En su lugar, dependen de las operaciones <xref:System.Threading.Interlocked> para lograr la seguridad para subprocesos.</span><span class="sxs-lookup"><span data-stu-id="48e5e-129">Instead, they rely on <xref:System.Threading.Interlocked> operations to achieve thread-safety.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="48e5e-130">Como las clases de colección simultáneas son compatibles con <xref:System.Collections.ICollection>, proporcionan implementaciones para las propiedades <xref:System.Collections.ICollection.IsSynchronized%2A> y <xref:System.Collections.ICollection.SyncRoot%2A>, aunque estas propiedades sean irrelevantes.</span><span class="sxs-lookup"><span data-stu-id="48e5e-130">Because the concurrent collections classes support <xref:System.Collections.ICollection>, they provide implementations for the <xref:System.Collections.ICollection.IsSynchronized%2A> and <xref:System.Collections.ICollection.SyncRoot%2A> properties, even though these properties are irrelevant.</span></span> <span data-ttu-id="48e5e-131">`IsSynchronized` devuelve siempre `false` y `SyncRoot` es siempre `null` (`Nothing` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="48e5e-131">`IsSynchronized` always returns `false` and `SyncRoot` is always `null` (`Nothing` in Visual Basic).</span></span>  
  
 <span data-ttu-id="48e5e-132">La siguiente tabla enumera los tipos de colección en el espacio de nombres <xref:System.Collections.Concurrent?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="48e5e-132">The following table lists the collection types in the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace.</span></span>  
  
|<span data-ttu-id="48e5e-133">Tipo</span><span class="sxs-lookup"><span data-stu-id="48e5e-133">Type</span></span>|<span data-ttu-id="48e5e-134">Descripción</span><span class="sxs-lookup"><span data-stu-id="48e5e-134">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Collections.Concurrent.BlockingCollection%601>|<span data-ttu-id="48e5e-135">Proporciona funcionalidad de límite y bloqueo para cualquier tipo que implemente <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>.</span><span class="sxs-lookup"><span data-stu-id="48e5e-135">Provides bounding and blocking functionality for any type that implements <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>.</span></span> <span data-ttu-id="48e5e-136">Para obtener más información, consulte [Información general sobre BlockingCollection](blockingcollection-overview.md).</span><span class="sxs-lookup"><span data-stu-id="48e5e-136">For more information, see [BlockingCollection Overview](blockingcollection-overview.md).</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentDictionary%602>|<span data-ttu-id="48e5e-137">Implementación segura para subprocesos de un diccionario de pares clave-valor.</span><span class="sxs-lookup"><span data-stu-id="48e5e-137">Thread-safe implementation of a dictionary of key-value pairs.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentQueue%601>|<span data-ttu-id="48e5e-138">Implementación segura para subprocesos de una cola FIFO (primero en entrar, primero en salir).</span><span class="sxs-lookup"><span data-stu-id="48e5e-138">Thread-safe implementation of a FIFO (first-in, first-out) queue.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentStack%601>|<span data-ttu-id="48e5e-139">Implementación segura para subprocesos de una pila LIFO (último en entrar, primero en salir).</span><span class="sxs-lookup"><span data-stu-id="48e5e-139">Thread-safe implementation of a LIFO (last-in, first-out) stack.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentBag%601>|<span data-ttu-id="48e5e-140">Implementación segura para subprocesos de una colección no ordenada de elementos.</span><span class="sxs-lookup"><span data-stu-id="48e5e-140">Thread-safe implementation of an unordered collection of elements.</span></span>|  
|<xref:System.Collections.Concurrent.IProducerConsumerCollection%601>|<span data-ttu-id="48e5e-141">Interfaz que debe implementar un tipo para su uso en `BlockingCollection`.</span><span class="sxs-lookup"><span data-stu-id="48e5e-141">The interface that a type must implement to be used in a `BlockingCollection`.</span></span>|  
  
## <a name="related-topics"></a><span data-ttu-id="48e5e-142">Temas relacionados</span><span class="sxs-lookup"><span data-stu-id="48e5e-142">Related Topics</span></span>  
  
|<span data-ttu-id="48e5e-143">Title</span><span class="sxs-lookup"><span data-stu-id="48e5e-143">Title</span></span>|<span data-ttu-id="48e5e-144">Descripción</span><span class="sxs-lookup"><span data-stu-id="48e5e-144">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="48e5e-145">Información general sobre BlockingCollection</span><span class="sxs-lookup"><span data-stu-id="48e5e-145">BlockingCollection Overview</span></span>](blockingcollection-overview.md)|<span data-ttu-id="48e5e-146">Describe la funcionalidad proporcionada por el tipo <xref:System.Collections.Concurrent.BlockingCollection%601>.</span><span class="sxs-lookup"><span data-stu-id="48e5e-146">Describes the functionality provided by the <xref:System.Collections.Concurrent.BlockingCollection%601> type.</span></span>|  
|[<span data-ttu-id="48e5e-147">Cómo: agregar y quitar elementos de ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="48e5e-147">How to: Add and Remove Items from a ConcurrentDictionary</span></span>](how-to-add-and-remove-items.md)|<span data-ttu-id="48e5e-148">Describe cómo agregar y quitar los elementos de <xref:System.Collections.Concurrent.ConcurrentDictionary%602></span><span class="sxs-lookup"><span data-stu-id="48e5e-148">Describes how to add and remove elements from a <xref:System.Collections.Concurrent.ConcurrentDictionary%602></span></span>|  
|[<span data-ttu-id="48e5e-149">Cómo: agregar y tomar elementos de forma individual en una clase BlockingCollection</span><span class="sxs-lookup"><span data-stu-id="48e5e-149">How to: Add and Take Items Individually from a BlockingCollection</span></span>](how-to-add-and-take-items.md)|<span data-ttu-id="48e5e-150">Describe cómo agregar y recuperar elementos de una colección de bloqueo sin utilizar el enumerador de solo lectura.</span><span class="sxs-lookup"><span data-stu-id="48e5e-150">Describes how to add and retrieve items from a blocking collection without using the read-only enumerator.</span></span>|  
|[<span data-ttu-id="48e5e-151">Cómo: agregar la funcionalidad de límite y bloqueo a una colección</span><span class="sxs-lookup"><span data-stu-id="48e5e-151">How to: Add Bounding and Blocking Functionality to a Collection</span></span>](how-to-add-bounding-and-blocking.md)|<span data-ttu-id="48e5e-152">Describe cómo utilizar cualquier clase de colección como mecanismo de almacenamiento subyacente para una colección <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>.</span><span class="sxs-lookup"><span data-stu-id="48e5e-152">Describes how to use any collection class as the underlying storage mechanism for an <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> collection.</span></span>|  
|[<span data-ttu-id="48e5e-153">Cómo: utilizar ForEach para quitar elementos de BlockingCollection</span><span class="sxs-lookup"><span data-stu-id="48e5e-153">How to: Use ForEach to Remove Items in a BlockingCollection</span></span>](how-to-use-foreach-to-remove.md)|<span data-ttu-id="48e5e-154">Describe cómo utilizar `foreach`, (`For Each` en Visual Basic) para quitar todos los elementos en una colección de bloqueo.</span><span class="sxs-lookup"><span data-stu-id="48e5e-154">Describes how to use `foreach`, (`For Each` in Visual Basic) to remove all items in a blocking collection.</span></span>|  
|[<span data-ttu-id="48e5e-155">Cómo: usar matrices de colecciones de bloqueo en una canalización</span><span class="sxs-lookup"><span data-stu-id="48e5e-155">How to: Use Arrays of Blocking Collections in a Pipeline</span></span>](how-to-use-arrays-of-blockingcollections.md)|<span data-ttu-id="48e5e-156">Describe cómo utilizar varias colecciones de bloqueo para implementar una canalización al mismo tiempo.</span><span class="sxs-lookup"><span data-stu-id="48e5e-156">Describes how to use multiple blocking collections at the same time to implement a pipeline.</span></span>|  
|[<span data-ttu-id="48e5e-157">Cómo: crear un grupo de objetos usando ConcurrentBag</span><span class="sxs-lookup"><span data-stu-id="48e5e-157">How to: Create an Object Pool by Using a ConcurrentBag</span></span>](how-to-create-an-object-pool.md)|<span data-ttu-id="48e5e-158">Muestra cómo usar un controlador simultáneo para mejorar el rendimiento en escenarios donde puede reutilizar objetos en lugar de crear continuamente otros nuevos.</span><span class="sxs-lookup"><span data-stu-id="48e5e-158">Shows how to use a concurrent bag to improve performance in scenarios where you can reuse objects instead of continually creating new ones.</span></span>|  
  
## <a name="reference"></a><span data-ttu-id="48e5e-159">Referencia</span><span class="sxs-lookup"><span data-stu-id="48e5e-159">Reference</span></span>  
 <xref:System.Collections.Concurrent?displayProperty=nameWithType>
