---
title: Opciones de fusión mediante combinación en PLINQ
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- PLINQ queries, merge options
ms.assetid: e8f7be3b-88de-4f33-ab14-dc008e76c1ba
ms.openlocfilehash: 623466e0e960ea991ae92e5de432171b70bad1d2
ms.sourcegitcommit: 961ec21c22d2f1d55c9cc8a7edf2ade1d1fd92e3
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 04/02/2020
ms.locfileid: "80588620"
---
# <a name="merge-options-in-plinq"></a><span data-ttu-id="f8606-102">Opciones de fusión mediante combinación en PLINQ</span><span class="sxs-lookup"><span data-stu-id="f8606-102">Merge Options in PLINQ</span></span>
<span data-ttu-id="f8606-103">Cuando una consulta se ejecuta en paralelo, PLINQ crea particiones de la secuencia de origen para que varios subprocesos puedan funcionar en diferentes partes al mismo tiempo, por lo general en subprocesos independientes.</span><span class="sxs-lookup"><span data-stu-id="f8606-103">When a query is executing as parallel, PLINQ partitions the source sequence so that multiple threads can work on different parts concurrently, typically on separate threads.</span></span> <span data-ttu-id="f8606-104">Si los resultados se van a usar en un subproceso, por ejemplo, en un bucle `foreach` (`For Each` en Visual Basic), los resultados de cada subproceso deben volver a combinarse en una secuencia.</span><span class="sxs-lookup"><span data-stu-id="f8606-104">If the results are to be consumed on one thread, for example, in a `foreach` (`For Each` in Visual Basic) loop, then the results from every thread must be merged back into one sequence.</span></span> <span data-ttu-id="f8606-105">El tipo de combinación que PLINQ realiza depende de los operadores que están presentes en la consulta.</span><span class="sxs-lookup"><span data-stu-id="f8606-105">The kind of merge that PLINQ performs depends on the operators that are present in the query.</span></span> <span data-ttu-id="f8606-106">Por ejemplo, los operadores que imponen un nuevo orden de los resultados deben almacenar en búfer todos los elementos de todos los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="f8606-106">For example, operators that impose a new order on the results must buffer all elements from all threads.</span></span> <span data-ttu-id="f8606-107">Desde la perspectiva del subproceso utilizado (que también es el del usuario de la aplicación), una consulta totalmente almacenada en búfer podría ejecutarse durante un período de tiempo considerable antes de generar su primer resultado.</span><span class="sxs-lookup"><span data-stu-id="f8606-107">From the perspective of the consuming thread (which is also that of the application user) a fully buffered query might run for a noticeable period of time before it produces its first result.</span></span> <span data-ttu-id="f8606-108">Otros operadores, de forma predeterminada, están parcialmente almacenados en búfer; producen sus resultados en lotes.</span><span class="sxs-lookup"><span data-stu-id="f8606-108">Other operators, by default, are partially buffered; they yield their results in batches.</span></span> <span data-ttu-id="f8606-109">Un operador, <xref:System.Linq.ParallelEnumerable.ForAll%2A>, no se almacena en búfer de forma predeterminada.</span><span class="sxs-lookup"><span data-stu-id="f8606-109">One operator, <xref:System.Linq.ParallelEnumerable.ForAll%2A> is not buffered by default.</span></span> <span data-ttu-id="f8606-110">Genera inmediatamente todos los elementos de todos los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="f8606-110">It yields all elements from all threads immediately.</span></span>  
  
 <span data-ttu-id="f8606-111">Mediante el uso del método <xref:System.Linq.ParallelEnumerable.WithMergeOptions%2A>, como se muestra en el ejemplo siguiente, puede proporcionar una sugerencia a PLINQ que indica qué tipo de combinación se debe llevar a cabo.</span><span class="sxs-lookup"><span data-stu-id="f8606-111">By using the <xref:System.Linq.ParallelEnumerable.WithMergeOptions%2A> method, as shown in the following example, you can provide a hint to PLINQ that indicates what kind of merging to perform.</span></span>  
  
 [!code-csharp[PLINQ#26](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinqsamples.cs#26)]
 [!code-vb[PLINQ#26](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#26)]  
  
 <span data-ttu-id="f8606-112">Para obtener un ejemplo completo, vea [Cómo: Especificar opciones de fusión mediante combinación en PLINQ](../../../docs/standard/parallel-programming/how-to-specify-merge-options-in-plinq.md).</span><span class="sxs-lookup"><span data-stu-id="f8606-112">For the complete example, see [How to: Specify Merge Options in PLINQ](../../../docs/standard/parallel-programming/how-to-specify-merge-options-in-plinq.md).</span></span>  
  
 <span data-ttu-id="f8606-113">Si la consulta determinada no puede admitir la opción solicitada, simplemente se omitirá la opción.</span><span class="sxs-lookup"><span data-stu-id="f8606-113">If the particular query cannot support the requested option, then the option will just be ignored.</span></span> <span data-ttu-id="f8606-114">En la mayoría de los casos, no es necesario especificar una opción de combinación para una consulta PLINQ.</span><span class="sxs-lookup"><span data-stu-id="f8606-114">In most cases, you do not have to specify a merge option for a PLINQ query.</span></span> <span data-ttu-id="f8606-115">Sin embargo, en algunos casos puede observar mediante pruebas y mediciones que una consulta se ejecuta mejor en un modo no predeterminado.</span><span class="sxs-lookup"><span data-stu-id="f8606-115">However, in some cases you may find by testing and measurement that a query executes best in a non-default mode.</span></span> <span data-ttu-id="f8606-116">Un uso común de esta opción es forzar a un operador de combinación de fragmentos a transmitir por secuencias sus resultados con el fin de proporcionar una interfaz de usuario más dinámica.</span><span class="sxs-lookup"><span data-stu-id="f8606-116">A common use of this option is to force a chunk-merging operator to stream its results in order to provide a more responsive user interface.</span></span>  
  
## <a name="parallelmergeoptions"></a><span data-ttu-id="f8606-117">ParallelMergeOptions</span><span class="sxs-lookup"><span data-stu-id="f8606-117">ParallelMergeOptions</span></span>  
 <span data-ttu-id="f8606-118">La enumeración <xref:System.Linq.ParallelMergeOptions> incluye las siguientes opciones que especifican, para las formas de consulta compatibles, cómo se produjo el resultado final de la consulta cuando se usan los resultados en un subproceso:</span><span class="sxs-lookup"><span data-stu-id="f8606-118">The <xref:System.Linq.ParallelMergeOptions> enumeration includes the following options that specify, for supported query shapes, how the final output of the query is yielded when the results are consumed on one thread:</span></span>  
  
- `Not Buffered`  
  
     <span data-ttu-id="f8606-119">La opción <xref:System.Linq.ParallelMergeOptions.NotBuffered> hace que cada elemento procesado devuelva cada subproceso en cuanto se produzca.</span><span class="sxs-lookup"><span data-stu-id="f8606-119">The <xref:System.Linq.ParallelMergeOptions.NotBuffered> option causes each processed element to be returned from each thread as soon as it is produced.</span></span> <span data-ttu-id="f8606-120">Este comportamiento es análogo a la salida "streaming".</span><span class="sxs-lookup"><span data-stu-id="f8606-120">This behavior is analogous to "streaming" the output.</span></span> <span data-ttu-id="f8606-121">Si el operador <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> está presente en la consulta, `NotBuffered` conserva el orden de los elementos de origen.</span><span class="sxs-lookup"><span data-stu-id="f8606-121">If the <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> operator is present in the query, `NotBuffered` preserves the order of the source elements.</span></span> <span data-ttu-id="f8606-122">Aunque `NotBuffered` empieza a producir resultados en cuanto están disponibles, el tiempo total para generar todos los resultados puede ser más largo con respecto al uso de alguna de las demás opciones de combinación.</span><span class="sxs-lookup"><span data-stu-id="f8606-122">Although `NotBuffered` starts yielding results as soon as they're available, the total time to produce all the results might still be longer than using one of the other merge options.</span></span>  
  
- `Auto Buffered`  
  
     <span data-ttu-id="f8606-123">La opción <xref:System.Linq.ParallelMergeOptions.AutoBuffered> hace que la consulta recopile los elementos en un búfer y, a continuación, proporcionará periódicamente el contenido del búfer a la vez para el subproceso utilizado.</span><span class="sxs-lookup"><span data-stu-id="f8606-123">The <xref:System.Linq.ParallelMergeOptions.AutoBuffered> option causes the query to collect elements into a buffer and then periodically yield the buffer contents all at once to the consuming thread.</span></span> <span data-ttu-id="f8606-124">Esto es análogo a producir los datos de origen en "fragmentos" en lugar de usar el comportamiento de "streaming" de `NotBuffered`.</span><span class="sxs-lookup"><span data-stu-id="f8606-124">This is analogous to yielding the source data in "chunks" instead of using the "streaming" behavior of `NotBuffered`.</span></span> <span data-ttu-id="f8606-125">`AutoBuffered` puede tardar más que `NotBuffered` en habilitar el primer elemento en el subproceso utilizado.</span><span class="sxs-lookup"><span data-stu-id="f8606-125">`AutoBuffered` may take longer than `NotBuffered` to make the first element available on the consuming thread.</span></span> <span data-ttu-id="f8606-126">El tamaño del búfer y el comportamiento productivo exacto no se pueden configurar y pueden variar en función de varios factores relacionados con la consulta.</span><span class="sxs-lookup"><span data-stu-id="f8606-126">The size of the buffer and the exact yielding behavior are not configurable and may vary, depending on various factors that relate to the query.</span></span>  
  
- `FullyBuffered`  
  
     <span data-ttu-id="f8606-127">La opción <xref:System.Linq.ParallelMergeOptions.FullyBuffered> hace que el resultado de la consulta completa se almacene en búfer antes de que se produzca cualquiera de los elementos.</span><span class="sxs-lookup"><span data-stu-id="f8606-127">The <xref:System.Linq.ParallelMergeOptions.FullyBuffered> option causes the output of the whole query to be buffered before any of the elements are yielded.</span></span> <span data-ttu-id="f8606-128">Al usar esta opción, puede tardar más tiempo antes de que el primer elemento esté disponible en el subproceso utilizado, pero los resultados completos pueden producirse más rápido en comparación con el uso de otras opciones.</span><span class="sxs-lookup"><span data-stu-id="f8606-128">When you use this option, it can take longer before the first element is available on the consuming thread, but the complete results might still be produced faster than by using the other options.</span></span>  
  
## <a name="query-operators-that-support-merge-options"></a><span data-ttu-id="f8606-129">Operadores de consulta que admiten opciones de combinación</span><span class="sxs-lookup"><span data-stu-id="f8606-129">Query Operators that Support Merge Options</span></span>  
 <span data-ttu-id="f8606-130">En la tabla siguiente se enumeran los operadores que admiten todos los modos de opción de combinación, sujetos a las restricciones especificadas.</span><span class="sxs-lookup"><span data-stu-id="f8606-130">The following table lists the operators that support all merge option modes, subject to the specified restrictions.</span></span>  
  
|<span data-ttu-id="f8606-131">"??"</span><span class="sxs-lookup"><span data-stu-id="f8606-131">Operator</span></span>|<span data-ttu-id="f8606-132">Restricciones</span><span class="sxs-lookup"><span data-stu-id="f8606-132">Restrictions</span></span>|  
|--------------|------------------|  
|<xref:System.Linq.ParallelEnumerable.AsEnumerable%2A>|<span data-ttu-id="f8606-133">Ninguna</span><span class="sxs-lookup"><span data-stu-id="f8606-133">None</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Cast%2A>|<span data-ttu-id="f8606-134">Ninguna</span><span class="sxs-lookup"><span data-stu-id="f8606-134">None</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Concat%2A>|<span data-ttu-id="f8606-135">Consultas no ordenadas que tienen solo un origen de matriz o lista.</span><span class="sxs-lookup"><span data-stu-id="f8606-135">Non-ordered queries that have an Array or List source only.</span></span>|  
|<xref:System.Linq.ParallelEnumerable.DefaultIfEmpty%2A>|<span data-ttu-id="f8606-136">Ninguna</span><span class="sxs-lookup"><span data-stu-id="f8606-136">None</span></span>|  
|<xref:System.Linq.ParallelEnumerable.OfType%2A>|<span data-ttu-id="f8606-137">Ninguna</span><span class="sxs-lookup"><span data-stu-id="f8606-137">None</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Reverse%2A>|<span data-ttu-id="f8606-138">Consultas no ordenadas que tienen solo un origen de matriz o lista.</span><span class="sxs-lookup"><span data-stu-id="f8606-138">Non-ordered queries that have an Array or List source only.</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Select%2A>|<span data-ttu-id="f8606-139">Ninguna</span><span class="sxs-lookup"><span data-stu-id="f8606-139">None</span></span>|  
|<xref:System.Linq.ParallelEnumerable.SelectMany%2A>|<span data-ttu-id="f8606-140">Ninguna</span><span class="sxs-lookup"><span data-stu-id="f8606-140">None</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Skip%2A>|<span data-ttu-id="f8606-141">Ninguna</span><span class="sxs-lookup"><span data-stu-id="f8606-141">None</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Take%2A>|<span data-ttu-id="f8606-142">Ninguna</span><span class="sxs-lookup"><span data-stu-id="f8606-142">None</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Where%2A>|<span data-ttu-id="f8606-143">Ninguna</span><span class="sxs-lookup"><span data-stu-id="f8606-143">None</span></span>|  
  
 <span data-ttu-id="f8606-144">Todos los demás operadores de consulta PLINQ podrían omitir opciones de combinación proporcionadas por el usuario.</span><span class="sxs-lookup"><span data-stu-id="f8606-144">All other PLINQ query operators might ignore user-provided merge options.</span></span> <span data-ttu-id="f8606-145">Algunos operadores de consulta, por ejemplo <xref:System.Linq.ParallelEnumerable.Reverse%2A> y <xref:System.Linq.ParallelEnumerable.OrderBy%2A>, no pueden proporcionar todos los elementos hasta que no se hayan producido y reordenado.</span><span class="sxs-lookup"><span data-stu-id="f8606-145">Some query operators, for example, <xref:System.Linq.ParallelEnumerable.Reverse%2A> and <xref:System.Linq.ParallelEnumerable.OrderBy%2A>, cannot yield any elements until all have been produced and reordered.</span></span> <span data-ttu-id="f8606-146">Por lo tanto, cuando se utiliza <xref:System.Linq.ParallelMergeOptions> en una consulta que también contiene un operador como <xref:System.Linq.ParallelEnumerable.Reverse%2A>, el comportamiento de combinación no se aplicará en la consulta hasta después de que el operador genere sus resultados.</span><span class="sxs-lookup"><span data-stu-id="f8606-146">Therefore, when <xref:System.Linq.ParallelMergeOptions> is used in a query that also contains an operator such as <xref:System.Linq.ParallelEnumerable.Reverse%2A>, the merge behavior will not be applied in the query until after that operator has produced its results.</span></span>  
  
 <span data-ttu-id="f8606-147">La capacidad de algunos operadores para controlar las opciones de combinación depende del tipo de la secuencia de origen y de si el operador <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> se usó anteriormente en la consulta.</span><span class="sxs-lookup"><span data-stu-id="f8606-147">The ability of some operators to handle merge options depends on the type of the source sequence, and whether the <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> operator was used earlier in the query.</span></span> <span data-ttu-id="f8606-148"><xref:System.Linq.ParallelEnumerable.ForAll%2A> siempre es <xref:System.Linq.ParallelMergeOptions.NotBuffered>; produce inmediatamente sus elementos.</span><span class="sxs-lookup"><span data-stu-id="f8606-148"><xref:System.Linq.ParallelEnumerable.ForAll%2A> is always <xref:System.Linq.ParallelMergeOptions.NotBuffered> ; it yields its elements immediately.</span></span> <span data-ttu-id="f8606-149"><xref:System.Linq.ParallelEnumerable.OrderBy%2A> siempre es <xref:System.Linq.ParallelMergeOptions.FullyBuffered>; debe ordenar toda la lista antes de producirla.</span><span class="sxs-lookup"><span data-stu-id="f8606-149"><xref:System.Linq.ParallelEnumerable.OrderBy%2A> is always <xref:System.Linq.ParallelMergeOptions.FullyBuffered>; it must sort the whole list before it yields.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="f8606-150">Vea también</span><span class="sxs-lookup"><span data-stu-id="f8606-150">See also</span></span>

- [<span data-ttu-id="f8606-151">Parallel LINQ (PLINQ)</span><span class="sxs-lookup"><span data-stu-id="f8606-151">Parallel LINQ (PLINQ)</span></span>](../../../docs/standard/parallel-programming/introduction-to-plinq.md)
- [<span data-ttu-id="f8606-152">Especificación de opciones de combinación en PLINQ</span><span class="sxs-lookup"><span data-stu-id="f8606-152">How to: Specify Merge Options in PLINQ</span></span>](../../../docs/standard/parallel-programming/how-to-specify-merge-options-in-plinq.md)
