---
title: Reglas de seguridad (análisis de código)
description: Obtenga información sobre las reglas de seguridad del análisis de código.
ms.date: 10/02/2019
ms.topic: reference
f1_keywords:
- vs.codeanalysis.securityrules
helpviewer_keywords:
- security [Visual Studio ALM], Enterprise Templates
- security rules
- managed code analysis rules, security rules
- rules, security
author: gewarren
ms.author: gewarren
ms.openlocfilehash: 861827662a771ec7cc1827cdd8125be6c05bf05c
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 02/06/2021
ms.locfileid: "99719726"
---
# <a name="security-rules"></a>Reglas de seguridad

Las reglas de seguridad admiten bibliotecas y aplicaciones más seguras. Estas reglas ayudan a evitar los errores de seguridad en el programa. Si deshabilita alguna de estas reglas, debe marcar claramente el motivo en el código y también informar al responsable de seguridad designado para el proyecto de desarrollo.

## <a name="in-this-section"></a>En esta sección

|Regla|Descripción|
|----------|-----------------|
|[CA2100: Revisar consultas SQL para comprobar si tienen vulnerabilidades de seguridad](ca2100.md)|Un método establece la propiedad System.Data.IDbCommand.CommandText utilizando una cadena que se construye partiendo de un argumento de cadena para el método. Esta regla supone que el argumento de cadena contiene datos proporcionados por el usuario. Una cadena de comandos de SQL compilada a partir de datos proporcionados por el usuario es vulnerable a ataques de inserción de SQL.|
|[CA2109: Revisar los controladores de eventos visibles](ca2109.md)|Se detectó un método de control de eventos público o protegido. No se deberían exponer los métodos de control de eventos a menos que sea absolutamente necesario.|
|[CA2119: Sellar los métodos que satisfacen las interfaces privadas](ca2119.md)|Un tipo público heredable proporciona una implementación de método reemplazable de una interfaz interna (de tipo "Friend" en Visual Basic). Para corregir una infracción de esta regla, impida que el método se invalide fuera del ensamblado.|
|[CA2153: Evitar el control de excepciones de estado dañadas](ca2153.md)|Las[excepciones de estado dañado (CSE)](/archive/msdn-magazine/2009/february/clr-inside-out-handling-corrupted-state-exceptions) indican que la memoria está dañada en el proceso. Detectar estos problemas y evitar el bloqueo del proceso puede provocar vulnerabilidades de seguridad si un atacante puede colocar una vulnerabilidad de seguridad en la región de memoria dañada.|
|[CA2300: No usar el deserializador no seguro BinaryFormatter](ca2300.md)|Los deserializadores inseguros son vulnerables al deserializar datos que no son de confianza. Un atacante podría modificar los datos serializados para incluir tipos inesperados para insertar objetos con efectos secundarios malintencionados.|
|[CA2301: No llamar a BinaryFormatter.Deserialize sin establecer primero BinaryFormatter.Binder](ca2301.md)|Los deserializadores inseguros son vulnerables al deserializar datos que no son de confianza. Un atacante podría modificar los datos serializados para incluir tipos inesperados para insertar objetos con efectos secundarios malintencionados.|
|[CA2302: Asegurarse de que BinaryFormatter.Binder está establecido antes de llamar a BinaryFormatter.Deserialize](ca2302.md)|Los deserializadores inseguros son vulnerables al deserializar datos que no son de confianza. Un atacante podría modificar los datos serializados para incluir tipos inesperados para insertar objetos con efectos secundarios malintencionados.|
|[CA2305: No usar el deserializador no seguro LosFormatter](ca2305.md)|Los deserializadores inseguros son vulnerables al deserializar datos que no son de confianza. Un atacante podría modificar los datos serializados para incluir tipos inesperados para insertar objetos con efectos secundarios malintencionados.|
|[CA2310: No usar el deserializador no seguro NetDataContractSerializer](ca2310.md)|Los deserializadores inseguros son vulnerables al deserializar datos que no son de confianza. Un atacante podría modificar los datos serializados para incluir tipos inesperados para insertar objetos con efectos secundarios malintencionados.|
|[CA2311: No deserializar sin establecer primero NetDataContractSerializer.Binder](ca2311.md)|Los deserializadores inseguros son vulnerables al deserializar datos que no son de confianza. Un atacante podría modificar los datos serializados para incluir tipos inesperados para insertar objetos con efectos secundarios malintencionados.|
|[CA2312: Asegúrese de que se establece NetDataContractSerializer.Binder antes de deserializar](ca2312.md)|Los deserializadores inseguros son vulnerables al deserializar datos que no son de confianza. Un atacante podría modificar los datos serializados para incluir tipos inesperados para insertar objetos con efectos secundarios malintencionados.|
|[CA2315: No usar el deserializador no seguro ObjectStateFormatter](ca2315.md)|Los deserializadores inseguros son vulnerables al deserializar datos que no son de confianza. Un atacante podría modificar los datos serializados para incluir tipos inesperados para insertar objetos con efectos secundarios malintencionados.|
|[CA2321: No deserializar con JavaScriptSerializer mediante SimpleTypeResolver](ca2321.md)|Los deserializadores inseguros son vulnerables al deserializar datos que no son de confianza. Un atacante podría modificar los datos serializados para incluir tipos inesperados para insertar objetos con efectos secundarios malintencionados.|
|[CA2322: Asegúrese de que JavaScriptSerializer no se ha inicializado con SimpleTypeResolver antes de deserializar](ca2322.md)|Los deserializadores inseguros son vulnerables al deserializar datos que no son de confianza. Un atacante podría modificar los datos serializados para incluir tipos inesperados para insertar objetos con efectos secundarios malintencionados.|
|[CA2326: No usar valores TypeNameHandling que no sean None](ca2326.md)|Los deserializadores inseguros son vulnerables al deserializar datos que no son de confianza. Un atacante podría modificar los datos serializados para incluir tipos inesperados para insertar objetos con efectos secundarios malintencionados.|
|[CA2327: No usar valores JsonSerializerSettings no seguros](ca2327.md)|Los deserializadores inseguros son vulnerables al deserializar datos que no son de confianza. Un atacante podría modificar los datos serializados para incluir tipos inesperados para insertar objetos con efectos secundarios malintencionados.|
|[CA2328: Asegurarse de que los valores JsonSerializerSettings sean seguros](ca2328.md)|Los deserializadores inseguros son vulnerables al deserializar datos que no son de confianza. Un atacante podría modificar los datos serializados para incluir tipos inesperados para insertar objetos con efectos secundarios malintencionados.|
|[CA2329: No deserializar con JsonSerializer y una configuración no segura](ca2329.md)|Los deserializadores inseguros son vulnerables al deserializar datos que no son de confianza. Un atacante podría modificar los datos serializados para incluir tipos inesperados para insertar objetos con efectos secundarios malintencionados.|
|[CA2330: Asegurarse de que la configuración de JsonSerializer es segura al deserializar](ca2330.md)|Los deserializadores inseguros son vulnerables al deserializar datos que no son de confianza. Un atacante podría modificar los datos serializados para incluir tipos inesperados para insertar objetos con efectos secundarios malintencionados.|
|[CA2350: Asegurarse de que la entrada de DataTable.ReadXml() sea de confianza](ca2350.md)|Al deserializar un <xref:System.Data.DataTable> con una entrada que no es de confianza, un atacante puede crear una entrada malintencionada para realizar un ataque de denegación de servicio. Puede haber vulnerabilidades de ejecución de código remoto desconocidas.|
|[CA2351: Asegúrese de que la entrada de DataSet.ReadXml() sea de confianza](ca2351.md)|Al deserializar un <xref:System.Data.DataSet> con una entrada que no es de confianza, un atacante puede crear una entrada malintencionada para realizar un ataque de denegación de servicio. Puede haber vulnerabilidades de ejecución de código remoto desconocidas.|
|[CA2352: Un objeto DataSet o DataTable no seguro en un tipo serializable puede ser vulnerable a ataques de ejecución de código remoto](ca2352.md)|Una clase o estructura marcada con <xref:System.SerializableAttribute> contiene un <xref:System.Data.DataSet> campo o una <xref:System.Data.DataTable> propiedad, y no tiene un <xref:System.CodeDom.Compiler.GeneratedCodeAttribute> .|
|[CA2353: Objeto DataSet o DataTable no seguro en un tipo serializable](ca2353.md)|Una clase o estructura marcada con un atributo de serialización XML o un atributo de contrato de datos contiene una <xref:System.Data.DataSet> propiedad o un <xref:System.Data.DataTable> campo o.|
|[CA2354: Un objeto DataSet o DataTable no seguro en un gráfico de objetos deserializado puede ser vulnerable a ataques de ejecución de código remoto](ca2354.md)|La deserialización con un <xref:System.Runtime.Serialization.IFormatter?displayProperty=nameWithType> serializado y el gráfico de objetos del tipo convertido pueden incluir <xref:System.Data.DataSet> o <xref:System.Data.DataTable> .|
|[CA2355: Objeto DataSet o DataTable no seguro en un gráfico de objetos deserializado](ca2355.md)|Deserializar cuando el gráfico de objetos del tipo especificado o convertido puede incluir <xref:System.Data.DataSet> o <xref:System.Data.DataTable> .|
|[CA2356: DataSet no seguro o DataTable en el gráfico de objetos deserializados Web](ca2356.md)|Un método con <xref:System.Web.Services.WebMethodAttribute?displayProperty=nameWithType> o <xref:System.ServiceModel.OperationContractAttribute?displayProperty=nameWithType> tiene un parámetro que puede hacer referencia a un <xref:System.Data.DataSet> o <xref:System.Data.DataTable> .|
|[CA2361: Asegurarse de que la clase autogenerada que contiene DataSet.ReadXml() no se utilice con datos que no son de confianza](ca2361.md)|Al deserializar un <xref:System.Data.DataSet> con una entrada que no es de confianza, un atacante puede crear una entrada malintencionada para realizar un ataque de denegación de servicio. Puede haber vulnerabilidades de ejecución de código remoto desconocidas.|
|[CA2362: Un elemento DataSet o DataTable no seguro en un tipo serializable autogenerado puede ser vulnerable a ataques de ejecución remota de código](ca2362.md)|Al deserializar la entrada que no es de confianza con <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> y el gráfico de objetos deserializados contiene <xref:System.Data.DataSet> o <xref:System.Data.DataTable> , un atacante puede crear una carga malintencionada para realizar un ataque de ejecución de código remoto.|
|[CA3001: Revisión de código en busca de vulnerabilidades de inyección de SQL](ca3001.md)|Al trabajar con comandos SQL y de entrada que no son de confianza, tenga en cuentan los ataques por inyección de SQL. Un ataque por inyección de SQL puede ejecutar comandos SQL malintencionados, poniendo en peligro la seguridad y la integridad de la aplicación.|
|[CA3002: Revisión de código en busca de vulnerabilidades de XSS](ca3002.md)|Al trabajar con una entrada que no es de confianza de las solicitudes Web, tenga en cuentan los ataques de scripting entre sitios (XSS). Un ataque XSS inyecta entradas que no son de confianza en salidas HTML sin procesar, lo que permite al atacante ejecutar scripts malintencionados o modificar contenido de forma malintencionada en la Página Web.|
|[CA3003: Revisión de código en busca de vulnerabilidades de inyección de rutas de acceso a archivos](ca3003.md)|Al trabajar con una entrada que no es de confianza de las solicitudes Web, tenga en cuentan el uso de entradas controladas por el usuario al especificar las rutas de acceso a los archivos.|
|[CA3004: Revisión de código en busca de vulnerabilidades de divulgación de información](ca3004.md)|Al revelar la información de la excepción, se ofrece a los atacantes información sobre el funcionamiento interno de la aplicación, lo que puede ayudar a los atacantes a encontrar otras vulnerabilidades que se puedan aprovechar.|
|[CA3006: Revisión de código en busca de vulnerabilidades de inyección de comandos de procesos](ca3006.md)|Al trabajar con una entrada que no es de confianza, tenga en cuentan los ataques por inyección de comandos. Un ataque por inyección de comandos puede ejecutar comandos malintencionados en el sistema operativo subyacente, poniendo en peligro la seguridad y la integridad del servidor.|
|[CA3007: Revisión de código en busca de vulnerabilidades de redireccionamiento abierto](ca3007.md)|Al trabajar con una entrada que no es de confianza, tenga en cuentan las vulnerabilidades de redireccionamiento abierto. Un atacante puede aprovechar una vulnerabilidad de redirección abierta para usar el sitio web con el fin de dar la apariencia de una dirección URL legítima, pero redirigir a un visitante que no sospecha a un phishing u otra página web malintencionada.|
|[CA3008: Revisión de código en busca de vulnerabilidades de inyección de XPath](ca3008.md)|Al trabajar con una entrada que no es de confianza, tenga en cuentan los ataques por inyección de XPath. La construcción de consultas XPath mediante la entrada que no es de confianza puede permitir a un atacante manipular de forma malintencionada la consulta para devolver un resultado no deseado y, posiblemente, divulgar el contenido del XML consultado.|
|[CA3009: Revisión de código en busca de vulnerabilidades de inyección de XML](ca3009.md)|Al trabajar con una entrada que no es de confianza, tenga en cuentan los ataques por inyección de XML.|
|[CA3010: Revisión de código en busca de vulnerabilidades de inyección de XAML](ca3010.md)|Al trabajar con una entrada que no es de confianza, tenga en cuentan los ataques por inyección de XAML. XAML es un lenguaje de marcado que representa directamente la creación de instancias y la ejecución de objetos. Esto significa que los elementos creados en XAML pueden interactuar con los recursos del sistema (por ejemplo, el acceso a la red y la e/s del sistema de archivos).|
|[CA3011: Revisión de código en busca de vulnerabilidades de inyección de DLL](ca3011.md)|Al trabajar con una entrada que no es de confianza, tenga en cuentan la carga de código que no es de confianza. Si la aplicación web carga código que no es de confianza, es posible que un atacante pueda insertar archivos dll malintencionados en el proceso y ejecutar código malintencionado.|
|[CA3012: Revisión de código en busca de vulnerabilidades de inyección de expresiones regulares](ca3012.md)|Al trabajar con una entrada que no es de confianza, tenga en cuentan los ataques por inyección de Regex. Un atacante puede usar la inyección de Regex para modificar de forma malintencionada una expresión regular, para hacer que el regex coincida con los resultados imprevistos o para hacer que la expresión regular consuma una CPU excesiva, lo que produce un ataque de denegación de servicio.|
|[CA3061: No agregar esquema por dirección URL](ca3061.md)|No use la sobrecarga no segura del método Add porque puede provocar referencias externas peligrosas.|
|[CA3075: Procesamiento no seguro de DTD](ca3075.md)|Si usa instancias de DTDProcessing inseguras o hace referencia a orígenes de entidades externas, el analizador podría aceptar entradas que no sean de confianza y revelar información confidencial a atacantes.|
|[CA3076: Ejecución del script XSLT no segura](ca3076.md)|Si ejecuta transformaciones del lenguaje de hojas de estilo extensible (XSLT) en aplicaciones .NET de forma no segura, el procesador puede resolver referencias de URI que no son de confianza y que podrían revelar información confidencial a atacantes, lo que provoca ataques de denegación de servicio y entre sitios.|
|[CA3077: Procesamiento no seguro en el diseño de una API, documento XML y lector de texto XML](ca3077.md)|Al diseñar una API derivada de XMLDocument y XMLTextReader, tenga en cuenta la propiedad DtdProcessing. El uso de instancias de DTDProcessing inseguras al hacer referencia a orígenes de entidades externas o resolverlos, o la definición de valores inseguros en el lenguaje XML puede provocar la divulgación de información.|
|[CA3147: Marcar los controladores de verbo con ValidateAntiForgeryToken](ca3147.md)|Al diseñar un controlador ASP.NET MVC, tenga en cuentan los ataques de falsificación de solicitudes entre sitios. Un ataque de falsificación de solicitudes entre sitios puede enviar solicitudes malintencionadas de un usuario autenticado a su controlador ASP.NET MVC.|
|[CA5350: No usar algoritmos criptográficos no seguros](ca5350.md)|Las funciones hash y los algoritmos de cifrado débiles se usan hoy en día para numerosos propósitos, pero no se recomiendan para garantizar la confidencialidad o la integridad de los datos que se protegen. Esta regla se desencadena cuando se encuentran los algoritmos TripleDES, SHA1 o RIPEMD160 en el código.|
|[CA5351: no usar algoritmos criptográficos rotos](ca5351.md)|Los algoritmos criptográficos rotos no se consideran seguros y debe desalentarse su uso. Esta regla se desencadena cuando encuentra el algoritmo hash MD5 o los algoritmos de cifrado DES o RC2 en el código.|
|[CA5358: No usar modos de cifrado inseguro](ca5358.md)|No usar modos de cifrado inseguro|
|[CA5359: No deshabilitar la validación de certificado](ca5359.md)|Un certificado puede ayudar a autenticar la identidad del servidor. Los clientes deben validar el certificado de servidor para asegurarse de que las solicitudes se envían al servidor previsto. Si ServerCertificateValidationCallback (siempre devuelve `true` , cualquier certificado pasará la validación.|
|[CA5360: No llamar a métodos peligrosos durante la deserialización](ca5360.md)|La deserialización no segura es una vulnerabilidad que se produce cuando los datos que no son de confianza se usan para abusar la lógica de una aplicación, provocar un ataque de denegación de servicio (DoS) o incluso ejecutar código arbitrario cuando se deserializa. A menudo, es posible que los usuarios malintencionados abusan estas características de deserialización cuando la aplicación está deserializando datos que no son de confianza y están bajo su control. En concreto, invoque métodos peligrosos en el proceso de deserialización. Los ataques de deserialización inseguros que se han realizado correctamente podrían permitir que un atacante lleve a cabo ataques como ataques de DoS, omisiones de autenticación y ejecución remota de código.|
|[CA5361: no deshabilite el uso de SChannel de cifrado seguro](ca5361.md)|Establecer `Switch.System.Net.DontEnableSchUseStrongCrypto` para `true` debilita la criptografía usada en las conexiones de seguridad de la capa de transporte (TLS) salientes. La criptografía más débil puede poner en peligro la confidencialidad de la comunicación entre la aplicación y el servidor, lo que facilita a los atacantes la interceptación de información confidencial.|
|[CA5362: Ciclo de referencia potencial en gráfico de objetos deserializados](ca5362.md)|Si se deserializan los datos que no son de confianza, el procesamiento de código del gráfico de objetos deserializados debe controlar los ciclos de referencia sin entrar en bucles infinitos. Esto incluye el código que forma parte de una devolución de llamada de deserialización y el código que procesa el gráfico de objetos una vez completada la deserialización. De lo contrario, un atacante podría realizar un ataque por denegación de servicio con datos malintencionados que contuvieran un ciclo de referencia.|
|[CA5363: No deshabilitar la validación de solicitudes](ca5363.md)|La validación de solicitudes es una característica de ASP.NET que examina las solicitudes HTTP y determina si contienen contenido potencialmente peligroso que puede conducir a ataques de inyección, incluido el scripting entre sitios.|
|[CA5364: No usar protocolos de seguridad en desuso](ca5364.md)|La seguridad de la capa de transporte (TLS) protege la comunicación entre equipos, normalmente con el protocolo seguro de transferencia de hipertexto (HTTPS). Las versiones de protocolo anteriores de TLS son menos seguras que las de TLS 1,2 y TLS 1,3 y es más probable que tengan nuevas vulnerabilidades. Evite las versiones anteriores del protocolo para minimizar el riesgo.|
|[CA5365: No deshabilitar la comprobación de encabezados HTTP](ca5365.md)|La comprobación de encabezados HTTP permite codificar el retorno de carro y los caracteres de nueva línea, \r y \n, que se encuentran en los encabezados de respuesta. Esta codificación puede ayudar a evitar ataques de inyección que aprovechan una aplicación que repite datos que no son de confianza contenidos en el encabezado.|
|[CA5366: Utilizar XmlReader para el XML de lectura de DataSet](ca5366.md)|El uso de <xref:System.Data.DataSet> para leer XML con datos que no son de confianza puede cargar referencias externas peligrosas, que se deben restringir mediante un <xref:System.Xml.XmlReader> con un solucionador seguro o con el procesamiento de DTD deshabilitado.|
|[CA5367: No serializar los tipos con campos de puntero](ca5367.md)|Esta regla comprueba si hay una clase serializable con una propiedad o un campo de puntero. Los miembros que no se pueden serializar pueden ser un puntero, como los miembros estáticos o los campos marcados con <xref:System.NonSerializedAttribute> .|
|[CA5368: Establecer ViewStateUserKey para clases derivadas de página](ca5368.md)|El establecimiento de la <xref:System.Web.UI.Page.ViewStateUserKey> propiedad puede ayudarle a evitar ataques en la aplicación al permitirle asignar un identificador a la variable de estado de vista de usuarios individuales para que los atacantes no puedan usar la variable para generar un ataque. De lo contrario, habrá vulnerabilidades en la falsificación de solicitudes entre sitios.|
|[CA5369: Usar XmlReader para deserializar](ca5369.md)|El procesamiento de DTD y esquemas XML que no son de confianza puede habilitar la carga de referencias externas peligrosas, que se deben restringir mediante un XmlReader con un solucionador seguro o con el procesamiento de esquemas en línea XML y DTD deshabilitado.|
|[CA5370: Usar XmlReader para validar el lector](ca5370.md)|El procesamiento de DTD y esquemas XML que no son de confianza puede habilitar la carga de referencias externas peligrosas. Esta carga peligrosa se puede restringir mediante el uso de un XmlReader con un solucionador seguro o con el procesamiento de esquemas en línea de DTD y XML deshabilitado.|
|[CA5371: Usar XmlReader para leer el esquema](ca5371.md)|El procesamiento de DTD y esquemas XML que no son de confianza puede habilitar la carga de referencias externas peligrosas. El uso de un XmlReader con un solucionador seguro o con DTD y el procesamiento de esquemas en línea XML deshabilitado restringe esto.|
|[CA5372: Usar XmlReader para XPathDocument](ca5372.md)|El procesamiento de XML a partir de datos que no son de confianza puede cargar referencias externas peligrosas, que se pueden restringir mediante un XmlReader con un solucionador seguro o con el procesamiento de DTD deshabilitado.|
|[CA5373: No usar la función de derivación de clave obsoleta](ca5373.md)|Esta regla detecta la invocación de métodos de derivación de claves débiles <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> y `Rfc2898DeriveBytes.CryptDeriveKey` . <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> usó un algoritmo débil del PBKDF1.|
|[CA5374: No utilizar XslTransform](ca5374.md)|Esta regla comprueba si <xref:System.Xml.Xsl.XslTransform?displayProperty=nameWithType> se crean instancias en el código. <xref:System.Xml.Xsl.XslTransform?displayProperty=nameWithType> está ahora obsoleto y no debe usarse.|
|[CA5375: No usar la firma de acceso compartido de la cuenta](ca5375.md)|Una SAS de cuenta puede delegar el acceso a operaciones de lectura, escritura y eliminación en contenedores de blobs, tablas, colas y recursos compartidos de archivos que no se permiten con una SAS de servicio. Sin embargo, no es compatible con las directivas de nivel de contenedor y tiene menos flexibilidad y control sobre los permisos que se conceden. Una vez que los usuarios malintencionados la obtienen, la cuenta de almacenamiento se verá comprometida fácilmente.|
|[CA5376: Usar HttpsOnly con SharedAccessProtocol](ca5376.md)|SAS es información confidencial que no se puede transportar en texto sin formato en HTTP.|
|[CA5377: Usar una directiva de acceso de nivel de contenedor](ca5377.md)|Una directiva de acceso de nivel de contenedor se puede modificar o revocar en cualquier momento. Proporciona mayor flexibilidad y control sobre los permisos que se conceden.|
|[CA5378: No deshabilitar ServicePointManagerSecurityProtocols](ca5378.md)|Establecer `DisableUsingServicePointManagerSecurityProtocols` en `true` limita las conexiones de seguridad de la capa de transporte (TLS) de Windows Communication Framework (WCF) al uso de TLS 1,0. Esa versión de TLS quedará en desuso.|
|[CA5379: Asegúrese de que el algoritmo de función de derivación de claves sea suficientemente seguro](ca5379.md)|De <xref:System.Security.Cryptography.Rfc2898DeriveBytes> forma predeterminada, la clase usa el <xref:System.Security.Cryptography.HashAlgorithmName.SHA1> algoritmo. Debe especificar el algoritmo hash que se utilizará en algunas sobrecargas del constructor con <xref:System.Security.Cryptography.HashAlgorithmName.SHA256> o superior. Tenga en cuenta <xref:System.Security.Cryptography.Rfc2898DeriveBytes.HashAlgorithm> que la propiedad solo tiene un `get` descriptor de acceso y no tiene un `overriden` modificador.|
|[CA5380: No agregar certificados al almacén raíz](ca5380.md)|Esta regla detecta código que agrega un certificado al almacén de certificados de entidades de certificación raíz de confianza. De forma predeterminada, el almacén de certificados de entidades de certificación raíz de confianza se configura con un conjunto de entidades de certificación públicas que cumplen los requisitos del programa de certificados raíz de Microsoft.|
|[CA5381: Asegurar que no se agregan certificados al almacén raíz](ca5381.md)|Esta regla detecta código que puede Agregar un certificado al almacén de certificados de entidades de certificación raíz de confianza. De forma predeterminada, el almacén de certificados de entidades de certificación raíz de confianza se configura con un conjunto de entidades de certificación (CA) públicas que cumplen los requisitos del programa de certificados raíz de Microsoft.|
|[CA5382: Usar cookies seguras en ASP.NET Core](ca5382.md)|Las aplicaciones disponibles a través de HTTPS deben usar cookies seguras, que indican al explorador que la cookie solo se debe transmitir mediante seguridad de la capa de transporte (TLS).|
|[CA5383: Asegurarse de usar cookies seguras en ASP.NET Core](ca5383.md)|Las aplicaciones disponibles a través de HTTPS deben usar cookies seguras, que indican al explorador que la cookie solo se debe transmitir mediante seguridad de la capa de transporte (TLS).|
|[CA5384: No usar el algoritmo de firma digital (DSA)](ca5384.md)|DSA es un algoritmo de cifrado asimétrico débil.|
|[CA5385: Usar un algoritmo de Rivest-Shamir-Adleman (RSA) con un tamaño de clave suficiente](ca5385.md)|Una clave RSA de menos de 2048 bits es más vulnerable a los ataques por fuerza bruta.|
|[CA5386: Evitar codificar el valor SecurityProtocolType de forma rígida](ca5386.md)|La seguridad de la capa de transporte (TLS) protege la comunicación entre equipos, normalmente con el protocolo seguro de transferencia de hipertexto (HTTPS). Las versiones de protocolo TLS 1,0 y TLS 1,1 están desusadas, mientras que TLS 1,2 y TLS 1,3 están actualizados. En el futuro, TLS 1,2 y TLS 1,3 pueden estar en desuso. Para asegurarse de que la aplicación sigue siendo segura, evite codificar una versión del protocolo y tenga como destino al menos .NET Framework v 4.7.1.|
|[CA5387: No usar una función de derivación de claves débiles con un recuento de iteraciones insuficiente](ca5387.md)|Esta regla comprueba si se generó una clave criptográfica <xref:System.Security.Cryptography.Rfc2898DeriveBytes> con un recuento de iteraciones inferior a 100.000. Un recuento de iteraciones mayor puede ayudar a mitigar los ataques de diccionario que intentan adivinar la clave criptográfica generada.|
|[CA5388: Garantizar un recuento de iteraciones suficiente al usar una función de derivación de claves débiles](ca5388.md)|Esta regla comprueba si se generó una clave criptográfica <xref:System.Security.Cryptography.Rfc2898DeriveBytes> con un recuento de iteraciones que puede ser inferior a 100.000. Un recuento de iteraciones mayor puede ayudar a mitigar los ataques de diccionario que intentan adivinar la clave criptográfica generada.|
|[CA5389: No agregar la ruta de acceso del elemento de archivo a la ruta de acceso del sistema de archivos de destino](ca5389.md)|La ruta de acceso de archivo puede ser relativa y puede dar lugar a un acceso al sistema de archivos fuera de la ruta de destino del sistema de archivos esperada, lo que provoca cambios de configuración malintencionados y la ejecución remota de código mediante la técnica de establecer y esperar.|
|[CA5390: No codificar la clave de cifrado de forma rígida](ca5390.md)|Para que un algoritmo simétrico se realice correctamente, solo el remitente y el receptor deben conocer la clave secreta. Cuando una clave está codificada de forma rígida, se detecta fácilmente. Incluso con los archivos binarios compilados, es fácil que los usuarios malintencionados lo extraigan. Una vez que la clave privada se ve comprometida, el texto cifrado se puede descifrar directamente y ya no está protegido.|
|[CA5391: Usar tokens antifalsificación en los controladores de ASP.NET Core MVC](ca5391.md)|Controlar una `POST` `PUT` solicitud,, `PATCH` o `DELETE` sin validar un token antifalsificación puede ser vulnerable a los ataques de falsificación de solicitudes entre sitios. Un ataque de falsificación de solicitudes entre sitios puede enviar solicitudes malintencionadas de un usuario autenticado a un controlador de MVC de ASP.NET Core.|
|[CA5392: Usar el atributo DefaultDllImportSearchPaths para P/Invoke](ca5392.md)|De forma predeterminada, las funciones P/Invoke <xref:System.Runtime.InteropServices.DllImportAttribute> que usan sondeos incluyen un número de directorios, incluido el directorio de trabajo actual de la biblioteca que se va a cargar. Puede tratarse de un problema de seguridad para ciertas aplicaciones, lo que conduce a la secuestro de DLL.|
|[CA5393: No usar un valor de DllImportSearchPath no seguro](ca5393.md)|Podría haber un archivo DLL malintencionado en los directorios de búsqueda DLL predeterminados y los directorios de ensamblado. O, en función de dónde se ejecute la aplicación, podría haber un archivo DLL malintencionado en el directorio de la aplicación.|
|[CA5394: No usar aleatoriedad no segura](ca5394.md)|El uso de un generador de números pseudoaleatorios no seguros criptográficamente puede permitir que un atacante prediga qué valor de seguridad se generará.|
|[CA5395: Falta el atributo HttpVerb para los métodos de acción](ca5395.md)|Todos los métodos de acción que crean, modifican, eliminan o modifican de algún otro modo los datos deben protegerse con el atributo antifalsificación de los ataques de falsificación de solicitudes entre sitios. Realizar una operación GET debe ser una operación segura que no tenga efectos secundarios y no modifique los datos persistentes.|
|[CA5396: Establecer HttpOnly en true para HttpCookie](ca5396.md)|Como medida de defensa en profundidad, asegúrese de que las cookies HTTP confidenciales de seguridad estén marcadas como HttpOnly. Esto indica que los exploradores Web deben impedir que los scripts tengan acceso a las cookies. Los scripts malintencionados insertados son una forma habitual de robar cookies.|
|[CA5397: No usar valores SslProtocols en desuso](ca5397.md)|La seguridad de la capa de transporte (TLS) protege la comunicación entre equipos, normalmente con el protocolo seguro de transferencia de hipertexto (HTTPS). Las versiones de protocolo anteriores de TLS son menos seguras que las de TLS 1,2 y TLS 1,3 y es más probable que tengan nuevas vulnerabilidades. Evite las versiones anteriores del protocolo para minimizar el riesgo.|
|[CA5398: Evitar valores SslProtocols codificados de forma rígida](ca5398.md)|La seguridad de la capa de transporte (TLS) protege la comunicación entre equipos, normalmente con el protocolo seguro de transferencia de hipertexto (HTTPS). Las versiones de protocolo TLS 1,0 y TLS 1,1 están desusadas, mientras que TLS 1,2 y TLS 1,3 están actualizados. En el futuro, TLS 1,2 y TLS 1,3 pueden estar en desuso. Para asegurarse de que la aplicación sigue siendo segura, evite codificar una versión del protocolo.|
|[CA5399: Deshabilitar definitivamente la comprobación de la lista de revocación de certificados HttpClient](ca5399.md)|Un certificado revocado ya no es de confianza. Podría ser utilizado por los atacantes para pasar algunos datos malintencionados o robar datos confidenciales en la comunicación HTTPS.|
|[CA5400: Garantizar que la comprobación de la lista de revocación de certificados HttpClient no está deshabilitada](ca5400.md)|Un certificado revocado ya no es de confianza. Podría ser utilizado por los atacantes para pasar algunos datos malintencionados o robar datos confidenciales en la comunicación HTTPS.|
|[CA5401: No usar CreateEncryptor con un vector de inicialización no predeterminado](ca5401.md)|El cifrado simétrico siempre debe usar un vector de inicialización no repetible para evitar ataques de diccionario.|
|[CA5402: Usar CreateEncryptor con el vector de inicialización predeterminado](ca5402.md)|El cifrado simétrico siempre debe usar un vector de inicialización no repetible para evitar ataques de diccionario.|
|[CA5403: No codificar el certificado de forma rígida](ca5403.md)|El `data` `rawData` parámetro o de un <xref:System.Security.Cryptography.X509Certificates.X509Certificate> <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> constructor o está codificado de forma rígida.|
