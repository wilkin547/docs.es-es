---
title: Reglas de uso (análisis de código)
description: Más información sobre las reglas de uso de análisis de código.
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.usagerules
helpviewer_keywords:
- rules, usage
- managed code analysis rules, usage rules
- usage rules
author: gewarren
ms.author: gewarren
ms.openlocfilehash: b05edde3c6faef39aa724dd49d159abe23d049f5
ms.sourcegitcommit: 42d436ebc2a7ee02fc1848c7742bc7d80e13fc2f
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 03/04/2021
ms.locfileid: "102102976"
---
# <a name="usage-rules"></a><span data-ttu-id="04143-103">Reglas de uso</span><span class="sxs-lookup"><span data-stu-id="04143-103">Usage rules</span></span>

<span data-ttu-id="04143-104">Las reglas de uso admiten el uso adecuado de .NET.</span><span class="sxs-lookup"><span data-stu-id="04143-104">Usage rules support proper usage of .NET.</span></span>

## <a name="in-this-section"></a><span data-ttu-id="04143-105">En esta sección</span><span class="sxs-lookup"><span data-stu-id="04143-105">In this section</span></span>

|<span data-ttu-id="04143-106">Regla</span><span class="sxs-lookup"><span data-stu-id="04143-106">Rule</span></span>|<span data-ttu-id="04143-107">Descripción</span><span class="sxs-lookup"><span data-stu-id="04143-107">Description</span></span>|
|----------|-----------------|
|[<span data-ttu-id="04143-108">CA1801: Revisar parámetros sin utilizar</span><span class="sxs-lookup"><span data-stu-id="04143-108">CA1801: Review unused parameters</span></span>](ca1801.md)|<span data-ttu-id="04143-109">Una firma de método incluye un parámetro que no se utiliza en el cuerpo del método.</span><span class="sxs-lookup"><span data-stu-id="04143-109">A method signature includes a parameter that is not used in the method body.</span></span>|
|[<span data-ttu-id="04143-110">CA1816: Llamar a GC.SuppressFinalize correctamente</span><span class="sxs-lookup"><span data-stu-id="04143-110">CA1816: Call GC.SuppressFinalize correctly</span></span>](ca1816.md)|<span data-ttu-id="04143-111">Un método que es una implementación de Dispose no llama a `GC.SuppressFinalize` ; o a un método que no es una implementación de `Dispose` llamadas `GC.SuppressFinalize` ; o a un método llama a `GC.SuppressFinalize` y pasa un valor distinto de `this` ( `Me` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="04143-111">A method that is an implementation of Dispose does not call `GC.SuppressFinalize`; or a method that is not an implementation of `Dispose` calls `GC.SuppressFinalize`; or a method calls `GC.SuppressFinalize` and passes something other than `this` (`Me` in Visual Basic).</span></span>|
|[<span data-ttu-id="04143-112">CA2200: Reiniciar para mantener los detalles de la pila</span><span class="sxs-lookup"><span data-stu-id="04143-112">CA2200: Rethrow to preserve stack details</span></span>](ca2200.md)|<span data-ttu-id="04143-113">Se vuelve a producir una excepción y se especifica explícitamente en la instrucción throw.</span><span class="sxs-lookup"><span data-stu-id="04143-113">An exception is rethrown and the exception is explicitly specified in the throw statement.</span></span> <span data-ttu-id="04143-114">Si se vuelve a producir una excepción especificándola en la instrucción throw, se pierde la lista de llamadas al método entre el método original que produjo la excepción y el método actual.</span><span class="sxs-lookup"><span data-stu-id="04143-114">If an exception is rethrown by specifying the exception in the throw statement, the list of method calls between the original method that threw the exception and the current method is lost.</span></span>|
|[<span data-ttu-id="04143-115">CA2201: No provocar tipos de excepción reservados</span><span class="sxs-lookup"><span data-stu-id="04143-115">CA2201: Do not raise reserved exception types</span></span>](ca2201.md)|<span data-ttu-id="04143-116">Esto hace que el error original sea difícil de detectar y depurar.</span><span class="sxs-lookup"><span data-stu-id="04143-116">This makes the original error hard to detect and debug.</span></span>|
|[<span data-ttu-id="04143-117">CA2207: Inicializar campos estáticos de tipo de valor insertados</span><span class="sxs-lookup"><span data-stu-id="04143-117">CA2207: Initialize value type static fields inline</span></span>](ca2207.md)|<span data-ttu-id="04143-118">Un tipo de valor declara un constructor estático explícito.</span><span class="sxs-lookup"><span data-stu-id="04143-118">A value type declares an explicit static constructor.</span></span> <span data-ttu-id="04143-119">Para corregir una infracción de esta regla, inicialice todos los datos estáticos cuando se declara y quite el constructor estático.</span><span class="sxs-lookup"><span data-stu-id="04143-119">To fix a violation of this rule, initialize all static data when it is declared and remove the static constructor.</span></span>|
|[<span data-ttu-id="04143-120">CA2208: Crear instancias de las excepciones del argumento correctamente</span><span class="sxs-lookup"><span data-stu-id="04143-120">CA2208: Instantiate argument exceptions correctly</span></span>](ca2208.md)|<span data-ttu-id="04143-121">Se realiza una llamada al constructor predeterminado (sin parámetros) de un tipo de excepción que es o deriva de ArgumentException, o se pasa un argumento de cadena incorrecto a un constructor con parámetros de un tipo de excepción que es o deriva de ArgumentException.</span><span class="sxs-lookup"><span data-stu-id="04143-121">A call is made to the default (parameterless) constructor of an exception type that is or derives from ArgumentException, or an incorrect string argument is passed to a parameterized constructor of an exception type that is or derives from ArgumentException.</span></span>|
|[<span data-ttu-id="04143-122">CA2211: Los campos no constantes no deben ser visibles</span><span class="sxs-lookup"><span data-stu-id="04143-122">CA2211: Non-constant fields should not be visible</span></span>](ca2211.md)|<span data-ttu-id="04143-123">Los campos estáticos que no son constantes o de solo lectura no son seguros para subprocesos.</span><span class="sxs-lookup"><span data-stu-id="04143-123">Static fields that are not constants or read-only are not thread-safe.</span></span> <span data-ttu-id="04143-124">El acceso a este tipo de campo debe controlarse cuidadosamente y requiere técnicas de programación avanzada para sincronizar el acceso al objeto de clase.</span><span class="sxs-lookup"><span data-stu-id="04143-124">Access to such a field must be carefully controlled and requires advanced programming techniques for synchronizing access to the class object.</span></span>|
|[<span data-ttu-id="04143-125">CA2213: Los campos descartables deben ser descartables</span><span class="sxs-lookup"><span data-stu-id="04143-125">CA2213: Disposable fields should be disposed</span></span>](ca2213.md)|<span data-ttu-id="04143-126">Un tipo que implementa <xref:System.IDisposable?displayProperty=fullName> declara campos que son de tipos que también implementan `IDisposable` .</span><span class="sxs-lookup"><span data-stu-id="04143-126">A type that implements <xref:System.IDisposable?displayProperty=fullName> declares fields that are of types that also implement `IDisposable`.</span></span> <span data-ttu-id="04143-127">El método del `Dispose` tipo declarativo no llama al método del campo `Dispose` .</span><span class="sxs-lookup"><span data-stu-id="04143-127">The `Dispose` method of the field is not called by the `Dispose` method of the declaring type.</span></span>|
|[<span data-ttu-id="04143-128">CA2214: No llamar a métodos reemplazables en constructores</span><span class="sxs-lookup"><span data-stu-id="04143-128">CA2214: Do not call overridable methods in constructors</span></span>](ca2214.md)|<span data-ttu-id="04143-129">Cuando un constructor llama a un método virtual, es posible que no se haya ejecutado el constructor de la instancia que invoca el método.</span><span class="sxs-lookup"><span data-stu-id="04143-129">When a constructor calls a virtual method, it is possible that the constructor for the instance that invokes the method has not executed.</span></span>|
|[<span data-ttu-id="04143-130">CA2215: Los métodos Dispose deben llamar al método Dispose de la clase base</span><span class="sxs-lookup"><span data-stu-id="04143-130">CA2215: Dispose methods should call base class dispose</span></span>](ca2215.md)|<span data-ttu-id="04143-131">Si un tipo hereda de un tipo descartable, debe llamar al `Dispose` método del tipo base desde su propio `Dispose` método.</span><span class="sxs-lookup"><span data-stu-id="04143-131">If a type inherits from a disposable type, it must call the `Dispose` method of the base type from its own `Dispose` method.</span></span>|
|[<span data-ttu-id="04143-132">CA2216: Los tipos descartables deben declarar el finalizador</span><span class="sxs-lookup"><span data-stu-id="04143-132">CA2216: Disposable types should declare finalizer</span></span>](ca2216.md)|<span data-ttu-id="04143-133">Un tipo que implementa <xref:System.IDisposable?displayProperty=fullName> , y tiene campos que sugieren el uso de recursos no administrados, no implementa un finalizador tal como se describe en `Object.Finalize` .</span><span class="sxs-lookup"><span data-stu-id="04143-133">A type that implements <xref:System.IDisposable?displayProperty=fullName>, and has fields that suggest the use of unmanaged resources, does not implement a finalizer as described by `Object.Finalize`.</span></span>|
|[<span data-ttu-id="04143-134">CA2217: No marcar enumeraciones con FlagsAttribute</span><span class="sxs-lookup"><span data-stu-id="04143-134">CA2217: Do not mark enums with FlagsAttribute</span></span>](ca2217.md)|<span data-ttu-id="04143-135">Una enumeración visible externamente está marcada con `FlagsAttribute` y tiene uno o más valores que no son potencias de dos o una combinación de los demás valores definidos en la enumeración.</span><span class="sxs-lookup"><span data-stu-id="04143-135">An externally visible enumeration is marked with `FlagsAttribute`, and it has one or more values that are not powers of two or a combination of the other defined values on the enumeration.</span></span>|
|[<span data-ttu-id="04143-136">CA2218: Invalidar el método GetHashCode al invalidar el método Equals</span><span class="sxs-lookup"><span data-stu-id="04143-136">CA2218: Override GetHashCode on overriding Equals</span></span>](ca2218.md)|<span data-ttu-id="04143-137">Un tipo público invalida pero no <xref:System.Object.Equals%2A?displayProperty=fullName> invalida <xref:System.Object.GetHashCode%2A?displayProperty=fullName> .</span><span class="sxs-lookup"><span data-stu-id="04143-137">A public type overrides <xref:System.Object.Equals%2A?displayProperty=fullName> but does not override <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</span></span>|
|[<span data-ttu-id="04143-138">CA2219: No producir excepciones en cláusulas de excepción</span><span class="sxs-lookup"><span data-stu-id="04143-138">CA2219: Do not raise exceptions in exception clauses</span></span>](ca2219.md)|<span data-ttu-id="04143-139">Cuando se genera una excepción en una cláusula finally o fault, la nueva excepción oculta la excepción activa.</span><span class="sxs-lookup"><span data-stu-id="04143-139">When an exception is raised in a finally or fault clause, the new exception hides the active exception.</span></span> <span data-ttu-id="04143-140">Cuando se genera una excepción en una cláusula filter, el runtime la detecta automáticamente.</span><span class="sxs-lookup"><span data-stu-id="04143-140">When an exception is raised in a filter clause, the run time silently catches the exception.</span></span> <span data-ttu-id="04143-141">Esto hace que el error original sea difícil de detectar y depurar.</span><span class="sxs-lookup"><span data-stu-id="04143-141">This makes the original error hard to detect and debug.</span></span>|
|[<span data-ttu-id="04143-142">CA2224: Invalidar Equals al sobrecargar operadores de igualdad</span><span class="sxs-lookup"><span data-stu-id="04143-142">CA2224: Override equals on overloading operator equals</span></span>](ca2224.md)|<span data-ttu-id="04143-143">Un tipo público implementa el operador de igualdad pero no invalida <xref:System.Object.Equals%2A?displayProperty=fullName> .</span><span class="sxs-lookup"><span data-stu-id="04143-143">A public type implements the equality operator but doesn't override <xref:System.Object.Equals%2A?displayProperty=fullName>.</span></span>|
|[<span data-ttu-id="04143-144">CA2225: Las sobrecargas del operador tienen alternativas con nombre</span><span class="sxs-lookup"><span data-stu-id="04143-144">CA2225: Operator overloads have named alternates</span></span>](ca2225.md)|<span data-ttu-id="04143-145">Se detectó una sobrecarga del operador y no se encontró el método alternativo con el nombre esperado.</span><span class="sxs-lookup"><span data-stu-id="04143-145">An operator overload was detected, and the expected named alternative method was not found.</span></span> <span data-ttu-id="04143-146">El miembro alternativo con nombre proporciona acceso a la misma funcionalidad que el operador y se proporciona a los desarrolladores que programan en lenguajes que no admiten operadores sobrecargados.</span><span class="sxs-lookup"><span data-stu-id="04143-146">The named alternative member provides access to the same functionality as the operator, and is provided for developers who program in languages that do not support overloaded operators.</span></span>|
|[<span data-ttu-id="04143-147">CA2226: Los operadores deben tener sobrecargas simétricas</span><span class="sxs-lookup"><span data-stu-id="04143-147">CA2226: Operators should have symmetrical overloads</span></span>](ca2226.md)|<span data-ttu-id="04143-148">Un tipo implementa el operador de igualdad o desigualdad y no implementa el operador opuesto.</span><span class="sxs-lookup"><span data-stu-id="04143-148">A type implements the equality or inequality operator, and does not implement the opposite operator.</span></span>|
|[<span data-ttu-id="04143-149">CA2227: Las propiedades de la colección deben ser de solo lectura</span><span class="sxs-lookup"><span data-stu-id="04143-149">CA2227: Collection properties should be read only</span></span>](ca2227.md)|<span data-ttu-id="04143-150">Una propiedad de colección grabable permite al usuario reemplazar la colección por otra diferente.</span><span class="sxs-lookup"><span data-stu-id="04143-150">A writable collection property allows a user to replace the collection with a different collection.</span></span> <span data-ttu-id="04143-151">Una propiedad de sólo lectura impide que la colección se reemplace, pero sí permite establecer miembros individuales.</span><span class="sxs-lookup"><span data-stu-id="04143-151">A read-only property stops the collection from being replaced but still allows the individual members to be set.</span></span>|
|[<span data-ttu-id="04143-152">CA2229: Implementar constructores de serialización</span><span class="sxs-lookup"><span data-stu-id="04143-152">CA2229: Implement serialization constructors</span></span>](ca2229.md)|<span data-ttu-id="04143-153">Para corregir una infracción de esta regla, implemente el constructor de serialización.</span><span class="sxs-lookup"><span data-stu-id="04143-153">To fix a violation of this rule, implement the serialization constructor.</span></span> <span data-ttu-id="04143-154">Para una clase sellada, marque el constructor como privado; de lo contrario, márquelo como protegido.</span><span class="sxs-lookup"><span data-stu-id="04143-154">For a sealed class, make the constructor private; otherwise, make it protected.</span></span>|
|[<span data-ttu-id="04143-155">CA2231: Sobrecargar el operador equals al invalidar ValueType.Equals</span><span class="sxs-lookup"><span data-stu-id="04143-155">CA2231: Overload operator equals on overriding ValueType.Equals</span></span>](ca2231.md)|<span data-ttu-id="04143-156">Un tipo de valor invalida `Object.Equals` pero no implementa el operador de igualdad.</span><span class="sxs-lookup"><span data-stu-id="04143-156">A value type overrides `Object.Equals` but does not implement the equality operator.</span></span>|
|[<span data-ttu-id="04143-157">CA2234: Pasar objetos System.Uri en lugar de cadenas</span><span class="sxs-lookup"><span data-stu-id="04143-157">CA2234: Pass System.Uri objects instead of strings</span></span>](ca2234.md)|<span data-ttu-id="04143-158">Se realiza una llamada a un método que tiene un parámetro de cadena cuyo nombre contiene "uri", "URI", "urn", "URN", "url" o "URL".</span><span class="sxs-lookup"><span data-stu-id="04143-158">A call is made to a method that has a string parameter whose name contains "uri", "URI", "urn", "URN", "url", or "URL".</span></span>  <span data-ttu-id="04143-159">El tipo declarativo del método contiene una sobrecarga de método correspondiente que tiene un <xref:System.Uri?displayProperty=fullName> parámetro.</span><span class="sxs-lookup"><span data-stu-id="04143-159">The declaring type of the method contains a corresponding method overload that has a <xref:System.Uri?displayProperty=fullName> parameter.</span></span>|
|[<span data-ttu-id="04143-160">CA2235: Marcar todos los campos no serializables</span><span class="sxs-lookup"><span data-stu-id="04143-160">CA2235: Mark all non-serializable fields</span></span>](ca2235.md)|<span data-ttu-id="04143-161">Un campo de instancia de un tipo que no es serializable se declara en un tipo que es serializable.</span><span class="sxs-lookup"><span data-stu-id="04143-161">An instance field of a type that is not serializable is declared in a type that is serializable.</span></span>|
|[<span data-ttu-id="04143-162">CA2237: Marcar los tipos ISerializable con SerializableAttribute</span><span class="sxs-lookup"><span data-stu-id="04143-162">CA2237: Mark ISerializable types with SerializableAttribute</span></span>](ca2237.md)|<span data-ttu-id="04143-163">Para ser reconocibles por el Common Language Runtime como serializable, los tipos se deben marcar con el atributo SerializableAttribute incluso si el tipo utiliza una rutina de serialización personalizada a través de la implementación de la `ISerializable` interfaz.</span><span class="sxs-lookup"><span data-stu-id="04143-163">To be recognized by the common language runtime as serializable, types must be marked with the SerializableAttribute attribute even if the type uses a custom serialization routine through implementation of the `ISerializable` interface.</span></span>|
|[<span data-ttu-id="04143-164">CA2241: Proporcionar argumentos correctos a los métodos de formato</span><span class="sxs-lookup"><span data-stu-id="04143-164">CA2241: Provide correct arguments to formatting methods</span></span>](ca2241.md)|<span data-ttu-id="04143-165">El argumento de formato pasado a no <xref:System.String.Format%2A?displayProperty=nameWithType> contiene un elemento de formato que corresponda a cada argumento de objeto, o viceversa.</span><span class="sxs-lookup"><span data-stu-id="04143-165">The format argument passed to <xref:System.String.Format%2A?displayProperty=nameWithType> does not contain a format item that corresponds to each object argument, or vice versa.</span></span>|
|[<span data-ttu-id="04143-166">CA2242: Comprobar NaN correctamente</span><span class="sxs-lookup"><span data-stu-id="04143-166">CA2242: Test for NaN correctly</span></span>](ca2242.md)|<span data-ttu-id="04143-167">Esta expresión prueba un valor con `Single.Nan` o `Double.Nan` .</span><span class="sxs-lookup"><span data-stu-id="04143-167">This expression tests a value against `Single.Nan` or `Double.Nan`.</span></span> <span data-ttu-id="04143-168">Use `Single.IsNan(Single)` o `Double.IsNan(Double)` para probar el valor.</span><span class="sxs-lookup"><span data-stu-id="04143-168">Use `Single.IsNan(Single)` or `Double.IsNan(Double)` to test the value.</span></span>|
|[<span data-ttu-id="04143-169">CA2243: Los literales de cadena de atributo se deben analizar correctamente</span><span class="sxs-lookup"><span data-stu-id="04143-169">CA2243: Attribute string literals should parse correctly</span></span>](ca2243.md)|<span data-ttu-id="04143-170">El parámetro de literal de cadena de un atributo no se analiza correctamente para una dirección URL, un GUID o una versión.</span><span class="sxs-lookup"><span data-stu-id="04143-170">An attribute's string literal parameter does not parse correctly for a URL, a GUID, or a version.</span></span>|
|[<span data-ttu-id="04143-171">CA2244: No duplicar inicializaciones de elementos indexados</span><span class="sxs-lookup"><span data-stu-id="04143-171">CA2244: Do not duplicate indexed element initializations</span></span>](ca2244.md)|<span data-ttu-id="04143-172">Un inicializador de objeto tiene más de un inicializador de elemento indizado con el mismo índice de constante.</span><span class="sxs-lookup"><span data-stu-id="04143-172">An object initializer has more than one indexed element initializer with the same constant index.</span></span> <span data-ttu-id="04143-173">Todo menos el último inicializador son redundantes.</span><span class="sxs-lookup"><span data-stu-id="04143-173">All but the last initializer are redundant.</span></span>|
|[<span data-ttu-id="04143-174">CA2245: No asignar una propiedad a sí misma</span><span class="sxs-lookup"><span data-stu-id="04143-174">CA2245: Do not assign a property to itself</span></span>](ca2245.md)|<span data-ttu-id="04143-175">Una propiedad se asignó accidentalmente a sí misma.</span><span class="sxs-lookup"><span data-stu-id="04143-175">A property was accidentally assigned to itself.</span></span>|
|[<span data-ttu-id="04143-176">CA2246: No asignar un símbolo y su miembro en la misma instrucción</span><span class="sxs-lookup"><span data-stu-id="04143-176">CA2246: Do not assign a symbol and its member in the same statement</span></span>](ca2246.md)|<span data-ttu-id="04143-177">No se recomienda asignar un símbolo y su miembro, es decir, un campo o una propiedad, en la misma instrucción.</span><span class="sxs-lookup"><span data-stu-id="04143-177">Assigning a symbol and its member, that is, a field or a property, in the same statement is not recommended.</span></span> <span data-ttu-id="04143-178">No está claro si el acceso a miembros debía usar el valor anterior del símbolo antes de la asignación o el nuevo valor de la asignación en esta instrucción.</span><span class="sxs-lookup"><span data-stu-id="04143-178">It is not clear if the member access was intended to use the symbol's old value prior to the assignment or the new value from the assignment in this statement.</span></span>|
|[<span data-ttu-id="04143-179">CA2247: El argumento pasado al constructor TaskCompletionSource debe ser una enumeración TaskCreationOptions en lugar de TaskContinuationOptions</span><span class="sxs-lookup"><span data-stu-id="04143-179">CA2247: Argument passed to TaskCompletionSource constructor should be TaskCreationOptions enum instead of TaskContinuationOptions enum</span></span>](ca2247.md)|<span data-ttu-id="04143-180">TaskCompletionSource tiene constructores que toman un TaskCreationOptions que controla la tarea subyacente y constructores que toman el estado del objeto almacenado en la tarea.</span><span class="sxs-lookup"><span data-stu-id="04143-180">TaskCompletionSource has constructors that take TaskCreationOptions that control the underlying Task, and constructors that take object state that's stored in the task.</span></span>  <span data-ttu-id="04143-181">Pasar accidentalmente un TaskContinuationOptions en lugar de un TaskCreationOptions dará lugar a que la llamada trate las opciones como estado.</span><span class="sxs-lookup"><span data-stu-id="04143-181">Accidentally passing a TaskContinuationOptions instead of a TaskCreationOptions will result in the call treating the options as state.</span></span>|
|[<span data-ttu-id="04143-182">CA2248: proporcione el argumento ' ENUM ' correcto a ' enum. HasFlag '</span><span class="sxs-lookup"><span data-stu-id="04143-182">CA2248: Provide correct 'enum' argument to 'Enum.HasFlag'</span></span>](ca2248.md)|<span data-ttu-id="04143-183">El tipo de enumeración que se pasa como argumento a la `HasFlag` llamada al método es diferente del tipo de enumeración que realiza la llamada.</span><span class="sxs-lookup"><span data-stu-id="04143-183">The enum type passed as an argument to the `HasFlag` method call is different from the calling enum type.</span></span>|
|[<span data-ttu-id="04143-184">CA2249: Valorar la posibilidad de usar String.Contains en lugar de String.IndexOf</span><span class="sxs-lookup"><span data-stu-id="04143-184">CA2249: Consider using String.Contains instead of String.IndexOf</span></span>](ca2249.md)|<span data-ttu-id="04143-185">Las llamadas a `string.IndexOf` donde se utiliza el resultado para comprobar la presencia o la ausencia de una subcadena se pueden reemplazar por `string.Contains` .</span><span class="sxs-lookup"><span data-stu-id="04143-185">Calls to `string.IndexOf` where the result is used to check for the presence or absence of a substring can be replaced by `string.Contains`.</span></span>|
