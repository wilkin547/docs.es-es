---
title: Reglas de diseño (análisis de código)
description: Más información sobre las reglas de diseño de análisis de código.
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.designrules
helpviewer_keywords:
- design rules
- managed code analysis rules, design rules
- rules, design
author: gewarren
ms.author: gewarren
ms.openlocfilehash: c8c7d46b9271e33ab7ce3f989fae95bd57394ccd
ms.sourcegitcommit: 636af37170ae75a11c4f7d1ecd770820e7dfe7bd
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 10/07/2020
ms.locfileid: "96594425"
---
# <a name="design-rules"></a><span data-ttu-id="dc767-103">Reglas de diseño</span><span class="sxs-lookup"><span data-stu-id="dc767-103">Design rules</span></span>

<span data-ttu-id="dc767-104">Las reglas de diseño admiten el cumplimiento de las [directrices de diseño de .NET Framework](../../../standard/design-guidelines/index.md).</span><span class="sxs-lookup"><span data-stu-id="dc767-104">Design rules support adherence to the [.NET Framework Design Guidelines](../../../standard/design-guidelines/index.md).</span></span>

## <a name="in-this-section"></a><span data-ttu-id="dc767-105">En esta sección</span><span class="sxs-lookup"><span data-stu-id="dc767-105">In this section</span></span>

| <span data-ttu-id="dc767-106">Regla</span><span class="sxs-lookup"><span data-stu-id="dc767-106">Rule</span></span> | <span data-ttu-id="dc767-107">Descripción</span><span class="sxs-lookup"><span data-stu-id="dc767-107">Description</span></span> |
| - | - |
| [<span data-ttu-id="dc767-108">CA1000: No declarar miembros estáticos en tipos genéricos</span><span class="sxs-lookup"><span data-stu-id="dc767-108">CA1000: Do not declare static members on generic types</span></span>](ca1000.md) | <span data-ttu-id="dc767-109">Cuando se llama a un miembro estático de un tipo genérico, se debe especificar el argumento de tipo correspondiente a ese tipo.</span><span class="sxs-lookup"><span data-stu-id="dc767-109">When a static member of a generic type is called, the type argument must be specified for the type.</span></span> <span data-ttu-id="dc767-110">Cuando se llama a un miembro de instancia genérico que no admite la interferencia, se debe especificar el argumento de tipo para el miembro.</span><span class="sxs-lookup"><span data-stu-id="dc767-110">When a generic instance member that does not support inference is called, the type argument must be specified for the member.</span></span> <span data-ttu-id="dc767-111">En estos dos casos, la sintaxis para especificar el argumento de tipo es diferente y resulta fácil confundirse.</span><span class="sxs-lookup"><span data-stu-id="dc767-111">In these two cases, the syntax for specifying the type argument is different and easily confused.</span></span> |
| [<span data-ttu-id="dc767-112">CA1001: Los tipos que poseen campos descartables deben ser descartables</span><span class="sxs-lookup"><span data-stu-id="dc767-112">CA1001: Types that own disposable fields should be disposable</span></span>](ca1001.md) | <span data-ttu-id="dc767-113">Una clase declara e implementa un campo de instancia que es un tipo System. IDisposable y la clase no implementa IDisposable.</span><span class="sxs-lookup"><span data-stu-id="dc767-113">A class declares and implements an instance field that is a System.IDisposable type and the class does not implement IDisposable.</span></span> <span data-ttu-id="dc767-114">Una clase que declara un campo IDisposable posee indirectamente un recurso no administrado y debería implementar la interfaz IDisposable.</span><span class="sxs-lookup"><span data-stu-id="dc767-114">A class that declares an IDisposable field indirectly owns an unmanaged resource and should implement the IDisposable interface.</span></span> |
| [<span data-ttu-id="dc767-115">CA1002: No exponer listas genéricas</span><span class="sxs-lookup"><span data-stu-id="dc767-115">CA1002: Do not expose generic lists</span></span>](ca1002.md) | <span data-ttu-id="dc767-116">System. Collections. Generic. List< (of \<(T> ) >) es una colección genérica diseñada para el rendimiento, no para la herencia.</span><span class="sxs-lookup"><span data-stu-id="dc767-116">System.Collections.Generic.List<(Of \<(T>)>) is a generic collection that is designed for performance, not inheritance.</span></span> <span data-ttu-id="dc767-117">Por consiguiente, List no contiene ningún miembro virtual.</span><span class="sxs-lookup"><span data-stu-id="dc767-117">Therefore, List does not contain any virtual members.</span></span> <span data-ttu-id="dc767-118">En su lugar, se debe exponer las colecciones genéricas diseñadas para herencia.</span><span class="sxs-lookup"><span data-stu-id="dc767-118">The generic collections that are designed for inheritance should be exposed instead.</span></span> |
| [<span data-ttu-id="dc767-119">CA1003: Utilizar instancias genéricas de controlador de eventos</span><span class="sxs-lookup"><span data-stu-id="dc767-119">CA1003: Use generic event handler instances</span></span>](ca1003.md) | <span data-ttu-id="dc767-120">Un tipo contiene un delegado que devuelve void, cuya firma contiene dos parámetros (el primero es un objeto y el segundo un tipo que se puede asignar a EventArgs) y el ensamblado contenedor tiene como destino .NET Framework 2,0.</span><span class="sxs-lookup"><span data-stu-id="dc767-120">A type contains a delegate that returns void, whose signature contains two parameters (the first an object and the second a type that is assignable to EventArgs), and the containing assembly targets .NET Framework 2.0.</span></span> |
| [<span data-ttu-id="dc767-121">CA1005: Evitar los parámetros excesivos en tipos genéricos</span><span class="sxs-lookup"><span data-stu-id="dc767-121">CA1005: Avoid excessive parameters on generic types</span></span>](ca1005.md) | <span data-ttu-id="dc767-122">Cuantos más parámetros type contenga un tipo genérico, más difícil resulta saber y recordar qué representa cada uno de ellos.</span><span class="sxs-lookup"><span data-stu-id="dc767-122">The more type parameters a generic type contains, the more difficult it is to know and remember what each type parameter represents.</span></span> <span data-ttu-id="dc767-123">Normalmente, es obvio con un parámetro de tipo, como en la lista \<T> , y en algunos casos con dos parámetros de tipo, como en el diccionario \<TKey, TValue> .</span><span class="sxs-lookup"><span data-stu-id="dc767-123">It is usually obvious with one type parameter, as in List\<T>, and in certain cases with two type parameters, as in Dictionary\<TKey, TValue>.</span></span> <span data-ttu-id="dc767-124">Sin embargo, si hay más de dos parámetros de tipo, la dificultad se vuelve demasiado grande para la mayoría de los usuarios.</span><span class="sxs-lookup"><span data-stu-id="dc767-124">However, if more than two type parameters exist, the difficulty becomes too great for most users.</span></span> |
| [<span data-ttu-id="dc767-125">CA1008: Las enumeraciones deben tener un valor igual a cero</span><span class="sxs-lookup"><span data-stu-id="dc767-125">CA1008: Enums should have zero value</span></span>](ca1008.md) | <span data-ttu-id="dc767-126">El valor predeterminado de una enumeración no inicializada, igual que otros tipos de valor, es cero.</span><span class="sxs-lookup"><span data-stu-id="dc767-126">The default value of an uninitialized enumeration, just as other value types, is zero.</span></span> <span data-ttu-id="dc767-127">Una enumeración con atributos sin marcadores debe definir un miembro utilizando el valor cero para que el valor predeterminado sea un valor válido de la enumeración.</span><span class="sxs-lookup"><span data-stu-id="dc767-127">A nonflags attributed enumeration should define a member by using the value of zero so that the default value is a valid value of the enumeration.</span></span> <span data-ttu-id="dc767-128">Si una enumeración a la que se le haya aplicado el atributo FlagsAttribute define un miembro con valor cero, su nombre debe ser "None" para indicar que no se han establecido valores en la enumeración.</span><span class="sxs-lookup"><span data-stu-id="dc767-128">If an enumeration that has the FlagsAttribute attribute applied defines a zero-valued member, its name should be "None" to indicate that no values have been set in the enumeration.</span></span> |
| [<span data-ttu-id="dc767-129">CA1010: Las colecciones deben implementar la interfaz genérica</span><span class="sxs-lookup"><span data-stu-id="dc767-129">CA1010: Collections should implement generic interface</span></span>](ca1010.md) | <span data-ttu-id="dc767-130">Para ampliar la utilidad de una colección, implemente una de las interfaces de colección genéricas.</span><span class="sxs-lookup"><span data-stu-id="dc767-130">To broaden the usability of a collection, implement one of the generic collection interfaces.</span></span> <span data-ttu-id="dc767-131">Entonces podrá utilizar la colección para rellenar tipos de colecciones genéricas.</span><span class="sxs-lookup"><span data-stu-id="dc767-131">Then the collection can be used to populate generic collection types.</span></span> |
| [<span data-ttu-id="dc767-132">CA1012: Los tipos abstractos no deberían tener constructores</span><span class="sxs-lookup"><span data-stu-id="dc767-132">CA1012: Abstract types should not have constructors</span></span>](ca1012.md) | <span data-ttu-id="dc767-133">Los tipos derivados pueden llamar solo a los constructores de tipos abstractos.</span><span class="sxs-lookup"><span data-stu-id="dc767-133">Constructors on abstract types can be called only by derived types.</span></span> <span data-ttu-id="dc767-134">Puesto que los constructores públicos crean instancias de un tipo y no se pueden crear instancias de un tipo abstracto, no es correcto diseñar un tipo abstracto con un constructor público.</span><span class="sxs-lookup"><span data-stu-id="dc767-134">Because public constructors create instances of a type, and you cannot create instances of an abstract type, an abstract type that has a public constructor is incorrectly designed.</span></span> |
| [<span data-ttu-id="dc767-135">CA1014: Marcar los ensamblados con CLSCompliantAttribute</span><span class="sxs-lookup"><span data-stu-id="dc767-135">CA1014: Mark assemblies with CLSCompliantAttribute</span></span>](ca1014.md) | <span data-ttu-id="dc767-136">La Common Language Specification (CLS) define las restricciones de nomenclatura, los tipos de datos y las reglas a las que los ensamblados deben ajustarse si se van a utilizar los lenguajes de programación.</span><span class="sxs-lookup"><span data-stu-id="dc767-136">The Common Language Specification (CLS) defines naming restrictions, data types, and rules to which assemblies must conform if they will be used across programming languages.</span></span> <span data-ttu-id="dc767-137">Un buen diseño determina que todos los ensamblados indican explícitamente la conformidad con CLS mediante CLSCompliantAttribute.</span><span class="sxs-lookup"><span data-stu-id="dc767-137">Good design dictates that all assemblies explicitly indicate CLS compliance by using CLSCompliantAttribute.</span></span> <span data-ttu-id="dc767-138">Si este atributo no está presente en un ensamblado, el ensamblado no es conforme.</span><span class="sxs-lookup"><span data-stu-id="dc767-138">If this attribute is not present on an assembly, the assembly is not compliant.</span></span> |
| [<span data-ttu-id="dc767-139">CA1016: Marcar los ensamblados con AssemblyVersionAttribute</span><span class="sxs-lookup"><span data-stu-id="dc767-139">CA1016: Mark assemblies with AssemblyVersionAttribute</span></span>](ca1016.md) | <span data-ttu-id="dc767-140">.NET usa el número de versión para identificar de forma única un ensamblado, y para enlazar a los tipos de ensamblados con nombre seguro.</span><span class="sxs-lookup"><span data-stu-id="dc767-140">.NET uses the version number to uniquely identify an assembly, and to bind to types in strongly named assemblies.</span></span> <span data-ttu-id="dc767-141">El número de versión se utiliza junto con la versión y la directiva del fabricante.</span><span class="sxs-lookup"><span data-stu-id="dc767-141">The version number is used together with version and publisher policy.</span></span> <span data-ttu-id="dc767-142">De forma predeterminada, las aplicaciones sólo se ejecutan con la versión de ensamblado con la que se compilaron.</span><span class="sxs-lookup"><span data-stu-id="dc767-142">By default, applications run only with the assembly version with which they were built.</span></span> |
| [<span data-ttu-id="dc767-143">CA1017: Marcar los ensamblados con ComVisibleAttribute</span><span class="sxs-lookup"><span data-stu-id="dc767-143">CA1017: Mark assemblies with ComVisibleAttribute</span></span>](ca1017.md) | <span data-ttu-id="dc767-144">ComVisibleAttribute determina cómo obtienen acceso los clientes COM al código administrado.</span><span class="sxs-lookup"><span data-stu-id="dc767-144">ComVisibleAttribute determines how COM clients access managed code.</span></span> <span data-ttu-id="dc767-145">Los procedimientos de diseño recomendados dictan que los ensamblados indican explícitamente la visibilidad COM.</span><span class="sxs-lookup"><span data-stu-id="dc767-145">Good design dictates that assemblies explicitly indicate COM visibility.</span></span> <span data-ttu-id="dc767-146">La visibilidad COM se puede establecer para un ensamblado completo y, a continuación, se puede invalidar para los tipos individuales y los miembros de tipo.</span><span class="sxs-lookup"><span data-stu-id="dc767-146">COM visibility can be set for the whole assembly and then overridden for individual types and type members.</span></span> <span data-ttu-id="dc767-147">Si este atributo no está presente, el contenido del ensamblado es visible para los clientes COM.</span><span class="sxs-lookup"><span data-stu-id="dc767-147">If this attribute is not present, the contents of the assembly are visible to COM clients.</span></span> |
| [<span data-ttu-id="dc767-148">CA1018: Marcar atributos con AttributeUsageAttribute</span><span class="sxs-lookup"><span data-stu-id="dc767-148">CA1018: Mark attributes with AttributeUsageAttribute</span></span>](ca1018.md) | <span data-ttu-id="dc767-149">Cuando defina un atributo personalizado, márquelo utilizando AttributeUsageAttribute para indicar dónde se puede aplicar en el código fuente.</span><span class="sxs-lookup"><span data-stu-id="dc767-149">When you define a custom attribute, mark it by using AttributeUsageAttribute to indicate where in the source code the custom attribute can be applied.</span></span> <span data-ttu-id="dc767-150">El significado de un atributo y el uso que se le va a dar determinará sus ubicaciones válidas en código.</span><span class="sxs-lookup"><span data-stu-id="dc767-150">The meaning and intended usage of an attribute will determine its valid locations in code.</span></span> |
| [<span data-ttu-id="dc767-151">CA1019: Definir descriptores de acceso para los argumentos de atributo</span><span class="sxs-lookup"><span data-stu-id="dc767-151">CA1019: Define accessors for attribute arguments</span></span>](ca1019.md) | <span data-ttu-id="dc767-152">Los atributos pueden definir argumentos obligatorios que deben especificarse al aplicar el atributo a un destino.</span><span class="sxs-lookup"><span data-stu-id="dc767-152">Attributes can define mandatory arguments that must be specified when you apply the attribute to a target.</span></span> <span data-ttu-id="dc767-153">Éstos también se denominan argumentos posicionales porque se proporcionan para atribuir constructores como parámetros posicionales.</span><span class="sxs-lookup"><span data-stu-id="dc767-153">These are also known as positional arguments because they are supplied to attribute constructors as positional parameters.</span></span> <span data-ttu-id="dc767-154">Para cada argumento obligatorio, el atributo debe proporcionar también una propiedad de sólo lectura correspondiente de modo que el valor del argumento se pueda recuperar en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="dc767-154">For every mandatory argument, the attribute should also provide a corresponding read-only property so that the value of the argument can be retrieved at execution time.</span></span> <span data-ttu-id="dc767-155">Los atributos también pueden definir argumentos opcionales, que también se denominan argumentos con nombre.</span><span class="sxs-lookup"><span data-stu-id="dc767-155">Attributes can also define optional arguments, which are also known as named arguments.</span></span> <span data-ttu-id="dc767-156">Estos argumentos se proporcionan para atribuir constructores por nombre y deben tener una propiedad de lectura/escritura correspondiente.</span><span class="sxs-lookup"><span data-stu-id="dc767-156">These arguments are supplied to attribute constructors by name and should have a corresponding read/write property.</span></span> |
| [<span data-ttu-id="dc767-157">CA1021: Evitar los parámetros out</span><span class="sxs-lookup"><span data-stu-id="dc767-157">CA1021: Avoid out parameters</span></span>](ca1021.md) | <span data-ttu-id="dc767-158">Para pasar tipos por referencia (utilizando los parámetros out o ref) es necesario tener experiencia con punteros, saber la diferencia entre los tipos de referencia y los tipos de valor, y controlar métodos con varios valores devueltos.</span><span class="sxs-lookup"><span data-stu-id="dc767-158">Passing types by reference (using out or ref) requires experience with pointers, understanding how value types and reference types differ, and handling methods with multiple return values.</span></span> <span data-ttu-id="dc767-159">Además, no se suele saber qué diferencia hay entre los parámetros out y ref.</span><span class="sxs-lookup"><span data-stu-id="dc767-159">Also, the difference between out and ref parameters is not widely understood.</span></span> |
| [<span data-ttu-id="dc767-160">CA1024: Utilizar las propiedades donde corresponda</span><span class="sxs-lookup"><span data-stu-id="dc767-160">CA1024: Use properties where appropriate</span></span>](ca1024.md) | <span data-ttu-id="dc767-161">Un método público o protegido tiene un nombre que comienza por "Get", no toma ningún parámetro y devuelve un valor que no es una matriz.</span><span class="sxs-lookup"><span data-stu-id="dc767-161">A public or protected method has a name that starts with "Get", takes no parameters, and returns a value that is not an array.</span></span> <span data-ttu-id="dc767-162">El método podría ser un buen candidato para convertirse en propiedad.</span><span class="sxs-lookup"><span data-stu-id="dc767-162">The method might be a good candidate to become a property.</span></span> |
| [<span data-ttu-id="dc767-163">CA1027: Marcar enumeraciones con FlagsAttribute</span><span class="sxs-lookup"><span data-stu-id="dc767-163">CA1027: Mark enums with FlagsAttribute</span></span>](ca1027.md) | <span data-ttu-id="dc767-164">Una enumeración es un tipo de valor que define un conjunto de constantes con nombre relacionadas.</span><span class="sxs-lookup"><span data-stu-id="dc767-164">An enumeration is a value type that defines a set of related named constants.</span></span> <span data-ttu-id="dc767-165">Aplique FlagsAttribute a una enumeración cuando se pueda combinar con sentido sus constantes con nombre.</span><span class="sxs-lookup"><span data-stu-id="dc767-165">Apply FlagsAttribute to an enumeration when its named constants can be meaningfully combined.</span></span> |
| [<span data-ttu-id="dc767-166">CA1028: El almacenamiento de la enumeración debe ser de tipo Int32</span><span class="sxs-lookup"><span data-stu-id="dc767-166">CA1028: Enum storage should be Int32</span></span>](ca1028.md) | <span data-ttu-id="dc767-167">Una enumeración es un tipo de valor que define un conjunto de constantes con nombre relacionadas.</span><span class="sxs-lookup"><span data-stu-id="dc767-167">An enumeration is a value type that defines a set of related named constants.</span></span> <span data-ttu-id="dc767-168">De manera predeterminada, el tipo de datos System.Int32 se utiliza para almacenar el valor constante.</span><span class="sxs-lookup"><span data-stu-id="dc767-168">By default, the System.Int32 data type is used to store the constant value.</span></span> <span data-ttu-id="dc767-169">Aunque puede cambiar este tipo subyacente, no es necesario ni se recomienda para la mayoría de los escenarios.</span><span class="sxs-lookup"><span data-stu-id="dc767-169">Even though you can change this underlying type, it is not required or recommended for most scenarios.</span></span> |
| [<span data-ttu-id="dc767-170">CA1030: Utilizar eventos cuando sea apropiado</span><span class="sxs-lookup"><span data-stu-id="dc767-170">CA1030: Use events where appropriate</span></span>](ca1030.md) | <span data-ttu-id="dc767-171">Esta regla detecta métodos que tienen nombres que normalmente se utilizarían para eventos.</span><span class="sxs-lookup"><span data-stu-id="dc767-171">This rule detects methods that have names that ordinarily would be used for events.</span></span> <span data-ttu-id="dc767-172">Si se llama a un método en respuesta a un cambio de estado claramente definido, un controlador de eventos debe invocar al método.</span><span class="sxs-lookup"><span data-stu-id="dc767-172">If a method is called in response to a clearly defined state change, the method should be invoked by an event handler.</span></span> <span data-ttu-id="dc767-173">Los objetos que llaman al método deben provocar eventos en lugar de llamar directamente al método.</span><span class="sxs-lookup"><span data-stu-id="dc767-173">Objects that call the method should raise events instead of calling the method directly.</span></span> |
| [<span data-ttu-id="dc767-174">CA1031: No capturar los tipos de excepción general</span><span class="sxs-lookup"><span data-stu-id="dc767-174">CA1031: Do not catch general exception types</span></span>](ca1031.md) | <span data-ttu-id="dc767-175">No se deben capturar excepciones generales.</span><span class="sxs-lookup"><span data-stu-id="dc767-175">General exceptions should not be caught.</span></span> <span data-ttu-id="dc767-176">Detecte una excepción más específica o vuelva a producir la excepción general como última instrucción del bloque catch.</span><span class="sxs-lookup"><span data-stu-id="dc767-176">Catch a more-specific exception, or rethrow the general exception as the last statement in the catch block.</span></span> |
| [<span data-ttu-id="dc767-177">CA1032: Implementar constructores de excepción estándar</span><span class="sxs-lookup"><span data-stu-id="dc767-177">CA1032: Implement standard exception constructors</span></span>](ca1032.md) | <span data-ttu-id="dc767-178">El error al proporcionar el conjunto completo de constructores puede dificultar el control correcto de las excepciones.</span><span class="sxs-lookup"><span data-stu-id="dc767-178">Failure to provide the full set of constructors can make it difficult to correctly handle exceptions.</span></span> |
| [<span data-ttu-id="dc767-179">CA1033: Los tipos secundarios deben poder llamar a los métodos de interfaz</span><span class="sxs-lookup"><span data-stu-id="dc767-179">CA1033: Interface methods should be callable by child types</span></span>](ca1033.md) | <span data-ttu-id="dc767-180">Un tipo no sellado visible externamente proporciona un método explícito de implementación de una interfaz pública pero no proporciona un método visible externamente alternativo con el mismo nombre.</span><span class="sxs-lookup"><span data-stu-id="dc767-180">An unsealed externally visible type provides an explicit method implementation of a public interface and does not provide an alternative externally visible method that has the same name.</span></span> |
| [<span data-ttu-id="dc767-181">CA1034: Los tipos anidados no deben ser visibles</span><span class="sxs-lookup"><span data-stu-id="dc767-181">CA1034: Nested types should not be visible</span></span>](ca1034.md) | <span data-ttu-id="dc767-182">Los tipos anidados son tipos declarados en el ámbito de otro tipo.</span><span class="sxs-lookup"><span data-stu-id="dc767-182">A nested type is a type that is declared in the scope of another type.</span></span> <span data-ttu-id="dc767-183">Los tipos anidados son útiles para encapsular los detalles de la implementación privada del tipo contenido.</span><span class="sxs-lookup"><span data-stu-id="dc767-183">Nested types are useful to encapsulate private implementation details of the containing type.</span></span> <span data-ttu-id="dc767-184">Los tipos anidados, utilizados para este propósito, no deben ser visibles externamente.</span><span class="sxs-lookup"><span data-stu-id="dc767-184">Used for this purpose, nested types should not be externally visible.</span></span> |
| [<span data-ttu-id="dc767-185">CA1036: Invalidar métodos en tipos comparables</span><span class="sxs-lookup"><span data-stu-id="dc767-185">CA1036: Override methods on comparable types</span></span>](ca1036.md) | <span data-ttu-id="dc767-186">Un tipo público o protegido implementa la interfaz System.IComparable.</span><span class="sxs-lookup"><span data-stu-id="dc767-186">A public or protected type implements the System.IComparable interface.</span></span> <span data-ttu-id="dc767-187">No invalida Object.Equals ni sobrecarga al operador específico del lenguaje para la igualdad, desigualdad, menor que o mayor que.</span><span class="sxs-lookup"><span data-stu-id="dc767-187">It does not override Object.Equals nor does it overload the language-specific operator for equality, inequality, less than, or greater than.</span></span> |
| [<span data-ttu-id="dc767-188">CA1040: Evitar las interfaces vacías</span><span class="sxs-lookup"><span data-stu-id="dc767-188">CA1040: Avoid empty interfaces</span></span>](ca1040.md) | <span data-ttu-id="dc767-189">Las interfaces definen miembros que proporcionan un comportamiento o acuerdo de uso.</span><span class="sxs-lookup"><span data-stu-id="dc767-189">Interfaces define members that provide a behavior or usage contract.</span></span> <span data-ttu-id="dc767-190">Cualquier tipo puede adoptar la funcionalidad descrita por la interfaz sin tener en cuenta dónde aparece el tipo en la jerarquía de herencia.</span><span class="sxs-lookup"><span data-stu-id="dc767-190">The functionality that is described by the interface can be adopted by any type, regardless of where the type appears in the inheritance hierarchy.</span></span> <span data-ttu-id="dc767-191">Un tipo implementa una interfaz proporcionando las implementaciones para los miembros de la interfaz.</span><span class="sxs-lookup"><span data-stu-id="dc767-191">A type implements an interface by providing implementations for the members of the interface.</span></span> <span data-ttu-id="dc767-192">Una interfaz vacía no define ningún miembro; por consiguiente, no define ningún contrato que se pueda implementar.</span><span class="sxs-lookup"><span data-stu-id="dc767-192">An empty interface does not define any members; therefore, it does not define a contract that can be implemented.</span></span> |
| [<span data-ttu-id="dc767-193">CA1041: Proporcionar un mensaje ObsoleteAttribute</span><span class="sxs-lookup"><span data-stu-id="dc767-193">CA1041: Provide ObsoleteAttribute message</span></span>](ca1041.md) | <span data-ttu-id="dc767-194">Un tipo o miembro se marca con un atributo System.ObsoleteAttribute para el que no se ha especificado su propiedad ObsoleteAttribute.Message.</span><span class="sxs-lookup"><span data-stu-id="dc767-194">A type or member is marked by using a System.ObsoleteAttribute attribute that does not have its ObsoleteAttribute.Message property specified.</span></span> <span data-ttu-id="dc767-195">Cuando se compila un tipo o miembro marcado con ObsoleteAttribute, se muestra la propiedad Message del atributo, que proporciona la información de usuario sobre el tipo o miembro obsoleto.</span><span class="sxs-lookup"><span data-stu-id="dc767-195">When a type or member that is marked by using ObsoleteAttribute is compiled, the Message property of the attribute is displayed, which gives the user information about the obsolete type or member.</span></span> |
| [<span data-ttu-id="dc767-196">CA1043: Utilizar un argumento integral o de cadena en indizadores</span><span class="sxs-lookup"><span data-stu-id="dc767-196">CA1043: Use integral or string argument for indexers</span></span>](ca1043.md) | <span data-ttu-id="dc767-197">Los indizadores (es decir, las propiedades indizadas) deben utilizar tipos enteros o de cadena para el índice.</span><span class="sxs-lookup"><span data-stu-id="dc767-197">Indexers (that is, indexed properties) should use integral or string types for the index.</span></span> <span data-ttu-id="dc767-198">Estos tipos se utilizan normalmente para indizar las estructuras de datos y aumentan la utilidad de la biblioteca.</span><span class="sxs-lookup"><span data-stu-id="dc767-198">These types are typically used for indexing data structures and they increase the usability of the library.</span></span> <span data-ttu-id="dc767-199">El uso del tipo Object debería limitarse a los casos en los que el tipo entero o de cadena no se puede especificar en tiempo de diseño.</span><span class="sxs-lookup"><span data-stu-id="dc767-199">Use of the Object type should be restricted to those cases where the specific integral or string type cannot be specified at design time.</span></span> |
| [<span data-ttu-id="dc767-200">CA1044: Las propiedades no deben ser de solo escritura</span><span class="sxs-lookup"><span data-stu-id="dc767-200">CA1044: Properties should not be write only</span></span>](ca1044.md) | <span data-ttu-id="dc767-201">Aunque es aceptable y a menudo necesario tener una propiedad de solo lectura, las directrices de diseño prohíben el uso de propiedades de solo escritura.</span><span class="sxs-lookup"><span data-stu-id="dc767-201">Although it is acceptable and often necessary to have a read-only property, the design guidelines prohibit the use of write-only properties.</span></span> <span data-ttu-id="dc767-202">Esto es porque si se deja que un usuario configure un valor, y a continuación se impide que el usuario vea ese valor, no proporciona ninguna seguridad.</span><span class="sxs-lookup"><span data-stu-id="dc767-202">This is because letting a user set a value, and then preventing the user from viewing that value, does not provide any security.</span></span> <span data-ttu-id="dc767-203">Además, sin acceso de lectura, no se puede ver el estado de los objetos compartidos, lo que limita su utilidad.</span><span class="sxs-lookup"><span data-stu-id="dc767-203">Also, without read access, the state of shared objects cannot be viewed, which limits their usefulness.</span></span> |
| [<span data-ttu-id="dc767-204">CA1045: No pasar tipos por referencia</span><span class="sxs-lookup"><span data-stu-id="dc767-204">CA1045: Do not pass types by reference</span></span>](ca1045.md) | <span data-ttu-id="dc767-205">Para pasar tipos por referencia (utilizando los parámetros out o ref) es necesario tener experiencia con punteros, saber la diferencia entre los tipos de referencia y los tipos de valor, y controlar métodos con varios valores devueltos.</span><span class="sxs-lookup"><span data-stu-id="dc767-205">Passing types by reference (using out or ref) requires experience with pointers, understanding how value types and reference types differ, and handling methods with multiple return values.</span></span> <span data-ttu-id="dc767-206">Los arquitectos de bibliotecas cuyos diseños están destinados a los usuarios en general no deben esperar que los usuarios dominen el uso de los parámetros out o ref.</span><span class="sxs-lookup"><span data-stu-id="dc767-206">Library architects who design for a general audience should not expect users to master working with out or ref parameters.</span></span> |
| [<span data-ttu-id="dc767-207">CA1046: No sobrecargar el operador de igualdad en los tipos de referencia</span><span class="sxs-lookup"><span data-stu-id="dc767-207">CA1046: Do not overload operator equals on reference types</span></span>](ca1046.md) | <span data-ttu-id="dc767-208">Para los tipos de referencia, la implementación predeterminada del operador de igualdad casi siempre es correcta.</span><span class="sxs-lookup"><span data-stu-id="dc767-208">For reference types, the default implementation of the equality operator is almost always correct.</span></span> <span data-ttu-id="dc767-209">De manera predeterminada, dos referencias son iguales sólo si señalan al mismo objeto.</span><span class="sxs-lookup"><span data-stu-id="dc767-209">By default, two references are equal only if they point to the same object.</span></span> |
| [<span data-ttu-id="dc767-210">CA1047: No declarar miembros protegidos en tipos sellados</span><span class="sxs-lookup"><span data-stu-id="dc767-210">CA1047: Do not declare protected members in sealed types</span></span>](ca1047.md) | <span data-ttu-id="dc767-211">Los tipos declaran miembros protegidos para que los tipos heredados puedan obtener acceso o reemplazar el miembro.</span><span class="sxs-lookup"><span data-stu-id="dc767-211">Types declare protected members so that inheriting types can access or override the member.</span></span> <span data-ttu-id="dc767-212">Por definición, no se puede heredar de tipos sealed, lo que significa que no se puede llamar a los métodos protegidos en tipos sealed.</span><span class="sxs-lookup"><span data-stu-id="dc767-212">By definition, sealed types cannot be inherited, which means that protected methods on sealed types cannot be called.</span></span> |
| [<span data-ttu-id="dc767-213">CA1050: Declarar tipos en espacios de nombres</span><span class="sxs-lookup"><span data-stu-id="dc767-213">CA1050: Declare types in namespaces</span></span>](ca1050.md) | <span data-ttu-id="dc767-214">Los tipos se declaran dentro de los espacios de nombres para evitar conflictos de nombre y como una forma de organizar los tipos relacionados en una jerarquía de objetos.</span><span class="sxs-lookup"><span data-stu-id="dc767-214">Types are declared in namespaces to prevent name collisions and as a way to organize related types in an object hierarchy.</span></span> |
| [<span data-ttu-id="dc767-215">CA1051: No declarar campos de instancia visibles</span><span class="sxs-lookup"><span data-stu-id="dc767-215">CA1051: Do not declare visible instance fields</span></span>](ca1051.md) | <span data-ttu-id="dc767-216">El uso principal de un campo debe ser como un detalle de implementación.</span><span class="sxs-lookup"><span data-stu-id="dc767-216">The primary use of a field should be as an implementation detail.</span></span> <span data-ttu-id="dc767-217">Los campos deben ser privados o internos y deben exponerse utilizando propiedades.</span><span class="sxs-lookup"><span data-stu-id="dc767-217">Fields should be private or internal and should be exposed by using properties.</span></span> |
| [<span data-ttu-id="dc767-218">CA1052: Los tipos titulares estáticos deben estar sellados</span><span class="sxs-lookup"><span data-stu-id="dc767-218">CA1052: Static holder types should be sealed</span></span>](ca1052.md) | <span data-ttu-id="dc767-219">Un tipo público o protegido solo contiene miembros estáticos y no se declara mediante el modificador Sealed (C#) o NotInheritable (Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="dc767-219">A public or protected type contains only static members and is not declared by using the sealed (C#) or NotInheritable (Visual Basic) modifier.</span></span> <span data-ttu-id="dc767-220">Un tipo que no está diseñado para heredarse debería marcarse con el modificador sealed para impedir su uso como tipo base.</span><span class="sxs-lookup"><span data-stu-id="dc767-220">A type that is not meant to be inherited should be marked by using the sealed modifier to prevent its use as a base type.</span></span> |
| [<span data-ttu-id="dc767-221">CA1053: Los tipos titulares estáticos no deben tener constructores</span><span class="sxs-lookup"><span data-stu-id="dc767-221">CA1053: Static holder types should not have constructors</span></span>](ca1053.md) | <span data-ttu-id="dc767-222">Un tipo público o público anidado declara sólo miembros estáticos y tiene un constructor predeterminado público o protegido.</span><span class="sxs-lookup"><span data-stu-id="dc767-222">A public or nested public type declares only static members and has a public or protected default constructor.</span></span> <span data-ttu-id="dc767-223">El constructor no es necesario puesto que al llamar a los miembros estáticos no se requiere una instancia del tipo.</span><span class="sxs-lookup"><span data-stu-id="dc767-223">The constructor is unnecessary because calling static members does not require an instance of the type.</span></span> <span data-ttu-id="dc767-224">La sobrecarga de la cadena debería llamar a la sobrecarga del identificador URI utilizando el argumento string por motivos de seguridad y protección.</span><span class="sxs-lookup"><span data-stu-id="dc767-224">The string overload should call the uniform resource identifier (URI) overload by using the string argument for safety and security.</span></span> |
| [<span data-ttu-id="dc767-225">CA1054: Los parámetros de URI no deben ser cadenas</span><span class="sxs-lookup"><span data-stu-id="dc767-225">CA1054: URI parameters should not be strings</span></span>](ca1054.md) | <span data-ttu-id="dc767-226">Si un método toma una representación de cadena de un identificador URI, debe proporcionarse la sobrecarga correspondiente que toma una instancia de la clase URI, que proporciona estos servicios de forma segura.</span><span class="sxs-lookup"><span data-stu-id="dc767-226">If a method takes a string representation of a URI, a corresponding overload should be provided that takes an instance of the URI class, which provides these services in a safe and secure manner.</span></span> |
| [<span data-ttu-id="dc767-227">CA1055: Los valores devueltos URI no deben ser cadenas</span><span class="sxs-lookup"><span data-stu-id="dc767-227">CA1055: URI return values should not be strings</span></span>](ca1055.md) | <span data-ttu-id="dc767-228">Esta regla supone que el método devuelve un URI.</span><span class="sxs-lookup"><span data-stu-id="dc767-228">This rule assumes that the method returns a URI.</span></span> <span data-ttu-id="dc767-229">Las representaciones de cadena de identificadores URI tienen tendencia a analizar y codificar errores, por lo que pueden crear puntos vulnerables en la seguridad.</span><span class="sxs-lookup"><span data-stu-id="dc767-229">A string representation of a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities.</span></span> <span data-ttu-id="dc767-230">La clase System.Uri proporciona estos servicios de una manera segura.</span><span class="sxs-lookup"><span data-stu-id="dc767-230">The System.Uri class provides these services in a safe and secure manner.</span></span> |
| [<span data-ttu-id="dc767-231">CA1056: Las propiedades URI no deben ser cadenas</span><span class="sxs-lookup"><span data-stu-id="dc767-231">CA1056: URI properties should not be strings</span></span>](ca1056.md) | <span data-ttu-id="dc767-232">Esta regla supone que la propiedad representa un identificador URI.</span><span class="sxs-lookup"><span data-stu-id="dc767-232">This rule assumes that the property represents a URI.</span></span> <span data-ttu-id="dc767-233">Las representaciones de cadena de identificadores URI tienen tendencia a analizar y codificar errores, por lo que pueden crear puntos vulnerables en la seguridad.</span><span class="sxs-lookup"><span data-stu-id="dc767-233">A string representation of a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities.</span></span> <span data-ttu-id="dc767-234">La clase System.Uri proporciona estos servicios de una manera segura.</span><span class="sxs-lookup"><span data-stu-id="dc767-234">The System.Uri class provides these services in a safe and secure manner.</span></span> |
| [<span data-ttu-id="dc767-235">CA1058: Los tipos no deben ampliar ciertos tipos base</span><span class="sxs-lookup"><span data-stu-id="dc767-235">CA1058: Types should not extend certain base types</span></span>](ca1058.md) | <span data-ttu-id="dc767-236">Un tipo visible externamente extiende algunos tipos base.</span><span class="sxs-lookup"><span data-stu-id="dc767-236">An externally visible type extends certain base types.</span></span> <span data-ttu-id="dc767-237">Utilice una de las alternativas.</span><span class="sxs-lookup"><span data-stu-id="dc767-237">Use one of the alternatives.</span></span> |
| [<span data-ttu-id="dc767-238">CA1060: mueve P/Invoke a la clase NativeMethods</span><span class="sxs-lookup"><span data-stu-id="dc767-238">CA1060: Move P/Invokes to NativeMethods class</span></span>](ca1060.md) | <span data-ttu-id="dc767-239">Los métodos de invocación de plataforma, como los marcados con los <xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=fullName> métodos o definidos mediante la palabra clave declare en Visual Basic, tienen acceso al código no administrado.</span><span class="sxs-lookup"><span data-stu-id="dc767-239">Platform Invocation methods, such as those marked with the <xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=fullName> or methods defined by using the Declare keyword in Visual Basic, access unmanaged code.</span></span> <span data-ttu-id="dc767-240">Estos métodos deben ser de la clase NativeMethods, UnsafeNativeMethods o SafeNativeMethods.</span><span class="sxs-lookup"><span data-stu-id="dc767-240">These methods should be of the NativeMethods, SafeNativeMethods, or UnsafeNativeMethods class.</span></span> |
| [<span data-ttu-id="dc767-241">CA1061: No ocultar métodos de clase base</span><span class="sxs-lookup"><span data-stu-id="dc767-241">CA1061: Do not hide base class methods</span></span>](ca1061.md) | <span data-ttu-id="dc767-242">Un método de un tipo base está oculto por un método del mismo nombre en un tipo derivado cuando la firma del parámetro del método derivado solo se diferencia por tipos derivados de manera más débil que los tipos correspondientes de la firma del parámetro del método base.</span><span class="sxs-lookup"><span data-stu-id="dc767-242">A method in a base type is hidden by an identically named method in a derived type, when the parameter signature of the derived method differs only by types that are more weakly derived than the corresponding types in the parameter signature of the base method.</span></span> |
| [<span data-ttu-id="dc767-243">CA1062: Validar argumentos de métodos públicos</span><span class="sxs-lookup"><span data-stu-id="dc767-243">CA1062: Validate arguments of public methods</span></span>](ca1062.md) | <span data-ttu-id="dc767-244">Todos los argumentos de referencia pasados a métodos visibles externamente se deben comprobar para ver si son null.</span><span class="sxs-lookup"><span data-stu-id="dc767-244">All reference arguments that are passed to externally visible methods should be checked against null.</span></span> |
| [<span data-ttu-id="dc767-245">CA1063: Implementar IDisposable correctamente</span><span class="sxs-lookup"><span data-stu-id="dc767-245">CA1063: Implement IDisposable correctly</span></span>](ca1063.md) | <span data-ttu-id="dc767-246">Todos los tipos IDisposable deben implementar el modelo de Dispose correctamente.</span><span class="sxs-lookup"><span data-stu-id="dc767-246">All IDisposable types should implement the Dispose pattern correctly.</span></span> |
| [<span data-ttu-id="dc767-247">CA1064: Las excepciones deben ser públicas</span><span class="sxs-lookup"><span data-stu-id="dc767-247">CA1064: Exceptions should be public</span></span>](ca1064.md) | <span data-ttu-id="dc767-248">Una excepción interna solo se ve dentro de su propio ámbito interno.</span><span class="sxs-lookup"><span data-stu-id="dc767-248">An internal exception is visible only inside its own internal scope.</span></span> <span data-ttu-id="dc767-249">Cuando la excepción esté fuera del ámbito interno, sólo se podrá usar la excepción base para detectarla.</span><span class="sxs-lookup"><span data-stu-id="dc767-249">After the exception falls outside the internal scope, only the base exception can be used to catch the exception.</span></span> <span data-ttu-id="dc767-250">Si la excepción interna se hereda de <xref:System.Exception?displayProperty=fullName> , <xref:System.SystemException?displayProperty=fullName> o <xref:System.ApplicationException?displayProperty=fullName> , el código externo no tendrá información suficiente para saber qué hacer con la excepción.</span><span class="sxs-lookup"><span data-stu-id="dc767-250">If the internal exception is inherited from <xref:System.Exception?displayProperty=fullName>, <xref:System.SystemException?displayProperty=fullName>, or <xref:System.ApplicationException?displayProperty=fullName>, the external code will not have sufficient information to know what to do with the exception.</span></span> |
| [<span data-ttu-id="dc767-251">CA1065: No producir excepciones en ubicaciones inesperadas</span><span class="sxs-lookup"><span data-stu-id="dc767-251">CA1065: Do not raise exceptions in unexpected locations</span></span>](ca1065.md) | <span data-ttu-id="dc767-252">Un método que no se espera que produzca excepciones inicia una excepción.</span><span class="sxs-lookup"><span data-stu-id="dc767-252">A method that is not expected to throw exceptions throws an exception.</span></span> |
| [<span data-ttu-id="dc767-253">CA1066: Implementar IEquatable al invalidar Equals</span><span class="sxs-lookup"><span data-stu-id="dc767-253">CA1066: Implement IEquatable when overriding Equals</span></span>](ca1066.md) | <span data-ttu-id="dc767-254">Un tipo de valor invalida el <xref:System.Object.Equals%2A> método, pero no implementa <xref:System.IEquatable%601> .</span><span class="sxs-lookup"><span data-stu-id="dc767-254">A value type overrides <xref:System.Object.Equals%2A> method, but does not implement <xref:System.IEquatable%601>.</span></span> |
| [<span data-ttu-id="dc767-255">CA1067: Invalidar Equals al implementar IEquatable</span><span class="sxs-lookup"><span data-stu-id="dc767-255">CA1067: Override Equals when implementing IEquatable</span></span>](ca1067.md) | <span data-ttu-id="dc767-256">Un tipo implementa <xref:System.IEquatable%601> , pero no invalida el <xref:System.Object.Equals%2A> método.</span><span class="sxs-lookup"><span data-stu-id="dc767-256">A type implements <xref:System.IEquatable%601>, but does not override <xref:System.Object.Equals%2A> method.</span></span> |
| [<span data-ttu-id="dc767-257">CA1068: Los parámetros CancellationToken deben aparecer en último lugar</span><span class="sxs-lookup"><span data-stu-id="dc767-257">CA1068: CancellationToken parameters must come last</span></span>](ca1068.md) | <span data-ttu-id="dc767-258">Un método tiene un parámetro CancellationToken que no es el último parámetro.</span><span class="sxs-lookup"><span data-stu-id="dc767-258">A method has a CancellationToken parameter that is not the last parameter.</span></span> |
| [<span data-ttu-id="dc767-259">CA1069: Los enumeradores no deben tener valores duplicados</span><span class="sxs-lookup"><span data-stu-id="dc767-259">CA1069: Enums should not have duplicate values</span></span>](ca1069.md) | <span data-ttu-id="dc767-260">Una enumeración tiene varios miembros a los que se les asigna explícitamente el mismo valor constante.</span><span class="sxs-lookup"><span data-stu-id="dc767-260">An enumeration has multiple members which are explicitly assigned the same constant value.</span></span> |
| [<span data-ttu-id="dc767-261">CA1070: No declarar los campos de eventos como virtuales</span><span class="sxs-lookup"><span data-stu-id="dc767-261">CA1070: Do not declare event fields as virtual</span></span>](ca1070.md) | <span data-ttu-id="dc767-262">Un [evento similar](../../../csharp/event-pattern.md#defining-and-raising-field-like-events) a un campo se declaró como virtual.</span><span class="sxs-lookup"><span data-stu-id="dc767-262">A [field-like event](../../../csharp/event-pattern.md#defining-and-raising-field-like-events) was declared as virtual.</span></span> |
