---
title: Reglas de diseño (análisis de código)
description: Más información sobre las reglas de diseño de análisis de código.
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.designrules
helpviewer_keywords:
- design rules
- managed code analysis rules, design rules
- rules, design
author: gewarren
ms.author: gewarren
ms.openlocfilehash: 548e0eaaa6239a9b9ee6a08677cd720710bb48c2
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 02/06/2021
ms.locfileid: "99714136"
---
# <a name="design-rules"></a>Reglas de diseño

Las reglas de diseño admiten el cumplimiento de las [directrices de diseño de .NET Framework](../../../standard/design-guidelines/index.md).

## <a name="in-this-section"></a>En esta sección

| Regla | Descripción |
| - | - |
| [CA1000: No declarar miembros estáticos en tipos genéricos](ca1000.md) | Cuando se llama a un miembro estático de un tipo genérico, se debe especificar el argumento de tipo correspondiente a ese tipo. Cuando se llama a un miembro de instancia genérico que no admite la interferencia, se debe especificar el argumento de tipo para el miembro. En estos dos casos, la sintaxis para especificar el argumento de tipo es diferente y resulta fácil confundirse. |
| [CA1001: Los tipos que poseen campos descartables deben ser descartables](ca1001.md) | Una clase declara e implementa un campo de instancia que es un tipo System. IDisposable y la clase no implementa IDisposable. Una clase que declara un campo IDisposable posee indirectamente un recurso no administrado y debería implementar la interfaz IDisposable. |
| [CA1002: No exponer listas genéricas](ca1002.md) | System. Collections. Generic. List< (of \<(T> ) >) es una colección genérica diseñada para el rendimiento, no para la herencia. Por consiguiente, List no contiene ningún miembro virtual. En su lugar, se debe exponer las colecciones genéricas diseñadas para herencia. |
| [CA1003: Utilizar instancias genéricas de controlador de eventos](ca1003.md) | Un tipo contiene un delegado que devuelve void, cuya firma contiene dos parámetros (el primero es un objeto y el segundo un tipo que se puede asignar a EventArgs) y el ensamblado contenedor tiene como destino .NET Framework 2,0. |
| [CA1005: Evitar los parámetros excesivos en tipos genéricos](ca1005.md) | Cuantos más parámetros type contenga un tipo genérico, más difícil resulta saber y recordar qué representa cada uno de ellos. Normalmente, es obvio con un parámetro de tipo, como en la lista \<T> , y en algunos casos con dos parámetros de tipo, como en el diccionario \<TKey, TValue> . Sin embargo, si hay más de dos parámetros de tipo, la dificultad se vuelve demasiado grande para la mayoría de los usuarios. |
| [CA1008: Las enumeraciones deben tener un valor igual a cero](ca1008.md) | El valor predeterminado de una enumeración no inicializada, igual que otros tipos de valor, es cero. Una enumeración con atributos sin marcadores debe definir un miembro utilizando el valor cero para que el valor predeterminado sea un valor válido de la enumeración. Si una enumeración a la que se le haya aplicado el atributo FlagsAttribute define un miembro con valor cero, su nombre debe ser "None" para indicar que no se han establecido valores en la enumeración. |
| [CA1010: Las colecciones deben implementar la interfaz genérica](ca1010.md) | Para ampliar la utilidad de una colección, implemente una de las interfaces de colección genéricas. Entonces podrá utilizar la colección para rellenar tipos de colecciones genéricas. |
| [CA1012: Los tipos abstractos no deberían tener constructores](ca1012.md) | Los tipos derivados pueden llamar solo a los constructores de tipos abstractos. Puesto que los constructores públicos crean instancias de un tipo y no se pueden crear instancias de un tipo abstracto, no es correcto diseñar un tipo abstracto con un constructor público. |
| [CA1014: Marcar los ensamblados con CLSCompliantAttribute](ca1014.md) | La Common Language Specification (CLS) define las restricciones de nomenclatura, los tipos de datos y las reglas a las que los ensamblados deben ajustarse si se van a utilizar los lenguajes de programación. Un buen diseño determina que todos los ensamblados indican explícitamente la conformidad con CLS mediante CLSCompliantAttribute. Si este atributo no está presente en un ensamblado, el ensamblado no es conforme. |
| [CA1016: Marcar los ensamblados con AssemblyVersionAttribute](ca1016.md) | .NET usa el número de versión para identificar de forma única un ensamblado, y para enlazar a los tipos de ensamblados con nombre seguro. El número de versión se utiliza junto con la versión y la directiva del fabricante. De forma predeterminada, las aplicaciones sólo se ejecutan con la versión de ensamblado con la que se compilaron. |
| [CA1017: Marcar los ensamblados con ComVisibleAttribute](ca1017.md) | ComVisibleAttribute determina cómo obtienen acceso los clientes COM al código administrado. Los procedimientos de diseño recomendados dictan que los ensamblados indican explícitamente la visibilidad COM. La visibilidad COM se puede establecer para un ensamblado completo y, a continuación, se puede invalidar para los tipos individuales y los miembros de tipo. Si este atributo no está presente, el contenido del ensamblado es visible para los clientes COM. |
| [CA1018: Marcar atributos con AttributeUsageAttribute](ca1018.md) | Cuando defina un atributo personalizado, márquelo utilizando AttributeUsageAttribute para indicar dónde se puede aplicar en el código fuente. El significado de un atributo y el uso que se le va a dar determinará sus ubicaciones válidas en código. |
| [CA1019: Definir descriptores de acceso para los argumentos de atributo](ca1019.md) | Los atributos pueden definir argumentos obligatorios que deben especificarse al aplicar el atributo a un destino. Éstos también se denominan argumentos posicionales porque se proporcionan para atribuir constructores como parámetros posicionales. Para cada argumento obligatorio, el atributo debe proporcionar también una propiedad de sólo lectura correspondiente de modo que el valor del argumento se pueda recuperar en tiempo de ejecución. Los atributos también pueden definir argumentos opcionales, que también se denominan argumentos con nombre. Estos argumentos se proporcionan para atribuir constructores por nombre y deben tener una propiedad de lectura/escritura correspondiente. |
| [CA1021: Evitar los parámetros out](ca1021.md) | Para pasar tipos por referencia (utilizando los parámetros out o ref) es necesario tener experiencia con punteros, saber la diferencia entre los tipos de referencia y los tipos de valor, y controlar métodos con varios valores devueltos. Además, no se suele saber qué diferencia hay entre los parámetros out y ref. |
| [CA1024: Utilizar las propiedades donde corresponda](ca1024.md) | Un método público o protegido tiene un nombre que comienza por "Get", no toma ningún parámetro y devuelve un valor que no es una matriz. El método podría ser un buen candidato para convertirse en propiedad. |
| [CA1027: Marcar enumeraciones con FlagsAttribute](ca1027.md) | Una enumeración es un tipo de valor que define un conjunto de constantes con nombre relacionadas. Aplique FlagsAttribute a una enumeración cuando se pueda combinar con sentido sus constantes con nombre. |
| [CA1028: El almacenamiento de la enumeración debe ser de tipo Int32](ca1028.md) | Una enumeración es un tipo de valor que define un conjunto de constantes con nombre relacionadas. De manera predeterminada, el tipo de datos System.Int32 se utiliza para almacenar el valor constante. Aunque puede cambiar este tipo subyacente, no es necesario ni se recomienda para la mayoría de los escenarios. |
| [CA1030: Utilizar eventos cuando sea apropiado](ca1030.md) | Esta regla detecta métodos que tienen nombres que normalmente se utilizarían para eventos. Si se llama a un método en respuesta a un cambio de estado claramente definido, un controlador de eventos debe invocar al método. Los objetos que llaman al método deben provocar eventos en lugar de llamar directamente al método. |
| [CA1031: No capturar los tipos de excepción general](ca1031.md) | No se deben capturar excepciones generales. Detecte una excepción más específica o vuelva a producir la excepción general como última instrucción del bloque catch. |
| [CA1032: Implementar constructores de excepción estándar](ca1032.md) | El error al proporcionar el conjunto completo de constructores puede dificultar el control correcto de las excepciones. |
| [CA1033: Los tipos secundarios deben poder llamar a los métodos de interfaz](ca1033.md) | Un tipo no sellado visible externamente proporciona un método explícito de implementación de una interfaz pública pero no proporciona un método visible externamente alternativo con el mismo nombre. |
| [CA1034: Los tipos anidados no deben ser visibles](ca1034.md) | Los tipos anidados son tipos declarados en el ámbito de otro tipo. Los tipos anidados son útiles para encapsular los detalles de la implementación privada del tipo contenido. Los tipos anidados, utilizados para este propósito, no deben ser visibles externamente. |
| [CA1036: Invalidar métodos en tipos comparables](ca1036.md) | Un tipo público o protegido implementa la interfaz System.IComparable. No invalida Object.Equals ni sobrecarga al operador específico del lenguaje para la igualdad, desigualdad, menor que o mayor que. |
| [CA1040: Evitar las interfaces vacías](ca1040.md) | Las interfaces definen miembros que proporcionan un comportamiento o acuerdo de uso. Cualquier tipo puede adoptar la funcionalidad descrita por la interfaz sin tener en cuenta dónde aparece el tipo en la jerarquía de herencia. Un tipo implementa una interfaz proporcionando las implementaciones para los miembros de la interfaz. Una interfaz vacía no define ningún miembro; por consiguiente, no define ningún contrato que se pueda implementar. |
| [CA1041: Proporcionar un mensaje ObsoleteAttribute](ca1041.md) | Un tipo o miembro se marca con un atributo System.ObsoleteAttribute para el que no se ha especificado su propiedad ObsoleteAttribute.Message. Cuando se compila un tipo o miembro marcado con ObsoleteAttribute, se muestra la propiedad Message del atributo, que proporciona la información de usuario sobre el tipo o miembro obsoleto. |
| [CA1043: Utilizar un argumento integral o de cadena en indizadores](ca1043.md) | Los indizadores (es decir, las propiedades indizadas) deben utilizar tipos enteros o de cadena para el índice. Estos tipos se utilizan normalmente para indizar las estructuras de datos y aumentan la utilidad de la biblioteca. El uso del tipo Object debería limitarse a los casos en los que el tipo entero o de cadena no se puede especificar en tiempo de diseño. |
| [CA1044: Las propiedades no deben ser de solo escritura](ca1044.md) | Aunque es aceptable y a menudo necesario tener una propiedad de solo lectura, las directrices de diseño prohíben el uso de propiedades de solo escritura. Esto es porque si se deja que un usuario configure un valor, y a continuación se impide que el usuario vea ese valor, no proporciona ninguna seguridad. Además, sin acceso de lectura, no se puede ver el estado de los objetos compartidos, lo que limita su utilidad. |
| [CA1045: No pasar tipos por referencia](ca1045.md) | Para pasar tipos por referencia (utilizando los parámetros out o ref) es necesario tener experiencia con punteros, saber la diferencia entre los tipos de referencia y los tipos de valor, y controlar métodos con varios valores devueltos. Los arquitectos de bibliotecas cuyos diseños están destinados a los usuarios en general no deben esperar que los usuarios dominen el uso de los parámetros out o ref. |
| [CA1046: No sobrecargar el operador de igualdad en los tipos de referencia](ca1046.md) | Para los tipos de referencia, la implementación predeterminada del operador de igualdad casi siempre es correcta. De manera predeterminada, dos referencias son iguales sólo si señalan al mismo objeto. |
| [CA1047: No declarar miembros protegidos en tipos sellados](ca1047.md) | Los tipos declaran miembros protegidos para que los tipos heredados puedan obtener acceso o reemplazar el miembro. Por definición, no se puede heredar de tipos sealed, lo que significa que no se puede llamar a los métodos protegidos en tipos sealed. |
| [CA1050: Declarar tipos en espacios de nombres](ca1050.md) | Los tipos se declaran dentro de los espacios de nombres para evitar conflictos de nombre y como una forma de organizar los tipos relacionados en una jerarquía de objetos. |
| [CA1051: No declarar campos de instancia visibles](ca1051.md) | El uso principal de un campo debe ser como un detalle de implementación. Los campos deben ser privados o internos y deben exponerse utilizando propiedades. |
| [CA1052: Los tipos titulares estáticos deben estar sellados](ca1052.md) | Un tipo público o protegido solo contiene miembros estáticos y no se declara mediante el modificador Sealed (C#) o NotInheritable (Visual Basic). Un tipo que no está diseñado para heredarse debería marcarse con el modificador sealed para impedir su uso como tipo base. |
| [CA1053: Los tipos titulares estáticos no deben tener constructores](ca1053.md) | Un tipo público o público anidado declara sólo miembros estáticos y tiene un constructor predeterminado público o protegido. El constructor no es necesario puesto que al llamar a los miembros estáticos no se requiere una instancia del tipo. La sobrecarga de la cadena debería llamar a la sobrecarga del identificador URI utilizando el argumento string por motivos de seguridad y protección. |
| [CA1054: Los parámetros de URI no deben ser cadenas](ca1054.md) | Si un método toma una representación de cadena de un identificador URI, debe proporcionarse la sobrecarga correspondiente que toma una instancia de la clase URI, que proporciona estos servicios de forma segura. |
| [CA1055: Los valores devueltos URI no deben ser cadenas](ca1055.md) | Esta regla supone que el método devuelve un URI. Las representaciones de cadena de identificadores URI tienen tendencia a analizar y codificar errores, por lo que pueden crear puntos vulnerables en la seguridad. La clase System.Uri proporciona estos servicios de una manera segura. |
| [CA1056: Las propiedades URI no deben ser cadenas](ca1056.md) | Esta regla supone que la propiedad representa un identificador URI. Las representaciones de cadena de identificadores URI tienen tendencia a analizar y codificar errores, por lo que pueden crear puntos vulnerables en la seguridad. La clase System.Uri proporciona estos servicios de una manera segura. |
| [CA1058: Los tipos no deben ampliar ciertos tipos base](ca1058.md) | Un tipo visible externamente extiende algunos tipos base. Utilice una de las alternativas. |
| [CA1060: mueve P/Invoke a la clase NativeMethods](ca1060.md) | Los métodos de invocación de plataforma, como los marcados con los <xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=fullName> métodos o definidos mediante la palabra clave declare en Visual Basic, tienen acceso al código no administrado. Estos métodos deben ser de la clase NativeMethods, UnsafeNativeMethods o SafeNativeMethods. |
| [CA1061: No ocultar métodos de clase base](ca1061.md) | Un método de un tipo base está oculto por un método del mismo nombre en un tipo derivado cuando la firma del parámetro del método derivado solo se diferencia por tipos derivados de manera más débil que los tipos correspondientes de la firma del parámetro del método base. |
| [CA1062: Validar argumentos de métodos públicos](ca1062.md) | Todos los argumentos de referencia pasados a métodos visibles externamente se deben comprobar para ver si son null. |
| [CA1063: Implementar IDisposable correctamente](ca1063.md) | Todos los tipos IDisposable deben implementar el modelo de Dispose correctamente. |
| [CA1064: Las excepciones deben ser públicas](ca1064.md) | Una excepción interna solo se ve dentro de su propio ámbito interno. Cuando la excepción esté fuera del ámbito interno, sólo se podrá usar la excepción base para detectarla. Si la excepción interna se hereda de <xref:System.Exception?displayProperty=fullName> , <xref:System.SystemException?displayProperty=fullName> o <xref:System.ApplicationException?displayProperty=fullName> , el código externo no tendrá información suficiente para saber qué hacer con la excepción. |
| [CA1065: No producir excepciones en ubicaciones inesperadas](ca1065.md) | Un método que no se espera que produzca excepciones inicia una excepción. |
| [CA1066: Implementar IEquatable al invalidar Equals](ca1066.md) | Un tipo de valor invalida el <xref:System.Object.Equals%2A> método, pero no implementa <xref:System.IEquatable%601> . |
| [CA1067: Invalidar Equals al implementar IEquatable](ca1067.md) | Un tipo implementa <xref:System.IEquatable%601> , pero no invalida el <xref:System.Object.Equals%2A> método. |
| [CA1068: Los parámetros CancellationToken deben aparecer en último lugar](ca1068.md) | Un método tiene un parámetro CancellationToken que no es el último parámetro. |
| [CA1069: Los enumeradores no deben tener valores duplicados](ca1069.md) | Una enumeración tiene varios miembros a los que se les asigna explícitamente el mismo valor constante. |
| [CA1070: No declarar los campos de eventos como virtuales](ca1070.md) | Un [evento similar](../../../csharp/event-pattern.md#defining-and-raising-field-like-events) a un campo se declaró como virtual. |
