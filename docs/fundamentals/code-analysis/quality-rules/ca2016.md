---
title: 'CA2016: reenviar el parámetro CancellationToken a los métodos que toman uno (análisis de código)'
description: 'Más información sobre la regla de análisis de código CA2016: reenviar el parámetro CancellationToken a los métodos que toman uno'
ms.date: 06/18/2020
ms.topic: reference
f1_keywords:
- ForwardCancellationTokenToInvocations
- CA2016
helpviewer_keywords:
- ForwardCancellationTokenToInvocations
- CA2016
author: carlossanlop
ms.author: calope
dev_langs:
- CSharp
- VB
ms.openlocfilehash: 1f602490b7b28bc1228a4d16741d61518ae3c9f9
ms.sourcegitcommit: 4df8e005c074ceb1f978f007b222fe253be2baf3
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 02/04/2021
ms.locfileid: "99545586"
---
# <a name="ca2016-forward-the-cancellationtoken-parameter-to-methods-that-take-one"></a><span data-ttu-id="2a750-103">CA2016: Reenviar el parámetro CancellationToken a los métodos que lo usan</span><span class="sxs-lookup"><span data-stu-id="2a750-103">CA2016: Forward the CancellationToken parameter to methods that take one</span></span>

| | <span data-ttu-id="2a750-104">Valor</span><span class="sxs-lookup"><span data-stu-id="2a750-104">Value</span></span> |
|-|-|
|<span data-ttu-id="2a750-105">TypeName</span><span class="sxs-lookup"><span data-stu-id="2a750-105">TypeName</span></span>|<span data-ttu-id="2a750-106">ForwardCancellationTokenToInvocations</span><span class="sxs-lookup"><span data-stu-id="2a750-106">ForwardCancellationTokenToInvocations</span></span>|
| <span data-ttu-id="2a750-107">**Identificador de la regla**</span><span class="sxs-lookup"><span data-stu-id="2a750-107">**Rule ID**</span></span> |<span data-ttu-id="2a750-108">CA2016</span><span class="sxs-lookup"><span data-stu-id="2a750-108">CA2016</span></span>|
| <span data-ttu-id="2a750-109">**Categoría**</span><span class="sxs-lookup"><span data-stu-id="2a750-109">**Category**</span></span> |[<span data-ttu-id="2a750-110">Microsoft. performance</span><span class="sxs-lookup"><span data-stu-id="2a750-110">Microsoft.Performance</span></span>](performance-warnings.md)|
| <span data-ttu-id="2a750-111">**Corrección o interrupción**</span><span class="sxs-lookup"><span data-stu-id="2a750-111">**Fix is breaking or non-breaking**</span></span> |<span data-ttu-id="2a750-112">Poco problemático</span><span class="sxs-lookup"><span data-stu-id="2a750-112">Non-breaking</span></span>|

## <a name="cause"></a><span data-ttu-id="2a750-113">Causa</span><span class="sxs-lookup"><span data-stu-id="2a750-113">Cause</span></span>

<span data-ttu-id="2a750-114">Esta regla localiza las invocaciones de método que podrían aceptar un <xref:System.Threading.CancellationToken> parámetro, pero que no pasan ningún, y sugiere reenviar a ellos el método primario `CancellationToken` .</span><span class="sxs-lookup"><span data-stu-id="2a750-114">This rule locates method invocations that could accept a <xref:System.Threading.CancellationToken> parameter, but are not passing any, and suggests to forward the parent method's `CancellationToken` to them.</span></span>

## <a name="rule-description"></a><span data-ttu-id="2a750-115">Descripción de la regla</span><span class="sxs-lookup"><span data-stu-id="2a750-115">Rule description</span></span>

<span data-ttu-id="2a750-116">Esta regla analiza las definiciones de método que toman `CancellationToken` como el último parámetro y, a continuación, analiza todos los métodos invocados en su cuerpo.</span><span class="sxs-lookup"><span data-stu-id="2a750-116">This rule analyzes method definitions that take a `CancellationToken` as their last parameter, then analyzes all methods invoked in its body.</span></span> <span data-ttu-id="2a750-117">Si alguna de las invocaciones de método puede aceptar `CancellationToken` como último parámetro, o tener una sobrecarga que tome `CancellationToken` como el último parámetro, la regla sugiere usar esa opción en su lugar para asegurarse de que la notificación de cancelación se propague a todas las operaciones que pueden escuchar en ella.</span><span class="sxs-lookup"><span data-stu-id="2a750-117">If any of the method invocations can either accept a `CancellationToken` as the last parameter, or have an overload that takes a `CancellationToken` as the last parameter, then the rule suggests using that option instead to ensure that the cancellation notification gets propagated to all operations that can listen to it.</span></span>

> [!NOTE]
> <span data-ttu-id="2a750-118">La regla CA2016 está disponible en todas las versiones de .NET en las que el `CancellationToken` tipo está disponible.</span><span class="sxs-lookup"><span data-stu-id="2a750-118">Rule CA2016 is available in all .NET versions where the `CancellationToken` type is available.</span></span> <span data-ttu-id="2a750-119">Vea la [sección CancellationToken "se aplica a"](/dotnet/api/system.threading.cancellationtoken#moniker-applies-to)</span><span class="sxs-lookup"><span data-stu-id="2a750-119">See [CancellationToken "Applies to" section](/dotnet/api/system.threading.cancellationtoken#moniker-applies-to)</span></span>

## <a name="how-to-fix-violations"></a><span data-ttu-id="2a750-120">Cómo corregir infracciones</span><span class="sxs-lookup"><span data-stu-id="2a750-120">How to fix violations</span></span>

<span data-ttu-id="2a750-121">Puede corregirlos manualmente o puede dejar que Visual Studio lo haga por usted, si mantiene el puntero sobre la bombilla que aparece junto a la invocación del método y selecciona el cambio sugerido.</span><span class="sxs-lookup"><span data-stu-id="2a750-121">You can either fix them manually, or you can opt to let Visual Studio do it for you, by hovering over the light bulb that shows up next to the method invocation, and selecting the suggested change.</span></span>

<span data-ttu-id="2a750-122">En el ejemplo siguiente se muestran dos cambios sugeridos:</span><span class="sxs-lookup"><span data-stu-id="2a750-122">The following example shows two suggested changes:</span></span>

![Regla CA2016: reenviar el parámetro CancellationToken a los métodos que toman uno](media/ca2016-diagnose.png)

<span data-ttu-id="2a750-124">Es seguro suprimir una infracción de esta regla si no le preocupa reenviar la notificación de operación cancelada a las invocaciones de método inferiores.</span><span class="sxs-lookup"><span data-stu-id="2a750-124">It's safe to suppress a violation of this rule if you're not concerned about forwarding the canceled operation notification to lower method invocations.</span></span> <span data-ttu-id="2a750-125">También puede pasar explícitamente `default` en C# ( `Nothing` en Visual Basic) o <xref:System.Threading.CancellationToken.None> para suprimir la infracción de la regla.</span><span class="sxs-lookup"><span data-stu-id="2a750-125">You can also explicitly pass `default` in C# (`Nothing` in Visual Basic) or <xref:System.Threading.CancellationToken.None> to suppress the rule violation.</span></span>

<span data-ttu-id="2a750-126">La regla puede detectar una variedad de infracciones.</span><span class="sxs-lookup"><span data-stu-id="2a750-126">The rule can detect a variety of violations.</span></span> <span data-ttu-id="2a750-127">En los ejemplos siguientes se muestran los casos que la regla puede detectar:</span><span class="sxs-lookup"><span data-stu-id="2a750-127">The following examples show cases that the rule can detect:</span></span>

### <a name="example-1"></a><span data-ttu-id="2a750-128">Ejemplo 1</span><span class="sxs-lookup"><span data-stu-id="2a750-128">Example 1</span></span>

<span data-ttu-id="2a750-129">La regla sugerirá el reenvío del `c` parámetro de `MyMethod` a la `MyMethodWithDefault` invocación, porque el método define un parámetro de token opcional:</span><span class="sxs-lookup"><span data-stu-id="2a750-129">The rule will suggest forwarding the `c` parameter from `MyMethod` to the `MyMethodWithDefault` invocation, because the method defines an optional token parameter:</span></span>

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithDefault(CancellationToken ct = default)
        {
        }

        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithDefault();
        }
    }
}
```

<span data-ttu-id="2a750-130">Solución:</span><span class="sxs-lookup"><span data-stu-id="2a750-130">Fix:</span></span>

<span data-ttu-id="2a750-131">Reenvíe el `c` parámetro:</span><span class="sxs-lookup"><span data-stu-id="2a750-131">Forward the `c` parameter:</span></span>

```csharp
        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithDefault(c);
        }
```

<span data-ttu-id="2a750-132">Si no le preocupa el reenvío de notificaciones de cancelación a invocaciones más bajas, puede:</span><span class="sxs-lookup"><span data-stu-id="2a750-132">If you are not concerned about forwarding cancellation notifications to lower invocations, you can either:</span></span>

<span data-ttu-id="2a750-133">Pasar explícitamente `default` :</span><span class="sxs-lookup"><span data-stu-id="2a750-133">Explicitly pass `default`:</span></span>

```csharp
        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithDefault(default);
        }
```

<span data-ttu-id="2a750-134">O pase explícitamente `CancellationToken.None` :</span><span class="sxs-lookup"><span data-stu-id="2a750-134">Or explicitly pass `CancellationToken.None`:</span></span>

```csharp
        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithDefault(CancellationToken.None);
        }
```

### <a name="example-2"></a><span data-ttu-id="2a750-135">Ejemplo 2</span><span class="sxs-lookup"><span data-stu-id="2a750-135">Example 2</span></span>

<span data-ttu-id="2a750-136">La regla sugerirá el reenvío del `c` parámetro de `MyMethod` a la `MyMethodWithDefault` invocación, porque el método tiene una sobrecarga que toma un `CancellationToken` parámetro:</span><span class="sxs-lookup"><span data-stu-id="2a750-136">The rule will suggest forwarding the `c` parameter from `MyMethod` to the `MyMethodWithDefault` invocation, because the method has an overload that takes a `CancellationToken` parameter:</span></span>

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithOverload()
        {
        }

        public static void MyMethodWithOverload(CancellationToken ct = default)
        {
        }

        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithOverload();
        }
    }
}
```

<span data-ttu-id="2a750-137">Solución:</span><span class="sxs-lookup"><span data-stu-id="2a750-137">Fix:</span></span>

<span data-ttu-id="2a750-138">Reenvíe el `c` parámetro:</span><span class="sxs-lookup"><span data-stu-id="2a750-138">Forward the `c` parameter:</span></span>

```csharp
        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithOverload(c);
        }
```

<span data-ttu-id="2a750-139">Si no le preocupa el reenvío de notificaciones de cancelación a invocaciones más bajas, puede:</span><span class="sxs-lookup"><span data-stu-id="2a750-139">If you are not concerned about forwarding cancellation notifications to lower invocations, you can either:</span></span>

<span data-ttu-id="2a750-140">Pasar explícitamente `default` :</span><span class="sxs-lookup"><span data-stu-id="2a750-140">Explicitly pass `default`:</span></span>

```csharp
        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithOverload(default);
        }
```

<span data-ttu-id="2a750-141">O pase explícitamente `CancellationToken.None` :</span><span class="sxs-lookup"><span data-stu-id="2a750-141">Or explicitly pass `CancellationToken.None`:</span></span>

```csharp
        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithOverload(CancellationToken.None);
        }
```

## <a name="non-violation-examples"></a><span data-ttu-id="2a750-142">Ejemplos de no infracción</span><span class="sxs-lookup"><span data-stu-id="2a750-142">Non-violation examples</span></span>

<span data-ttu-id="2a750-143">El `CancellationToken` parámetro del método primario no está en la última posición:</span><span class="sxs-lookup"><span data-stu-id="2a750-143">The `CancellationToken` parameter in the parent method is not in the last position:</span></span>

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithDefault(CancellationToken ct = default)
        {
        }

        public static void MyMethod(CancellationToken c, int lastParameter)
        {
            MyMethodWithDefault();
        }
    }
}
```

<span data-ttu-id="2a750-144">El `CancellationToken` parámetro del método predeterminado no está en la última posición:</span><span class="sxs-lookup"><span data-stu-id="2a750-144">The `CancellationToken` parameter in the default method is not in the last position:</span></span>

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithDefault(CancellationToken ct = default, int lastParameter = 0)
        {
        }

        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithDefault();
        }
    }
}
```

<span data-ttu-id="2a750-145">El `CancellationToken` parámetro del método de sobrecarga no está en la última posición:</span><span class="sxs-lookup"><span data-stu-id="2a750-145">The `CancellationToken` parameter in the overload method is not in the last position:</span></span>

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithOverload(int lastParameter)
        {
        }
        public static void MyMethodWithOverload(CancellationToken ct, int lastParameter)
        {
        }

        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithOverload();
        }
    }
}
```

<span data-ttu-id="2a750-146">El método primario define más de un `CancellationToken` parámetro:</span><span class="sxs-lookup"><span data-stu-id="2a750-146">The parent method defines more than one `CancellationToken` parameter:</span></span>

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithDefault(CancellationToken ct = default)
        {
        }

        public static void MyMethod(CancellationToken c1, CancellationToken c2)
        {
            MyMethodWithDefault();
        }
    }
}
```

<span data-ttu-id="2a750-147">El método con valores predeterminados define más de un `CancellationToken` parámetro:</span><span class="sxs-lookup"><span data-stu-id="2a750-147">The method with defaults defines more than one `CancellationToken` parameter:</span></span>

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithDefault(CancellationToken c1 = default, CancellationToken c2 = default)
        {
        }

        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithDefault();
        }
    }
}
```

<span data-ttu-id="2a750-148">La sobrecarga del método define más de un `CancellationToken` parámetro:</span><span class="sxs-lookup"><span data-stu-id="2a750-148">The method overload defines more than one `CancellationToken` parameter:</span></span>

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithOverload(CancellationToken c1, CancellationToken c2)
        {
        }

        public static void MyMethodWithOverload()
        {
        }

        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithOverload();
        }
    }
}
```
