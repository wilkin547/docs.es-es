---
title: 'CA1835: Preferencia de las sobrecargas basadas en memoria de los métodos ReadAsync/WriteAsync en clases basadas en secuencias (análisis de código)'
description: Obtenga más información sobre la regla de análisis de código CA1835, relativa a la preferencia de las sobrecargas basadas en memoria de los métodos ReadAsync/WriteAsync en clases basadas en secuencias.
ms.date: 05/11/2020
ms.topic: reference
f1_keywords:
- PreferStreamAsyncMemoryOverloads
- CA1835
helpviewer_keywords:
- PreferStreamAsyncMemoryOverloads
- CA1835
author: carlossanlop
ms.author: calope
dev_langs:
- CSharp
- VB
ms.openlocfilehash: 5febce07d38bd3781601d6d70a663c779eaa6d66
ms.sourcegitcommit: 05d0087dfca85aac9ca2960f86c5efd218bf833f
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 03/27/2021
ms.locfileid: "105637278"
---
# <a name="ca1835-prefer-the-memory-based-overloads-of-readasyncwriteasync-methods-in-stream-based-classes"></a><span data-ttu-id="28104-103">CA1835: Preferencia de las sobrecargas basadas en memoria de los métodos ReadAsync/WriteAsync en clases basadas en secuencias</span><span class="sxs-lookup"><span data-stu-id="28104-103">CA1835: Prefer the memory-based overloads of ReadAsync/WriteAsync methods in stream-based classes</span></span>

| | <span data-ttu-id="28104-104">Value</span><span class="sxs-lookup"><span data-stu-id="28104-104">Value</span></span> |
|-|-|
| <span data-ttu-id="28104-105">**Nombre de tipo**</span><span class="sxs-lookup"><span data-stu-id="28104-105">**Type name**</span></span> |<span data-ttu-id="28104-106">PreferStreamAsyncMemoryOverloads</span><span class="sxs-lookup"><span data-stu-id="28104-106">PreferStreamAsyncMemoryOverloads</span></span>|
| <span data-ttu-id="28104-107">**Identificador de la regla**</span><span class="sxs-lookup"><span data-stu-id="28104-107">**Rule ID**</span></span> |<span data-ttu-id="28104-108">CA1835</span><span class="sxs-lookup"><span data-stu-id="28104-108">CA1835</span></span>|
| <span data-ttu-id="28104-109">**Categoría**</span><span class="sxs-lookup"><span data-stu-id="28104-109">**Category**</span></span> |[<span data-ttu-id="28104-110">Rendimiento</span><span class="sxs-lookup"><span data-stu-id="28104-110">Performance</span></span>](performance-warnings.md)|
| <span data-ttu-id="28104-111">**La corrección es problemática o no problemática**</span><span class="sxs-lookup"><span data-stu-id="28104-111">**Fix is breaking or non-breaking**</span></span> |<span data-ttu-id="28104-112">Poco problemático</span><span class="sxs-lookup"><span data-stu-id="28104-112">Non-breaking</span></span>|

## <a name="cause"></a><span data-ttu-id="28104-113">Causa</span><span class="sxs-lookup"><span data-stu-id="28104-113">Cause</span></span>

<span data-ttu-id="28104-114">Esta regla localiza las invocaciones esperadas de las sobrecargas del método basado en la matriz de bytes para `ReadAsync` y `WriteAsync`, y sugiere el uso de las sobrecargas del método basado en memoria en su lugar, porque son más eficaces.</span><span class="sxs-lookup"><span data-stu-id="28104-114">This rule locates awaited invocations of the byte-array-based method overloads for `ReadAsync` and `WriteAsync`, and suggests using the memory-based method overloads instead, because they are more efficient.</span></span>

## <a name="rule-description"></a><span data-ttu-id="28104-115">Descripción de la regla</span><span class="sxs-lookup"><span data-stu-id="28104-115">Rule description</span></span>

<span data-ttu-id="28104-116">Las sobrecargas del método basado en memoria tienen un uso de memoria más eficaz que las basadas en la matriz de bytes.</span><span class="sxs-lookup"><span data-stu-id="28104-116">The memory-based method overloads have a more efficient memory usage than the byte array-based ones.</span></span>

<span data-ttu-id="28104-117">La regla funciona en las invocaciones de `ReadAsync` y `WriteAsync` de cualquier clase que se herede de <xref:System.IO.Stream>.</span><span class="sxs-lookup"><span data-stu-id="28104-117">The rule works on `ReadAsync` and `WriteAsync` invocations of any class that inherits from <xref:System.IO.Stream>.</span></span>

<span data-ttu-id="28104-118">La regla solo funciona cuando el método está precedido por la palabra clave `await`.</span><span class="sxs-lookup"><span data-stu-id="28104-118">The rule only works when the method is preceded by the `await` keyword.</span></span>

|<span data-ttu-id="28104-119">Método detectado</span><span class="sxs-lookup"><span data-stu-id="28104-119">Detected method</span></span>|<span data-ttu-id="28104-120">Método sugerido</span><span class="sxs-lookup"><span data-stu-id="28104-120">Suggested method</span></span>|
|-|-|
|<xref:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)>|<xref:System.IO.Stream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)>|
|<xref:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)>|<span data-ttu-id="28104-121"><xref:System.IO.Stream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)> con `CancellationToken` establecido en `default` en C# o `Nothing` en Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="28104-121"><xref:System.IO.Stream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)> with `CancellationToken` set to `default` in C#, or `Nothing` in Visual Basic.</span></span>|
|<xref:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)>|<xref:System.IO.Stream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)>|
|<xref:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)>|<span data-ttu-id="28104-122"><xref:System.IO.Stream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)> con `CancellationToken` establecido en `default` en C# o `Nothing` en Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="28104-122"><xref:System.IO.Stream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)> with `CancellationToken` set to `default` in C#, or `Nothing` in Visual Basic.</span></span>|

> [!IMPORTANT]
> <span data-ttu-id="28104-123">Asegúrese de pasar los argumentos de entero `offset` y `count` a las instancias de `Memory` o `ReadOnlyMemory` creadas.</span><span class="sxs-lookup"><span data-stu-id="28104-123">Make sure to pass the `offset` and `count` integer arguments to the created `Memory` or `ReadOnlyMemory` instances.</span></span>

> [!NOTE]
> <span data-ttu-id="28104-124">La regla CA1835 está disponible en todas las versiones de .NET en las que las sobrecargas basadas en memoria están disponibles:</span><span class="sxs-lookup"><span data-stu-id="28104-124">Rule CA1835 is available in all .NET versions where the memory-based overloads are available:</span></span>
>
> - <span data-ttu-id="28104-125">.NET Standard 2.1 y versiones posteriores.</span><span class="sxs-lookup"><span data-stu-id="28104-125">.NET Standard 2.1 and above.</span></span>
> - <span data-ttu-id="28104-126">.NET Core 2.1 y versiones posteriores.</span><span class="sxs-lookup"><span data-stu-id="28104-126">.NET Core 2.1 and above.</span></span>

## <a name="how-to-fix-violations"></a><span data-ttu-id="28104-127">Cómo corregir infracciones</span><span class="sxs-lookup"><span data-stu-id="28104-127">How to fix violations</span></span>

<span data-ttu-id="28104-128">Puede corregirlas manualmente o dejar que Visual Studio lo haga por usted. Para ello, mantenga el puntero sobre la bombilla que aparece junto a la invocación del método y seleccione el cambio sugerido.</span><span class="sxs-lookup"><span data-stu-id="28104-128">You can either fix them manually, or you can opt to let Visual Studio do it for you, by hovering over the light bulb that shows up next to the method invocation, and selecting the suggested change.</span></span> <span data-ttu-id="28104-129">Ejemplo:</span><span class="sxs-lookup"><span data-stu-id="28104-129">Example:</span></span>

![Corrección de código para CA1835: Preferencia de las sobrecargas basadas en memoria de los métodos ReadAsync/WriteAsync en clases basadas en secuencias](media/ca1835-codefix.png)

<span data-ttu-id="28104-131">La regla puede detectar diversas infracciones para los métodos `ReadAsync` y `WriteAsync`.</span><span class="sxs-lookup"><span data-stu-id="28104-131">The rule can detect a variety of violations for the `ReadAsync` and `WriteAsync` methods.</span></span> <span data-ttu-id="28104-132">Estos son algunos ejemplos de los casos que la regla puede detectar:</span><span class="sxs-lookup"><span data-stu-id="28104-132">Here are examples of the cases that the rule can detect:</span></span>

### <a name="example-1"></a><span data-ttu-id="28104-133">Ejemplo 1</span><span class="sxs-lookup"><span data-stu-id="28104-133">Example 1</span></span>

<span data-ttu-id="28104-134">Invocaciones de `ReadAsync`, con o sin un argumento `CancellationToken`:</span><span class="sxs-lookup"><span data-stu-id="28104-134">Invocations of `ReadAsync`, without and with a `CancellationToken` argument:</span></span>

```cs
using System;
using System.IO;
using System.Threading;

class MyClass
{
    public async void MyMethod(CancellationToken ct)
    {
        using (FileStream s = new FileStream("path.txt", FileMode.Create))
        {
            byte[] buffer = new byte[s.Length];
            await s.ReadAsync(buffer, 0, buffer.Length);
            await s.ReadAsync(buffer, 0, buffer.Length, ct);
        }
    }
}
```

<span data-ttu-id="28104-135">Solución:</span><span class="sxs-lookup"><span data-stu-id="28104-135">Fix:</span></span>

```cs
using System;
using System.IO;
using System.Threading;

class MyClass
{
    public async void MyMethod(CancellationToken ct)
    {
        using (FileStream s = new FileStream("path.txt", FileMode.Create))
        {
            byte[] buffer = new byte[s.Length];
            await s.ReadAsync(buffer.AsMemory(0, buffer.Length));
            await s.ReadAsync(buffer.AsMemory(0, buffer.Length), ct);
        }
    }
}
```

### <a name="example-2"></a><span data-ttu-id="28104-136">Ejemplo 2</span><span class="sxs-lookup"><span data-stu-id="28104-136">Example 2</span></span>

<span data-ttu-id="28104-137">Invocaciones de `WriteAsync`, con o sin un argumento `CancellationToken`:</span><span class="sxs-lookup"><span data-stu-id="28104-137">Invocations of `WriteAsync`, without and with a `CancellationToken` argument:</span></span>

```cs
using System;
using System.IO;
using System.Threading;

class MyClass
{
    public async void MyMethod(CancellationToken ct)
    {
        using (FileStream s = File.Open("path.txt", FileMode.Open))
        {
            byte[] buffer = { 0xBA, 0x5E, 0xBA, 0x11, 0xF0, 0x07, 0xBA, 0x11 };
            await s.WriteAsync(buffer, 0, buffer.Length);
            await s.WriteAsync(buffer, 0, buffer.Length, ct);
        }
    }
}
```

<span data-ttu-id="28104-138">Solución:</span><span class="sxs-lookup"><span data-stu-id="28104-138">Fix:</span></span>

```cs
using System;
using System.IO;
using System.Threading;

class MyClass
{
    public async void MyMethod()
    {
        using (FileStream s = File.Open("path.txt", FileMode.Open))
        {
            byte[] buffer = { 0xBA, 0x5E, 0xBA, 0x11, 0xF0, 0x07, 0xBA, 0x11 };
            await s.WriteAsync(buffer.AsMemory(0, buffer.Length));
            await s.WriteAsync(buffer.AsMemory(0, buffer.Length), ct);
        }
    }
}
```

### <a name="example-3"></a><span data-ttu-id="28104-139">Ejemplo 3</span><span class="sxs-lookup"><span data-stu-id="28104-139">Example 3</span></span>

<span data-ttu-id="28104-140">Invocaciones con `ConfigureAwait`:</span><span class="sxs-lookup"><span data-stu-id="28104-140">Invocations with `ConfigureAwait`:</span></span>

```cs
using System;
using System.IO;
using System.Threading;

class MyClass
{
    public async void MyMethod()
    {
        using (FileStream s = File.Open("path.txt", FileMode.Open))
        {
            byte[] buffer1 = { 0xBA, 0x5E, 0xBA, 0x11, 0xF0, 0x07, 0xBA, 0x11 };
            await s.WriteAsync(buffer1, 0, buffer1.Length).ConfigureAwait(false);

            byte[] buffer2 = new byte[s.Length];
            await s.ReadAsync(buffer2, 0, buffer2.Length).ConfigureAwait(true);
        }
    }
}
```

<span data-ttu-id="28104-141">Solución:</span><span class="sxs-lookup"><span data-stu-id="28104-141">Fix:</span></span>

```cs
using System;
using System.IO;
using System.Threading;

class MyClass
{
    public async void MyMethod()
    {
        using (FileStream s = File.Open("path.txt", FileMode.Open))
        {
            byte[] buffer1 = { 0xBA, 0x5E, 0xBA, 0x11, 0xF0, 0x07, 0xBA, 0x11 };
            await s.WriteAsync(buffer1.AsMemory(0, buffer1.Length)).ConfigureAwait(false);

            byte[] buffer2 = new byte[s.Length];
            await s.ReadAsync(buffer2.AsMemory(0, buffer.Length)).ConfigureAwait(true);
        }
    }
}
```

## <a name="non-violations"></a><span data-ttu-id="28104-142">No infracciones</span><span class="sxs-lookup"><span data-stu-id="28104-142">Non-violations</span></span>

<span data-ttu-id="28104-143">A continuación se muestran algunos ejemplos de las invocaciones en las que **no** se activará la regla.</span><span class="sxs-lookup"><span data-stu-id="28104-143">Following are some examples of invocations where the rule will **not** be fired.</span></span>

<span data-ttu-id="28104-144">El valor devuelto se guarda en una variable `Task`, en lugar de esperar:</span><span class="sxs-lookup"><span data-stu-id="28104-144">The return value is saved in a `Task` variable instead of being awaited:</span></span>

```cs
using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;

class MyClass
{
    public void MyMethod()
    {
        byte[] buffer = { 0xBA, 0x5E, 0xBA, 0x11, 0xF0, 0x07, 0xBA, 0x11 };
        using (FileStream s = new FileStream("path.txt", FileMode.Create))
        {
            Task t = s.WriteAsync(buffer, 0, buffer.Length);
        }
    }
}
```

<span data-ttu-id="28104-145">El método de ajuste devuelve el valor devuelto, en lugar de esperar:</span><span class="sxs-lookup"><span data-stu-id="28104-145">The return value is returned by the wrapping method instead of being awaited:</span></span>

```cs
using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;

class MyClass
{
    public Task MyMethod(FileStream s, byte[] buffer)
    {
        return s.WriteAsync(buffer, 0, buffer.Length);
    }
}
```

<span data-ttu-id="28104-146">El valor devuelto se usa para llamar a `ContinueWith`, que es el método que se espera:</span><span class="sxs-lookup"><span data-stu-id="28104-146">The return value is used to call `ContinueWith`, which is the method being awaited:</span></span>

```cs
using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;

class MyClass
{
    public void MyMethod()
    {
        byte[] buffer = { 0xBA, 0x5E, 0xBA, 0x11, 0xF0, 0x07, 0xBA, 0x11 };
        using (FileStream s = new FileStream("path.txt", FileMode.Create))
        {
            await s.WriteAsync(buffer, 0, buffer.Length).ContinueWith(c => { /* ... */ });
        }
    }
}
```

## <a name="when-to-suppress-warnings"></a><span data-ttu-id="28104-147">Cuándo suprimir las advertencias</span><span class="sxs-lookup"><span data-stu-id="28104-147">When to suppress warnings</span></span>

<span data-ttu-id="28104-148">Es seguro suprimir una infracción de esta regla si no le preocupa mejorar el rendimiento al leer o escribir búferes en clases basadas en secuencias.</span><span class="sxs-lookup"><span data-stu-id="28104-148">It's safe to suppress a violation of this rule if you're not concerned about improving performance when reading or writing buffers in stream-based classes.</span></span>

## <a name="see-also"></a><span data-ttu-id="28104-149">Vea también</span><span class="sxs-lookup"><span data-stu-id="28104-149">See also</span></span>

- [<span data-ttu-id="28104-150">Reglas de rendimiento</span><span class="sxs-lookup"><span data-stu-id="28104-150">Performance rules</span></span>](performance-warnings.md)
