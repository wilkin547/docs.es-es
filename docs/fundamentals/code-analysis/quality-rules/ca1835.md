---
title: 'CA1835: preferir las sobrecargas basadas en memoria de los métodos ReadAsync/WriteAsync en clases basadas en secuencias (análisis de código)'
description: 'Más información sobre la regla de análisis de código CA1835: preferir las sobrecargas basadas en memoria de los métodos ReadAsync/WriteAsync en clases basadas en secuencias'
ms.date: 05/11/2020
ms.topic: reference
f1_keywords:
- PreferStreamAsyncMemoryOverloads
- CA1835
helpviewer_keywords:
- PreferStreamAsyncMemoryOverloads
- CA1835
author: carlossanlop
ms.author: calope
dev_langs:
- CSharp
- VB
ms.openlocfilehash: 5f67124c5489103b2cc37597ff955caf35ffdeb9
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 02/06/2021
ms.locfileid: "99792419"
---
# <a name="ca1835-prefer-the-memory-based-overloads-of-readasyncwriteasync-methods-in-stream-based-classes"></a><span data-ttu-id="ca259-103">CA1835: preferir las sobrecargas basadas en memoria de los métodos ReadAsync/WriteAsync en clases basadas en secuencias</span><span class="sxs-lookup"><span data-stu-id="ca259-103">CA1835: Prefer the memory-based overloads of ReadAsync/WriteAsync methods in stream-based classes</span></span>

| | <span data-ttu-id="ca259-104">Value</span><span class="sxs-lookup"><span data-stu-id="ca259-104">Value</span></span> |
|-|-|
| <span data-ttu-id="ca259-105">**Nombre de tipo**</span><span class="sxs-lookup"><span data-stu-id="ca259-105">**Type name**</span></span> |<span data-ttu-id="ca259-106">PreferStreamAsyncMemoryOverlodas</span><span class="sxs-lookup"><span data-stu-id="ca259-106">PreferStreamAsyncMemoryOverlodas</span></span>|
| <span data-ttu-id="ca259-107">**Identificador de la regla**</span><span class="sxs-lookup"><span data-stu-id="ca259-107">**Rule ID**</span></span> |<span data-ttu-id="ca259-108">CA1835</span><span class="sxs-lookup"><span data-stu-id="ca259-108">CA1835</span></span>|
| <span data-ttu-id="ca259-109">**Categoría**</span><span class="sxs-lookup"><span data-stu-id="ca259-109">**Category**</span></span> |[<span data-ttu-id="ca259-110">Rendimiento</span><span class="sxs-lookup"><span data-stu-id="ca259-110">Performance</span></span>](performance-warnings.md)|
| <span data-ttu-id="ca259-111">**Corrección o interrupción**</span><span class="sxs-lookup"><span data-stu-id="ca259-111">**Fix is breaking or non-breaking**</span></span> |<span data-ttu-id="ca259-112">Poco problemático</span><span class="sxs-lookup"><span data-stu-id="ca259-112">Non-breaking</span></span>|

## <a name="cause"></a><span data-ttu-id="ca259-113">Causa</span><span class="sxs-lookup"><span data-stu-id="ca259-113">Cause</span></span>

<span data-ttu-id="ca259-114">Esta regla localiza las invocaciones esperadas de las sobrecargas del método basado en la matriz de bytes para `ReadAsync` y `WriteAsync` , y sugiere el uso de las sobrecargas del método basado en memoria en su lugar, porque son más eficaces.</span><span class="sxs-lookup"><span data-stu-id="ca259-114">This rule locates awaited invocations of the byte-array-based method overloads for `ReadAsync` and `WriteAsync`, and suggests using the memory-based method overloads instead, because they are more efficient.</span></span>

## <a name="rule-description"></a><span data-ttu-id="ca259-115">Descripción de la regla</span><span class="sxs-lookup"><span data-stu-id="ca259-115">Rule description</span></span>

<span data-ttu-id="ca259-116">Las sobrecargas del método basado en memoria tienen un uso de memoria más eficaz que los basados en la matriz de bytes.</span><span class="sxs-lookup"><span data-stu-id="ca259-116">The memory-based method overloads have a more efficient memory usage than the byte array-based ones.</span></span>

<span data-ttu-id="ca259-117">La regla funciona en `ReadAsync` y las `WriteAsync` invocaciones de cualquier clase que herede de <xref:System.IO.Stream> .</span><span class="sxs-lookup"><span data-stu-id="ca259-117">The rule works on `ReadAsync` and `WriteAsync` invocations of any class that inherits from <xref:System.IO.Stream>.</span></span>

<span data-ttu-id="ca259-118">La regla solo funciona cuando el método está precedido por la `await` palabra clave.</span><span class="sxs-lookup"><span data-stu-id="ca259-118">The rule only works when the method is preceded by the `await` keyword.</span></span>

|<span data-ttu-id="ca259-119">Método detectado</span><span class="sxs-lookup"><span data-stu-id="ca259-119">Detected method</span></span>|<span data-ttu-id="ca259-120">Método sugerido</span><span class="sxs-lookup"><span data-stu-id="ca259-120">Suggested method</span></span>|
|-|-|
|<xref:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)>|<xref:System.IO.Stream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)>|
|<xref:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)>|<span data-ttu-id="ca259-121"><xref:System.IO.Stream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)> con `CancellationToken` establecido en `default` en C#, o `Nothing` en Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="ca259-121"><xref:System.IO.Stream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)> with `CancellationToken` set to `default` in C#, or `Nothing` in Visual Basic.</span></span>|
|<xref:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)>|<xref:System.IO.Stream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)>|
|<xref:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)>|<span data-ttu-id="ca259-122"><xref:System.IO.Stream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)> con `CancellationToken` establecido en `default` en C#, o `Nothing` en Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="ca259-122"><xref:System.IO.Stream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)> with `CancellationToken` set to `default` in C#, or `Nothing` in Visual Basic.</span></span>|

> [!IMPORTANT]
> <span data-ttu-id="ca259-123">Asegúrese de pasar los `offset` argumentos de `count` tipo entero y a las instancias de creadas `Memory` `ReadOnlyMemory` .</span><span class="sxs-lookup"><span data-stu-id="ca259-123">Make sure to pass the `offset` and `count` integer arguments to the created `Memory` or `ReadOnlyMemory` instances.</span></span>

> [!NOTE]
> <span data-ttu-id="ca259-124">La regla CA1835 está disponible en todas las versiones de .NET en las que las sobrecargas basadas en memoria están disponibles:</span><span class="sxs-lookup"><span data-stu-id="ca259-124">Rule CA1835 is available in all .NET versions where the memory-based overloads are available:</span></span>
>
> - <span data-ttu-id="ca259-125">.NET Standard 2,1 y versiones posteriores.</span><span class="sxs-lookup"><span data-stu-id="ca259-125">.NET Standard 2.1 and above.</span></span>
> - <span data-ttu-id="ca259-126">.NET Core 2,1 y versiones posteriores.</span><span class="sxs-lookup"><span data-stu-id="ca259-126">.NET Core 2.1 and above.</span></span>

## <a name="how-to-fix-violations"></a><span data-ttu-id="ca259-127">Cómo corregir infracciones</span><span class="sxs-lookup"><span data-stu-id="ca259-127">How to fix violations</span></span>

<span data-ttu-id="ca259-128">Puede corregirlos manualmente o puede dejar que Visual Studio lo haga por usted, si mantiene el puntero sobre la bombilla que aparece junto a la invocación del método y selecciona el cambio sugerido.</span><span class="sxs-lookup"><span data-stu-id="ca259-128">You can either fix them manually, or you can opt to let Visual Studio do it for you, by hovering over the light bulb that shows up next to the method invocation, and selecting the suggested change.</span></span> <span data-ttu-id="ca259-129">Ejemplo:</span><span class="sxs-lookup"><span data-stu-id="ca259-129">Example:</span></span>

![Corrección de código para CA1835: preferir las sobrecargas basadas en memoria de los métodos ReadAsync/WriteAsync en clases basadas en secuencias](media/ca1835-codefix.png)

<span data-ttu-id="ca259-131">La regla puede detectar una variedad de infracciones para `ReadAsync` los `WriteAsync` métodos y.</span><span class="sxs-lookup"><span data-stu-id="ca259-131">The rule can detect a variety of violations for the `ReadAsync` and `WriteAsync` methods.</span></span> <span data-ttu-id="ca259-132">Estos son algunos ejemplos de los casos que la regla puede detectar:</span><span class="sxs-lookup"><span data-stu-id="ca259-132">Here are examples of the cases that the rule can detect:</span></span>

### <a name="example-1"></a><span data-ttu-id="ca259-133">Ejemplo 1</span><span class="sxs-lookup"><span data-stu-id="ca259-133">Example 1</span></span>

<span data-ttu-id="ca259-134">Invocaciones de `ReadAsync` , sin y con un `CancellationToken` argumento:</span><span class="sxs-lookup"><span data-stu-id="ca259-134">Invocations of `ReadAsync`, without and with a `CancellationToken` argument:</span></span>

```cs
using System;
using System.IO;
using System.Threading;

class MyClass
{
    public async void MyMethod(CancellationToken ct)
    {
        using (FileStream s = new FileStream("path.txt", FileMode.Create))
        {
            byte[] buffer = new byte[s.Length];
            await s.ReadAsync(buffer, 0, buffer.Length);
            await s.ReadAsync(buffer, 0, buffer.Length, ct);
        }
    }
}
```

<span data-ttu-id="ca259-135">Solución:</span><span class="sxs-lookup"><span data-stu-id="ca259-135">Fix:</span></span>

```cs
using System;
using System.IO;
using System.Threading;

class MyClass
{
    public async void MyMethod(CancellationToken ct)
    {
        using (FileStream s = new FileStream("path.txt", FileMode.Create))
        {
            byte[] buffer = new byte[s.Length];
            await s.ReadAsync(buffer.AsMemory(0, buffer.Length));
            await s.ReadAsync(buffer.AsMemory(0, buffer.Length), ct);
        }
    }
}
```

### <a name="example-2"></a><span data-ttu-id="ca259-136">Ejemplo 2</span><span class="sxs-lookup"><span data-stu-id="ca259-136">Example 2</span></span>

<span data-ttu-id="ca259-137">Invocaciones de `WriteAsync` , sin y con un `CancellationToken` argumento:</span><span class="sxs-lookup"><span data-stu-id="ca259-137">Invocations of `WriteAsync`, without and with a `CancellationToken` argument:</span></span>

```cs
using System;
using System.IO;
using System.Threading;

class MyClass
{
    public async void MyMethod(CancellationToken ct)
    {
        using (FileStream s = File.Open("path.txt", FileMode.Open))
        {
            byte[] buffer = { 0xBA, 0x5E, 0xBA, 0x11, 0xF0, 0x07, 0xBA, 0x11 };
            await s.WriteAsync(buffer, 0, buffer.Length);
            await s.WriteAsync(buffer, 0, buffer.Length, ct);
        }
    }
}
```

<span data-ttu-id="ca259-138">Solución:</span><span class="sxs-lookup"><span data-stu-id="ca259-138">Fix:</span></span>

```cs
using System;
using System.IO;
using System.Threading;

class MyClass
{
    public async void MyMethod()
    {
        using (FileStream s = File.Open("path.txt", FileMode.Open))
        {
            byte[] buffer = { 0xBA, 0x5E, 0xBA, 0x11, 0xF0, 0x07, 0xBA, 0x11 };
            await s.WriteAsync(buffer.AsMemory(0, buffer.Length));
            await s.WriteAsync(buffer.AsMemory(0, buffer.Length), ct);
        }
    }
}
```

### <a name="example-3"></a><span data-ttu-id="ca259-139">Ejemplo 3</span><span class="sxs-lookup"><span data-stu-id="ca259-139">Example 3</span></span>

<span data-ttu-id="ca259-140">Invocaciones con `ConfigureAwait` :</span><span class="sxs-lookup"><span data-stu-id="ca259-140">Invocations with `ConfigureAwait`:</span></span>

```cs
using System;
using System.IO;
using System.Threading;

class MyClass
{
    public async void MyMethod()
    {
        using (FileStream s = File.Open("path.txt", FileMode.Open))
        {
            byte[] buffer1 = { 0xBA, 0x5E, 0xBA, 0x11, 0xF0, 0x07, 0xBA, 0x11 };
            await s.WriteAsync(buffer1, 0, buffer1.Length).ConfigureAwait(false);

            byte[] buffer2 = new byte[s.Length];
            await s.ReadAsync(buffer2, 0, buffer2.Length).ConfigureAwait(true);
        }
    }
}
```

<span data-ttu-id="ca259-141">Solución:</span><span class="sxs-lookup"><span data-stu-id="ca259-141">Fix:</span></span>

```cs
using System;
using System.IO;
using System.Threading;

class MyClass
{
    public async void MyMethod()
    {
        using (FileStream s = File.Open("path.txt", FileMode.Open))
        {
            byte[] buffer1 = { 0xBA, 0x5E, 0xBA, 0x11, 0xF0, 0x07, 0xBA, 0x11 };
            await s.WriteAsync(buffer1.AsMemory(0, buffer1.Length)).ConfigureAwait(false);

            byte[] buffer2 = new byte[s.Length];
            await s.ReadAsync(buffer2.AsMemory(0, buffer.Length)).ConfigureAwait(true);
        }
    }
}
```

## <a name="non-violations"></a><span data-ttu-id="ca259-142">No infracciones</span><span class="sxs-lookup"><span data-stu-id="ca259-142">Non-violations</span></span>

<span data-ttu-id="ca259-143">A continuación se muestran algunos ejemplos de las invocaciones en las que **no** se desencadenará la regla.</span><span class="sxs-lookup"><span data-stu-id="ca259-143">Following are some examples of invocations where the rule will **not** be fired.</span></span>

<span data-ttu-id="ca259-144">El valor devuelto se guarda en una `Task` variable en lugar de esperar:</span><span class="sxs-lookup"><span data-stu-id="ca259-144">The return value is saved in a `Task` variable instead of being awaited:</span></span>

```cs
using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;

class MyClass
{
    public void MyMethod()
    {
        byte[] buffer = { 0xBA, 0x5E, 0xBA, 0x11, 0xF0, 0x07, 0xBA, 0x11 };
        using (FileStream s = new FileStream("path.txt", FileMode.Create))
        {
            Task t = s.WriteAsync(buffer, 0, buffer.Length);
        }
    }
}
```

<span data-ttu-id="ca259-145">El método de ajuste devuelve el valor devuelto en lugar de esperar:</span><span class="sxs-lookup"><span data-stu-id="ca259-145">The return value is returned by the wrapping method instead of being awaited:</span></span>

```cs
using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;

class MyClass
{
    public Task MyMethod(FileStream s, byte[] buffer)
    {
        return s.WriteAsync(buffer, 0, buffer.Length);
    }
}
```

<span data-ttu-id="ca259-146">El valor devuelto se usa para llamar a `ContinueWith` , que es el método que se espera:</span><span class="sxs-lookup"><span data-stu-id="ca259-146">The return value is used to call `ContinueWith`, which is the method being awaited:</span></span>

```cs
using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;

class MyClass
{
    public void MyMethod()
    {
        byte[] buffer = { 0xBA, 0x5E, 0xBA, 0x11, 0xF0, 0x07, 0xBA, 0x11 };
        using (FileStream s = new FileStream("path.txt", FileMode.Create))
        {
            await s.WriteAsync(buffer, 0, buffer.Length).ContinueWith(c => { /* ... */ });
        }
    }
}
```

## <a name="when-to-suppress-warnings"></a><span data-ttu-id="ca259-147">Cuándo suprimir advertencias</span><span class="sxs-lookup"><span data-stu-id="ca259-147">When to suppress warnings</span></span>

<span data-ttu-id="ca259-148">Es seguro suprimir una infracción de esta regla si no le preocupa mejorar el rendimiento al leer o escribir búferes en clases basadas en secuencias.</span><span class="sxs-lookup"><span data-stu-id="ca259-148">It's safe to suppress a violation of this rule if you're not concerned about improving performance when reading or writing buffers in stream-based classes.</span></span>

## <a name="see-also"></a><span data-ttu-id="ca259-149">Vea también</span><span class="sxs-lookup"><span data-stu-id="ca259-149">See also</span></span>

- [<span data-ttu-id="ca259-150">Reglas de rendimiento</span><span class="sxs-lookup"><span data-stu-id="ca259-150">Performance rules</span></span>](performance-warnings.md)
