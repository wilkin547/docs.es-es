---
title: Novedades
ms.date: 10/24/2018
f1_keywords:
- VB.StartPage.WhatsNew
helpviewer_keywords:
- new features, Visual Basic
- what's new [Visual Basic]
- Visual Basic, what's new
ms.assetid: d7e97396-7f42-4873-a81c-4ebcc4b6ca02
ms.openlocfilehash: e9ab745a60cd9eb646bee57a9a6838c30add77c5
ms.sourcegitcommit: cbacb5d2cebbf044547f6af6e74a9de866800985
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 09/05/2020
ms.locfileid: "89495738"
---
# <a name="whats-new-for-visual-basic"></a><span data-ttu-id="210b7-102">Novedades de Visual Basic</span><span class="sxs-lookup"><span data-stu-id="210b7-102">What's new for Visual Basic</span></span>

<span data-ttu-id="210b7-103">En este tema se enumeran los nombres de las características clave de cada versión de Visual Basic con descripciones detalladas de las características nuevas y mejoradas de las versiones más recientes del lenguaje.</span><span class="sxs-lookup"><span data-stu-id="210b7-103">This topic lists key feature names for each version of Visual Basic, with detailed descriptions of the new and enhanced features in the latest versions of the language.</span></span>

## <a name="current-version"></a><span data-ttu-id="210b7-104">Versión actual</span><span class="sxs-lookup"><span data-stu-id="210b7-104">Current version</span></span>

<span data-ttu-id="210b7-105">Visual Basic 16.0/Visual Studio 2019, versión 16.0</span><span class="sxs-lookup"><span data-stu-id="210b7-105">Visual Basic 16.0 / Visual Studio 2019 version 16.0</span></span>\
<span data-ttu-id="210b7-106">Para las nuevas características, vea [Visual Basic 16.0](#visual-basic-160).</span><span class="sxs-lookup"><span data-stu-id="210b7-106">For new features, see [Visual Basic 16.0](#visual-basic-160).</span></span>

## <a name="previous-versions"></a><span data-ttu-id="210b7-107">Versiones anteriores</span><span class="sxs-lookup"><span data-stu-id="210b7-107">Previous versions</span></span>

<span data-ttu-id="210b7-108">Visual Basic 15.8/Visual Studio 2017, versión 15.8</span><span class="sxs-lookup"><span data-stu-id="210b7-108">Visual Basic 15.8 / Visual Studio 2017 version 15.8</span></span>\
<span data-ttu-id="210b7-109">Para consultar las nuevas características, vea [Visual Basic 15.8](#visual-basic-158).</span><span class="sxs-lookup"><span data-stu-id="210b7-109">For new features, see [Visual Basic 15.8](#visual-basic-158).</span></span>

<span data-ttu-id="210b7-110">Visual Basic 15.5/Visual Studio 2017, versión 15.5</span><span class="sxs-lookup"><span data-stu-id="210b7-110">Visual Basic 15.5 / Visual Studio 2017 version 15.5</span></span>\
<span data-ttu-id="210b7-111">Para consultar las nuevas características, vea [Visual Basic 15.5](#visual-basic-155).</span><span class="sxs-lookup"><span data-stu-id="210b7-111">For new features, see [Visual Basic 15.5](#visual-basic-155).</span></span>

<span data-ttu-id="210b7-112">Visual Basic 15.3/Visual Studio 2017, versión 15.3</span><span class="sxs-lookup"><span data-stu-id="210b7-112">Visual Basic 15.3 / Visual Studio 2017 version 15.3</span></span>\
<span data-ttu-id="210b7-113">Para consultar las nuevas características, vea [Visual Basic 15.3](#visual-basic-153).</span><span class="sxs-lookup"><span data-stu-id="210b7-113">For new features, see [Visual Basic 15.3](#visual-basic-153).</span></span>

<span data-ttu-id="210b7-114">Visual Basic 2017/Visual Studio 2017</span><span class="sxs-lookup"><span data-stu-id="210b7-114">Visual Basic 2017 / Visual Studio 2017</span></span>\
<span data-ttu-id="210b7-115">Para consultar las nuevas características, vea [Visual Basic 2017](#visual-basic-2017).</span><span class="sxs-lookup"><span data-stu-id="210b7-115">For new features, see [Visual Basic 2017](#visual-basic-2017).</span></span>

<span data-ttu-id="210b7-116">Visual Basic/Visual Studio 2015</span><span class="sxs-lookup"><span data-stu-id="210b7-116">Visual Basic / Visual Studio 2015</span></span>\
<span data-ttu-id="210b7-117">Para consultar las nuevas características, vea [Visual Basic 14](#visual-basic-14).</span><span class="sxs-lookup"><span data-stu-id="210b7-117">For new features, see [Visual Basic 14](#visual-basic-14).</span></span>

<span data-ttu-id="210b7-118">Visual Basic/Visual Studio 2013</span><span class="sxs-lookup"><span data-stu-id="210b7-118">Visual Basic / Visual Studio 2013</span></span>\
<span data-ttu-id="210b7-119">Vistas previas de tecnología de .NET Compiler Platform ("Roslyn")</span><span class="sxs-lookup"><span data-stu-id="210b7-119">Technology previews of the .NET Compiler Platform ("Roslyn")</span></span>

<span data-ttu-id="210b7-120">Visual Basic/Visual Studio 2012</span><span class="sxs-lookup"><span data-stu-id="210b7-120">Visual Basic / Visual Studio 2012</span></span>\
<span data-ttu-id="210b7-121">palabras clave `Async` y `await`, iteradores, atributos de información de autor de llamada</span><span class="sxs-lookup"><span data-stu-id="210b7-121">`Async` and `await` keywords, iterators, caller info attributes</span></span>

<span data-ttu-id="210b7-122">Visual Basic, Visual Studio 2010</span><span class="sxs-lookup"><span data-stu-id="210b7-122">Visual Basic, Visual Studio 2010</span></span>\
<span data-ttu-id="210b7-123">Propiedades autoimplementadas, inicializadores de colección, continuación de línea implícita, dinámica, covarianza/contravarianza genérica, acceso de espacio de nombres global</span><span class="sxs-lookup"><span data-stu-id="210b7-123">Auto-implemented properties, collection initializers, implicit line continuation, dynamic, generic co/contra variance, global namespace access</span></span>

<span data-ttu-id="210b7-124">Visual Basic/Visual Studio 2008</span><span class="sxs-lookup"><span data-stu-id="210b7-124">Visual Basic / Visual Studio 2008</span></span>\
<span data-ttu-id="210b7-125">Language Integrated Query (LINQ), literales XML, inferencia de tipo de variable local, inicializadores de objeto, tipos anónimos, métodos de extensión, inferencia de tipo de variable local `var`, expresiones lambda, operador `if`, métodos parciales, tipos de valor que aceptan valores null</span><span class="sxs-lookup"><span data-stu-id="210b7-125">Language Integrated Query (LINQ), XML literals, local type inference, object initializers, anonymous types, extension methods, local `var` type inference, lambda expressions, `if` operator, partial methods, nullable value types</span></span>

<span data-ttu-id="210b7-126">Visual Basic/Visual Studio 2005</span><span class="sxs-lookup"><span data-stu-id="210b7-126">Visual Basic / Visual Studio 2005</span></span>\
<span data-ttu-id="210b7-127">El tipo `My` y los tipos del asistente (acceso a la aplicación, equipo, sistema de archivos, red)</span><span class="sxs-lookup"><span data-stu-id="210b7-127">The `My` type and helper types (access to app, computer, files system, network)</span></span>

<span data-ttu-id="210b7-128">Visual Basic/Visual Studio .NET 2003</span><span class="sxs-lookup"><span data-stu-id="210b7-128">Visual Basic / Visual Studio .NET 2003</span></span>\
<span data-ttu-id="210b7-129">Operadores de desplazamiento de bits, declaración de variable de bucle</span><span class="sxs-lookup"><span data-stu-id="210b7-129">Bit-shift operators, loop variable declaration</span></span>

<span data-ttu-id="210b7-130">Visual Basic/Visual Studio .NET 2002</span><span class="sxs-lookup"><span data-stu-id="210b7-130">Visual Basic / Visual Studio .NET 2002</span></span>\
<span data-ttu-id="210b7-131">La primera versión de Visual Basic .NET</span><span class="sxs-lookup"><span data-stu-id="210b7-131">The first release of Visual Basic .NET</span></span>

## <a name="visual-basic-160"></a><span data-ttu-id="210b7-132">Visual Basic 16.0</span><span class="sxs-lookup"><span data-stu-id="210b7-132">Visual Basic 16.0</span></span>

<span data-ttu-id="210b7-133">Visual Basic 16.0 se centra en proporcionar más características del entorno de ejecución de Visual Basic (microsoft.visualbasic.dll) a .NET Core y es la primera versión de Visual Basic centrada en .NET Core.</span><span class="sxs-lookup"><span data-stu-id="210b7-133">Visual Basic 16.0 focuses on supplying more of the features of the Visual Basic Runtime (microsoft.visualbasic.dll) to .NET Core and is the first version of Visual Basic focused on .NET Core.</span></span> <span data-ttu-id="210b7-134">Muchas partes del entorno de ejecución de Visual Basic dependen de WinForms y se agregarán en una versión posterior de Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="210b7-134">Many portions of the Visual Basic Runtime depend on WinForms and these will be added in a later version of Visual Basic.</span></span>

<span data-ttu-id="210b7-135">**Comentarios permitidos en más lugares dentro de las instrucciones**</span><span class="sxs-lookup"><span data-stu-id="210b7-135">**Comments allowed in more places within statements**</span></span>

<span data-ttu-id="210b7-136">En Visual Basic 15.8 y versiones anteriores, solo se permiten comentarios en líneas en blanco, al final de una instrucción o en lugares específicos dentro de una instrucción donde se permita una continuación de línea implícita.</span><span class="sxs-lookup"><span data-stu-id="210b7-136">In Visual Basic 15.8 and earlier versions, comments are only allowed on blank lines, at the end of a statement, or in specific places within a statement where an implicit line continuation is allowed.</span></span> <span data-ttu-id="210b7-137">A partir de Visual Basic 16.0, también se permiten comentarios después de las continuaciones de línea explícitas y dentro de una instrucción en una línea que comienza con un espacio seguido de un guion bajo.</span><span class="sxs-lookup"><span data-stu-id="210b7-137">Starting with Visual Basic 16.0, comments are also allowed after explicit line continuations and within a statement on a line beginning with a space followed by an underscore.</span></span>

```vb
Public Sub Main()
    cmd.CommandText = ' Comment is allowed here without _
        "SELECT * FROM Titles JOIN Publishers " _ ' This is a comment
        & "ON Publishers.PubId = Titles.PubID " _
 _ ' This is a comment on a line without code
        & "WHERE Publishers.State = 'CA'"
End Sub
```

## <a name="visual-basic-158"></a><span data-ttu-id="210b7-138">Visual Basic 15.8</span><span class="sxs-lookup"><span data-stu-id="210b7-138">Visual Basic 15.8</span></span>

<span data-ttu-id="210b7-139">**Punto flotante optimizado para la conversión de enteros**</span><span class="sxs-lookup"><span data-stu-id="210b7-139">**Optimized floating-point to integer conversion**</span></span>

<span data-ttu-id="210b7-140">En versiones anteriores de Visual Basic, la conversión de valores [dobles](../language-reference/data-types/double-data-type.md) y [únicos](../language-reference/data-types/single-data-type.md) a enteros ofrecía un rendimiento relativamente bajo.</span><span class="sxs-lookup"><span data-stu-id="210b7-140">In previous versions of Visual Basic, conversion of [Double](../language-reference/data-types/double-data-type.md) and [Single](../language-reference/data-types/single-data-type.md) values to integers offered relatively poor performance.</span></span> <span data-ttu-id="210b7-141">Visual Basic 15.8 mejora significativamente el rendimiento de las conversiones de punto flotante a enteros al pasar el valor devuelto por cualquiera de los métodos siguientes a uno de las [funciones de conversión de enteros de Visual Basic intrínsecas](../language-reference/functions/type-conversion-functions.md) (CByte, CShort, CInt, CLng, CSByte, CUShort, CUInt, CULng) o cuando el valor devuelto por cualquiera de los métodos siguientes se convierte implícitamente a un tipo entero cuando [Opción estricta](../language-reference/statements/option-strict-statement.md) se establece en `Off`:</span><span class="sxs-lookup"><span data-stu-id="210b7-141">Visual Basic 15.8 significantly enhances the performance of floating-point conversions to integers when you pass the value returned by any of the following methods to one of the [intrinsic Visual Basic integer conversion functions](../language-reference/functions/type-conversion-functions.md) (CByte, CShort, CInt, CLng, CSByte, CUShort, CUInt, CULng), or when the value returned by any of the following methods is implicitly cast to an integral type when [Option Strict](../language-reference/statements/option-strict-statement.md) is set to `Off`:</span></span>

- <xref:Microsoft.VisualBasic.Conversion.Fix(System.Double)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Fix(System.Object)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Fix(System.Single)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Int(System.Double)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Int(System.Object)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Int(System.Single)?displayProperty=nameWithType>
- <xref:System.Math.Ceiling(System.Double)?displayProperty=nameWithType>
- <xref:System.Math.Floor(System.Double)?displayProperty=nameWithType>
- <xref:System.Math.Round(System.Double)?displayProperty=nameWithType>
- <xref:System.Math.Truncate(System.Double)?displayProperty=nameWithType>

<span data-ttu-id="210b7-142">Esta optimización permite que el código se ejecute más rápido, hasta el doble de rápido para código que realiza un gran número de conversiones a tipos enteros.</span><span class="sxs-lookup"><span data-stu-id="210b7-142">This optimization allows code to run faster -- up to twice as fast for code that does a large number of conversions to integer types.</span></span> <span data-ttu-id="210b7-143">En el ejemplo siguiente se muestran algunas llamadas a métodos simples que se ven afectadas por esta optimización:</span><span class="sxs-lookup"><span data-stu-id="210b7-143">The following example illustrates some simple method calls that are affected by this optimization:</span></span>

```vb
Dim s As Single = 173.7619
Dim d As Double = s

Dim i1 As Integer = CInt(Fix(s))               ' Result: 173
Dim b1 As Byte = CByte(Int(d))                 ' Result: 173
Dim s1 AS Short = CShort(Math.Truncate(s))     ' Result: 173
Dim i2 As Integer = CInt(Math.Ceiling(d))      ' Result: 174
Dim i3 As Integer = CInt(Math.Round(s))        ' Result: 174
```

<span data-ttu-id="210b7-144">Tenga en cuenta que esto trunca los valores de punto flotante en lugar de redondearlos.</span><span class="sxs-lookup"><span data-stu-id="210b7-144">Note that this truncates rather than rounds floating-point values.</span></span>

## <a name="visual-basic-155"></a><span data-ttu-id="210b7-145">Visual Basic 15.5</span><span class="sxs-lookup"><span data-stu-id="210b7-145">Visual Basic 15.5</span></span>

[<span data-ttu-id="210b7-146">Argumentos con nombre no finales</span><span class="sxs-lookup"><span data-stu-id="210b7-146">Non-trailing named arguments</span></span>](../programming-guide/language-features/procedures/passing-arguments-by-position-and-by-name.md#mixing-arguments-by-position-and-by-name)

<span data-ttu-id="210b7-147">En Visual Basic 15.3 y en versiones anteriores, cuando una llamada de método incluía argumentos por posición y por nombre, los argumentos posicionales tenían que preceder a los argumentos con nombre.</span><span class="sxs-lookup"><span data-stu-id="210b7-147">In Visual Basic 15.3 and earlier versions, when a method call included arguments both by position and by name, positional arguments had to precede named arguments.</span></span> <span data-ttu-id="210b7-148">A partir de Visual Basic 15.5, los argumentos posicionales y los argumentos con nombre pueden aparecer en cualquier orden, siempre y cuando todos los argumentos hasta el último argumento posicional se encuentren en la posición correcta.</span><span class="sxs-lookup"><span data-stu-id="210b7-148">Starting with Visual Basic 15.5, positional and named arguments can appear in any order as long as all arguments up to the last positional argument are in the correct position.</span></span> <span data-ttu-id="210b7-149">Esto es muy útil si se usan argumentos con nombre para mejorar la legibilidad del código.</span><span class="sxs-lookup"><span data-stu-id="210b7-149">This is particularly useful when named arguments are used to make code more readable.</span></span>

<span data-ttu-id="210b7-150">Por ejemplo, la siguiente llamada de método tiene dos argumentos posicionales entre un argumento con nombre.</span><span class="sxs-lookup"><span data-stu-id="210b7-150">For example, the following method call has two positional arguments between a named argument.</span></span> <span data-ttu-id="210b7-151">El argumento con nombre deja claro que el valor 19 representa una edad.</span><span class="sxs-lookup"><span data-stu-id="210b7-151">The named argument makes it clear that the value 19 represents an age.</span></span>

```vb
StudentInfo.Display("Mary", age:=19, #9/21/1998#)
```

[<span data-ttu-id="210b7-152">Modificador de acceso de miembro `Private Protected`</span><span class="sxs-lookup"><span data-stu-id="210b7-152">`Private Protected` member access modifier</span></span>](../language-reference/modifiers/private-protected.md)

<span data-ttu-id="210b7-153">Esta nueva combinación de palabras clave define un miembro al que pueden acceder todos los miembros de su clase contenedora y los tipos derivados de dicha clase, pero solo si también se encuentran en el ensamblado contenedor.</span><span class="sxs-lookup"><span data-stu-id="210b7-153">This new keyword combination defines a member that is accessible by all members in its containing class as well as by types derived from the containing class, but only if they are also found in the containing assembly.</span></span> <span data-ttu-id="210b7-154">Dado que las estructuras no se pueden heredar, `Private Protected` solo se pueden aplicar a los miembros de una clase.</span><span class="sxs-lookup"><span data-stu-id="210b7-154">Because structures cannot be inherited, `Private Protected` can only be applied to the members of a class.</span></span>

<span data-ttu-id="210b7-155">**Separador hexadecimal/binario/octal inicial**</span><span class="sxs-lookup"><span data-stu-id="210b7-155">**Leading hex/binary/octal separator**</span></span>

<span data-ttu-id="210b7-156">En Visual Basic 2017 se ha agregado compatibilidad con el carácter de subrayado (`_`) como separador de dígitos.</span><span class="sxs-lookup"><span data-stu-id="210b7-156">Visual Basic 2017 added support for the underscore character (`_`) as a digit separator.</span></span> <span data-ttu-id="210b7-157">A partir de Visual Basic 15.5 puede usar el carácter de subrayado como separador inicial entre el prefijo y los dígitos hexadecimales, binarios u octales.</span><span class="sxs-lookup"><span data-stu-id="210b7-157">Starting with Visual Basic 15.5, you can use the underscore character as a leading separator between the prefix and hexadecimal, binary, or octal digits.</span></span> <span data-ttu-id="210b7-158">En el ejemplo siguiente se usa un separador de dígitos inicial para definir 3,271,948,384 como número hexadecimal:</span><span class="sxs-lookup"><span data-stu-id="210b7-158">The following example uses a leading digit separator to define 3,271,948,384 as a hexadecimal number:</span></span>

```vb
Dim number As Integer = &H_C305_F860
```

<span data-ttu-id="210b7-159">Para usar el carácter de subrayado como separador inicial, debe agregar el elemento siguiente al archivo del proyecto de Visual Basic (\*.vbproj):</span><span class="sxs-lookup"><span data-stu-id="210b7-159">To use the underscore character as a leading separator, you must add the following element to your Visual Basic project (\*.vbproj) file:</span></span>

```xml
<PropertyGroup>
  <LangVersion>15.5</LangVersion>
</PropertyGroup>
```

## <a name="visual-basic-153"></a><span data-ttu-id="210b7-160">Visual Basic 15.3</span><span class="sxs-lookup"><span data-stu-id="210b7-160">Visual Basic 15.3</span></span>

[<span data-ttu-id="210b7-161">**Inferencia en tuplas con nombre**</span><span class="sxs-lookup"><span data-stu-id="210b7-161">**Named tuple inference**</span></span>](../programming-guide/language-features/data-types/tuples.md#inferred-tuple-element-names)

<span data-ttu-id="210b7-162">Al asignar el valor de elementos de tupla desde variables, Visual Basic infiere el nombre de los elementos de tupla a partir de los nombres de variable correspondientes, por lo que no es necesario asignar un nombre a un elemento de tupla de forma explícita.</span><span class="sxs-lookup"><span data-stu-id="210b7-162">When you assign the value of tuple elements from variables, Visual Basic infers the name of tuple elements from the corresponding variable names; you do not have to explicitly name a tuple element.</span></span> <span data-ttu-id="210b7-163">En el ejemplo siguiente se usa la inferencia para crear una tupla con tres elementos con nombre: `state`, `stateName` y `capital`.</span><span class="sxs-lookup"><span data-stu-id="210b7-163">The following example uses inference to create a tuple with three named elements, `state`, `stateName`, and `capital`.</span></span>

[!code-vb[Inferred tuple names](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/named-tuples/program.vb#2)]

<span data-ttu-id="210b7-164">**Modificadores del compilador adicionales**</span><span class="sxs-lookup"><span data-stu-id="210b7-164">**Additional compiler switches**</span></span>

<span data-ttu-id="210b7-165">El compilador de línea de comandos de Visual Basic ahora admite las opciones de compilador [ **-refout**](../reference/command-line-compiler/refout-compiler-option.md) y [ **-refonly**](../reference/command-line-compiler/refonly-compiler-option.md) para controlar la salida de ensamblados de referencia.</span><span class="sxs-lookup"><span data-stu-id="210b7-165">The Visual Basic command-line compiler now supports the [**-refout**](../reference/command-line-compiler/refout-compiler-option.md) and [**-refonly**](../reference/command-line-compiler/refonly-compiler-option.md) compiler options to control the output of reference assemblies.</span></span> <span data-ttu-id="210b7-166">**-refout** define el directorio de salida del ensamblado de referencia y **-refonly** especifica que solo un ensamblado de referencia se transferirá por compilación.</span><span class="sxs-lookup"><span data-stu-id="210b7-166">**-refout** defines the output directory of the reference assembly, and **-refonly** specifies that only a reference assembly is to be output by compilation.</span></span>

## <a name="visual-basic-2017"></a><span data-ttu-id="210b7-167">Visual Basic 2017</span><span class="sxs-lookup"><span data-stu-id="210b7-167">Visual Basic 2017</span></span>

[<span data-ttu-id="210b7-168">**Tuplas**</span><span class="sxs-lookup"><span data-stu-id="210b7-168">**Tuples**</span></span>](../programming-guide/language-features/data-types/tuples.md)

<span data-ttu-id="210b7-169">Las tuplas son una estructura de datos ligera que se usan normalmente para devolver varios valores de una sola llamada al método.</span><span class="sxs-lookup"><span data-stu-id="210b7-169">Tuples are a lightweight data structure that most commonly is used to return multiple values from a single method call.</span></span> <span data-ttu-id="210b7-170">Normalmente, para devolver varios valores de un método, tiene que realizar una de las siguientes acciones:</span><span class="sxs-lookup"><span data-stu-id="210b7-170">Ordinarily, to return multiple values from a method, you have to do one of the following:</span></span>

- <span data-ttu-id="210b7-171">Definir un tipo personalizado (`Class` o `Structure`).</span><span class="sxs-lookup"><span data-stu-id="210b7-171">Define a custom type (a `Class` or a `Structure`).</span></span> <span data-ttu-id="210b7-172">Esta es una solución pesada.</span><span class="sxs-lookup"><span data-stu-id="210b7-172">This is a heavyweight solution.</span></span>

- <span data-ttu-id="210b7-173">Definir uno o más parámetros `ByRef`, además de devolver un valor del método.</span><span class="sxs-lookup"><span data-stu-id="210b7-173">Define one or more `ByRef` parameters, in addition to returning a value from the method.</span></span>

<span data-ttu-id="210b7-174">La compatibilidad de Visual Basic con las tuplas le permite definir rápidamente una tupla, asignar opcionalmente nombres semánticos a sus valores y recuperar sus valores rápidamente.</span><span class="sxs-lookup"><span data-stu-id="210b7-174">Visual Basic's support for tuples lets you quickly define a tuple, optionally assign semantic names to its values, and quickly retrieve its values.</span></span> <span data-ttu-id="210b7-175">En el ejemplo siguiente se ajusta una llamada al método <xref:System.Int32.TryParse%2A> y se devuelve una tupla.</span><span class="sxs-lookup"><span data-stu-id="210b7-175">The following example wraps a call to the <xref:System.Int32.TryParse%2A> method and returns a tuple.</span></span>

[!code-vb[Tuple](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#2)]

<span data-ttu-id="210b7-176">Después, puede llamar al método y controlar la tupla devuelta con código como el siguiente.</span><span class="sxs-lookup"><span data-stu-id="210b7-176">You can then call the method and handle the returned tuple with code like the following.</span></span>

[!code-vb[ReturnTuple](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#3)]

<span data-ttu-id="210b7-177">**Literales binarios y separadores de dígitos**</span><span class="sxs-lookup"><span data-stu-id="210b7-177">**Binary literals and digit separators**</span></span>

<span data-ttu-id="210b7-178">Puede definir un literal binario con el prefijo `&B` o `&b`.</span><span class="sxs-lookup"><span data-stu-id="210b7-178">You can define a binary literal by using the prefix `&B` or `&b`.</span></span> <span data-ttu-id="210b7-179">Además, puede usar el carácter de subrayado, `_`, como un separador de dígitos para mejorar la legibilidad.</span><span class="sxs-lookup"><span data-stu-id="210b7-179">In addition, you can use the underscore character, `_`, as a digit separator to enhance readability.</span></span> <span data-ttu-id="210b7-180">En el ejemplo siguiente se usan ambas características para asignar un valor `Byte` y para mostrarlo como un número binario, hexadecimal y decimal.</span><span class="sxs-lookup"><span data-stu-id="210b7-180">The following example uses both features to assign a `Byte` value and to display it as a decimal, hexadecimal, and binary number.</span></span>

[!code-vb[Binary](../../../samples/snippets/visualbasic/getting-started/bin-example.vb#1)]

<span data-ttu-id="210b7-181">Para obtener más información, vea la sección "Asignaciones literales" de los tipos de datos [Byte](../language-reference/data-types/byte-data-type.md#literal-assignments), [Integer](../language-reference/data-types/integer-data-type.md#literal-assignments), [Long](../language-reference/data-types/long-data-type.md#literal-assignments), [Short](../language-reference/data-types/short-data-type.md#literal-assignments), [SByte](../language-reference/data-types/sbyte-data-type.md#literal-assignments), [UInteger](../language-reference/data-types/uinteger-data-type.md#literal-assignments), [ULong](../language-reference/data-types/ulong-data-type.md#literal-assignments) y [UShort](../language-reference/data-types/ushort-data-type.md#literal-assignments).</span><span class="sxs-lookup"><span data-stu-id="210b7-181">For more information, see the "Literal assignments" section of the [Byte](../language-reference/data-types/byte-data-type.md#literal-assignments), [Integer](../language-reference/data-types/integer-data-type.md#literal-assignments), [Long](../language-reference/data-types/long-data-type.md#literal-assignments), [Short](../language-reference/data-types/short-data-type.md#literal-assignments), [SByte](../language-reference/data-types/sbyte-data-type.md#literal-assignments), [UInteger](../language-reference/data-types/uinteger-data-type.md#literal-assignments), [ULong](../language-reference/data-types/ulong-data-type.md#literal-assignments), and [UShort](../language-reference/data-types/ushort-data-type.md#literal-assignments) data types.</span></span>

[<span data-ttu-id="210b7-182">**Compatibilidad con los valores devueltos de referencia de C#** </span><span class="sxs-lookup"><span data-stu-id="210b7-182">**Support for C# reference return values**</span></span>](../programming-guide/language-features/procedures/ref-return-values.md)

<span data-ttu-id="210b7-183">A partir de C# 7.0, C# admite los valores devueltos de referencia.</span><span class="sxs-lookup"><span data-stu-id="210b7-183">Starting with C# 7.0, C# supports reference return values.</span></span> <span data-ttu-id="210b7-184">Es decir, cuando el método de llamada recibe un valor devuelto mediante referencia, puede cambiar el valor de esta.</span><span class="sxs-lookup"><span data-stu-id="210b7-184">That is, when the calling method receives a value returned by reference, it can change the value of the reference.</span></span> <span data-ttu-id="210b7-185">Visual Basic no le permite crear métodos con valores devueltos de referencia, pero le permite consumirlos y modificarlos.</span><span class="sxs-lookup"><span data-stu-id="210b7-185">Visual Basic does not allow you to author methods with reference return values, but it does allow you to consume and modify the reference return values.</span></span>

<span data-ttu-id="210b7-186">Por ejemplo, la siguiente clase `Sentence` escrita en C# incluye un método `FindNext` que busca la siguiente palabra de una frase que comienza por una subcadena especificada.</span><span class="sxs-lookup"><span data-stu-id="210b7-186">For example, the following `Sentence` class written in C# includes a `FindNext` method that finds the next word in a sentence that begins with a specified substring.</span></span> <span data-ttu-id="210b7-187">La cadena se devuelve como un valor devuelto de referencia, y una variable `Boolean` que se ha pasado mediante referencia al método indica si la búsqueda se ha realizado correctamente.</span><span class="sxs-lookup"><span data-stu-id="210b7-187">The string is returned as a reference return value, and a `Boolean` variable passed by reference to the method indicates whether the search was successful.</span></span> <span data-ttu-id="210b7-188">Esto significa que, aparte de leer el valor devuelto, el autor de la llamada también puede modificarlo, y esa modificación se refleja en la clase `Sentence`.</span><span class="sxs-lookup"><span data-stu-id="210b7-188">This means that in addition to reading the returned value, the caller can also modify it, and that modification is reflected in the `Sentence` class.</span></span>

[!code-csharp[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-returns.cs)]

<span data-ttu-id="210b7-189">En su forma más sencilla, puede modificar la palabra que se ha encontrado en la frase con código como el que se muestra a continuación.</span><span class="sxs-lookup"><span data-stu-id="210b7-189">In its simplest form, you can modify the word found in the sentence by using code like the following.</span></span> <span data-ttu-id="210b7-190">Tenga en cuenta que no está asignando un valor al método, sino a la expresión que devuelve el método, que es el valor devuelto de referencia.</span><span class="sxs-lookup"><span data-stu-id="210b7-190">Note that you are not assigning a value to the method, but rather to the expression that the method returns, which is the reference return value.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return.vb#1)]

<span data-ttu-id="210b7-191">En cambio, un problema con este código es que si no se detecta una coincidencia, el método devuelve la primera palabra.</span><span class="sxs-lookup"><span data-stu-id="210b7-191">A problem with this code, though, is that if a match is not found, the method returns the first word.</span></span> <span data-ttu-id="210b7-192">Como el ejemplo no examina el valor del argumento `Boolean` para determinar si se detecta una coincidencia, modifica la primera palabra si no hay ninguna.</span><span class="sxs-lookup"><span data-stu-id="210b7-192">Since the example does not examine the value of the `Boolean` argument to determine whether a match is found, it modifies the first word if there is no match.</span></span> <span data-ttu-id="210b7-193">En el ejemplo siguiente se corrige esto reemplazando la primera palabra por ella misma si no existe ninguna coincidencia.</span><span class="sxs-lookup"><span data-stu-id="210b7-193">The following example corrects this by replacing the first word with itself if there is no match.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return.vb#2)]

<span data-ttu-id="210b7-194">Una solución mejor es usar un método del asistente en el que el valor devuelto de referencia se pase mediante una referencia.</span><span class="sxs-lookup"><span data-stu-id="210b7-194">A better solution is to use a helper method to which the reference return value is passed by reference.</span></span> <span data-ttu-id="210b7-195">El método del asistente puede después modificar el argumento que se ha pasado por referencia.</span><span class="sxs-lookup"><span data-stu-id="210b7-195">The helper method can then modify the argument passed to it by reference.</span></span> <span data-ttu-id="210b7-196">En el siguiente ejemplo se realiza esto.</span><span class="sxs-lookup"><span data-stu-id="210b7-196">The following example does that.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return-helper.vb#1)]

<span data-ttu-id="210b7-197">Para obtener más información, vea [Valores devueltos de referencia](../programming-guide/language-features/procedures/ref-return-values.md).</span><span class="sxs-lookup"><span data-stu-id="210b7-197">For more information, see [Reference Return Values](../programming-guide/language-features/procedures/ref-return-values.md).</span></span>

## <a name="visual-basic-14"></a><span data-ttu-id="210b7-198">Visual Basic 14</span><span class="sxs-lookup"><span data-stu-id="210b7-198">Visual Basic 14</span></span>

[<span data-ttu-id="210b7-199">NameOf</span><span class="sxs-lookup"><span data-stu-id="210b7-199">NameOf</span></span>](../language-reference/operators/nameof.md)

<span data-ttu-id="210b7-200">Puede obtener el nombre de cadena no calificado de un tipo o miembro para usarlo en un mensaje de error sin codificar de forma rígida una cadena.</span><span class="sxs-lookup"><span data-stu-id="210b7-200">You can get the unqualified string name of a type or member for use in an error message without hard coding a string.</span></span>  <span data-ttu-id="210b7-201">Esto permite que el código siga siendo correcto al refactorizarlo.</span><span class="sxs-lookup"><span data-stu-id="210b7-201">This allows your code to remain correct when refactoring.</span></span>  <span data-ttu-id="210b7-202">Esta característica también es útil para enlazar los vínculos MVC del controlador de vista de modelos y desencadenar eventos de propiedad cambiada.</span><span class="sxs-lookup"><span data-stu-id="210b7-202">This feature is also useful for hooking up model-view-controller MVC links and firing property changed events.</span></span>

[<span data-ttu-id="210b7-203">Interpolación de cadenas</span><span class="sxs-lookup"><span data-stu-id="210b7-203">String interpolation</span></span>](../programming-guide/language-features/strings/interpolated-strings.md)

<span data-ttu-id="210b7-204">Puede usar expresiones de interpolación de cadenas para construir cadenas.</span><span class="sxs-lookup"><span data-stu-id="210b7-204">You can use string interpolation expressions to construct strings.</span></span>  <span data-ttu-id="210b7-205">Una expresión de cadena interpolada es similar a una cadena de plantilla que contiene expresiones.</span><span class="sxs-lookup"><span data-stu-id="210b7-205">An interpolated string expression looks like a template string that contains expressions.</span></span>  <span data-ttu-id="210b7-206">Una cadena interpolada es más fácil de entender con respecto a los argumentos que el [formato compuesto](../../standard/base-types/composite-formatting.md).</span><span class="sxs-lookup"><span data-stu-id="210b7-206">An interpolated string is easier to understand with respect to arguments than [Composite Formatting](../../standard/base-types/composite-formatting.md).</span></span>

[<span data-ttu-id="210b7-207">Acceso a miembros condicionales NULL e indexación</span><span class="sxs-lookup"><span data-stu-id="210b7-207">Null-conditional member access and indexing</span></span>](../language-reference/operators/null-conditional-operators.md)

<span data-ttu-id="210b7-208">Puede probar si hay valores null de forma sintáctica ligera antes de realizar una operación de acceso a miembros (`?.`) o índice (`?[]`).</span><span class="sxs-lookup"><span data-stu-id="210b7-208">You can test for null in a very light syntactic way before performing a member access (`?.`) or index (`?[]`) operation.</span></span>  <span data-ttu-id="210b7-209">Estos operadores ayudan a escribir menos código para controlar las comprobaciones de null, especialmente para descender en estructuras de datos.</span><span class="sxs-lookup"><span data-stu-id="210b7-209">These operators help you write less code to handle null checks, especially for descending into data structures.</span></span>  <span data-ttu-id="210b7-210">Si la referencia de objeto u operando izquierdo es null, la operación devuelve null.</span><span class="sxs-lookup"><span data-stu-id="210b7-210">If the left operand or object reference is null, the operations returns null.</span></span>

[<span data-ttu-id="210b7-211">Literales de cadena multilínea</span><span class="sxs-lookup"><span data-stu-id="210b7-211">Multi-line string literals</span></span>](../programming-guide/language-features/strings/string-basics.md)

<span data-ttu-id="210b7-212">Los literales de cadena pueden contener secuencias de nueva línea.</span><span class="sxs-lookup"><span data-stu-id="210b7-212">String literals can contain newline sequences.</span></span>  <span data-ttu-id="210b7-213">Ya no necesita la antigua solución alternativa que consistía en usar `<xml><![CDATA[...text with newlines...]]></xml>.Value`</span><span class="sxs-lookup"><span data-stu-id="210b7-213">You no longer need the old work around of using `<xml><![CDATA[...text with newlines...]]></xml>.Value`</span></span>

<span data-ttu-id="210b7-214">**Comentarios**</span><span class="sxs-lookup"><span data-stu-id="210b7-214">**Comments**</span></span>

<span data-ttu-id="210b7-215">Puede colocar comentarios después de las continuaciones de línea implícita, dentro de expresiones de inicializador y entre los términos de la expresión LINQ.</span><span class="sxs-lookup"><span data-stu-id="210b7-215">You can put comments after implicit line continuations, inside initializer expressions, and among LINQ expression terms.</span></span>

<span data-ttu-id="210b7-216">**Resolución de nombres completos más inteligente**</span><span class="sxs-lookup"><span data-stu-id="210b7-216">**Smarter fully-qualified name resolution**</span></span>

<span data-ttu-id="210b7-217">Dado código como `Threading.Thread.Sleep(1000)`, Visual Basic solía buscar el espacio de nombres "Threading", detectaba ambigüedad entre System.Threading y System.Windows.Threading y, a continuación, notificaba un error.</span><span class="sxs-lookup"><span data-stu-id="210b7-217">Given code such as `Threading.Thread.Sleep(1000)`, Visual Basic used to look up the namespace "Threading", discover it was ambiguous between System.Threading and System.Windows.Threading, and then report an error.</span></span>  <span data-ttu-id="210b7-218">Ahora, Visual Basic considera juntos ambos espacios de nombres posibles.</span><span class="sxs-lookup"><span data-stu-id="210b7-218">Visual Basic now considers both possible namespaces together.</span></span>  <span data-ttu-id="210b7-219">Si aparece la lista de finalización, el editor de Visual Studio muestra los miembros de ambos tipos en la lista de finalización.</span><span class="sxs-lookup"><span data-stu-id="210b7-219">If you show the completion list, the Visual Studio editor lists members from both types in the completion list.</span></span>

<span data-ttu-id="210b7-220">**Literales de fecha con el año en primer lugar**</span><span class="sxs-lookup"><span data-stu-id="210b7-220">**Year-first date literals**</span></span>

<span data-ttu-id="210b7-221">Puede tener literales de fecha en el formato aaaa-mm-dd, `#2015-03-17 16:10 PM#`.</span><span class="sxs-lookup"><span data-stu-id="210b7-221">You can have date literals in yyyy-mm-dd format, `#2015-03-17 16:10 PM#`.</span></span>

<span data-ttu-id="210b7-222">**Propiedades de interfaz de solo lectura**</span><span class="sxs-lookup"><span data-stu-id="210b7-222">**Readonly interface properties**</span></span>

<span data-ttu-id="210b7-223">Puede implementar propiedades de interfaz de solo lectura mediante una propiedad de lectura y escritura.</span><span class="sxs-lookup"><span data-stu-id="210b7-223">You can implement readonly interface properties using a readwrite property.</span></span> <span data-ttu-id="210b7-224">La interfaz garantiza una funcionalidad mínima y no impide que una clase de implementación pueda establecer la propiedad.</span><span class="sxs-lookup"><span data-stu-id="210b7-224">The interface guarantees minimum functionality, and it does not stop an implementing class from allowing the property to be set.</span></span>

[<span data-ttu-id="210b7-225">TypeOf \<expr> IsNot \<type></span><span class="sxs-lookup"><span data-stu-id="210b7-225">TypeOf \<expr> IsNot \<type></span></span>](../language-reference/operators/typeof-operator.md)

<span data-ttu-id="210b7-226">Para mejorar la legibilidad del código, ahora puede usar `TypeOf` con `IsNot`.</span><span class="sxs-lookup"><span data-stu-id="210b7-226">For more readability of your code, you can now use `TypeOf` with `IsNot`.</span></span>

[<span data-ttu-id="210b7-227">#Disable Warning \<ID> y #Enable Warning \<ID></span><span class="sxs-lookup"><span data-stu-id="210b7-227">#Disable Warning \<ID> and #Enable Warning \<ID></span></span>](../language-reference/directives/index.md)

<span data-ttu-id="210b7-228">Puede deshabilitar y habilitar advertencias específicas para las regiones dentro de un archivo de origen.</span><span class="sxs-lookup"><span data-stu-id="210b7-228">You can disable and enable specific warnings for regions within a source file.</span></span>

<span data-ttu-id="210b7-229">**Mejoras de comentarios de documento XML**</span><span class="sxs-lookup"><span data-stu-id="210b7-229">**XML doc comment improvements**</span></span>

<span data-ttu-id="210b7-230">Al escribir comentarios de documento, obtiene compatibilidad inteligente de editor y compilación para validar nombres de parámetro, controlar adecuadamente `crefs` (genéricos, operadores, etc.), colorear y refactorizar.</span><span class="sxs-lookup"><span data-stu-id="210b7-230">When writing doc comments, you get smart editor and build support for validating parameter names, proper handling of `crefs` (generics, operators, etc.), colorizing, and refactoring.</span></span>

[<span data-ttu-id="210b7-231">Definiciones de módulo parcial e interfaz</span><span class="sxs-lookup"><span data-stu-id="210b7-231">Partial module and interface definitions</span></span>](../language-reference/modifiers/partial.md)

<span data-ttu-id="210b7-232">Además de clases y structs, puede declarar módulos parciales e interfaces.</span><span class="sxs-lookup"><span data-stu-id="210b7-232">In addition to classes and structs, you can declare partial modules and interfaces.</span></span>

[<span data-ttu-id="210b7-233">Directivas #Region dentro de cuerpos de método</span><span class="sxs-lookup"><span data-stu-id="210b7-233">#Region directives inside method bodies</span></span>](../language-reference/directives/region-directive.md)

<span data-ttu-id="210b7-234">Puede colocar delimitadores #Region... #End Region en cualquier parte de un archivo, dentro de funciones e incluso abarcando los cuerpos de función.</span><span class="sxs-lookup"><span data-stu-id="210b7-234">You can put #Region…#End Region delimiters anywhere in a file, inside functions, and even spanning across function bodies.</span></span>

[<span data-ttu-id="210b7-235">Las definiciones de invalidaciones son implícitamente sobrecargas</span><span class="sxs-lookup"><span data-stu-id="210b7-235">Overrides definitions are implicitly overloads</span></span>](../language-reference/modifiers/overrides.md)

<span data-ttu-id="210b7-236">Si agrega el modificador `Overrides` a una definición, el compilador agrega implícitamente `Overloads`, de modo que pueda escribir menos código en los casos comunes.</span><span class="sxs-lookup"><span data-stu-id="210b7-236">If you add the `Overrides` modifier to a definition, the compiler implicitly adds `Overloads` so that you can type less code in common cases.</span></span>

<span data-ttu-id="210b7-237">**CObj permitido en argumentos de atributos**</span><span class="sxs-lookup"><span data-stu-id="210b7-237">**CObj allowed in attributes arguments**</span></span>

<span data-ttu-id="210b7-238">El compilador solía producir un error advirtiendo de que CObj(...) no era una constante cuando se usaba en construcciones de atributo.</span><span class="sxs-lookup"><span data-stu-id="210b7-238">The compiler used to give an error that CObj(…) was not a constant when used in attribute constructions.</span></span>

<span data-ttu-id="210b7-239">**Declaración y consumo de métodos ambiguos desde otras interfaces**</span><span class="sxs-lookup"><span data-stu-id="210b7-239">**Declaring and consuming ambiguous methods from different interfaces**</span></span>

<span data-ttu-id="210b7-240">Anteriormente, en el código siguiente producía errores que impedían declarar `IMock` o llamar a `GetDetails` (si estos se habían declarado en C#):</span><span class="sxs-lookup"><span data-stu-id="210b7-240">Previously the following code yielded errors that prevented you from declaring `IMock` or from calling `GetDetails` (if these had been declared in C#):</span></span>

```vb
Interface ICustomer
  Sub GetDetails(x As Integer)
End Interface

Interface ITime
  Sub GetDetails(x As String)
End Interface

Interface IMock : Inherits ICustomer, ITime
  Overloads Sub GetDetails(x As Char)
End Interface

Interface IMock2 : Inherits ICustomer, ITime
End Interface
```

<span data-ttu-id="210b7-241">Ahora el compilador usa las reglas de resolución de sobrecarga normales para elegir el `GetDetails` más apropiado que se va a llamar, y se pueden declarar relaciones de interfaz en Visual Basic como las que se muestran en el ejemplo.</span><span class="sxs-lookup"><span data-stu-id="210b7-241">Now the compiler will use normal overload resolution rules to choose the most appropriate `GetDetails` to call, and you can declare interface relationships in Visual Basic like those shown in the sample.</span></span>

## <a name="see-also"></a><span data-ttu-id="210b7-242">Vea también</span><span class="sxs-lookup"><span data-stu-id="210b7-242">See also</span></span>

- [<span data-ttu-id="210b7-243">Novedades de Visual Studio 2017</span><span class="sxs-lookup"><span data-stu-id="210b7-243">What's New in Visual Studio 2017</span></span>](/visualstudio/ide/whats-new-visual-studio-2017)
- [<span data-ttu-id="210b7-244">Novedades de Visual Studio 2019</span><span class="sxs-lookup"><span data-stu-id="210b7-244">What's New in Visual Studio 2019</span></span>](/visualstudio/ide/whats-new-visual-studio-2019)
