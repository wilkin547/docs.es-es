---
title: Recopilación de diagnósticos en contenedores
description: En este artículo, aprenderá cómo se pueden usar las herramientas de diagnóstico de .NET Core en contenedores de Docker.
ms.date: 09/01/2020
ms.openlocfilehash: cf4bbdf75e943f093a2202f91303a2eea7125487
ms.sourcegitcommit: 5114e7847e0ff8ddb8c266802d47af78567949cf
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 11/19/2020
ms.locfileid: "94916214"
---
# <a name="collect-diagnostics-in-containers"></a><span data-ttu-id="f54c0-103">Recopilación de diagnósticos en contenedores</span><span class="sxs-lookup"><span data-stu-id="f54c0-103">Collect diagnostics in containers</span></span>

<span data-ttu-id="f54c0-104">Las mismas herramientas de diagnóstico que son útiles para diagnosticar problemas de .NET Core en otros escenarios también funcionan en contenedores de Docker.</span><span class="sxs-lookup"><span data-stu-id="f54c0-104">The same diagnostics tools that are useful for diagnosing .NET Core issues in other scenarios also work in Docker containers.</span></span> <span data-ttu-id="f54c0-105">Sin embargo, algunas de las herramientas requieren pasos especiales para funcionar en un contenedor.</span><span class="sxs-lookup"><span data-stu-id="f54c0-105">However, some of the tools require special steps to work in a container.</span></span> <span data-ttu-id="f54c0-106">En este artículo se explica cómo se pueden usar herramientas para reunir seguimientos del rendimiento y recopilar volcados en contenedores de Docker.</span><span class="sxs-lookup"><span data-stu-id="f54c0-106">This article covers how tools for gathering performance traces and collecting dumps can be used in Docker containers.</span></span>

## <a name="using-net-core-cli-tools-in-a-container"></a><span data-ttu-id="f54c0-107">Uso de herramientas de CLI de .NET Core en un contenedor</span><span class="sxs-lookup"><span data-stu-id="f54c0-107">Using .NET Core CLI tools in a container</span></span>

<span data-ttu-id="f54c0-108">**Estas herramientas se aplican a: ✔️** SDK de .NET Core 3.0 y versiones posteriores</span><span class="sxs-lookup"><span data-stu-id="f54c0-108">**These tools apply to: ✔️** .NET Core 3.0 SDK and later versions</span></span>

<span data-ttu-id="f54c0-109">Las herramientas de diagnóstico de la CLI global de .NET Core ([`dotnet-counters`](dotnet-counters.md), [`dotnet-dump`](dotnet-dump.md), [`dotnet-gcdump`](dotnet-gcdump.md) y [`dotnet-trace`](dotnet-trace.md)) están diseñadas para funcionar en una amplia variedad de entornos y deberían funcionar directamente en contenedores de Docker.</span><span class="sxs-lookup"><span data-stu-id="f54c0-109">The .NET Core global CLI diagnostic tools ([`dotnet-counters`](dotnet-counters.md), [`dotnet-dump`](dotnet-dump.md), [`dotnet-gcdump`](dotnet-gcdump.md), and [`dotnet-trace`](dotnet-trace.md)) are designed to work in a wide variety of environments and should all work directly in Docker containers.</span></span> <span data-ttu-id="f54c0-110">Por este motivo, estas herramientas son el método preferido para recopilar información de diagnóstico para escenarios de .NET Core que tienen como destino .NET Core 3.0 o superior (o 3.1 o superior en el caso de `dotnet-gcdump`) en contenedores.</span><span class="sxs-lookup"><span data-stu-id="f54c0-110">Because of this, these tools are the preferred method of collecting diagnostic information for .NET Core scenarios targeting .NET Core 3.0 or above (or 3.1 or above in the case of `dotnet-gcdump`) in containers.</span></span>

<span data-ttu-id="f54c0-111">El único factor que complica el uso de estas herramientas en un contenedor es que se instalan con el SDK de .NET Core y muchos contenedores de Docker se ejecutan sin el SDK de .NET Core presente.</span><span class="sxs-lookup"><span data-stu-id="f54c0-111">The only complicating factor of using these tools in a container is that they are installed with the .NET Core SDK and many Docker containers run without the .NET Core SDK present.</span></span> <span data-ttu-id="f54c0-112">Una solución sencilla a este problema es instalar las herramientas en la imagen inicial de Docker.</span><span class="sxs-lookup"><span data-stu-id="f54c0-112">One easy solution to this problem is to install the tools in the initial Docker image.</span></span> <span data-ttu-id="f54c0-113">Las herramientas no necesitan que el SDK de .NET Core se ejecute, solo que esté instalado.</span><span class="sxs-lookup"><span data-stu-id="f54c0-113">The tools don't need the .NET Core SDK to run, only to be installed.</span></span> <span data-ttu-id="f54c0-114">Por lo tanto, es posible crear un Dockerfile con una [compilación de varias fases](https://docs.docker.com/develop/develop-images/multistage-build/) que instale las herramientas en una fase de compilación (donde esté presente el SDK de .NET Core) y, a continuación, copie los archivos binarios en la imagen final.</span><span class="sxs-lookup"><span data-stu-id="f54c0-114">Therefore, it's possible to create a Dockerfile with a [multi-stage build](https://docs.docker.com/develop/develop-images/multistage-build/) that installs the tools in a build stage (where the .NET Core SDK is present) and then copies the binaries into the final image.</span></span> <span data-ttu-id="f54c0-115">El único inconveniente de este enfoque es el aumento del tamaño de la imagen de Docker.</span><span class="sxs-lookup"><span data-stu-id="f54c0-115">The only downside to this approach is increased Docker image size.</span></span>

```dockerfile
# In build stage
# Install desired .NET CLI diagnostics tools
RUN dotnet tool install --tool-path /tools dotnet-trace
RUN dotnet tool install --tool-path /tools dotnet-counters
RUN dotnet tool install --tool-path /tools dotnet-dump

...

# In final stage
# Copy diagnostics tools
WORKDIR /tools
COPY --from=build /tools .
```

<span data-ttu-id="f54c0-116">Como alternativa, el SDK de .NET Core se puede instalar en un contenedor cuando sea necesario para instalar las herramientas de la CLI.</span><span class="sxs-lookup"><span data-stu-id="f54c0-116">Alternatively, the .NET Core SDK can be installed in a container when needed in order to install the CLI tools.</span></span> <span data-ttu-id="f54c0-117">Tenga en cuenta que la instalación del SDK de .NET Core tendrá como efecto secundario la reinstalación del entorno de ejecución de .NET Core.</span><span class="sxs-lookup"><span data-stu-id="f54c0-117">Be aware that installing the .NET Core SDK will have the side-effect of reinstalling the .NET Core runtime.</span></span> <span data-ttu-id="f54c0-118">Asegúrese de instalar la versión del SDK que coincida con el entorno de ejecución presente en el contenedor.</span><span class="sxs-lookup"><span data-stu-id="f54c0-118">So be sure to install the version of the SDK that matches the runtime present in the container.</span></span>

### <a name="using-net-core-global-cli-tools-in-a-sidecar-container"></a><span data-ttu-id="f54c0-119">Uso de las herramientas de la CLI global de .NET Core en un contenedor sidecar</span><span class="sxs-lookup"><span data-stu-id="f54c0-119">Using .NET Core global CLI tools in a sidecar container</span></span>

<span data-ttu-id="f54c0-120">Si desea usar las herramientas de diagnóstico de la CLI global de .NET Core para diagnosticar los procesos en otro contenedor, tenga en cuenta los siguientes requisitos adicionales:</span><span class="sxs-lookup"><span data-stu-id="f54c0-120">If you would like to use .NET Core global CLI diagnostic tools to diagnose processes in a different container, bear the following additional requirements in mind:</span></span>

1. <span data-ttu-id="f54c0-121">Los contenedores deben [compartir un espacio de nombres de proceso](https://docs.docker.com/engine/reference/run/#pid-settings---pid) (de modo que las herramientas del contenedor sidecar puedan acceder a los procesos del contenedor de destino).</span><span class="sxs-lookup"><span data-stu-id="f54c0-121">The containers must [share a process namespace](https://docs.docker.com/engine/reference/run/#pid-settings---pid) (so that tools in the sidecar container can access processes in the target container).</span></span>
2. <span data-ttu-id="f54c0-122">Las herramientas de diagnóstico de la CLI global de .NET Core necesitan acceso a los archivos que el entorno de ejecución de .NET Core escribe en el directorio /tmp, por lo que el directorio /tmp debe compartirse entre el contenedor de destino y sidecar a través de un montaje de volumen.</span><span class="sxs-lookup"><span data-stu-id="f54c0-122">The .NET Core global CLI diagnostic tools need access to files the .NET Core runtime writes to the /tmp directory, so the /tmp directory must be shared between the target and sidecar container via a volume mount.</span></span> <span data-ttu-id="f54c0-123">Esto puede hacerse, por ejemplo, haciendo que los contenedores compartan un [volumen](https://docs.docker.com/storage/volumes/#create-and-manage-volumes) común o un volumen [emptyDir](https://kubernetes.io/docs/concepts/storage/volumes/#emptydir) de Kubernetes.</span><span class="sxs-lookup"><span data-stu-id="f54c0-123">This could be done, for example, by having the containers share a common [volume](https://docs.docker.com/storage/volumes/#create-and-manage-volumes) or a Kubernetes [emptyDir](https://kubernetes.io/docs/concepts/storage/volumes/#emptydir) volume.</span></span> <span data-ttu-id="f54c0-124">Si intenta usar las herramientas de diagnóstico desde un contenedor sidecar sin compartir el directorio /tmp, obtendrá un error que indica que el proceso "no está ejecutando un entorno de ejecución de .NET compatible".</span><span class="sxs-lookup"><span data-stu-id="f54c0-124">If you attempt to use the diagnostic tools from a sidecar container without sharing the /tmp directory, you will get an error about the process "not running compatible .NET runtime."</span></span>

## <a name="using-perfcollect-in-a-container"></a><span data-ttu-id="f54c0-125">Uso de `PerfCollect` en un contenedor</span><span class="sxs-lookup"><span data-stu-id="f54c0-125">Using `PerfCollect` in a container</span></span>

<span data-ttu-id="f54c0-126">**Esta herramienta se aplica a: ✔️** .NET Core 2.1 y versiones posteriores</span><span class="sxs-lookup"><span data-stu-id="f54c0-126">**This tool applies to: ✔️** .NET Core 2.1 and later versions</span></span>

<span data-ttu-id="f54c0-127">El script [`PerfCollect`](./trace-perfcollect-lttng.md) resulta útil para recopilar seguimientos del rendimiento y es la herramienta recomendada para recopilar seguimientos anteriores a .NET Core 3.0.</span><span class="sxs-lookup"><span data-stu-id="f54c0-127">The [`PerfCollect`](./trace-perfcollect-lttng.md) script is useful for collecting performance traces and is the recommended tool for collecting traces prior to .NET Core 3.0.</span></span> <span data-ttu-id="f54c0-128">Si utiliza `PerfCollect` en un contenedor, tenga en cuenta los siguientes requisitos:</span><span class="sxs-lookup"><span data-stu-id="f54c0-128">If using `PerfCollect` in a container, keep the following requirements in mind:</span></span>

1. <span data-ttu-id="f54c0-129">`PerfCollect` requiere la [funcionalidad `SYS_ADMIN`](https://man7.org/linux/man-pages/man7/capabilities.7.html) (para ejecutar la herramienta `perf`), por lo que debe asegurarse de que el contenedor se [inicia con esa capacidad](https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities).</span><span class="sxs-lookup"><span data-stu-id="f54c0-129">`PerfCollect` requires the [`SYS_ADMIN` capability](https://man7.org/linux/man-pages/man7/capabilities.7.html) (in order to run the `perf` tool), so be sure the container is [started with that capability](https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities).</span></span>
2. <span data-ttu-id="f54c0-130">`PerfCollect` requiere que se establezcan algunas variables de entorno antes de que se inicie la generación de perfiles de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="f54c0-130">`PerfCollect` requires some environment variables be set prior to the app it is profiling starting.</span></span> <span data-ttu-id="f54c0-131">Se pueden establecer en un [Dockerfile](https://docs.docker.com/engine/reference/builder/#env) o cuando [se inicia el contenedor](https://docs.docker.com/engine/reference/run/#env-environment-variables).</span><span class="sxs-lookup"><span data-stu-id="f54c0-131">These can be set either in a [Dockerfile](https://docs.docker.com/engine/reference/builder/#env) or when [starting the container](https://docs.docker.com/engine/reference/run/#env-environment-variables).</span></span> <span data-ttu-id="f54c0-132">Dado que estas variables no deben establecerse en entornos de producción normales, es habitual simplemente agregarlas al iniciar un contenedor del que se va a crear un perfil.</span><span class="sxs-lookup"><span data-stu-id="f54c0-132">Because these variables shouldn't be set in normal production environments, it's common to just add them when starting a container that will be profiled.</span></span> <span data-ttu-id="f54c0-133">Las dos variables que requiere PerfCollect son:</span><span class="sxs-lookup"><span data-stu-id="f54c0-133">The two variables which PerfCollect requires are:</span></span>
    1. <span data-ttu-id="f54c0-134">COMPlus_PerfMapEnabled=1</span><span class="sxs-lookup"><span data-stu-id="f54c0-134">COMPlus_PerfMapEnabled=1</span></span>
    1. <span data-ttu-id="f54c0-135">COMPlus_EnableEventLog=1</span><span class="sxs-lookup"><span data-stu-id="f54c0-135">COMPlus_EnableEventLog=1</span></span>

### <a name="using-perfcollect-in-a-sidecar-container"></a><span data-ttu-id="f54c0-136">Uso de `PerfCollect` en un contenedor sidecar</span><span class="sxs-lookup"><span data-stu-id="f54c0-136">Using `PerfCollect` in a sidecar container</span></span>

<span data-ttu-id="f54c0-137">Si desea ejecutar `PerfCollect` en un contenedor para generar perfiles de un proceso de .NET Core en un contenedor diferente, la experiencia es prácticamente la misma, con la salvedad de estas diferencias:</span><span class="sxs-lookup"><span data-stu-id="f54c0-137">If you would like to run `PerfCollect` in one container to profile a .NET Core process in a different container, the experience is almost the same except for these differences:</span></span>

1. <span data-ttu-id="f54c0-138">Las variables de entorno mencionadas previamente (COMPlus_PerfMapEnabled y COMPlus_EnableEventLog) se deben establecer para el contenedor de destino (no el que ejecuta `PerfCollect`).</span><span class="sxs-lookup"><span data-stu-id="f54c0-138">The environment variables mentioned previously (COMPlus_PerfMapEnabled and COMPlus_EnableEventLog) must be set for the target container (not the one running `PerfCollect`).</span></span>
2. <span data-ttu-id="f54c0-139">El contenedor que ejecuta `PerfCollect` debe tener la funcionalidad `SYS_ADMIN` (no el contenedor de destino).</span><span class="sxs-lookup"><span data-stu-id="f54c0-139">The container running `PerfCollect` must have the `SYS_ADMIN` capability (not the target container).</span></span>
3. <span data-ttu-id="f54c0-140">Los dos contenedores deben [compartir un espacio de nombres de proceso](https://docs.docker.com/engine/reference/run/#pid-settings---pid).</span><span class="sxs-lookup"><span data-stu-id="f54c0-140">The two containers must [share a process namespace](https://docs.docker.com/engine/reference/run/#pid-settings---pid).</span></span>

## <a name="using-createdump-in-a-container"></a><span data-ttu-id="f54c0-141">Uso de `createdump` en un contenedor</span><span class="sxs-lookup"><span data-stu-id="f54c0-141">Using `createdump` in a container</span></span>

<span data-ttu-id="f54c0-142">**Esta herramienta se aplica a: ✔️** .NET Core 2.1 y versiones posteriores</span><span class="sxs-lookup"><span data-stu-id="f54c0-142">**This tool applies to: ✔️** .NET Core 2.1 and later versions</span></span>

<span data-ttu-id="f54c0-143">Alternativa a `dotnet-dump`, [`createdump`](https://github.com/dotnet/runtime/blob/master/docs/design/coreclr/botr/xplat-minidump-generation.md) se puede usar para crear volcados principales en Linux que contienen información nativa y administrada.</span><span class="sxs-lookup"><span data-stu-id="f54c0-143">An alternative to `dotnet-dump`, [`createdump`](https://github.com/dotnet/runtime/blob/master/docs/design/coreclr/botr/xplat-minidump-generation.md) can be used for creating core dumps on Linux containing both native and managed information.</span></span> <span data-ttu-id="f54c0-144">La herramienta `createdump` se instala con el entorno de ejecución de .NET y se puede encontrar junto a libcoreclr.so (normalmente en "/usr/share/dotnet/shared/Microsoft.NETCore.App/[versión]").</span><span class="sxs-lookup"><span data-stu-id="f54c0-144">The `createdump` tool is installed with the .NET Core runtime and can be found next to libcoreclr.so (typically in "/usr/share/dotnet/shared/Microsoft.NETCore.App/[version]").</span></span> <span data-ttu-id="f54c0-145">La herramienta funciona de la misma forma en un contenedor que en entornos de Linux no contenedores con la única excepción de que la herramienta requiere la [capacidad `SYS_PTRACE`](https://man7.org/linux/man-pages/man7/capabilities.7.html), por lo que el contenedor de Docker debe [iniciarse con esa capacidad](https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities).</span><span class="sxs-lookup"><span data-stu-id="f54c0-145">The tool works the same in a container as it does in non-containerized Linux environments with the single exception that the tool requires the [`SYS_PTRACE` capability](https://man7.org/linux/man-pages/man7/capabilities.7.html), so the Docker container must be [started with that capability](https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities).</span></span>

### <a name="using-createdump-in-a-sidecar-container"></a><span data-ttu-id="f54c0-146">Uso de `createdump` en un contenedor sidecar</span><span class="sxs-lookup"><span data-stu-id="f54c0-146">Using `createdump` in a sidecar container</span></span>

<span data-ttu-id="f54c0-147">Si desea usar `createdump` para crear un volcado de memoria a partir de un proceso en un contenedor diferente, la experiencia es prácticamente la misma, con la salvedad de estas diferencias:</span><span class="sxs-lookup"><span data-stu-id="f54c0-147">If you would like to use `createdump` to create a dump from a process in a different container, the experience is almost the same except for these differences:</span></span>

1. <span data-ttu-id="f54c0-148">El contenedor que ejecuta `createdump` debe tener la funcionalidad `SYS_PTRACE` (no el contenedor de destino).</span><span class="sxs-lookup"><span data-stu-id="f54c0-148">The container running `createdump` must have the `SYS_PTRACE` capability (not the target container).</span></span>
2. <span data-ttu-id="f54c0-149">Los dos contenedores deben [compartir un espacio de nombres de proceso](https://docs.docker.com/engine/reference/run/#pid-settings---pid).</span><span class="sxs-lookup"><span data-stu-id="f54c0-149">The two containers must [share a process namespace](https://docs.docker.com/engine/reference/run/#pid-settings---pid).</span></span>
