---
title: EventCounters de .NET Core
description: En este artículo se aprende qué son los EventCounters, cómo se implementan y cómo se usan.
ms.date: 08/07/2020
ms.openlocfilehash: 8efa3134e83ba6fdc7563e97ef6422cb5f2099b6
ms.sourcegitcommit: c7f0beaa2bd66ebca86362ca17d673f7e8256ca6
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 03/23/2021
ms.locfileid: "104872787"
---
# <a name="eventcounters-in-net-core"></a><span data-ttu-id="cca74-103">EventCounters de .NET Core</span><span class="sxs-lookup"><span data-stu-id="cca74-103">EventCounters in .NET Core</span></span>

<span data-ttu-id="cca74-104">**Este artículo se aplica a: ✔️** SDK de .NET Core 3.0 y versiones posteriores</span><span class="sxs-lookup"><span data-stu-id="cca74-104">**This article applies to: ✔️** .NET Core 3.0 SDK and later versions</span></span>

<span data-ttu-id="cca74-105">Los EventCounters son las API de .NET Core que se usan para la recopilación ligera, multiplataforma y casi en tiempo real de métricas de rendimiento.</span><span class="sxs-lookup"><span data-stu-id="cca74-105">EventCounters are .NET Core APIs used for lightweight, cross-platform, and near real-time performance metric collection.</span></span> <span data-ttu-id="cca74-106">Los EventCounters se agregaron como una alternativa multiplataforma a los "contadores de rendimiento" de .NET Framework en Windows.</span><span class="sxs-lookup"><span data-stu-id="cca74-106">EventCounters were added as a cross-platform alternative to the "performance counters" of the .NET Framework on Windows.</span></span> <span data-ttu-id="cca74-107">En este artículo se aprende qué son los EventCounters, cómo se implementan y cómo se usan.</span><span class="sxs-lookup"><span data-stu-id="cca74-107">In this article you'll learn what EventCounters are, how to implement them, and how to consume them.</span></span>

<span data-ttu-id="cca74-108">El entorno de ejecución de .NET Core y algunas bibliotecas de .NET publican información de diagnóstico básica mediante EventCounters a partir de .NET Core 3.0.</span><span class="sxs-lookup"><span data-stu-id="cca74-108">The .NET Core runtime and a few .NET libraries publish basic diagnostics information using EventCounters starting in .NET Core 3.0.</span></span> <span data-ttu-id="cca74-109">Además de los EventCounters proporcionados por el entorno de ejecución de .NET, puede implementar sus propios EventCounters.</span><span class="sxs-lookup"><span data-stu-id="cca74-109">Apart from the EventCounters that are provided by the .NET runtime, you may choose to implement your own EventCounters.</span></span> <span data-ttu-id="cca74-110">Los EventCounters se pueden usar para realizar el seguimiento de diversas métricas.</span><span class="sxs-lookup"><span data-stu-id="cca74-110">EventCounters can be used to track various metrics.</span></span> <span data-ttu-id="cca74-111">Obtenga más información en [EventCounters conocidos en .NET](available-counters.md)</span><span class="sxs-lookup"><span data-stu-id="cca74-111">Learn more about them in the [well-known EventCounters in .NET](available-counters.md)</span></span>

<span data-ttu-id="cca74-112">Los EventCounters existen como parte de <xref:System.Diagnostics.Tracing.EventSource> y se insertan automáticamente en las herramientas de escucha de forma periódica.</span><span class="sxs-lookup"><span data-stu-id="cca74-112">EventCounters live as a part of an <xref:System.Diagnostics.Tracing.EventSource>, and are automatically pushed to listener tools on a regular basis.</span></span> <span data-ttu-id="cca74-113">Al igual que todos los demás eventos de <xref:System.Diagnostics.Tracing.EventSource>, se pueden consumir en proceso y fuera de proceso mediante <xref:System.Diagnostics.Tracing.EventListener> y [EventPipe](./eventpipe.md).</span><span class="sxs-lookup"><span data-stu-id="cca74-113">Like all other events on an <xref:System.Diagnostics.Tracing.EventSource>, they can be consumed both in-proc and out-of-proc via <xref:System.Diagnostics.Tracing.EventListener> and [EventPipe](./eventpipe.md).</span></span> <span data-ttu-id="cca74-114">Este artículo se centra en las capacidades multiplataforma de los EventCounters y excluye de forma deliberada a PerfView y ETW (seguimiento de eventos para Windows), aunque ambos se pueden usar con los EventCounters.</span><span class="sxs-lookup"><span data-stu-id="cca74-114">This article focuses on the cross-platform capabilities of EventCounters, and intentionally excludes PerfView and ETW (Event Tracing for Windows) - although both can be used with EventCounters.</span></span>

![Imagen de diagrama de EventCounters en proceso y fuera de proceso](media/event-counters.svg)

## <a name="eventcounter-api-overview"></a><span data-ttu-id="cca74-116">Información general sobre la API EventCounter</span><span class="sxs-lookup"><span data-stu-id="cca74-116">EventCounter API overview</span></span>

<span data-ttu-id="cca74-117">Hay dos categorías principales de contadores.</span><span class="sxs-lookup"><span data-stu-id="cca74-117">There are two primary categories of counters.</span></span> <span data-ttu-id="cca74-118">Algunos contadores son para valores de tipo "tasa", como el número total de excepciones, el número total de GC y el número total de solicitudes.</span><span class="sxs-lookup"><span data-stu-id="cca74-118">Some counters are for "rate" values, such as total number of exceptions, total number of GCs, and total number of requests.</span></span> <span data-ttu-id="cca74-119">Otros contadores son valores de tipo "instantánea", como el uso del montón, el uso de la CPU y el tamaño del espacio de trabajo.</span><span class="sxs-lookup"><span data-stu-id="cca74-119">Other counters are "snapshot" values, such as heap usage, CPU usage, and working set size.</span></span> <span data-ttu-id="cca74-120">Dentro de cada una de estas categorías de contadores, hay dos tipos de contadores que varían según el modo en que obtienen su valor.</span><span class="sxs-lookup"><span data-stu-id="cca74-120">Within each of these categories of counters, there are two types of counters that vary by how they get their value.</span></span> <span data-ttu-id="cca74-121">Los contadores de sondeo recuperan su valor por medio de una devolución de llamada, mientras que los contadores que no son de sondeo tienen sus valores establecidos directamente en la instancia de contador.</span><span class="sxs-lookup"><span data-stu-id="cca74-121">Polling counters retrieve their value via a callback, and non-polling counters have their values directly set on the counter instance.</span></span>

<span data-ttu-id="cca74-122">Los contadores se representan mediante las siguientes implementaciones:</span><span class="sxs-lookup"><span data-stu-id="cca74-122">The counters are represented by the following implementations:</span></span>

* <xref:System.Diagnostics.Tracing.EventCounter>
* <xref:System.Diagnostics.Tracing.IncrementingEventCounter>
* <xref:System.Diagnostics.Tracing.IncrementingPollingCounter>
* <xref:System.Diagnostics.Tracing.PollingCounter>

<span data-ttu-id="cca74-123">Una escucha de eventos especifica la duración de los intervalos de medición.</span><span class="sxs-lookup"><span data-stu-id="cca74-123">An event listener specifies how long measurement intervals are.</span></span> <span data-ttu-id="cca74-124">Al final de cada intervalo se transmite un valor a la escucha de cada contador.</span><span class="sxs-lookup"><span data-stu-id="cca74-124">At the end of each interval a value is transmitted to the listener for each counter.</span></span> <span data-ttu-id="cca74-125">Las implementaciones de un contador determinan las API y los cálculos que se usan para generar el valor de cada intervalo.</span><span class="sxs-lookup"><span data-stu-id="cca74-125">The implementations of a counter determine what APIs and calculations are used to produce the value each interval.</span></span>

1. <span data-ttu-id="cca74-126"><xref:System.Diagnostics.Tracing.EventCounter> registra un conjunto de valores.</span><span class="sxs-lookup"><span data-stu-id="cca74-126">The <xref:System.Diagnostics.Tracing.EventCounter> records a set of values.</span></span> <span data-ttu-id="cca74-127">El método <xref:System.Diagnostics.Tracing.EventCounter.WriteMetric%2A?displayProperty=nameWithType> agrega un nuevo valor al conjunto.</span><span class="sxs-lookup"><span data-stu-id="cca74-127">The <xref:System.Diagnostics.Tracing.EventCounter.WriteMetric%2A?displayProperty=nameWithType> method adds a new value to the set.</span></span> <span data-ttu-id="cca74-128">Con cada intervalo se calcula un resumen estadístico del conjunto, como valor mínimo, máximo y medio.</span><span class="sxs-lookup"><span data-stu-id="cca74-128">With each interval, a statistical summary for the set is computed, such as the min, max, and mean.</span></span> <span data-ttu-id="cca74-129">La herramienta [dotnet-counters](dotnet-counters.md) siempre muestra el valor medio.</span><span class="sxs-lookup"><span data-stu-id="cca74-129">The [dotnet-counters](dotnet-counters.md) tool will always display the mean value.</span></span> <span data-ttu-id="cca74-130"><xref:System.Diagnostics.Tracing.EventCounter> es útil para describir un conjunto discreto de operaciones.</span><span class="sxs-lookup"><span data-stu-id="cca74-130">The <xref:System.Diagnostics.Tracing.EventCounter> is useful to describe a discrete set of operations.</span></span> <span data-ttu-id="cca74-131">Su uso habitual puede incluir la supervisión del tamaño medio en bytes de operaciones de E/S recientes o el valor monetario medio de un conjunto de transacciones financieras.</span><span class="sxs-lookup"><span data-stu-id="cca74-131">Common usage may include monitoring the average size in bytes of recent IO operations, or the average monetary value of a set of financial transactions.</span></span>

1. <span data-ttu-id="cca74-132"><xref:System.Diagnostics.Tracing.IncrementingEventCounter> registra un total acumulado de cada intervalo de tiempo.</span><span class="sxs-lookup"><span data-stu-id="cca74-132">The <xref:System.Diagnostics.Tracing.IncrementingEventCounter> records a running total for each time interval.</span></span> <span data-ttu-id="cca74-133">El método <xref:System.Diagnostics.Tracing.IncrementingEventCounter.Increment%2A?displayProperty=nameWithType> agrega al total.</span><span class="sxs-lookup"><span data-stu-id="cca74-133">The <xref:System.Diagnostics.Tracing.IncrementingEventCounter.Increment%2A?displayProperty=nameWithType> method adds to the total.</span></span> <span data-ttu-id="cca74-134">Por ejemplo, si se llama a `Increment()` tres veces durante un intervalo con valores `1`, `2` y `5`, el total acumulado de `8` se comunica como valor del contador de este intervalo.</span><span class="sxs-lookup"><span data-stu-id="cca74-134">For example, if `Increment()` is called three times during one interval with values `1`, `2`, and `5`, then the running total of `8` will be reported as the counter value for this interval.</span></span> <span data-ttu-id="cca74-135">La herramienta [dotnet-counters](dotnet-counters.md) muestra la tasa como el total / tiempo registrado.</span><span class="sxs-lookup"><span data-stu-id="cca74-135">The [dotnet-counters](dotnet-counters.md) tool will display the rate as the recorded total / time.</span></span> <span data-ttu-id="cca74-136"><xref:System.Diagnostics.Tracing.IncrementingEventCounter> resulta útil para medir la frecuencia con que se produce una acción, como el número de solicitudes procesadas por segundo.</span><span class="sxs-lookup"><span data-stu-id="cca74-136">The <xref:System.Diagnostics.Tracing.IncrementingEventCounter> is useful to measure how frequently an action is occurring, such as the number of requests processed per second.</span></span>

1. <span data-ttu-id="cca74-137"><xref:System.Diagnostics.Tracing.PollingCounter> usa una devolución de llamada para determinar el valor que se comunica.</span><span class="sxs-lookup"><span data-stu-id="cca74-137">The <xref:System.Diagnostics.Tracing.PollingCounter> uses a callback to determine the value that is reported.</span></span> <span data-ttu-id="cca74-138">Con cada intervalo de tiempo se invoca a la función de devolución de llamada proporcionada por el usuario y se usa el valor devuelto como valor del contador.</span><span class="sxs-lookup"><span data-stu-id="cca74-138">With each time interval, the user provided callback function is invoked and the return value is used as the counter value.</span></span> <span data-ttu-id="cca74-139"><xref:System.Diagnostics.Tracing.PollingCounter> se puede usar para consultar una métrica de un origen externo, por ejemplo, para obtener los bytes libres actuales en un disco.</span><span class="sxs-lookup"><span data-stu-id="cca74-139">A <xref:System.Diagnostics.Tracing.PollingCounter> can be used to query a metric from an external source, for example getting the current free bytes on a disk.</span></span> <span data-ttu-id="cca74-140">También se puede usar para notificar estadísticas personalizadas que una aplicación puede calcular a petición.</span><span class="sxs-lookup"><span data-stu-id="cca74-140">It can also be used to report custom statistics that can be computed on demand by an application.</span></span> <span data-ttu-id="cca74-141">Los ejemplos incluyen los informes del percentil 95 de las latencias de solicitud recientes o la proporción de aciertos o errores actual de una caché.</span><span class="sxs-lookup"><span data-stu-id="cca74-141">Examples include reporting the 95th percentile of recent request latencies, or the current hit or miss ratio of a cache.</span></span>

1. <span data-ttu-id="cca74-142"><xref:System.Diagnostics.Tracing.IncrementingPollingCounter> usa una devolución de llamada para determinar el valor de incremento comunicado.</span><span class="sxs-lookup"><span data-stu-id="cca74-142">The <xref:System.Diagnostics.Tracing.IncrementingPollingCounter> uses a callback to determine the reported increment value.</span></span> <span data-ttu-id="cca74-143">Con cada intervalo de tiempo se invoca a la devolución de llamada y la diferencia entre la invocación actual y la última es el valor comunicado.</span><span class="sxs-lookup"><span data-stu-id="cca74-143">With each time interval, the callback is invoked, and then the difference between the current invocation, and the last invocation is the reported value.</span></span> <span data-ttu-id="cca74-144">La herramienta [dotnet-counters](dotnet-counters.md) siempre muestra la diferencia como una tasa, el valor / tiempo comunicado.</span><span class="sxs-lookup"><span data-stu-id="cca74-144">The [dotnet-counters](dotnet-counters.md) tool will always display the difference as a rate, the reported value / time.</span></span> <span data-ttu-id="cca74-145">Este contador es útil cuando no resulta factible llamar a una API en cada repetición, pero es posible consultar el número total de repeticiones.</span><span class="sxs-lookup"><span data-stu-id="cca74-145">This counter is useful when it isn't feasible to call an API on each occurrence, but it's possible to query the total number of occurrences.</span></span> <span data-ttu-id="cca74-146">Por ejemplo, puede notificar el número de bytes escritos en un archivo por segundo, incluso sin una notificación cada vez que se escribe un byte.</span><span class="sxs-lookup"><span data-stu-id="cca74-146">For example, you could report the number of bytes written to a file per second, even without a notification each time a byte is written.</span></span>

## <a name="implement-an-eventsource"></a><span data-ttu-id="cca74-147">Implementación de un EventSource</span><span class="sxs-lookup"><span data-stu-id="cca74-147">Implement an EventSource</span></span>

<span data-ttu-id="cca74-148">En el código siguiente se implementa un ejemplo <xref:System.Diagnostics.Tracing.EventSource> expuesto como proveedor `"Sample.EventCounter.Minimal"` con nombre.</span><span class="sxs-lookup"><span data-stu-id="cca74-148">The following code implements a sample <xref:System.Diagnostics.Tracing.EventSource> exposed as the named `"Sample.EventCounter.Minimal"` provider.</span></span> <span data-ttu-id="cca74-149">Este origen contiene un <xref:System.Diagnostics.Tracing.EventCounter> que representa el tiempo de procesamiento de la solicitud.</span><span class="sxs-lookup"><span data-stu-id="cca74-149">This source contains an <xref:System.Diagnostics.Tracing.EventCounter> representing request processing time.</span></span> <span data-ttu-id="cca74-150">Un contador de este tipo tiene un nombre (es decir, su identificador único en el origen) y un nombre para mostrar, ambos usados por herramientas de escucha como [dotnet-counter](dotnet-counters.md).</span><span class="sxs-lookup"><span data-stu-id="cca74-150">Such a counter has a name (that is, its unique ID in the source) and a display name, both used by listener tools such as [dotnet-counter](dotnet-counters.md).</span></span>

:::code language="csharp" source="snippets/EventCounters/MinimalEventCounterSource.cs":::

<span data-ttu-id="cca74-151">Use `dotnet-counters ps` para mostrar una lista de los procesos de .NET que se pueden supervisar:</span><span class="sxs-lookup"><span data-stu-id="cca74-151">You use `dotnet-counters ps` to display a list of .NET processes that can be monitored:</span></span>

```console
dotnet-counters ps
   1398652 dotnet     C:\Program Files\dotnet\dotnet.exe
   1399072 dotnet     C:\Program Files\dotnet\dotnet.exe
   1399112 dotnet     C:\Program Files\dotnet\dotnet.exe
   1401880 dotnet     C:\Program Files\dotnet\dotnet.exe
   1400180 sample-counters C:\sample-counters\bin\Debug\netcoreapp3.1\sample-counters.exe
```

<span data-ttu-id="cca74-152">Pase el nombre <xref:System.Diagnostics.Tracing.EventSource> a la opción `--counters` para empezar a supervisar el contador:</span><span class="sxs-lookup"><span data-stu-id="cca74-152">Pass the <xref:System.Diagnostics.Tracing.EventSource> name to the `--counters` option to start monitoring your counter:</span></span>

```console
dotnet-counters monitor --process-id 1400180 --counters Sample.EventCounter.Minimal
```

<span data-ttu-id="cca74-153">En el siguiente ejemplo se muestra la salida de la supervisión:</span><span class="sxs-lookup"><span data-stu-id="cca74-153">The following example shows monitor output:</span></span>

```console
Press p to pause, r to resume, q to quit.
    Status: Running

[Samples-EventCounterDemos-Minimal]
    Request Processing Time (ms)                            0.445
```

<span data-ttu-id="cca74-154">Presione <kbd>q</kbd> para detener el comando de supervisión.</span><span class="sxs-lookup"><span data-stu-id="cca74-154">Press <kbd>q</kbd> to stop the monitoring command.</span></span>

#### <a name="conditional-counters"></a><span data-ttu-id="cca74-155">Contadores condicionales</span><span class="sxs-lookup"><span data-stu-id="cca74-155">Conditional counters</span></span>

<span data-ttu-id="cca74-156">Al implementar un <xref:System.Diagnostics.Tracing.EventSource>, se puede crear de forma condicional una instancia de los contadores contenedores al llamar al método <xref:System.Diagnostics.Tracing.EventSource.OnEventCommand%2A?displayProperty=nameWithType> con un valor <xref:System.Diagnostics.Tracing.EventCommandEventArgs.Command> de `EventCommand.Enable`.</span><span class="sxs-lookup"><span data-stu-id="cca74-156">When implementing an <xref:System.Diagnostics.Tracing.EventSource>, the containing counters can be conditionally instantiated when the <xref:System.Diagnostics.Tracing.EventSource.OnEventCommand%2A?displayProperty=nameWithType> method is called with a <xref:System.Diagnostics.Tracing.EventCommandEventArgs.Command> value of `EventCommand.Enable`.</span></span> <span data-ttu-id="cca74-157">Para crear una instancia de un contador de forma segura solo si es `null`, use el [operador de asignación de uso combinado de NULL](../../csharp/language-reference/operators/null-coalescing-operator.md).</span><span class="sxs-lookup"><span data-stu-id="cca74-157">To safely instantiate a counter instance only if it is `null`, use the [null-coalescing assignment operator](../../csharp/language-reference/operators/null-coalescing-operator.md).</span></span> <span data-ttu-id="cca74-158">Además, los métodos personalizados pueden evaluar el método <xref:System.Diagnostics.DiagnosticSource.IsEnabled%2A> para determinar si el origen del evento actual está habilitado o no.</span><span class="sxs-lookup"><span data-stu-id="cca74-158">Additionally, custom methods can evaluate the <xref:System.Diagnostics.DiagnosticSource.IsEnabled%2A> method to determine whether or not the current event source is enabled.</span></span>

:::code language="csharp" source="snippets/EventCounters/ConditionalEventCounterSource.cs":::

> [!TIP]
> <span data-ttu-id="cca74-159">Los contadores condicionales son contadores de los que se crean instancias de forma condicional, una microoptimización.</span><span class="sxs-lookup"><span data-stu-id="cca74-159">Conditional counters are counters that are conditionally instantiated, a micro-optimization.</span></span> <span data-ttu-id="cca74-160">El entorno de ejecución adopta este patrón para los escenarios en los que normalmente no se usan contadores, para ahorrar una fracción de un milisegundo.</span><span class="sxs-lookup"><span data-stu-id="cca74-160">The runtime adopts this pattern for scenarios where counters are normally not used, to save a fraction of a millisecond.</span></span>

### <a name="net-core-runtime-example-counters"></a><span data-ttu-id="cca74-161">Contadores de ejemplo del entorno de ejecución de .NET Core</span><span class="sxs-lookup"><span data-stu-id="cca74-161">.NET Core runtime example counters</span></span>

<span data-ttu-id="cca74-162">Hay muchas implementaciones de ejemplo excelentes del entorno de ejecución de .NET Core.</span><span class="sxs-lookup"><span data-stu-id="cca74-162">There are many great example implementations in the .NET Core runtime.</span></span> <span data-ttu-id="cca74-163">Esta es la implementación del entorno de ejecución del contador que realiza el seguimiento del tamaño del espacio de trabajo de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="cca74-163">Here is the runtime implementation for the counter that tracks the working set size of the application.</span></span>

```csharp
var workingSetCounter = new PollingCounter(
    "working-set",
    this,
    () => (double)(Environment.WorkingSet / 1_000_000))
{
    DisplayName = "Working Set",
    DisplayUnits = "MB"
};
```

<span data-ttu-id="cca74-164"><xref:System.Diagnostics.Tracing.PollingCounter> comunica la cantidad actual de memoria física asignada al proceso (espacio de trabajo) de la aplicación, ya que captura una métrica en un momento dado.</span><span class="sxs-lookup"><span data-stu-id="cca74-164">The <xref:System.Diagnostics.Tracing.PollingCounter> reports the current amount of physical memory mapped to the process (working set) of the app, since it captures a metric at a moment in time.</span></span> <span data-ttu-id="cca74-165">La devolución de llamada del sondeo de un valor es la expresión lambda proporcionada, que es simplemente una llamada a la API <xref:System.Environment.WorkingSet?displayProperty=fullName>.</span><span class="sxs-lookup"><span data-stu-id="cca74-165">The callback for polling a value is the provided lambda expression, which is just a call to the <xref:System.Environment.WorkingSet?displayProperty=fullName> API.</span></span> <span data-ttu-id="cca74-166"><xref:System.Diagnostics.Tracing.DiagnosticCounter.DisplayName> y <xref:System.Diagnostics.Tracing.DiagnosticCounter.DisplayUnits> son propiedades opcionales que se pueden establecer para ayudar al lado del consumidor del contador a mostrar el valor con más claridad.</span><span class="sxs-lookup"><span data-stu-id="cca74-166"><xref:System.Diagnostics.Tracing.DiagnosticCounter.DisplayName> and <xref:System.Diagnostics.Tracing.DiagnosticCounter.DisplayUnits> are optional properties that can be set to help the consumer side of the counter to display the value more clearly.</span></span> <span data-ttu-id="cca74-167">Por ejemplo, [dotnet-counters](dotnet-counters.md) usa estas propiedades para mostrar la versión más descriptiva de los nombres de contador.</span><span class="sxs-lookup"><span data-stu-id="cca74-167">For example, [dotnet-counters](dotnet-counters.md) uses these properties to display the more display-friendly version of the counter names.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="cca74-168">Las propiedades `DisplayName` no están traducidas.</span><span class="sxs-lookup"><span data-stu-id="cca74-168">The `DisplayName` properties are not localized.</span></span>

<span data-ttu-id="cca74-169">En el caso de <xref:System.Diagnostics.Tracing.PollingCounter> e <xref:System.Diagnostics.Tracing.IncrementingPollingCounter>, no es necesario hacer nada más.</span><span class="sxs-lookup"><span data-stu-id="cca74-169">For the <xref:System.Diagnostics.Tracing.PollingCounter>, and the <xref:System.Diagnostics.Tracing.IncrementingPollingCounter>, nothing else needs to be done.</span></span> <span data-ttu-id="cca74-170">Ambos sondean los valores por sí mismos en un intervalo solicitado por el consumidor.</span><span class="sxs-lookup"><span data-stu-id="cca74-170">They both poll the values themselves at an interval requested by the consumer.</span></span>

<span data-ttu-id="cca74-171">Este es un ejemplo de un contador de entorno de ejecución implementado mediante <xref:System.Diagnostics.Tracing.IncrementingPollingCounter>.</span><span class="sxs-lookup"><span data-stu-id="cca74-171">Here is an example of a runtime counter implemented using <xref:System.Diagnostics.Tracing.IncrementingPollingCounter>.</span></span>

```csharp
var monitorContentionCounter = new IncrementingPollingCounter(
    "monitor-lock-contention-count",
    this,
    () => Monitor.LockContentionCount
)
{
    DisplayName = "Monitor Lock Contention Count",
    DisplayRateTimeScale = TimeSpan.FromSeconds(1)
};
```

<span data-ttu-id="cca74-172"><xref:System.Diagnostics.Tracing.IncrementingPollingCounter> usa la API <xref:System.Threading.Monitor.LockContentionCount?displayProperty=nameWithType> para comunicar el incremento del recuento total de contenciones de bloqueo.</span><span class="sxs-lookup"><span data-stu-id="cca74-172">The <xref:System.Diagnostics.Tracing.IncrementingPollingCounter> uses the <xref:System.Threading.Monitor.LockContentionCount?displayProperty=nameWithType> API to report the increment of the total lock contention count.</span></span> <span data-ttu-id="cca74-173">La propiedad <xref:System.Diagnostics.Tracing.IncrementingPollingCounter.DisplayRateTimeScale> es opcional pero, cuando se usa, puede proporcionar una sugerencia sobre el intervalo de tiempo en el que se muestra mejor el contador.</span><span class="sxs-lookup"><span data-stu-id="cca74-173">The <xref:System.Diagnostics.Tracing.IncrementingPollingCounter.DisplayRateTimeScale> property is optional, but when used it can provide a hint for what time interval the counter is best displayed at.</span></span> <span data-ttu-id="cca74-174">Por ejemplo, el recuento de contenciones de bloqueo se muestra mejor como _recuento por segundo_, por lo que <xref:System.Diagnostics.Tracing.IncrementingPollingCounter.DisplayRateTimeScale> se establece en un segundo.</span><span class="sxs-lookup"><span data-stu-id="cca74-174">For example, the lock contention count is best displayed as _count per second_, so its <xref:System.Diagnostics.Tracing.IncrementingPollingCounter.DisplayRateTimeScale> is set to one second.</span></span> <span data-ttu-id="cca74-175">La tasa de presentación se puede ajustar a diferentes tipos de contadores de tasa.</span><span class="sxs-lookup"><span data-stu-id="cca74-175">The display rate can be adjusted for different types of rate counters.</span></span>

> [!NOTE]
> <span data-ttu-id="cca74-176">[dotnet-counters](dotnet-counters.md) _no_ usa <xref:System.Diagnostics.Tracing.IncrementingPollingCounter.DisplayRateTimeScale>, y no es necesario que las escuchas de eventos lo usen.</span><span class="sxs-lookup"><span data-stu-id="cca74-176">The <xref:System.Diagnostics.Tracing.IncrementingPollingCounter.DisplayRateTimeScale> is _not_ used by [dotnet-counters](dotnet-counters.md), and event listeners are not required to use it.</span></span>

<span data-ttu-id="cca74-177">Hay más implementaciones de contador que se pueden usar como referencia en el repositorio del [entorno de ejecución de .NET](https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/Diagnostics/Tracing/RuntimeEventSource.cs).</span><span class="sxs-lookup"><span data-stu-id="cca74-177">There are more counter implementations to use as a reference in the [.NET runtime](https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/Diagnostics/Tracing/RuntimeEventSource.cs) repo.</span></span>

## <a name="concurrency"></a><span data-ttu-id="cca74-178">Simultaneidad</span><span class="sxs-lookup"><span data-stu-id="cca74-178">Concurrency</span></span>

> [!TIP]
> <span data-ttu-id="cca74-179">La API de EventCounters no garantiza la seguridad para subprocesos.</span><span class="sxs-lookup"><span data-stu-id="cca74-179">The EventCounters API does not guarantee thread safety.</span></span> <span data-ttu-id="cca74-180">Cuando varios subprocesos llaman a los delegados pasados a instancias <xref:System.Diagnostics.Tracing.PollingCounter> o <xref:System.Diagnostics.Tracing.IncrementingPollingCounter>, es responsabilidad suya garantizar la seguridad para subprocesos de los delegados.</span><span class="sxs-lookup"><span data-stu-id="cca74-180">When the delegates passed to <xref:System.Diagnostics.Tracing.PollingCounter> or <xref:System.Diagnostics.Tracing.IncrementingPollingCounter> instances are called by multiple threads, it's your responsibility to guarantee the delegates' thread-safety.</span></span>

<span data-ttu-id="cca74-181">Por ejemplo, considere el siguiente <xref:System.Diagnostics.Tracing.EventSource> para realizar un seguimiento de las solicitudes.</span><span class="sxs-lookup"><span data-stu-id="cca74-181">For example, consider the following <xref:System.Diagnostics.Tracing.EventSource> to keep track of requests.</span></span>

:::code language="csharp" source="snippets/EventCounters/RequestEventSource.cs":::

<span data-ttu-id="cca74-182">Se puede llamar al método `AddRequest()` desde un controlador de solicitudes y `RequestRateCounter` sondea el valor en el intervalo especificado por el consumidor del contador.</span><span class="sxs-lookup"><span data-stu-id="cca74-182">The `AddRequest()` method can be called from a request handler, and the `RequestRateCounter` polls the value at the interval specified by the consumer of the counter.</span></span> <span data-ttu-id="cca74-183">Pero varios subprocesos pueden llamar al método `AddRequest()` a la vez, con lo que se coloca una condición de carrera sobre `_requestCount`.</span><span class="sxs-lookup"><span data-stu-id="cca74-183">However, the `AddRequest()` method can be called by multiple threads at once, putting a race condition on `_requestCount`.</span></span> <span data-ttu-id="cca74-184">Una manera alternativa segura para subprocesos de incrementar `_requestCount` es usar <xref:System.Threading.Interlocked.Increment%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="cca74-184">A thread-safe alternative way to increment the `_requestCount` is to use <xref:System.Threading.Interlocked.Increment%2A?displayProperty=nameWithType>.</span></span>

```csharp
public void AddRequest() => Interlocked.Increment(ref _requestCount);
```

<span data-ttu-id="cca74-185">Para evitar lecturas rasgadas (en arquitecturas de 32 bits) del campo `_requestCount` de tipo `long`, use <xref:System.Threading.Interlocked.Read%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="cca74-185">To prevent torn reads (on 32-bit architectures) of the `long`-field `_requestCount` use <xref:System.Threading.Interlocked.Read%2A?displayProperty=nameWithType>.</span></span>

```csharp
_requestRateCounter = new IncrementingPollingCounter("request-rate", this, () => Interlocked.Read(ref _requestCount))
{
    DisplayName = "Request Rate",
    DisplayRateTimeScale = TimeSpan.FromSeconds(1)
};
```

## <a name="consume-eventcounters"></a><span data-ttu-id="cca74-186">Uso de EventCounters</span><span class="sxs-lookup"><span data-stu-id="cca74-186">Consume EventCounters</span></span>

<span data-ttu-id="cca74-187">Hay dos formas principales de usar EventCounters, en proceso o fuera de proceso.</span><span class="sxs-lookup"><span data-stu-id="cca74-187">There are two primary ways of consuming EventCounters, either in-proc, or out-of-proc.</span></span> <span data-ttu-id="cca74-188">El uso de EventCounters se puede clasificar en tres capas de distintas tecnologías de uso.</span><span class="sxs-lookup"><span data-stu-id="cca74-188">The consumption of EventCounters can be distinguished into three layers of various consuming technologies.</span></span>

- <span data-ttu-id="cca74-189">Transporte de eventos en una secuencia sin formato a través de ETW o EventPipe:</span><span class="sxs-lookup"><span data-stu-id="cca74-189">Transporting events in a raw stream via ETW or EventPipe:</span></span>
  - <span data-ttu-id="cca74-190">Las API de ETW están incluidas en el sistema operativo Windows y se puede acceder a EventPipe como una [API de .NET](https://github.com/dotnet/diagnostics/blob/main/documentation/design-docs/diagnostics-client-library.md#1-attaching-to-a-process-and-dumping-out-all-the-runtime-gc-events-in-real-time-to-the-console) o el [protocolo IPC](https://github.com/dotnet/diagnostics/blob/main/documentation/design-docs/ipc-protocol.md) de diagnóstico.</span><span class="sxs-lookup"><span data-stu-id="cca74-190">ETW APIs come with the Windows OS, and EventPipe is accessible as a [.NET API](https://github.com/dotnet/diagnostics/blob/main/documentation/design-docs/diagnostics-client-library.md#1-attaching-to-a-process-and-dumping-out-all-the-runtime-gc-events-in-real-time-to-the-console), or the diagnostic [IPC protocol](https://github.com/dotnet/diagnostics/blob/main/documentation/design-docs/ipc-protocol.md).</span></span>
- <span data-ttu-id="cca74-191">Descodificación del flujo de eventos binario en eventos:</span><span class="sxs-lookup"><span data-stu-id="cca74-191">Decoding the binary event stream into events:</span></span>
  - <span data-ttu-id="cca74-192">La [biblioteca TraceEvent](https://www.nuget.org/packages/Microsoft.Diagnostics.Tracing.TraceEvent) controla los formatos de flujo de ETW y EventPipe.</span><span class="sxs-lookup"><span data-stu-id="cca74-192">The [TraceEvent library](https://www.nuget.org/packages/Microsoft.Diagnostics.Tracing.TraceEvent) handles both ETW and EventPipe stream formats.</span></span>
- <span data-ttu-id="cca74-193">Herramientas de línea de comandos y GUI:</span><span class="sxs-lookup"><span data-stu-id="cca74-193">Command-line and GUI tools:</span></span>
  - <span data-ttu-id="cca74-194">Herramientas como PerfView (ETW o EventPipe), dotnet-counters (solo EventPipe) y dotnet-monitor (solo EventPipe).</span><span class="sxs-lookup"><span data-stu-id="cca74-194">Tools like PerfView (ETW or EventPipe), dotnet-counters (EventPipe only), and dotnet-monitor (EventPipe only).</span></span>

### <a name="consume-out-of-proc"></a><span data-ttu-id="cca74-195">Uso fuera de proceso</span><span class="sxs-lookup"><span data-stu-id="cca74-195">Consume out-of-proc</span></span>

<span data-ttu-id="cca74-196">El uso de EventCounters fuera de proceso es un enfoque muy común.</span><span class="sxs-lookup"><span data-stu-id="cca74-196">Consuming EventCounters out-of-proc is a very common approach.</span></span> <span data-ttu-id="cca74-197">Puede usar [dotnet-counters](dotnet-counters.md) para consumirlos a modo multiplataforma a través de un EventPipe.</span><span class="sxs-lookup"><span data-stu-id="cca74-197">You can use [dotnet-counters](dotnet-counters.md) to consume them in a cross-platform manner via an EventPipe.</span></span> <span data-ttu-id="cca74-198">La herramienta `dotnet-counters` es una herramienta global de CLI de dotnet multiplataforma que se puede usar para supervisar los valores de los contadores.</span><span class="sxs-lookup"><span data-stu-id="cca74-198">The `dotnet-counters` tool is a cross-platform dotnet CLI global tool that can be used to monitor the counter values.</span></span> <span data-ttu-id="cca74-199">Para obtener información sobre cómo usar `dotnet-counters` para supervisar los contadores, vea [dotnet-counters](dotnet-counters.md) o trabaje con el tutorial [Medición del rendimiento mediante EventCounters](event-counter-perf.md).</span><span class="sxs-lookup"><span data-stu-id="cca74-199">To find out how to use `dotnet-counters` to monitor your counters, see [dotnet-counters](dotnet-counters.md), or work through the [Measure performance using EventCounters](event-counter-perf.md) tutorial.</span></span>

#### <a name="dotnet-trace"></a><span data-ttu-id="cca74-200">dotnet-trace</span><span class="sxs-lookup"><span data-stu-id="cca74-200">dotnet-trace</span></span>

<span data-ttu-id="cca74-201">La herramienta `dotnet-trace` se puede usar para consumir los datos del contador a través de EventPipe.</span><span class="sxs-lookup"><span data-stu-id="cca74-201">The `dotnet-trace` tool can be used to consume the counter data through an EventPipe.</span></span> <span data-ttu-id="cca74-202">Este es un ejemplo de uso de `dotnet-trace` para recopilar datos del contador.</span><span class="sxs-lookup"><span data-stu-id="cca74-202">Here is an example using `dotnet-trace` to collect counter data.</span></span>

```console
dotnet-trace collect --process-id <pid> Sample.EventCounter.Minimal:0:0:EventCounterIntervalSec=1
```

<span data-ttu-id="cca74-203">Para obtener más información sobre cómo recopilar valores de un contador a lo largo del tiempo, vea la documentación de [dotnet-trace](dotnet-trace.md#use-dotnet-trace-to-collect-counter-values-over-time).</span><span class="sxs-lookup"><span data-stu-id="cca74-203">For more information on how to collect counter values over time, see the [dotnet-trace](dotnet-trace.md#use-dotnet-trace-to-collect-counter-values-over-time) documentation.</span></span>

#### <a name="azure-application-insights"></a><span data-ttu-id="cca74-204">Azure Application Insights</span><span class="sxs-lookup"><span data-stu-id="cca74-204">Azure Application Insights</span></span>

<span data-ttu-id="cca74-205">Azure Monitor puede usar EventCounters, en concreto Azure Application Insights.</span><span class="sxs-lookup"><span data-stu-id="cca74-205">EventCounters can be consumed by Azure Monitor, specifically Azure Application Insights.</span></span> <span data-ttu-id="cca74-206">Los contadores se pueden agregar y quitar; además, el usuario puede especificar contadores personalizados o contadores conocidos.</span><span class="sxs-lookup"><span data-stu-id="cca74-206">Counters can be added and removed, and you're free to specify custom counters, or well-known counters.</span></span> <span data-ttu-id="cca74-207">Para obtener más información, vea [Personalización de los contadores que se van a recopilar](/azure/azure-monitor/app/eventcounters#customizing-counters-to-be-collected).</span><span class="sxs-lookup"><span data-stu-id="cca74-207">For more information, see [Customizing counters to be collected](/azure/azure-monitor/app/eventcounters#customizing-counters-to-be-collected).</span></span>

#### <a name="dotnet-monitor"></a><span data-ttu-id="cca74-208">dotnet-monitor</span><span class="sxs-lookup"><span data-stu-id="cca74-208">dotnet-monitor</span></span>

<span data-ttu-id="cca74-209">`dotnet-monitor` es una herramienta experimental que facilita el acceso a la información de diagnóstico de un proceso de .NET.</span><span class="sxs-lookup"><span data-stu-id="cca74-209">The `dotnet-monitor` tool is an experimental tool that makes it easier to get access to diagnostics information in a .NET process.</span></span> <span data-ttu-id="cca74-210">Esta herramienta sirve como superconjunto de todas las herramientas de diagnóstico.</span><span class="sxs-lookup"><span data-stu-id="cca74-210">The tool serves as a superset of all diagnostics tools.</span></span> <span data-ttu-id="cca74-211">Además de ofrecer seguimientos, permite supervisar métricas, así como recopilar volcados de memoria y de memoria GC.</span><span class="sxs-lookup"><span data-stu-id="cca74-211">In addition to traces, it can monitor metrics, collect memory dumps, and collect GC dumps.</span></span> <span data-ttu-id="cca74-212">Se distribuye tanto como herramienta de la CLI como imagen de Docker.</span><span class="sxs-lookup"><span data-stu-id="cca74-212">It's distributed as both a CLI tool and a docker image.</span></span> <span data-ttu-id="cca74-213">Expone una API de REST, y la recopilación de artefactos de diagnóstico se produce a través de llamadas REST.</span><span class="sxs-lookup"><span data-stu-id="cca74-213">It exposes a REST API, and the collection of diagnostic artifacts occurs through REST calls.</span></span>

<span data-ttu-id="cca74-214">Para obtener más información, vea [Presentación de dotnet-monitor, una herramienta experimental](https://devblogs.microsoft.com/dotnet/introducing-dotnet-monitor).</span><span class="sxs-lookup"><span data-stu-id="cca74-214">For more information, see [Introducing dotnet-monitor, an experimental tool](https://devblogs.microsoft.com/dotnet/introducing-dotnet-monitor).</span></span>

### <a name="consume-in-proc"></a><span data-ttu-id="cca74-215">Uso en proceso</span><span class="sxs-lookup"><span data-stu-id="cca74-215">Consume in-proc</span></span>

<span data-ttu-id="cca74-216">Puede usar los valores de un contador por medio de la API <xref:System.Diagnostics.Tracing.EventListener>.</span><span class="sxs-lookup"><span data-stu-id="cca74-216">You can consume the counter values via the <xref:System.Diagnostics.Tracing.EventListener> API.</span></span> <span data-ttu-id="cca74-217"><xref:System.Diagnostics.Tracing.EventListener> es una forma en proceso de usar los eventos escritos por todas las instancias de un <xref:System.Diagnostics.Tracing.EventSource> en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="cca74-217">An <xref:System.Diagnostics.Tracing.EventListener> is an in-proc way of consuming any events written by all instances of an <xref:System.Diagnostics.Tracing.EventSource> in your application.</span></span> <span data-ttu-id="cca74-218">Para obtener más información sobre cómo usar la API `EventListener`, vea <xref:System.Diagnostics.Tracing.EventListener>.</span><span class="sxs-lookup"><span data-stu-id="cca74-218">For more information on how to use the `EventListener` API, see <xref:System.Diagnostics.Tracing.EventListener>.</span></span>

<span data-ttu-id="cca74-219">En primer lugar, es necesario habilitar el <xref:System.Diagnostics.Tracing.EventSource> que genera el valor del contador.</span><span class="sxs-lookup"><span data-stu-id="cca74-219">First, the <xref:System.Diagnostics.Tracing.EventSource> that produces the counter value needs to be enabled.</span></span> <span data-ttu-id="cca74-220">Invalide el método <xref:System.Diagnostics.Tracing.EventListener.OnEventSourceCreated%2A?displayProperty=nameWithType> para obtener una notificación cuando se cree un <xref:System.Diagnostics.Tracing.EventSource> y, si es el <xref:System.Diagnostics.Tracing.EventSource> correcto con los EventCounters, puede llamar a <xref:System.Diagnostics.Tracing.EventListener.EnableEvents%2A?displayProperty=nameWithType> en él.</span><span class="sxs-lookup"><span data-stu-id="cca74-220">Override the <xref:System.Diagnostics.Tracing.EventListener.OnEventSourceCreated%2A?displayProperty=nameWithType> method to get a notification when an <xref:System.Diagnostics.Tracing.EventSource> is created, and if this is the correct <xref:System.Diagnostics.Tracing.EventSource> with your EventCounters, then you can call <xref:System.Diagnostics.Tracing.EventListener.EnableEvents%2A?displayProperty=nameWithType> on it.</span></span> <span data-ttu-id="cca74-221">Esta es una invalidación de ejemplo:</span><span class="sxs-lookup"><span data-stu-id="cca74-221">Here is an example override:</span></span>

:::code language="csharp" source="snippets/EventCounters/SimpleEventListener.cs" range="11-22":::

#### <a name="sample-code"></a><span data-ttu-id="cca74-222">Código de ejemplo</span><span class="sxs-lookup"><span data-stu-id="cca74-222">Sample code</span></span>

<span data-ttu-id="cca74-223">Esta es una clase <xref:System.Diagnostics.Tracing.EventListener> de ejemplo que imprime todos los nombres y valores de contador de <xref:System.Diagnostics.Tracing.EventSource> del entorno de ejecución de .NET para publicar sus contadores internos (`System.Runtime`) cada segundo.</span><span class="sxs-lookup"><span data-stu-id="cca74-223">Here is a sample <xref:System.Diagnostics.Tracing.EventListener> class that prints out all the counter names and values from the .NET runtime's <xref:System.Diagnostics.Tracing.EventSource>, for publishing its internal counters (`System.Runtime`) every second.</span></span>

:::code language="csharp" source="snippets/EventCounters/SimpleEventListener.cs":::

<span data-ttu-id="cca74-224">Como se ha mostrado anteriormente, _debe_ asegurarse de que el argumento `"EventCounterIntervalSec"` esté establecido en el argumento `filterPayload` al llamar a <xref:System.Diagnostics.Tracing.EventListener.EnableEvents%2A>.</span><span class="sxs-lookup"><span data-stu-id="cca74-224">As shown above, you _must_ make sure the `"EventCounterIntervalSec"` argument is set in the `filterPayload` argument when calling <xref:System.Diagnostics.Tracing.EventListener.EnableEvents%2A>.</span></span> <span data-ttu-id="cca74-225">De lo contrario, los contadores no pueden vaciar valores, ya que no saben en qué intervalo se debe hacer.</span><span class="sxs-lookup"><span data-stu-id="cca74-225">Otherwise the counters will not be able to flush out values since it doesn't know at which interval it should be getting flushed out.</span></span>

## <a name="see-also"></a><span data-ttu-id="cca74-226">Consulte también</span><span class="sxs-lookup"><span data-stu-id="cca74-226">See also</span></span>

- [<span data-ttu-id="cca74-227">dotnet-counters</span><span class="sxs-lookup"><span data-stu-id="cca74-227">dotnet-counters</span></span>](dotnet-counters.md)
- [<span data-ttu-id="cca74-228">dotnet-trace</span><span class="sxs-lookup"><span data-stu-id="cca74-228">dotnet-trace</span></span>](dotnet-trace.md)
- <xref:System.Diagnostics.Tracing.EventCounter>
- <xref:System.Diagnostics.Tracing.EventListener>
- <xref:System.Diagnostics.Tracing.EventSource>
