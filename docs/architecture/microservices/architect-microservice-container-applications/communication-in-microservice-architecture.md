---
title: Comunicación en una arquitectura de microservicio
description: Explore distintas formas de comunicación entre microservicios, y comprenda las implicaciones de formas sincrónicas y asincrónicas.
ms.date: 01/30/2020
ms.openlocfilehash: f2d6e78966bb7d5f481de6db0ab1dcfe2812a1b5
ms.sourcegitcommit: f38e527623883b92010cf4760246203073e12898
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 02/20/2020
ms.locfileid: "77503315"
---
# <a name="communication-in-a-microservice-architecture"></a><span data-ttu-id="66fe6-103">Comunicación en una arquitectura de microservicio</span><span class="sxs-lookup"><span data-stu-id="66fe6-103">Communication in a microservice architecture</span></span>

<span data-ttu-id="66fe6-104">En una aplicación monolítica que se ejecuta en un único proceso, los componentes se invocan entre sí mediante llamadas de función o método de nivel de lenguaje.</span><span class="sxs-lookup"><span data-stu-id="66fe6-104">In a monolithic application running on a single process, components invoke one another using language-level method or function calls.</span></span> <span data-ttu-id="66fe6-105">Pueden estar estrechamente acoplados si se crean objetos con código (por ejemplo, `new ClassName()`) o pueden invocarse de forma desacoplada si se usa la inserción de dependencias al hacer referencia a abstracciones en lugar de a instancias de objeto concretas.</span><span class="sxs-lookup"><span data-stu-id="66fe6-105">These can be strongly coupled if you're creating objects with code (for example, `new ClassName()`), or can be invoked in a decoupled way if you're using Dependency Injection by referencing abstractions rather than concrete object instances.</span></span> <span data-ttu-id="66fe6-106">En cualquier caso, los objetos se ejecutan en el mismo proceso.</span><span class="sxs-lookup"><span data-stu-id="66fe6-106">Either way, the objects are running within the same process.</span></span> <span data-ttu-id="66fe6-107">Lo más complicado a la hora de pasar de una aplicación monolítica a una aplicación basada en microservicios es cambiar el mecanismo de comunicación.</span><span class="sxs-lookup"><span data-stu-id="66fe6-107">The biggest challenge when changing from a monolithic application to a microservices-based application lies in changing the communication mechanism.</span></span> <span data-ttu-id="66fe6-108">Una conversión directa de llamadas de método en curso a llamadas RPC a servicios dará lugar a una comunicación extensa y no eficaz con un mal rendimiento en entornos distribuidos.</span><span class="sxs-lookup"><span data-stu-id="66fe6-108">A direct conversion from in-process method calls into RPC calls to services will cause a chatty and not efficient communication that won't perform well in distributed environments.</span></span> <span data-ttu-id="66fe6-109">Los desafíos que conlleva diseñar un sistema distribuido correctamente son tan bien conocidos que incluso existe un canon llamado [Falacias del cómputo distribuido](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing) que enumera las expectativas que suelen tener los desarrolladores al migrar de diseños monolíticos a distribuidos.</span><span class="sxs-lookup"><span data-stu-id="66fe6-109">The challenges of designing distributed system properly are well enough known that there's even a canon known as the [Fallacies of distributed computing](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing) that lists assumptions that developers often make when moving from monolithic to distributed designs.</span></span>

<span data-ttu-id="66fe6-110">No existe una única solución, sino varias.</span><span class="sxs-lookup"><span data-stu-id="66fe6-110">There isn't one solution, but several.</span></span> <span data-ttu-id="66fe6-111">Una de ellas implica aislar los microservicios de negocios lo máximo posible.</span><span class="sxs-lookup"><span data-stu-id="66fe6-111">One solution involves isolating the business microservices as much as possible.</span></span> <span data-ttu-id="66fe6-112">Luego se usa la comunicación asincrónica entre los microservicios internos y se sustituye la comunicación específica típica de la comunicación en proceso entre objetos por la comunicación general.</span><span class="sxs-lookup"><span data-stu-id="66fe6-112">You then use asynchronous communication between the internal microservices and replace fine-grained communication that's typical in intra-process communication between objects with coarser-grained communication.</span></span> <span data-ttu-id="66fe6-113">Para ello se agrupan las llamadas y se devuelven los datos que agregan los resultados de varias llamadas internas al cliente.</span><span class="sxs-lookup"><span data-stu-id="66fe6-113">You can do this by grouping calls, and by returning data that aggregates the results of multiple internal calls, to the client.</span></span>

<span data-ttu-id="66fe6-114">Una aplicación basada en microservicios es un sistema distribuido que se ejecuta en varios procesos o servicios, normalmente incluso en varios servidores o hosts.</span><span class="sxs-lookup"><span data-stu-id="66fe6-114">A microservices-based application is a distributed system running on multiple processes or services, usually even across multiple servers or hosts.</span></span> <span data-ttu-id="66fe6-115">Lo habitual es que cada instancia de servicio sea un proceso.</span><span class="sxs-lookup"><span data-stu-id="66fe6-115">Each service instance is typically a process.</span></span> <span data-ttu-id="66fe6-116">Por lo tanto, los servicios deben interactuar mediante un protocolo de comunicación entre procesos como HTTP, AMQP o un protocolo binario como TCP, en función de la naturaleza de cada servicio.</span><span class="sxs-lookup"><span data-stu-id="66fe6-116">Therefore, services must interact using an inter-process communication protocol such as HTTP, AMQP, or a binary protocol like TCP, depending on the nature of each service.</span></span>

<span data-ttu-id="66fe6-117">La comunidad de microservicios promueve la filosofía "[puntos de conexión inteligentes y canalizaciones tontas](https://simplicable.com/new/smart-endpoints-and-dumb-pipes)". Este eslogan fomenta un diseño lo más desacoplado posible entre microservicios y lo más cohesionado posible dentro de un único microservicio.</span><span class="sxs-lookup"><span data-stu-id="66fe6-117">The microservice community promotes the philosophy of "[smart endpoints and dumb pipes](https://simplicable.com/new/smart-endpoints-and-dumb-pipes)" This slogan encourages a design that's as decoupled as possible between microservices, and as cohesive as possible within a single microservice.</span></span> <span data-ttu-id="66fe6-118">Como se ha explicado anteriormente, cada microservicio posee sus propios datos y su propia lógica de dominio.</span><span class="sxs-lookup"><span data-stu-id="66fe6-118">As explained earlier, each microservice owns its own data and its own domain logic.</span></span> <span data-ttu-id="66fe6-119">Pero normalmente los microservicios que componen una aplicación de un extremo a otro se establecen sencillamente mediante comunicaciones de REST en lugar de protocolos complejos como WS-\* y comunicaciones flexibles controladas por eventos en lugar de orquestadores de procesos de negocios centralizados.</span><span class="sxs-lookup"><span data-stu-id="66fe6-119">But the microservices composing an end-to-end application are usually simply choreographed by using REST communications rather than complex protocols such as WS-\* and flexible event-driven communications instead of centralized business-process-orchestrators.</span></span>

<span data-ttu-id="66fe6-120">Los dos protocolos que se usan habitualmente son respuesta-solicitud HTTP con API de recurso (sobre todo al consultar) y mensajería asincrónica ligera al comunicar actualizaciones en varios microservicios.</span><span class="sxs-lookup"><span data-stu-id="66fe6-120">The two commonly used protocols are HTTP request/response with resource APIs (when querying most of all), and lightweight asynchronous messaging when communicating updates across multiple microservices.</span></span> <span data-ttu-id="66fe6-121">Se explican más detalladamente en las secciones siguientes.</span><span class="sxs-lookup"><span data-stu-id="66fe6-121">These are explained in more detail in the following sections.</span></span>

## <a name="communication-types"></a><span data-ttu-id="66fe6-122">Tipos de comunicación</span><span class="sxs-lookup"><span data-stu-id="66fe6-122">Communication types</span></span>

<span data-ttu-id="66fe6-123">El cliente y los servicios pueden comunicarse a través de muchos tipos diferentes de comunicación, cada uno destinado a un escenario y unos objetivos distintos.</span><span class="sxs-lookup"><span data-stu-id="66fe6-123">Client and services can communicate through many different types of communication, each one targeting a different scenario and goals.</span></span> <span data-ttu-id="66fe6-124">Inicialmente, esos tipos de comunicaciones se pueden clasificar en dos ejes.</span><span class="sxs-lookup"><span data-stu-id="66fe6-124">Initially, those types of communications can be classified in two axes.</span></span>

<span data-ttu-id="66fe6-125">El primer eje define si el protocolo es sincrónico o asincrónico:</span><span class="sxs-lookup"><span data-stu-id="66fe6-125">The first axis defines if the protocol is synchronous or asynchronous:</span></span>

- <span data-ttu-id="66fe6-126">Protocolo sincrónico.</span><span class="sxs-lookup"><span data-stu-id="66fe6-126">Synchronous protocol.</span></span> <span data-ttu-id="66fe6-127">HTTP es un protocolo sincrónico.</span><span class="sxs-lookup"><span data-stu-id="66fe6-127">HTTP is a synchronous protocol.</span></span> <span data-ttu-id="66fe6-128">El cliente envía una solicitud y espera una respuesta del servicio.</span><span class="sxs-lookup"><span data-stu-id="66fe6-128">The client sends a request and waits for a response from the service.</span></span> <span data-ttu-id="66fe6-129">Eso es independiente de la ejecución de código de cliente, que puede ser sincrónica (el subproceso está bloqueado) o asincrónica (el subproceso no está bloqueado y al final la respuesta llega a una devolución de llamada).</span><span class="sxs-lookup"><span data-stu-id="66fe6-129">That's independent of the client code execution that could be synchronous (thread is blocked) or asynchronous (thread isn't blocked, and the response will reach a callback eventually).</span></span> <span data-ttu-id="66fe6-130">Lo importante aquí es que el protocolo (HTTP/HTTPS) es sincrónico y el código de cliente solo puede continuar su tarea cuando recibe la respuesta del servidor HTTP.</span><span class="sxs-lookup"><span data-stu-id="66fe6-130">The important point here is that the protocol (HTTP/HTTPS) is synchronous and the client code can only continue its task when it receives the HTTP server response.</span></span>

- <span data-ttu-id="66fe6-131">Protocolo asincrónico.</span><span class="sxs-lookup"><span data-stu-id="66fe6-131">Asynchronous protocol.</span></span> <span data-ttu-id="66fe6-132">Otros protocolos como AMQP (un protocolo compatible con muchos sistemas operativos y entornos de nube) usan mensajes asincrónicos.</span><span class="sxs-lookup"><span data-stu-id="66fe6-132">Other protocols like AMQP (a protocol supported by many operating systems and cloud environments) use asynchronous messages.</span></span> <span data-ttu-id="66fe6-133">Normalmente el código de cliente o el remitente del mensaje no espera ninguna respuesta.</span><span class="sxs-lookup"><span data-stu-id="66fe6-133">The client code or message sender usually doesn't wait for a response.</span></span> <span data-ttu-id="66fe6-134">Simplemente envía el mensaje al igual que cuando se envía un mensaje a una cola de RabbitMQ o a cualquier otro agente de mensajes.</span><span class="sxs-lookup"><span data-stu-id="66fe6-134">It just sends the message as when sending a message to a RabbitMQ queue or any other message broker.</span></span>

<span data-ttu-id="66fe6-135">El segundo eje define si la comunicación tiene un único receptor o varios:</span><span class="sxs-lookup"><span data-stu-id="66fe6-135">The second axis defines if the communication has a single receiver or multiple receivers:</span></span>

- <span data-ttu-id="66fe6-136">Receptor único.</span><span class="sxs-lookup"><span data-stu-id="66fe6-136">Single receiver.</span></span> <span data-ttu-id="66fe6-137">Cada solicitud debe ser procesada por un receptor o servicio exactamente.</span><span class="sxs-lookup"><span data-stu-id="66fe6-137">Each request must be processed by exactly one receiver or service.</span></span> <span data-ttu-id="66fe6-138">Un ejemplo de este tipo de comunicación es el [patrón Command](https://en.wikipedia.org/wiki/Command_pattern).</span><span class="sxs-lookup"><span data-stu-id="66fe6-138">An example of this communication is the [Command pattern](https://en.wikipedia.org/wiki/Command_pattern).</span></span>

- <span data-ttu-id="66fe6-139">Varios receptores.</span><span class="sxs-lookup"><span data-stu-id="66fe6-139">Multiple receivers.</span></span> <span data-ttu-id="66fe6-140">Cada solicitud puede ser procesada por entre cero y varios receptores.</span><span class="sxs-lookup"><span data-stu-id="66fe6-140">Each request can be processed by zero to multiple receivers.</span></span> <span data-ttu-id="66fe6-141">Este tipo de comunicación debe ser asincrónica.</span><span class="sxs-lookup"><span data-stu-id="66fe6-141">This type of communication must be asynchronous.</span></span> <span data-ttu-id="66fe6-142">Un ejemplo es el mecanismo de [publicación o suscripción](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern) empleado en patrones como la [arquitectura controlada por eventos](https://microservices.io/patterns/data/event-driven-architecture.html).</span><span class="sxs-lookup"><span data-stu-id="66fe6-142">An example is the [publish/subscribe](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern) mechanism used in patterns like [Event-driven architecture](https://microservices.io/patterns/data/event-driven-architecture.html).</span></span> <span data-ttu-id="66fe6-143">Se basa en una interfaz de bus de eventos o un agente de mensajes para propagar las actualizaciones de datos entre varios microservicios mediante eventos; normalmente se implementa a través de un bus de servicio o algún artefacto similar como [Azure Service Bus](https://azure.microsoft.com/services/service-bus/) mediante [temas y suscripciones](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span><span class="sxs-lookup"><span data-stu-id="66fe6-143">This is based on an event-bus interface or message broker when propagating data updates between multiple microservices through events; it's usually implemented through a service bus or similar artifact like [Azure Service Bus](https://azure.microsoft.com/services/service-bus/) by using [topics and subscriptions](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span></span>

<span data-ttu-id="66fe6-144">Una aplicación basada en microservicio suele usar una combinación de estos estilos de comunicación.</span><span class="sxs-lookup"><span data-stu-id="66fe6-144">A microservice-based application will often use a combination of these communication styles.</span></span> <span data-ttu-id="66fe6-145">El tipo más común es la comunicación de un único receptor con un protocolo sincrónico como HTTP/HTTPS al invocar a un servicio normal HTTP Web API.</span><span class="sxs-lookup"><span data-stu-id="66fe6-145">The most common type is single-receiver communication with a synchronous protocol like HTTP/HTTPS when invoking a regular Web API HTTP service.</span></span> <span data-ttu-id="66fe6-146">Además, los microservicios suelen usar protocolos de mensajería para la comunicación asincrónica entre microservicios.</span><span class="sxs-lookup"><span data-stu-id="66fe6-146">Microservices also typically use messaging protocols for asynchronous communication between microservices.</span></span>

<span data-ttu-id="66fe6-147">Resulta útil conocer estos ejes para tener claros los posibles mecanismos de comunicación, aunque no son la preocupación más importante a la hora de compilar microservicios.</span><span class="sxs-lookup"><span data-stu-id="66fe6-147">These axes are good to know so you have clarity on the possible communication mechanisms, but they're not the important concerns when building microservices.</span></span> <span data-ttu-id="66fe6-148">Al integrar microservicios, no son importantes ni la naturaleza asincrónica de la ejecución de subprocesos de cliente ni la naturaleza asincrónica del protocolo seleccionado.</span><span class="sxs-lookup"><span data-stu-id="66fe6-148">Neither the asynchronous nature of client thread execution nor the asynchronous nature of the selected protocol are the important points when integrating microservices.</span></span> <span data-ttu-id="66fe6-149">Lo que *sí* es importante es poder integrar los microservicios de forma asincrónica a la vez que se mantiene su independencia, como se explica en la sección siguiente.</span><span class="sxs-lookup"><span data-stu-id="66fe6-149">What *is* important is being able to integrate your microservices asynchronously while maintaining the independence of microservices, as explained in the following section.</span></span>

## <a name="asynchronous-microservice-integration-enforces-microservices-autonomy"></a><span data-ttu-id="66fe6-150">La integración asincrónica del microservicio obliga a su autonomía</span><span class="sxs-lookup"><span data-stu-id="66fe6-150">Asynchronous microservice integration enforces microservice's autonomy</span></span>

<span data-ttu-id="66fe6-151">Como se ha mencionado, lo importante al compilar una aplicación basada en microservicios es la forma de integrarlos.</span><span class="sxs-lookup"><span data-stu-id="66fe6-151">As mentioned, the important point when building a microservices-based application is the way you integrate your microservices.</span></span> <span data-ttu-id="66fe6-152">Lo ideal es intentar minimizar la comunicación entre los microservicios internos.</span><span class="sxs-lookup"><span data-stu-id="66fe6-152">Ideally, you should try to minimize the communication between the internal microservices.</span></span> <span data-ttu-id="66fe6-153">Cuantas menos comunicaciones haya entre microservicios, mejor.</span><span class="sxs-lookup"><span data-stu-id="66fe6-153">The fewer communications between microservices, the better.</span></span> <span data-ttu-id="66fe6-154">Pero en muchos casos tendrá que integrar los microservicios de algún modo.</span><span class="sxs-lookup"><span data-stu-id="66fe6-154">But in many cases, you'll have to somehow integrate the microservices.</span></span> <span data-ttu-id="66fe6-155">Cuando necesite hacerlo, la regla fundamental es que la comunicación entre los microservicios debe ser asincrónica.</span><span class="sxs-lookup"><span data-stu-id="66fe6-155">When you need to do that, the critical rule here is that the communication between the microservices should be asynchronous.</span></span> <span data-ttu-id="66fe6-156">Eso no significa que tenga que usar un protocolo determinado (por ejemplo, mensajería asincrónica frente a HTTP sincrónico).</span><span class="sxs-lookup"><span data-stu-id="66fe6-156">That doesn't mean that you have to use a specific protocol (for example, asynchronous messaging versus synchronous HTTP).</span></span> <span data-ttu-id="66fe6-157">Simplemente significa que la comunicación entre los microservicios debe realizarse únicamente mediante la propagación asincrónica de datos, aunque se debe intentar no depender de otros microservicios internos como parte de la operación solicitud-respuesta HTTP del servicio inicial.</span><span class="sxs-lookup"><span data-stu-id="66fe6-157">It just means that the communication between microservices should be done only by propagating data asynchronously, but try not to depend on other internal microservices as part of the initial service's HTTP request/response operation.</span></span>

<span data-ttu-id="66fe6-158">Si es posible, no dependa nunca de la comunicación sincrónica (solicitud-respuesta) entre varios microservicios, ni siquiera para las consultas.</span><span class="sxs-lookup"><span data-stu-id="66fe6-158">If possible, never depend on synchronous communication (request/response) between multiple microservices, not even for queries.</span></span> <span data-ttu-id="66fe6-159">El objetivo de cada microservicio es ser autónomo y estar a disposición del cliente, aunque los demás servicios que forman parte de la aplicación de un extremo a otro estén inactivos o en mal estado.</span><span class="sxs-lookup"><span data-stu-id="66fe6-159">The goal of each microservice is to be autonomous and available to the client consumer, even if the other services that are part of the end-to-end application are down or unhealthy.</span></span> <span data-ttu-id="66fe6-160">Si cree que necesita realizar una llamada desde un microservicio a otros (por ejemplo, una solicitud HTTP para una consulta de datos) para poder proporcionar una respuesta a una aplicación cliente, tiene una arquitectura que no resistirá si se producen errores en algunos microservicios.</span><span class="sxs-lookup"><span data-stu-id="66fe6-160">If you think you need to make a call from one microservice to other microservices (like performing an HTTP request for a data query) to be able to provide a response to a client application, you have an architecture that won't be resilient when some microservices fail.</span></span>

<span data-ttu-id="66fe6-161">Además, el tener dependencias HTTP entre microservicios, como al crear largos ciclos de solicitud-respuesta con cadenas de solicitudes HTTP, como se muestra en la primera parte de la figura 4-15, no solo hace que los microservicios no sean autónomos, sino que también afecta a su rendimiento en cuanto alguno de los servicios de esa cadena no funciona correctamente.</span><span class="sxs-lookup"><span data-stu-id="66fe6-161">Moreover, having HTTP dependencies between microservices, like when creating long request/response cycles with HTTP request chains, as shown in the first part of the Figure 4-15, not only makes your microservices not autonomous but also their performance is impacted as soon as one of the services in that chain isn't performing well.</span></span>

<span data-ttu-id="66fe6-162">Cuantas más dependencias sincrónicas agregue entre microservicios, como solicitudes de consulta, peor será el tiempo de respuesta total de las aplicaciones cliente.</span><span class="sxs-lookup"><span data-stu-id="66fe6-162">The more you add synchronous dependencies between microservices, such as query requests, the worse the overall response time gets for the client apps.</span></span>

![Diagrama que muestra tres tipos de comunicaciones entre los microservicios.](./media/communication-in-microservice-architecture/sync-vs-async-patterns-across-microservices.png)

<span data-ttu-id="66fe6-164">**Figura 4-15**.</span><span class="sxs-lookup"><span data-stu-id="66fe6-164">**Figure 4-15**.</span></span> <span data-ttu-id="66fe6-165">Anti-patrones y patrones de comunicación entre microservicios</span><span class="sxs-lookup"><span data-stu-id="66fe6-165">Anti-patterns and patterns in communication between microservices</span></span>

<span data-ttu-id="66fe6-166">Tal y como se muestra en el diagrama anterior, en la comunicación sincrónica se crea una "cadena" de solicitudes entre los microservicios mientras se atiende la solicitud del cliente.</span><span class="sxs-lookup"><span data-stu-id="66fe6-166">As shown in the above diagram, in synchronous communication a "chain" of requests is created between microservices while serving the client request.</span></span> <span data-ttu-id="66fe6-167">Esto es un antipatrón.</span><span class="sxs-lookup"><span data-stu-id="66fe6-167">This is an anti-pattern.</span></span> <span data-ttu-id="66fe6-168">En la comunicación asincrónica los microservicios usan mensajes asincrónicos o sondeo http para comunicarse con otros microservicios, pero la solicitud de cliente se sirve inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="66fe6-168">In asynchronous communication microservices use asynchronous messages or http polling to communicate with other microservices, but the client request is served right away.</span></span>

<span data-ttu-id="66fe6-169">Si el microservicio tiene que producir una acción adicional en otro microservicio, siempre que sea posible, no realice esa acción de forma sincrónica como parte de la operación solicitud-respuesta original del microservicio.</span><span class="sxs-lookup"><span data-stu-id="66fe6-169">If your microservice needs to raise an additional action in another microservice, if possible, do not perform that action synchronously and as part of the original microservice request and reply operation.</span></span> <span data-ttu-id="66fe6-170">Por el contrario, hágalo de forma asincrónica (mediante mensajería asincrónica o eventos de integración, colas, etc.).</span><span class="sxs-lookup"><span data-stu-id="66fe6-170">Instead, do it asynchronously (using asynchronous messaging or integration events, queues, etc.).</span></span> <span data-ttu-id="66fe6-171">Pero, siempre que sea posible, no invoque a la acción de forma sincrónica como parte de la operación solicitud-respuesta sincrónica original.</span><span class="sxs-lookup"><span data-stu-id="66fe6-171">But, as much as possible, do not invoke the action synchronously as part of the original synchronous request and reply operation.</span></span>

<span data-ttu-id="66fe6-172">Y, por último (y aquí es donde surgen la mayoría de los problemas al compilar microservicios), si el microservicio inicial necesita datos cuyo propietario original es otro microservicio, no dependa de la realización de solicitudes sincrónicas para esos datos.</span><span class="sxs-lookup"><span data-stu-id="66fe6-172">And finally (and this is where most of the issues arise when building microservices), if your initial microservice needs data that's originally owned by other microservices, do not rely on making synchronous requests for that data.</span></span> <span data-ttu-id="66fe6-173">En su lugar, replique o propague esos datos (solo los atributos que necesite) en la base de datos del servicio inicial mediante la coherencia final (normalmente mediante eventos de integración, como se explica en las próximas secciones).</span><span class="sxs-lookup"><span data-stu-id="66fe6-173">Instead, replicate or propagate that data (only the attributes you need) into the initial service's database by using eventual consistency (typically by using integration events, as explained in upcoming sections).</span></span>

<span data-ttu-id="66fe6-174">Como se ha indicado anteriormente en la sección [Identificación de los límites del modelo de dominio para cada microservicio](identify-microservice-domain-model-boundaries.md), la duplicación de algunos datos en varios microservicios no es un diseño incorrecto, sino que permite convertir los datos al lenguaje o los términos específicos de ese dominio adicional o contexto enlazado.</span><span class="sxs-lookup"><span data-stu-id="66fe6-174">As noted earlier in the [Identifying domain-model boundaries for each microservice](identify-microservice-domain-model-boundaries.md) section, duplicating some data across several microservices isn't an incorrect design—on the contrary, when doing that you can translate the data into the specific language or terms of that additional domain or Bounded Context.</span></span> <span data-ttu-id="66fe6-175">Por ejemplo, en la [aplicación eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers), hay un microservicio denominado `identity-api` que se encarga de la mayoría de los datos del usuario con una entidad denominada `User`.</span><span class="sxs-lookup"><span data-stu-id="66fe6-175">For instance, in the [eShopOnContainers application](https://github.com/dotnet-architecture/eShopOnContainers) you have a microservice named `identity-api` that's in charge of most of the user's data with an entity named `User`.</span></span> <span data-ttu-id="66fe6-176">Sin embargo, cuando necesite almacenar datos sobre el usuario en el microservicio `Ordering`, lo hará como una entidad diferente denominada `Buyer`.</span><span class="sxs-lookup"><span data-stu-id="66fe6-176">However, when you need to store data about the user within the `Ordering` microservice, you store it as a different entity named `Buyer`.</span></span> <span data-ttu-id="66fe6-177">La entidad `Buyer` comparte la misma identidad con la entidad `User` original, pero podría tener solo los atributos que necesita el dominio `Ordering` y no el perfil completo del usuario.</span><span class="sxs-lookup"><span data-stu-id="66fe6-177">The `Buyer` entity shares the same identity with the original `User` entity, but it might have only the few attributes needed by the `Ordering` domain, and not the whole user profile.</span></span>

<span data-ttu-id="66fe6-178">Podría usar cualquier protocolo para comunicar y propagar datos de forma asincrónica en microservicios para disponer de coherencia final.</span><span class="sxs-lookup"><span data-stu-id="66fe6-178">You might use any protocol to communicate and propagate data asynchronously across microservices in order to have eventual consistency.</span></span> <span data-ttu-id="66fe6-179">Como se ha mencionado, puede usar eventos de integración con un bus de eventos o un agente de mensajes o, si no, puede usar incluso HTTP mediante el sondeo de los demás servicios,</span><span class="sxs-lookup"><span data-stu-id="66fe6-179">As mentioned, you could use integration events using an event bus or message broker or you could even use HTTP by polling the other services instead.</span></span> <span data-ttu-id="66fe6-180">No importa.</span><span class="sxs-lookup"><span data-stu-id="66fe6-180">It doesn't matter.</span></span> <span data-ttu-id="66fe6-181">Lo importante es no crear dependencias sincrónicas entre los microservicios.</span><span class="sxs-lookup"><span data-stu-id="66fe6-181">The important rule is to not create synchronous dependencies between your microservices.</span></span>

<span data-ttu-id="66fe6-182">En las siguientes secciones se explican los diversos estilos de comunicación que se pueden usar en una aplicación basada en microservicio.</span><span class="sxs-lookup"><span data-stu-id="66fe6-182">The following sections explain the multiple communication styles you can consider using in a microservice-based application.</span></span>

## <a name="communication-styles"></a><span data-ttu-id="66fe6-183">Estilos de comunicación</span><span class="sxs-lookup"><span data-stu-id="66fe6-183">Communication styles</span></span>

<span data-ttu-id="66fe6-184">Hay muchos protocolos y opciones que se pueden usar para la comunicación, según el tipo de comunicación que se quiera emplear.</span><span class="sxs-lookup"><span data-stu-id="66fe6-184">There are many protocols and choices you can use for communication, depending on the communication type you want to use.</span></span> <span data-ttu-id="66fe6-185">Si va a usar un mecanismo de comunicación sincrónico basado en solicitud-respuesta, los enfoques de protocolos como HTTP y REST son los más comunes, especialmente si va a publicar los servicios fuera del host de Docker o el clúster de microservicios.</span><span class="sxs-lookup"><span data-stu-id="66fe6-185">If you're using a synchronous request/response-based communication mechanism, protocols such as HTTP and REST approaches are the most common, especially if you're publishing your services outside the Docker host or microservice cluster.</span></span> <span data-ttu-id="66fe6-186">Si va a comunicarse entre servicios de forma interna (dentro del host de Docker o el clúster de microservicios), es posible que también quiera usar mecanismos de comunicación de formato binario (como WCF mediante TCP y formato binario).</span><span class="sxs-lookup"><span data-stu-id="66fe6-186">If you're communicating between services internally (within your Docker host or microservices cluster), you might also want to use binary format communication mechanisms (like WCF using TCP and binary format).</span></span> <span data-ttu-id="66fe6-187">También puede usar mecanismos de comunicación asincrónicos basados en mensajes como AMQP.</span><span class="sxs-lookup"><span data-stu-id="66fe6-187">Alternatively, you can use asynchronous, message-based communication mechanisms such as AMQP.</span></span>

<span data-ttu-id="66fe6-188">Además hay varios formatos de mensaje como JSON o XML, o incluso formatos binarios, que pueden resultar más eficaces.</span><span class="sxs-lookup"><span data-stu-id="66fe6-188">There are also multiple message formats like JSON or XML, or even binary formats, which can be more efficient.</span></span> <span data-ttu-id="66fe6-189">Si el formato binario elegido no es estándar, probablemente no sea buena idea publicar los servicios con ese formato.</span><span class="sxs-lookup"><span data-stu-id="66fe6-189">If your chosen binary format isn't a standard, it's probably not a good idea to publicly publish your services using that format.</span></span> <span data-ttu-id="66fe6-190">Puede usar un formato no estándar para la comunicación interna entre los microservicios.</span><span class="sxs-lookup"><span data-stu-id="66fe6-190">You could use a non-standard format for internal communication between your microservices.</span></span> <span data-ttu-id="66fe6-191">Podría hacerlo así para la comunicación entre microservicios dentro del host de Docker o el clúster de microservicios (orquestadores de Docker, por ejemplo) o para las aplicaciones cliente de su propiedad que se comunican con los microservicios.</span><span class="sxs-lookup"><span data-stu-id="66fe6-191">You might do this when communicating between microservices within your Docker host or microservice cluster (for example, Docker orchestrators), or for proprietary client applications that talk to the microservices.</span></span>

### <a name="requestresponse-communication-with-http-and-rest"></a><span data-ttu-id="66fe6-192">Comunicación solicitud-respuesta con HTTP y REST</span><span class="sxs-lookup"><span data-stu-id="66fe6-192">Request/response communication with HTTP and REST</span></span>

<span data-ttu-id="66fe6-193">Cuando un cliente usa la comunicación solicitud-respuesta, envía una solicitud a un servicio, este la procesa y luego envía una respuesta.</span><span class="sxs-lookup"><span data-stu-id="66fe6-193">When a client uses request/response communication, it sends a request to a service, then the service processes the request and sends back a response.</span></span> <span data-ttu-id="66fe6-194">La comunicación solicitud-respuesta resulta especialmente idónea para consultar datos de una interfaz de usuario en tiempo real (una interfaz de usuario activa) desde aplicaciones cliente.</span><span class="sxs-lookup"><span data-stu-id="66fe6-194">Request/response communication is especially well suited for querying data for a real-time UI (a live user interface) from client apps.</span></span> <span data-ttu-id="66fe6-195">Por tanto, en una arquitectura de microservicio probablemente se use este mecanismo de comunicación para la mayoría de las consultas, como se muestra en la figura 4-16.</span><span class="sxs-lookup"><span data-stu-id="66fe6-195">Therefore, in a microservice architecture you'll probably use this communication mechanism for most queries, as shown in Figure 4-16.</span></span>

![Diagrama que muestra las comunicaciones de solicitud/respuesta para las consultas y actualizaciones activas.](./media/communication-in-microservice-architecture/request-response-comms-live-queries-updates.png)

<span data-ttu-id="66fe6-197">**Figura 4-16**.</span><span class="sxs-lookup"><span data-stu-id="66fe6-197">**Figure 4-16**.</span></span> <span data-ttu-id="66fe6-198">Uso de la comunicación solicitud-respuesta HTTP (sincrónica o asincrónica)</span><span class="sxs-lookup"><span data-stu-id="66fe6-198">Using HTTP request/response communication (synchronous or asynchronous)</span></span>

<span data-ttu-id="66fe6-199">Cuando un cliente usa la comunicación solicitud-respuesta, da por hecho que la respuesta llegará en poco tiempo, normalmente en menos de un segundo, o unos pocos segundos como máximo.</span><span class="sxs-lookup"><span data-stu-id="66fe6-199">When a client uses request/response communication, it assumes that the response will arrive in a short time, typically less than a second, or a few seconds at most.</span></span> <span data-ttu-id="66fe6-200">Si se retrasan las respuestas, debe implementar la comunicación asincrónica basada en [patrones de mensajería](https://docs.microsoft.com/azure/architecture/patterns/category/messaging) y [tecnologías de mensajería](https://en.wikipedia.org/wiki/Message-oriented_middleware), que es otro enfoque que se explica en la sección siguiente.</span><span class="sxs-lookup"><span data-stu-id="66fe6-200">For delayed responses, you need to implement asynchronous communication based on [messaging patterns](https://docs.microsoft.com/azure/architecture/patterns/category/messaging) and [messaging technologies](https://en.wikipedia.org/wiki/Message-oriented_middleware), which is a different approach that we explain in the next section.</span></span>

<span data-ttu-id="66fe6-201">Un estilo arquitectónico popular para la comunicación solicitud-respuesta es [REST](https://en.wikipedia.org/wiki/Representational_state_transfer).</span><span class="sxs-lookup"><span data-stu-id="66fe6-201">A popular architectural style for request/response communication is [REST](https://en.wikipedia.org/wiki/Representational_state_transfer).</span></span> <span data-ttu-id="66fe6-202">Este enfoque se basa en el protocolo [HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) y está estrechamente relacionado con él, ya que adopta verbos HTTP como GET, POST y PUT.</span><span class="sxs-lookup"><span data-stu-id="66fe6-202">This approach is based on, and tightly coupled to, the [HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) protocol, embracing HTTP verbs like GET, POST, and PUT.</span></span> <span data-ttu-id="66fe6-203">REST es el enfoque de arquitectura de comunicación más usado a la hora de crear servicios.</span><span class="sxs-lookup"><span data-stu-id="66fe6-203">REST is the most commonly used architectural communication approach when creating services.</span></span> <span data-ttu-id="66fe6-204">Puede implementar servicios REST cuando desarrolle servicios Web API de ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="66fe6-204">You can implement REST services when you develop ASP.NET Core Web API services.</span></span>

<span data-ttu-id="66fe6-205">El uso de servicios REST de HTTP como lenguaje de definición de interfaz ofrece algunas ventajas.</span><span class="sxs-lookup"><span data-stu-id="66fe6-205">There's additional value when using HTTP REST services as your interface definition language.</span></span> <span data-ttu-id="66fe6-206">Por ejemplo, si usa [metadatos de Swagger](https://swagger.io/) para describir la API de servicio, puede usar herramientas que generan código auxiliar de cliente que puede detectar y usar directamente los servicios.</span><span class="sxs-lookup"><span data-stu-id="66fe6-206">For instance, if you use [Swagger metadata](https://swagger.io/) to describe your service API, you can use tools that generate client stubs that can directly discover and consume your services.</span></span>

### <a name="additional-resources"></a><span data-ttu-id="66fe6-207">Recursos adicionales</span><span class="sxs-lookup"><span data-stu-id="66fe6-207">Additional resources</span></span>

- <span data-ttu-id="66fe6-208">**Martin Fowler. Richardson Maturity Model** A description of the REST model (Modelo de madurez Richardson. Una descripción del modelo REST).</span><span class="sxs-lookup"><span data-stu-id="66fe6-208">**Martin Fowler. Richardson Maturity Model** A description of the REST model.</span></span> \
  <https://martinfowler.com/articles/richardsonMaturityModel.html>

- <span data-ttu-id="66fe6-209">**Swagger** Sitio oficial.</span><span class="sxs-lookup"><span data-stu-id="66fe6-209">**Swagger** The official site.</span></span> \
  <https://swagger.io/>

### <a name="push-and-real-time-communication-based-on-http"></a><span data-ttu-id="66fe6-210">Comunicación de inserción y en tiempo real basada en HTTP</span><span class="sxs-lookup"><span data-stu-id="66fe6-210">Push and real-time communication based on HTTP</span></span>

<span data-ttu-id="66fe6-211">Otra posibilidad (normalmente para fines distintos que REST) es una comunicación en tiempo real y de uno a varios con marcos de trabajo de nivel superior como [ASP.NET SignalR](https://www.asp.net/signalr) y protocolos como [WebSockets](https://en.wikipedia.org/wiki/WebSocket).</span><span class="sxs-lookup"><span data-stu-id="66fe6-211">Another possibility (usually for different purposes than REST) is a real-time and one-to-many communication with higher-level frameworks such as [ASP.NET SignalR](https://www.asp.net/signalr) and protocols such as [WebSockets](https://en.wikipedia.org/wiki/WebSocket).</span></span>

<span data-ttu-id="66fe6-212">Como se muestra en la figura 4-17, la comunicación HTTP en tiempo real significa que puede hacer que el código de servidor inserte contenido en los clientes conectados a medida que los datos están disponibles, en lugar de hacer que el servidor espere a que un cliente pida nuevos datos.</span><span class="sxs-lookup"><span data-stu-id="66fe6-212">As Figure 4-17 shows, real-time HTTP communication means that you can have server code pushing content to connected clients as the data becomes available, rather than having the server wait for a client to request new data.</span></span>

![Diagrama que muestra las comunicaciones de inserción y en tiempo real basadas en SignalR.](./media/communication-in-microservice-architecture/one-to-many-communication.png)

<span data-ttu-id="66fe6-214">**Figura 4-17**.</span><span class="sxs-lookup"><span data-stu-id="66fe6-214">**Figure 4-17**.</span></span> <span data-ttu-id="66fe6-215">Comunicación de mensajes asincrónica en tiempo real uno a uno</span><span class="sxs-lookup"><span data-stu-id="66fe6-215">One-to-one real-time asynchronous message communication</span></span>

<span data-ttu-id="66fe6-216">SignalR es una buena forma de lograr una comunicación en tiempo real para insertar contenido a los clientes desde un servidor back-end.</span><span class="sxs-lookup"><span data-stu-id="66fe6-216">SignalR is a good way to achieve real-time communication for pushing content to the clients from a back-end server.</span></span> <span data-ttu-id="66fe6-217">Puesto que la comunicación es en tiempo real, las aplicaciones cliente muestran los cambios prácticamente de forma inmediata.</span><span class="sxs-lookup"><span data-stu-id="66fe6-217">Since communication is in real time, client apps show the changes almost instantly.</span></span> <span data-ttu-id="66fe6-218">Normalmente, esto se controla mediante un protocolo como WebSockets, con muchas conexiones WebSockets (una por cliente).</span><span class="sxs-lookup"><span data-stu-id="66fe6-218">This is usually handled by a protocol such as WebSockets, using many WebSockets connections (one per client).</span></span> <span data-ttu-id="66fe6-219">Un ejemplo típico es cuando un servicio comunica un cambio en el marcador de un partido a muchas aplicaciones web cliente a la vez.</span><span class="sxs-lookup"><span data-stu-id="66fe6-219">A typical example is when a service communicates a change in the score of a sports game to many client web apps simultaneously.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="66fe6-220">[Anterior](direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md)
>[Siguiente](asynchronous-message-based-communication.md)</span><span class="sxs-lookup"><span data-stu-id="66fe6-220">[Previous](direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md)
[Next](asynchronous-message-based-communication.md)</span></span>
