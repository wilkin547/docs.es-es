---
title: Implementación de un modelo de dominio de microservicio con .NET
description: Arquitectura de microservicios de .NET para aplicaciones .NET en contenedor | Información sobre la implementación de un modelo de dominio orientado a un DDD.
ms.date: 02/02/2021
ms.openlocfilehash: 87d832101d95f3ab69d1a40bbdc820e1e09af5db
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 02/06/2021
ms.locfileid: "99665281"
---
# <a name="implement-a-microservice-domain-model-with-net"></a><span data-ttu-id="a0475-103">Implementación de un modelo de dominio de microservicio con .NET</span><span class="sxs-lookup"><span data-stu-id="a0475-103">Implement a microservice domain model with .NET</span></span>

<span data-ttu-id="a0475-104">En la sección anterior se han explicado los principios y patrones de diseño fundamentales para diseñar un modelo de dominio.</span><span class="sxs-lookup"><span data-stu-id="a0475-104">In the previous section, the fundamental design principles and patterns for designing a domain model were explained.</span></span> <span data-ttu-id="a0475-105">Ahora es el momento de analizar las posibles formas de implementar el modelo de dominio mediante .NET (código C\# sin formato) y EF Core.</span><span class="sxs-lookup"><span data-stu-id="a0475-105">Now it is time to explore possible ways to implement the domain model by using .NET (plain C\# code) and EF Core.</span></span> <span data-ttu-id="a0475-106">El modelo de dominio solo estará formado por el código.</span><span class="sxs-lookup"><span data-stu-id="a0475-106">Your domain model will be composed simply of your code.</span></span> <span data-ttu-id="a0475-107">Tiene solo los requisitos del modelo de EF Core, pero no las dependencias reales en EF.</span><span class="sxs-lookup"><span data-stu-id="a0475-107">It will have just the EF Core model requirements, but not real dependencies on EF.</span></span> <span data-ttu-id="a0475-108">En el modelo de dominio no debe haber dependencias fuertes ni referencias a EF Core ni ningún otro ORM.</span><span class="sxs-lookup"><span data-stu-id="a0475-108">You should not have hard dependencies or references to EF Core or any other ORM in your domain model.</span></span>

## <a name="domain-model-structure-in-a-custom-net-standard-library"></a><span data-ttu-id="a0475-109">Estructura del modelo de dominio en una biblioteca personalizada de .NET Standard</span><span class="sxs-lookup"><span data-stu-id="a0475-109">Domain model structure in a custom .NET Standard Library</span></span>

<span data-ttu-id="a0475-110">La organización de carpetas usada para la aplicación de referencia eShopOnContainers muestra el modelo DDD para la aplicación.</span><span class="sxs-lookup"><span data-stu-id="a0475-110">The folder organization used for the eShopOnContainers reference application demonstrates the DDD model for the application.</span></span> <span data-ttu-id="a0475-111">Es posible que descubra que otra organización de carpetas comunica con mayor claridad las opciones de diseño elegidas para la aplicación.</span><span class="sxs-lookup"><span data-stu-id="a0475-111">You might find that a different folder organization more clearly communicates the design choices made for your application.</span></span> <span data-ttu-id="a0475-112">Como puede ver en la figura 7-10, en el modelo de dominio Ordering hay dos agregados, el agregado Order y el agregado Buyer.</span><span class="sxs-lookup"><span data-stu-id="a0475-112">As you can see in Figure 7-10, in the ordering domain model there are two aggregates, the order aggregate and the buyer aggregate.</span></span> <span data-ttu-id="a0475-113">Cada agregado es un grupo de entidades de dominio y objetos de valor, aunque también podría tener un agregado compuesto por una sola entidad de dominio (la raíz de agregado o entidad raíz).</span><span class="sxs-lookup"><span data-stu-id="a0475-113">Each aggregate is a group of domain entities and value objects, although you could have an aggregate composed of a single domain entity (the aggregate root or root entity) as well.</span></span>

:::image type="complex" source="./media/net-core-microservice-domain-model/ordering-microservice-container.png" alt-text="Captura de pantalla del proyecto Ordering.Domain en el Explorador de soluciones.":::
<span data-ttu-id="a0475-115">Vista Explorador de soluciones para el proyecto Ordering.Domain, en la que se muestra la carpeta AggregatesModel que contiene las carpetas BuyerAggregate y OrderAggregate, cada una con sus clases de entidad, archivos de objeto de valor y otros elementos.</span><span class="sxs-lookup"><span data-stu-id="a0475-115">The Solution Explorer view for the Ordering.Domain project, showing the AggregatesModel folder containing the BuyerAggregate and OrderAggregate folders, each one containing its entity classes, value object files and so on.</span></span>
:::image-end:::

<span data-ttu-id="a0475-116">**Figura 7-10**.</span><span class="sxs-lookup"><span data-stu-id="a0475-116">**Figure 7-10**.</span></span> <span data-ttu-id="a0475-117">Estructura del modelo de dominio del microservicio Ordering de eShopOnContainers</span><span class="sxs-lookup"><span data-stu-id="a0475-117">Domain model structure for the ordering microservice in eShopOnContainers</span></span>

<span data-ttu-id="a0475-118">Además, la capa de modelo de dominio incluye los contratos de repositorio (interfaces) que son los requisitos de infraestructura del modelo de dominio.</span><span class="sxs-lookup"><span data-stu-id="a0475-118">Additionally, the domain model layer includes the repository contracts (interfaces) that are the infrastructure requirements of your domain model.</span></span> <span data-ttu-id="a0475-119">Es decir, estas interfaces expresan qué repositorios y métodos debe implementar la capa de infraestructura.</span><span class="sxs-lookup"><span data-stu-id="a0475-119">In other words, these interfaces express what repositories and the methods the infrastructure layer must implement.</span></span> <span data-ttu-id="a0475-120">Es fundamental que la implementación de los repositorios se coloque fuera de la capa de modelo de dominio, en la biblioteca de capas de infraestructura, para que la capa de modelo de dominio no quede "contaminada" por la API o clases de tecnologías de infraestructura, como Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="a0475-120">It is critical that the implementation of the repositories be placed outside of the domain model layer, in the infrastructure layer library, so the domain model layer is not "contaminated" by API or classes from infrastructure technologies, like Entity Framework.</span></span>

<span data-ttu-id="a0475-121">También puede ver una carpeta [SeedWork](https://martinfowler.com/bliki/Seedwork.html) que contiene clases base personalizadas que se pueden usar como base para las entidades de dominio y los objetos de valor, para no tener código redundante en la clase de objeto de cada dominio.</span><span class="sxs-lookup"><span data-stu-id="a0475-121">You can also see a [SeedWork](https://martinfowler.com/bliki/Seedwork.html) folder that contains custom base classes that you can use as a base for your domain entities and value objects, so you do not have redundant code in each domain's object class.</span></span>

## <a name="structure-aggregates-in-a-custom-net-standard-library"></a><span data-ttu-id="a0475-122">Estructuración de los agregados en una biblioteca personalizada de .NET Standard</span><span class="sxs-lookup"><span data-stu-id="a0475-122">Structure aggregates in a custom .NET Standard library</span></span>

<span data-ttu-id="a0475-123">Un agregado hace referencia a un clúster de objetos de dominio agrupados para aproximarse a la coherencia transaccional.</span><span class="sxs-lookup"><span data-stu-id="a0475-123">An aggregate refers to a cluster of domain objects grouped together to match transactional consistency.</span></span> <span data-ttu-id="a0475-124">Esos objetos pueden ser instancias de entidades (una de las cuales es la raíz de agregado o entidad raíz) más los objetos de valor adicionales.</span><span class="sxs-lookup"><span data-stu-id="a0475-124">Those objects could be instances of entities (one of which is the aggregate root or root entity) plus any additional value objects.</span></span>

<span data-ttu-id="a0475-125">La coherencia transaccional significa que se garantiza la coherencia y actualización de un agregado al final de una acción empresarial.</span><span class="sxs-lookup"><span data-stu-id="a0475-125">Transactional consistency means that an aggregate is guaranteed to be consistent and up to date at the end of a business action.</span></span> <span data-ttu-id="a0475-126">Por ejemplo, la composición del agregado Order del modelo de dominio del microservicio Ordering de eShopOnContainers es la que se muestra en la figura 7-11.</span><span class="sxs-lookup"><span data-stu-id="a0475-126">For example, the order aggregate from the eShopOnContainers ordering microservice domain model is composed as shown in Figure 7-11.</span></span>

:::image type="complex" source="./media/net-core-microservice-domain-model/vs-solution-explorer-order-aggregate.png" alt-text="Captura de pantalla de la carpeta OrderAggregate y sus clases.":::
<span data-ttu-id="a0475-128">Una vista detallada de la carpeta OrderAggregate: Address.cs es un objeto de valor, IOrderRepository es una interfaz de repositorio, Order.cs es una raíz agregada, OrderItem.cs es una entidad secundaria y OrderStatus.cs es una clase de enumeración.</span><span class="sxs-lookup"><span data-stu-id="a0475-128">A detailed view of the OrderAggregate folder: Address.cs is a value object, IOrderRepository is a repo interface, Order.cs is an aggregate root, OrderItem.cs is a child entity, and OrderStatus.cs is an enumeration class.</span></span>
:::image-end:::

<span data-ttu-id="a0475-129">**Figura 7-11**.</span><span class="sxs-lookup"><span data-stu-id="a0475-129">**Figure 7-11**.</span></span> <span data-ttu-id="a0475-130">Agregado Order en la solución de Visual Studio</span><span class="sxs-lookup"><span data-stu-id="a0475-130">The order aggregate in Visual Studio solution</span></span>

<span data-ttu-id="a0475-131">Si abre cualquiera de los archivos de una carpeta de agregado, puede ver que está marcado como clase base personalizada o interfaz, como entidad u objeto de valor, tal como se ha implementado en la carpeta [SeedWork](https://github.com/dotnet-architecture/eShopOnContainers/tree/master/src/Services/Ordering/Ordering.Domain/SeedWork).</span><span class="sxs-lookup"><span data-stu-id="a0475-131">If you open any of the files in an aggregate folder, you can see how it is marked as either a custom base class or interface, like entity or value object, as implemented in the [SeedWork](https://github.com/dotnet-architecture/eShopOnContainers/tree/master/src/Services/Ordering/Ordering.Domain/SeedWork) folder.</span></span>

## <a name="implement-domain-entities-as-poco-classes"></a><span data-ttu-id="a0475-132">Implementación de entidades de dominio como clases POCO</span><span class="sxs-lookup"><span data-stu-id="a0475-132">Implement domain entities as POCO classes</span></span>

<span data-ttu-id="a0475-133">En .NET, los modelos de dominio se implementan mediante la creación de clases POCO que implementan las entidades de dominio.</span><span class="sxs-lookup"><span data-stu-id="a0475-133">You implement a domain model in .NET by creating POCO classes that implement your domain entities.</span></span> <span data-ttu-id="a0475-134">En el ejemplo siguiente, la clase Order se define como una entidad y también como una raíz de agregado.</span><span class="sxs-lookup"><span data-stu-id="a0475-134">In the following example, the Order class is defined as an entity and also as an aggregate root.</span></span> <span data-ttu-id="a0475-135">Dado que la clase Order deriva de la clase base Entity, puede reutilizar código común relacionado con entidades.</span><span class="sxs-lookup"><span data-stu-id="a0475-135">Because the Order class derives from the Entity base class, it can reuse common code related to entities.</span></span> <span data-ttu-id="a0475-136">Tenga en cuenta que estas clases base e interfaces las define el usuario en el proyecto de modelo de dominio, por lo que es el código, no el código de infraestructura de un ORM, como EF.</span><span class="sxs-lookup"><span data-stu-id="a0475-136">Bear in mind that these base classes and interfaces are defined by you in the domain model project, so it is your code, not infrastructure code from an ORM like EF.</span></span>

```csharp
// COMPATIBLE WITH ENTITY FRAMEWORK CORE 5.0
// Entity is a custom base class with the ID
public class Order : Entity, IAggregateRoot
{
    private DateTime _orderDate;
    public Address Address { get; private set; }
    private int? _buyerId;

    public OrderStatus OrderStatus { get; private set; }
    private int _orderStatusId;

    private string _description;
    private int? _paymentMethodId;

    private readonly List<OrderItem> _orderItems;
    public IReadOnlyCollection<OrderItem> OrderItems => _orderItems;

    public Order(string userId, Address address, int cardTypeId, string cardNumber, string cardSecurityNumber,
            string cardHolderName, DateTime cardExpiration, int? buyerId = null, int? paymentMethodId = null)
    {
        _orderItems = new List<OrderItem>();
        _buyerId = buyerId;
        _paymentMethodId = paymentMethodId;
        _orderStatusId = OrderStatus.Submitted.Id;
        _orderDate = DateTime.UtcNow;
        Address = address;

        // ...Additional code ...
    }

    public void AddOrderItem(int productId, string productName,
                            decimal unitPrice, decimal discount,
                            string pictureUrl, int units = 1)
    {
        //...
        // Domain rules/logic for adding the OrderItem to the order
        // ...

        var orderItem = new OrderItem(productId, productName, unitPrice, discount, pictureUrl, units);

        _orderItems.Add(orderItem);

    }
    // ...
    // Additional methods with domain rules/logic related to the Order aggregate
    // ...
}
```

<span data-ttu-id="a0475-137">Es importante tener en cuenta que se trata de una entidad de dominio implementada como clase POCO.</span><span class="sxs-lookup"><span data-stu-id="a0475-137">It is important to note that this is a domain entity implemented as a POCO class.</span></span> <span data-ttu-id="a0475-138">No tiene ninguna dependencia directa con Entity Framework Core ni ningún otro marco de trabajo de infraestructura.</span><span class="sxs-lookup"><span data-stu-id="a0475-138">It does not have any direct dependency on Entity Framework Core or any other infrastructure framework.</span></span> <span data-ttu-id="a0475-139">Esta es la implementación que se debería usar en DDD: tan solo código de C# que implementa un modelo de dominio.</span><span class="sxs-lookup"><span data-stu-id="a0475-139">This implementation is as it should be in DDD, just C# code implementing a domain model.</span></span>

<span data-ttu-id="a0475-140">Además, la clase se decora con una interfaz denominada IAggregateRoot.</span><span class="sxs-lookup"><span data-stu-id="a0475-140">In addition, the class is decorated with an interface named IAggregateRoot.</span></span> <span data-ttu-id="a0475-141">Esa interfaz es una interfaz vacía, que a veces se denomina *interfaz de marcador*, que se usa simplemente para indicar que esta clase de entidad también es una raíz de agregado.</span><span class="sxs-lookup"><span data-stu-id="a0475-141">That interface is an empty interface, sometimes called a *marker interface*, that is used just to indicate that this entity class is also an aggregate root.</span></span>

<span data-ttu-id="a0475-142">Una interfaz de marcador a veces se considera un anti-patrón; pero también es una manera eficaz de marcar una clase, sobre todo cuando esa interfaz podría estar evolucionando.</span><span class="sxs-lookup"><span data-stu-id="a0475-142">A marker interface is sometimes considered as an anti-pattern; however, it is also a clean way to mark a class, especially when that interface might be evolving.</span></span> <span data-ttu-id="a0475-143">Un atributo podría ser la otra opción para el marcador, pero es más rápido ver la clase base (Entity) junto a la interfaz IAggregate en lugar de colocar un marcador de atributo Aggregate sobre la clase.</span><span class="sxs-lookup"><span data-stu-id="a0475-143">An attribute could be the other choice for the marker, but it is quicker to see the base class (Entity) next to the IAggregate interface instead of putting an Aggregate attribute marker above the class.</span></span> <span data-ttu-id="a0475-144">En cualquier caso, es una cuestión de preferencias.</span><span class="sxs-lookup"><span data-stu-id="a0475-144">It is a matter of preferences, in any case.</span></span>

<span data-ttu-id="a0475-145">Tener una raíz de agregado significa que la mayoría del código relacionado con la coherencia y las reglas de negocio de las entidades del agregado deben implementarse como métodos en la clase raíz de agregado Order (por ejemplo, AddOrderItem al agregar un objeto OrderItem al agregado).</span><span class="sxs-lookup"><span data-stu-id="a0475-145">Having an aggregate root means that most of the code related to consistency and business rules of the aggregate's entities should be implemented as methods in the Order aggregate root class (for example, AddOrderItem when adding an OrderItem object to the aggregate).</span></span> <span data-ttu-id="a0475-146">No debe crear ni actualizar objetos OrderItems de forma independiente ni directa; la clase AggregateRoot debe mantener el control y la coherencia de cualquier operación de actualización en sus entidades secundarias.</span><span class="sxs-lookup"><span data-stu-id="a0475-146">You should not create or update OrderItems objects independently or directly; the AggregateRoot class must keep control and consistency of any update operation against its child entities.</span></span>

## <a name="encapsulate-data-in-the-domain-entities"></a><span data-ttu-id="a0475-147">Encapsulación de datos en entidades de dominio</span><span class="sxs-lookup"><span data-stu-id="a0475-147">Encapsulate data in the Domain Entities</span></span>

<span data-ttu-id="a0475-148">Un problema habitual de los modelos de entidad es que exponen propiedades de navegación de colecciones como tipos de lista públicamente accesibles.</span><span class="sxs-lookup"><span data-stu-id="a0475-148">A common problem in entity models is that they expose collection navigation properties as publicly accessible list types.</span></span> <span data-ttu-id="a0475-149">Esto permite que cualquier desarrollador colaborador manipule el contenido de estos tipos de colecciones, con lo que se pueden omitir importantes reglas de negocio relacionadas con la colección, lo que podría dejar el objeto en un estado no válido.</span><span class="sxs-lookup"><span data-stu-id="a0475-149">This allows any collaborator developer to manipulate the contents of these collection types, which may bypass important business rules related to the collection, possibly leaving the object in an invalid state.</span></span> <span data-ttu-id="a0475-150">La solución es conceder acceso de solo lectura a las colecciones relacionadas y proporcionar explícitamente métodos que definan formas para que los clientes las manipulen.</span><span class="sxs-lookup"><span data-stu-id="a0475-150">The solution to this is to expose read-only access to related collections and explicitly provide methods that define ways in which clients can manipulate them.</span></span>

<span data-ttu-id="a0475-151">En el código anterior, observe que muchos atributos son de solo lectura o privados, y que solo pueden actualizarlos los métodos de clase, por lo que cualquier actualización tiene en cuenta las invariables de dominio de negocio de cuenta y la lógica especificada en los métodos de clase.</span><span class="sxs-lookup"><span data-stu-id="a0475-151">In the previous code, note that many attributes are read-only or private and are only updatable by the class methods, so any update considers business domain invariants and logic specified within the class methods.</span></span>

<span data-ttu-id="a0475-152">Por ejemplo, de acuerdo a los patrones DDD, ***no* debería hacer lo siguiente** desde ningún método de controlador de comando ni clase de capa de aplicación (de hecho debería ser imposible hacerlo):</span><span class="sxs-lookup"><span data-stu-id="a0475-152">For example, following DDD patterns, **you should *not* do the following** from any command handler method or application layer class (actually, it should be impossible for you to do so):</span></span>

```csharp
// WRONG ACCORDING TO DDD PATTERNS – CODE AT THE APPLICATION LAYER OR
// COMMAND HANDLERS
// Code in command handler methods or Web API controllers
//... (WRONG) Some code with business logic out of the domain classes ...
OrderItem myNewOrderItem = new OrderItem(orderId, productId, productName,
    pictureUrl, unitPrice, discount, units);

//... (WRONG) Accessing the OrderItems collection directly from the application layer // or command handlers
myOrder.OrderItems.Add(myNewOrderItem);
//...
```

<span data-ttu-id="a0475-153">En este caso, el método Add es puramente una operación para agregar datos, con acceso directo a la colección OrderItems.</span><span class="sxs-lookup"><span data-stu-id="a0475-153">In this case, the Add method is purely an operation to add data, with direct access to the OrderItems collection.</span></span> <span data-ttu-id="a0475-154">Por lo tanto, la mayoría de la lógica, las reglas o las validaciones del dominio relacionadas con esa operación con las entidades secundarias se distribuirá a la capa de aplicación (controladores de comandos y controladores de Web API).</span><span class="sxs-lookup"><span data-stu-id="a0475-154">Therefore, most of the domain logic, rules, or validations related to that operation with the child entities will be spread across the application layer (command handlers and Web API controllers).</span></span>

<span data-ttu-id="a0475-155">Si omite la raíz de agregado, esta no puede garantizar sus invariables, su validez ni su coherencia.</span><span class="sxs-lookup"><span data-stu-id="a0475-155">If you go around the aggregate root, the aggregate root cannot guarantee its invariants, its validity, or its consistency.</span></span> <span data-ttu-id="a0475-156">Al final tendrá código espagueti o código de script transaccional.</span><span class="sxs-lookup"><span data-stu-id="a0475-156">Eventually you will have spaghetti code or transactional script code.</span></span>

<span data-ttu-id="a0475-157">Para seguir los patrones DDD, las entidades no deben tener establecedores públicos en ninguna propiedad de entidad.</span><span class="sxs-lookup"><span data-stu-id="a0475-157">To follow DDD patterns, entities must not have public setters in any entity property.</span></span> <span data-ttu-id="a0475-158">Los cambios en una entidad deben realizarse mediante métodos explícitos con lenguaje ubicuo explícito sobre el cambio que están realizando en la entidad.</span><span class="sxs-lookup"><span data-stu-id="a0475-158">Changes in an entity should be driven by explicit methods with explicit ubiquitous language about the change they are performing in the entity.</span></span>

<span data-ttu-id="a0475-159">Además, las colecciones de la entidad (por ejemplo, OrderItems) deben ser propiedades de solo lectura (el método AsReadOnly explicado más adelante).</span><span class="sxs-lookup"><span data-stu-id="a0475-159">Furthermore, collections within the entity (like the order items) should be read-only properties (the AsReadOnly method explained later).</span></span> <span data-ttu-id="a0475-160">Debe ser capaz de actualizarla solo desde los métodos de la clase raíz de agregado o los métodos de entidad secundaria.</span><span class="sxs-lookup"><span data-stu-id="a0475-160">You should be able to update it only from within the aggregate root class methods or the child entity methods.</span></span>

<span data-ttu-id="a0475-161">Como puede ver en el código de la raíz de agregado Order, todos los establecedores deben ser privados o al menos de solo lectura externamente para que cualquier operación en los datos de la entidad o sus entidades secundarias tenga que realizarse mediante métodos en la clase de entidad.</span><span class="sxs-lookup"><span data-stu-id="a0475-161">As you can see in the code for the Order aggregate root, all setters should be private or at least read-only externally, so that any operation against the entity's data or its child entities has to be performed through methods in the entity class.</span></span> <span data-ttu-id="a0475-162">Esto mantiene la coherencia de una manera controlada y orientada a objetos en lugar de implementar código de script transaccional.</span><span class="sxs-lookup"><span data-stu-id="a0475-162">This maintains consistency in a controlled and object-oriented way instead of implementing transactional script code.</span></span>

<span data-ttu-id="a0475-163">El fragmento de código siguiente muestra la manera adecuada de programar la tarea de agregar un objeto OrderItem al agregado Order.</span><span class="sxs-lookup"><span data-stu-id="a0475-163">The following code snippet shows the proper way to code the task of adding an OrderItem object to the Order aggregate.</span></span>

```csharp
// RIGHT ACCORDING TO DDD--CODE AT THE APPLICATION LAYER OR COMMAND HANDLERS
// The code in command handlers or WebAPI controllers, related only to application stuff
// There is NO code here related to OrderItem object's business logic
myOrder.AddOrderItem(productId, productName, pictureUrl, unitPrice, discount, units);

// The code related to OrderItem params validations or domain rules should
// be WITHIN the AddOrderItem method.

//...
```

<span data-ttu-id="a0475-164">En este fragmento de código, la mayoría de las validaciones o la lógica relacionadas con la creación de un objeto OrderItem están bajo el control de la raíz de agregado Order, en el método AddOrderItem, especialmente las validaciones y la lógica relacionadas con otros elementos del agregado.</span><span class="sxs-lookup"><span data-stu-id="a0475-164">In this snippet, most of the validations or logic related to the creation of an OrderItem object will be under the control of the Order aggregate root—in the AddOrderItem method—especially validations and logic related to other elements in the aggregate.</span></span> <span data-ttu-id="a0475-165">Por ejemplo, podría obtener el mismo artículo como resultado de varias llamadas a AddOrderItem.</span><span class="sxs-lookup"><span data-stu-id="a0475-165">For instance, you might get the same product item as the result of multiple calls to AddOrderItem.</span></span> <span data-ttu-id="a0475-166">En ese método, puede examinar los artículos y consolidar los mismos en un único objeto OrderItem con varias unidades.</span><span class="sxs-lookup"><span data-stu-id="a0475-166">In that method, you could examine the product items and consolidate the same product items into a single OrderItem object with several units.</span></span> <span data-ttu-id="a0475-167">Además, si hay importes de descuento distintos pero el identificador de producto es el mismo, se aplicaría el mayor descuento.</span><span class="sxs-lookup"><span data-stu-id="a0475-167">Additionally, if there are different discount amounts but the product ID is the same, you would likely apply the higher discount.</span></span> <span data-ttu-id="a0475-168">Este principio se aplica a cualquier otra lógica de dominio del objeto OrderItem.</span><span class="sxs-lookup"><span data-stu-id="a0475-168">This principle applies to any other domain logic for the OrderItem object.</span></span>

<span data-ttu-id="a0475-169">Además, la nueva operación OrderItem(params) también es controlada y realizada por el método AddOrderItem de la raíz de agregado Order.</span><span class="sxs-lookup"><span data-stu-id="a0475-169">In addition, the new OrderItem(params) operation will also be controlled and performed by the AddOrderItem method from the Order aggregate root.</span></span> <span data-ttu-id="a0475-170">Por lo tanto, la mayoría de la lógica o las validaciones relacionadas con esa operación (especialmente todo lo que afecta a la coherencia entre otras entidades secundarias) estará en una única ubicación dentro de la raíz de agregado.</span><span class="sxs-lookup"><span data-stu-id="a0475-170">Therefore, most of the logic or validations related to that operation (especially anything that impacts the consistency between other child entities) will be in a single place within the aggregate root.</span></span> <span data-ttu-id="a0475-171">Ese es el fin último del patrón de raíz de agregado.</span><span class="sxs-lookup"><span data-stu-id="a0475-171">That is the ultimate purpose of the aggregate root pattern.</span></span>

<span data-ttu-id="a0475-172">Cuando use Entity Framework Core 1.1 o posterior, una entidad DDD se puede expresar mejor porque permite [asignar a campos](/ef/core/modeling/backing-field) además de a propiedades.</span><span class="sxs-lookup"><span data-stu-id="a0475-172">When you use Entity Framework Core 1.1 or later, a DDD entity can be better expressed because it allows [mapping to fields](/ef/core/modeling/backing-field) in addition to properties.</span></span> <span data-ttu-id="a0475-173">Esto resulta útil al proteger colecciones de entidades secundarias u objetos de valor.</span><span class="sxs-lookup"><span data-stu-id="a0475-173">This is useful when protecting collections of child entities or value objects.</span></span> <span data-ttu-id="a0475-174">Con esta mejora, puede usar campos privados simples en lugar de propiedades y puede implementar cualquier actualización de la colección de campos en los métodos públicos y proporcionar acceso de solo lectura mediante el método AsReadOnly.</span><span class="sxs-lookup"><span data-stu-id="a0475-174">With this enhancement, you can use simple private fields instead of properties and you can implement any update to the field collection in public methods and provide read-only access through the AsReadOnly method.</span></span>

<span data-ttu-id="a0475-175">En DDD, interesa actualizar la entidad únicamente mediante métodos de la entidad (o el constructor) para controlar cualquier invariable y la coherencia de los datos, de modo que las propiedades solo se definan con un descriptor de acceso get.</span><span class="sxs-lookup"><span data-stu-id="a0475-175">In DDD, you want to update the entity only through methods in the entity (or the constructor) in order to control any invariant and the consistency of the data, so properties are defined only with a get accessor.</span></span> <span data-ttu-id="a0475-176">Las propiedades se basan en campos privados.</span><span class="sxs-lookup"><span data-stu-id="a0475-176">The properties are backed by private fields.</span></span> <span data-ttu-id="a0475-177">A los miembros privados solo se puede acceder desde la clase.</span><span class="sxs-lookup"><span data-stu-id="a0475-177">Private members can only be accessed from within the class.</span></span> <span data-ttu-id="a0475-178">Pero hay una excepción: EF Core también debe establecer estos campos (de forma que pueda devolver el objeto con los valores adecuados).</span><span class="sxs-lookup"><span data-stu-id="a0475-178">However, there is one exception: EF Core needs to set these fields as well (so it can return the object with the proper values).</span></span>

### <a name="map-properties-with-only-get-accessors-to-the-fields-in-the-database-table"></a><span data-ttu-id="a0475-179">Asignación de propiedades con solo los descriptores de acceso get a los campos de la tabla de base de datos</span><span class="sxs-lookup"><span data-stu-id="a0475-179">Map properties with only get accessors to the fields in the database table</span></span>

<span data-ttu-id="a0475-180">La asignación de propiedades a columnas de la tabla de base de datos no es responsabilidad del dominio, sino que forma parte de la capa de infraestructura y persistencia.</span><span class="sxs-lookup"><span data-stu-id="a0475-180">Mapping properties to database table columns is not a domain responsibility but part of the infrastructure and persistence layer.</span></span> <span data-ttu-id="a0475-181">Se menciona aquí simplemente para que sea consciente de las nuevas capacidades de EF Core 1.1 o posterior relacionadas con la forma de modelar entidades.</span><span class="sxs-lookup"><span data-stu-id="a0475-181">We mention this here just so you are aware of the new capabilities in EF Core 1.1 or later related to how you can model entities.</span></span> <span data-ttu-id="a0475-182">En la sección de infraestructura y persistencia se explican más detalles sobre este tema.</span><span class="sxs-lookup"><span data-stu-id="a0475-182">Additional details on this topic are explained in the infrastructure and persistence section.</span></span>

<span data-ttu-id="a0475-183">Cuando se usa EF Core 1.0 o posterior, en DbContext es necesario asignar las propiedades definidas únicamente con captadores a los campos reales de la tabla de base de datos.</span><span class="sxs-lookup"><span data-stu-id="a0475-183">When you use EF Core 1.0 or later, within the DbContext you need to map the properties that are defined only with getters to the actual fields in the database table.</span></span> <span data-ttu-id="a0475-184">Esto se hace con el método HasField de la clase PropertyBuilder.</span><span class="sxs-lookup"><span data-stu-id="a0475-184">This is done with the HasField method of the PropertyBuilder class.</span></span>

### <a name="map-fields-without-properties"></a><span data-ttu-id="a0475-185">Asignación de campos sin propiedades</span><span class="sxs-lookup"><span data-stu-id="a0475-185">Map fields without properties</span></span>

<span data-ttu-id="a0475-186">La característica de EF Core 1.1 o posterior para asignar columnas a campos también permite no usar propiedades.</span><span class="sxs-lookup"><span data-stu-id="a0475-186">With the feature in EF Core 1.1 or later to map columns to fields, it is also possible to not use properties.</span></span> <span data-ttu-id="a0475-187">En su lugar, puede simplemente asignar columnas de una tabla a campos.</span><span class="sxs-lookup"><span data-stu-id="a0475-187">Instead, you can just map columns from a table to fields.</span></span> <span data-ttu-id="a0475-188">Un caso de uso común de esto son los campos privados de un estado interno al que no es necesario acceder desde fuera de la entidad.</span><span class="sxs-lookup"><span data-stu-id="a0475-188">A common use case for this is private fields for an internal state that does not need to be accessed from outside the entity.</span></span>

<span data-ttu-id="a0475-189">Por ejemplo, en el ejemplo de código OrderAggregate anterior, hay varios campos privados, como el campo `_paymentMethodId`, sin ninguna propiedad relacionada para un establecedor ni un captador.</span><span class="sxs-lookup"><span data-stu-id="a0475-189">For example, in the preceding OrderAggregate code example, there are several private fields, like the  `_paymentMethodId` field, that have no related property for either a setter or getter.</span></span> <span data-ttu-id="a0475-190">Ese campo también podría calcularse en la lógica de negocios de Order y usarse desde los métodos de Order, pero debe conservarse además en la base de datos.</span><span class="sxs-lookup"><span data-stu-id="a0475-190">That field could also be calculated within the order's business logic and used from the order's methods, but it needs to be persisted in the database as well.</span></span> <span data-ttu-id="a0475-191">Así, en EF Core (a partir de la versión 1.1) hay una forma de asignar un campo sin ninguna propiedad relacionada a una columna de la base de datos.</span><span class="sxs-lookup"><span data-stu-id="a0475-191">So in EF Core (since v1.1) there is a way to map a field without a related property to a column in the database.</span></span> <span data-ttu-id="a0475-192">Esto también se explica en la sección [Capa de infraestructura](ddd-oriented-microservice.md#the-infrastructure-layer) de esta guía.</span><span class="sxs-lookup"><span data-stu-id="a0475-192">This is also explained in the [Infrastructure layer](ddd-oriented-microservice.md#the-infrastructure-layer) section of this guide.</span></span>

### <a name="additional-resources"></a><span data-ttu-id="a0475-193">Recursos adicionales</span><span class="sxs-lookup"><span data-stu-id="a0475-193">Additional resources</span></span>

- <span data-ttu-id="a0475-194">**Vaughn Vernon. Modeling Aggregates with DDD and Entity Framework (Modelado de agregados con DDD y Entity Framework).**</span><span class="sxs-lookup"><span data-stu-id="a0475-194">**Vaughn Vernon. Modeling Aggregates with DDD and Entity Framework.**</span></span> <span data-ttu-id="a0475-195">Tenga en cuenta que esto *no* es Entity Framework Core.</span><span class="sxs-lookup"><span data-stu-id="a0475-195">Note that this is *not* Entity Framework Core.</span></span> \
  <https://kalele.io/blog-posts/modeling-aggregates-with-ddd-and-entity-framework/>

- <span data-ttu-id="a0475-196">**Julie Lerman. Puntos de datos - Programación para un diseño guiado por el dominio: sugerencias para los desarrolladores enfocados en datos** </span><span class="sxs-lookup"><span data-stu-id="a0475-196">**Julie Lerman. Data Points - Coding for Domain-Driven Design: Tips for Data-Focused Devs** </span></span>\
  <https://docs.microsoft.com/archive/msdn-magazine/2013/august/data-points-coding-for-domain-driven-design-tips-for-data-focused-devs>

- <span data-ttu-id="a0475-197">**Udi Dahan. Cómo crear modelos de dominio totalmente encapsulados** </span><span class="sxs-lookup"><span data-stu-id="a0475-197">**Udi Dahan. How to create fully encapsulated Domain Models** </span></span>\
  <https://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/>

> [!div class="step-by-step"]
> <span data-ttu-id="a0475-198">[Anterior](microservice-domain-model.md)
> [Siguiente](seedwork-domain-model-base-classes-interfaces.md)</span><span class="sxs-lookup"><span data-stu-id="a0475-198">[Previous](microservice-domain-model.md)
[Next](seedwork-domain-model-base-classes-interfaces.md)</span></span>
