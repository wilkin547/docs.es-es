---
title: Pasos del flujo de trabajo de DevOps de bucle externo para una aplicación de Docker
description: Conozca los pasos del "bucle exterior" del flujo de trabajo de DevOps.
ms.date: 01/06/2021
ms.openlocfilehash: bfac2d2c7866bfd11cd18201a93cb17a72cae588
ms.sourcegitcommit: 7ef96827b161ef3fcde75f79d839885632e26ef1
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 01/07/2021
ms.locfileid: "97970302"
---
# <a name="steps-in-the-outer-loop-devops-workflow-for-a-docker-application"></a><span data-ttu-id="271da-103">Pasos del flujo de trabajo de DevOps de bucle externo para una aplicación de Docker</span><span class="sxs-lookup"><span data-stu-id="271da-103">Steps in the outer-loop DevOps workflow for a Docker application</span></span>

<span data-ttu-id="271da-104">En la figura 5-1 se muestra una representación de un extremo a otro de los pasos que componen el flujo de trabajo del bucle externo de DevOps.</span><span class="sxs-lookup"><span data-stu-id="271da-104">Figure 5-1 presents an end-to-end depiction of the steps comprising the DevOps outer-loop workflow.</span></span> <span data-ttu-id="271da-105">Muestra el "bucle externo" de DevOps.</span><span class="sxs-lookup"><span data-stu-id="271da-105">It shows the "outer loop" of DevOps.</span></span> <span data-ttu-id="271da-106">Cuando se inserta código en el repositorio, se inicia una canalización de CI y, después, comienza la canalización de CD, donde se implementa la aplicación.</span><span class="sxs-lookup"><span data-stu-id="271da-106">When code is pushed to the repo, a CI pipeline is started, then begins the CD pipeline, where the application gets deployed.</span></span> <span data-ttu-id="271da-107">Las métricas recopiladas de las aplicaciones implementadas se envían a la carga de trabajo de desarrollo, donde se produce el "bucle interno", a fin de que los equipos de desarrollo tengan datos reales para responder a las necesidades del usuario y de la organización.</span><span class="sxs-lookup"><span data-stu-id="271da-107">Metrics collected from deployed applications are fed back into the development workload, where the "inner loop" occurs, so development teams have actual data to respond to user and business needs.</span></span>

![Diagrama que muestra los 6 pasos del flujo de trabajo del bucle externo de DevOps.](./media/docker-application-outer-loop-devops-workflow/overview-dev-ops-outter-loop-workflow.png)

<span data-ttu-id="271da-109">**Figura 5-1**.</span><span class="sxs-lookup"><span data-stu-id="271da-109">**Figure 5-1**.</span></span> <span data-ttu-id="271da-110">Flujo de trabajo del bucle externo de DevOps para aplicaciones de Docker con herramientas de Microsoft</span><span class="sxs-lookup"><span data-stu-id="271da-110">DevOps outer-loop workflow for Docker applications with Microsoft tools</span></span>

<span data-ttu-id="271da-111">Examinemos cada uno de estos pasos con mayor detalle.</span><span class="sxs-lookup"><span data-stu-id="271da-111">Now, let's examine each of these steps in greater detail.</span></span>

## <a name="step-1-inner-loop-development-workflow"></a><span data-ttu-id="271da-112">Paso 1: flujo de trabajo de desarrollo del bucle interno</span><span class="sxs-lookup"><span data-stu-id="271da-112">Step 1: Inner-loop development workflow</span></span>

<span data-ttu-id="271da-113">Este paso se explica con detalle en el capítulo 4, pero, a modo de resumen, aquí es donde empieza el bucle externo. En este momento, el desarrollador inserta código en el sistema de administración de control de código fuente (por ejemplo, GIT), lo que da inicio a acciones de la canalización de CI.</span><span class="sxs-lookup"><span data-stu-id="271da-113">This step is explained in detail in Chapter 4, but, to recap, here is where the outer-loop begins, the moment at which a developer pushes code to the source control management system (like Git) initiating CI pipeline actions.</span></span>

## <a name="step-2-source-code-control-integration-and-management-with-azure-devops-services-and-git"></a><span data-ttu-id="271da-114">Paso 2: integración y administración del control de código fuente con Azure DevOps Services y GIT</span><span class="sxs-lookup"><span data-stu-id="271da-114">Step 2: Source-Code Control integration and management with Azure DevOps Services and Git</span></span>

<span data-ttu-id="271da-115">En este paso, debe contar con un sistema de control de versiones para recopilar una versión consolidada de todo el código procedente de los diferentes desarrolladores del equipo.</span><span class="sxs-lookup"><span data-stu-id="271da-115">At this step, you need to have a version-control system to gather a consolidated version of all the code coming from the different developers in the team.</span></span>

<span data-ttu-id="271da-116">Aunque el control de código fuente (SCC) y la administración de código fuente pueden parecerles algo instintivo a la mayoría de los desarrolladores, al crear aplicaciones de Docker en un ciclo de vida de DevOps, es fundamental hacer hincapié en que no se deben enviar las imágenes de Docker con la aplicación directamente al registro de Docker de global (como Azure Container Registry o Docker Hub) desde el equipo del desarrollador.</span><span class="sxs-lookup"><span data-stu-id="271da-116">Even though source-code control (SCC) and source-code management might seem second-nature to most developers, when creating Docker applications in a DevOps life cycle, it's critical to emphasize that you must not submit the Docker images with the application directly to the global Docker Registry (like Azure Container Registry or Docker Hub) from the developer's machine.</span></span> <span data-ttu-id="271da-117">Por el contrario, las imágenes de Docker que van a lanzarse e implementarse en entornos de producción deben crearse únicamente en el código fuente que se está integrando en la canalización de compilación o CI global, en función del repositorio de código fuente (por ejemplo, GIT).</span><span class="sxs-lookup"><span data-stu-id="271da-117">On the contrary, the Docker images to be released and deployed to production environments must be created solely on the source code that's being integrated in your global build or CI pipeline based on your source-code repository (like Git).</span></span>

<span data-ttu-id="271da-118">Las imágenes locales que generen los desarrolladores se usarán exclusivamente cuando estos prueben sus equipos.</span><span class="sxs-lookup"><span data-stu-id="271da-118">The local images, generated by developers, should just be used by them when testing within their own machines.</span></span> <span data-ttu-id="271da-119">Por este motivo es fundamental que la canalización de DevOps esté activada desde el código de SCC.</span><span class="sxs-lookup"><span data-stu-id="271da-119">That's why it's critical to have the DevOps pipeline activated from the SCC code.</span></span>

<span data-ttu-id="271da-120">Azure DevOps Services y Team Foundation Server admiten GIT y Control de versiones de Team Foundation.</span><span class="sxs-lookup"><span data-stu-id="271da-120">Azure DevOps Services and Team Foundation Server support Git and Team Foundation Version Control.</span></span> <span data-ttu-id="271da-121">Puede elegir cualquiera de ellos y usarlo para disfrutar de una experiencia de Microsoft de un extremo a otro.</span><span class="sxs-lookup"><span data-stu-id="271da-121">You can choose between them and use it for an end-to-end Microsoft experience.</span></span> <span data-ttu-id="271da-122">Aun así, también puede administrar el código en repositorios externos (como GitHub, repositorios de GIT locales o Subversion) y seguir siendo capaz de conectarse a él y obtener el código como punto de partida para la canalización de CI de DevOps.</span><span class="sxs-lookup"><span data-stu-id="271da-122">However, you can also manage your code in external repositories (like GitHub, on-premises Git repositories, or Subversion) and still be able to connect to it and get the code as the starting point for your DevOps CI pipeline.</span></span>

## <a name="step-3-build-ci-integrate-and-test-with-azure-devops-services-and-docker"></a><span data-ttu-id="271da-123">Paso 3: compilación, CI, integración y prueba con Azure DevOps Services y Docker</span><span class="sxs-lookup"><span data-stu-id="271da-123">Step 3: Build, CI, Integrate, and Test with Azure DevOps Services and Docker</span></span>

<span data-ttu-id="271da-124">CI se ha convertido en un estándar para las pruebas y la entrega de software moderno.</span><span class="sxs-lookup"><span data-stu-id="271da-124">CI has emerged as a standard for modern software testing and delivery.</span></span> <span data-ttu-id="271da-125">La solución de Docker mantiene una clara separación de intereses entre los equipos de desarrollo y operaciones.</span><span class="sxs-lookup"><span data-stu-id="271da-125">The Docker solution maintains a clear separation of concerns between the development and operations teams.</span></span> <span data-ttu-id="271da-126">La inmutabilidad de las imágenes de Docker garantiza una implementación repetible entre lo que se ha desarrollado, lo que se ha probado a través de CI y lo que se ha ejecutado en producción.</span><span class="sxs-lookup"><span data-stu-id="271da-126">The immutability of Docker images ensures a repeatable deployment between what's developed, tested through CI, and run in production.</span></span> <span data-ttu-id="271da-127">El motor de Docker implementado en los portátiles de los desarrolladores y la infraestructura de prueba hace que los contenedores puedan transportarse a distintos entornos.</span><span class="sxs-lookup"><span data-stu-id="271da-127">Docker Engine deployed across the developer laptops and test infrastructure makes the containers portable across environments.</span></span>

<span data-ttu-id="271da-128">Llegado a este punto, cuando tenga un sistema de control de versiones con el código correcto enviado, necesitará un *servicio de compilación* para tomar el código y ejecutar la compilación y las pruebas globales.</span><span class="sxs-lookup"><span data-stu-id="271da-128">At this point, after you have a version-control system with the correct code submitted, you need a *build service* to pick up the code and run the global build and tests.</span></span>

<span data-ttu-id="271da-129">El flujo de trabajo interno para este paso (CI, compilación, prueba) consiste en la construcción de una canalización de CI que consta del repositorio de código (GIT, etc.), el servidor de compilación (Azure DevOps Services), el motor de Docker y un registro de Docker.</span><span class="sxs-lookup"><span data-stu-id="271da-129">The internal workflow for this step (CI, build, test) is about the construction of a CI pipeline consisting of your code repository (Git, etc.), your build server (Azure DevOps Services), Docker Engine, and a Docker Registry.</span></span>

<span data-ttu-id="271da-130">Puede usar Azure DevOps Services como base para compilar las aplicaciones y configurar la canalización de CI, así como para publicar los "artefactos" compilados en un "repositorio de artefactos", como se explica en el paso siguiente.</span><span class="sxs-lookup"><span data-stu-id="271da-130">You can use Azure DevOps Services as the foundation for building your applications and setting your CI pipeline, and for publishing the built "artifacts" to an "artifacts repository," which is explained in the next step.</span></span>

<span data-ttu-id="271da-131">Al usar Docker para la implementación, los "artefactos finales" que se implementarán son imágenes de Docker en las que se ha insertado la aplicación o los servicios.</span><span class="sxs-lookup"><span data-stu-id="271da-131">When using Docker for the deployment, the "final artifacts" to be deployed are Docker images with your application or services embedded within them.</span></span> <span data-ttu-id="271da-132">Dichas imágenes se insertan o se publican en un *registro de Docker* (un repositorio privado, como los que se pueden tener en Azure Container Registry, o un repositorio público, como el registro de Docker Hub, que suele usarse para imágenes base oficiales).</span><span class="sxs-lookup"><span data-stu-id="271da-132">Those images are pushed or published to a *Docker Registry* (a private repository like the ones you can have in Azure Container Registry, or a public one like Docker Hub Registry, which is commonly used for official base images).</span></span>

<span data-ttu-id="271da-133">Este es el concepto básico: la canalización de CI la iniciará una confirmación en un repositorio de SCC, como GIT.</span><span class="sxs-lookup"><span data-stu-id="271da-133">Here is the basic concept: The CI pipeline will be kicked-off by a commit to an SCC repository like Git.</span></span> <span data-ttu-id="271da-134">La confirmación hará que Azure DevOps Services ejecute un trabajo de compilación dentro de un contenedor de Docker y, tras la finalización correcta de ese trabajo, insertará una imagen de Docker en el registro de Docker, como se muestra en la figura 5-2.</span><span class="sxs-lookup"><span data-stu-id="271da-134">The commit will cause Azure DevOps Services to run a build job within a Docker container and, upon successful completion of that job, push a Docker image to the Docker Registry, as illustrated in Figure 5-2.</span></span> <span data-ttu-id="271da-135">La primera parte del bucle externo implica los pasos del 1 a 3, es decir, primero el paso de programación, ejecución, depuración y validación, después el repositorio de código y, por último, la compilación, la CI y la prueba.</span><span class="sxs-lookup"><span data-stu-id="271da-135">The first part of the outer loop involves steps 1 to 3, from code, run, debug and validate, then the code repo up to the build and test CI step.</span></span>

![Diagrama que muestra los tres pasos implicados en el flujo de trabajo de CI.](./media/docker-application-outer-loop-devops-workflow/continuous-integration-steps.png)

<span data-ttu-id="271da-137">**Figura 5-2**.</span><span class="sxs-lookup"><span data-stu-id="271da-137">**Figure 5-2**.</span></span> <span data-ttu-id="271da-138">Pasos del proceso de CI</span><span class="sxs-lookup"><span data-stu-id="271da-138">The steps involved in CI</span></span>

<span data-ttu-id="271da-139">Estos son los pasos básicos del flujo de trabajo de CI con Docker y Azure DevOps Services:</span><span class="sxs-lookup"><span data-stu-id="271da-139">Here are the basic CI workflow steps with Docker and Azure DevOps Services:</span></span>

1. <span data-ttu-id="271da-140">El desarrollador envía una confirmación a un repositorio de SCC (GIT/Azure DevOps Services, GitHub, etc.).</span><span class="sxs-lookup"><span data-stu-id="271da-140">The developer pushes a commit to an SCC repository (Git/Azure DevOps Services, GitHub, etc.).</span></span>

2. <span data-ttu-id="271da-141">Si usa Azure DevOps Services o GIT, CI estará integrada, lo que significa que es tan fácil como activar una casilla en Azure DevOps Services.</span><span class="sxs-lookup"><span data-stu-id="271da-141">If you're using Azure DevOps Services or Git, CI is built in, which means that it's as simple as selecting a check box in Azure DevOps Services.</span></span> <span data-ttu-id="271da-142">Si usa SCC externo (como GitHub), un `webhook` notificará a Azure DevOps Services la actualización o la insertará en GIT/GitHub.</span><span class="sxs-lookup"><span data-stu-id="271da-142">If you're using an external SCC (like GitHub), a `webhook` will notify Azure DevOps Services of the update or push to Git/GitHub.</span></span>

3. <span data-ttu-id="271da-143">Azure DevOps Services extrae el repositorio de SCC, incluido el archivo Dockerfile que describe la imagen, así como el código de la aplicación y la prueba.</span><span class="sxs-lookup"><span data-stu-id="271da-143">Azure DevOps Services pulls the SCC repository, including the Dockerfile describing the image, as well as the application and test code.</span></span>

4. <span data-ttu-id="271da-144">Azure DevOps Services compila una imagen de Docker y la etiqueta con un número de compilación.</span><span class="sxs-lookup"><span data-stu-id="271da-144">Azure DevOps Services builds a Docker image and labels it with a build number.</span></span>

5. <span data-ttu-id="271da-145">Azure DevOps Services crea una instancia del contenedor de Docker en el host de Docker aprovisionado y ejecuta las pruebas adecuadas.</span><span class="sxs-lookup"><span data-stu-id="271da-145">Azure DevOps Services instantiates the Docker container within the provisioned Docker Host, and runs the appropriate tests.</span></span>

6. <span data-ttu-id="271da-146">Si las pruebas son correctas, primero se vuelve a etiquetar la imagen con un nombre descriptivo para que se sepa que es una "compilación designada" (como "/1.0.0" o cualquier otra etiqueta) y, después, se inserta en el registro de Docker (Docker Hub, Azure Container Registry, DTR, etc.)</span><span class="sxs-lookup"><span data-stu-id="271da-146">If the tests are successful, the image is first relabeled to a meaningful name so that you know it's a "blessed build" (like "/1.0.0" or any other label), and then pushed up to your Docker Registry (Docker Hub, Azure Container Registry, DTR, etc.)</span></span>

### <a name="implementing-the-ci-pipeline-with-azure-devops-services-and-the-docker-extension-for-azure-devops-services"></a><span data-ttu-id="271da-147">Implementación de la canalización de CI con Azure DevOps Services y la extensión de Docker para Azure DevOps Services</span><span class="sxs-lookup"><span data-stu-id="271da-147">Implementing the CI pipeline with Azure DevOps Services and the Docker extension for Azure DevOps Services</span></span>

<span data-ttu-id="271da-148">Azure DevOps Services de Visual Studio contiene plantillas de compilación y versión que se pueden usar en la canalización de CI/CD para crear imágenes de Docker, insertarlas en un registro autenticado de Docker, ejecutarlas o llevar a cabo otras operaciones que ofrece la CLI de Docker.</span><span class="sxs-lookup"><span data-stu-id="271da-148">Visual Studio Azure DevOps Services contains Build & Release Templates that you can use in your CI/CD pipeline with which you can build Docker images, push Docker images to an authenticated Docker registry, run Docker images, or run other operations offered by the Docker CLI.</span></span> <span data-ttu-id="271da-149">También agrega una tarea de Docker Compose que se puede usar para compilar, insertar y ejecutar aplicaciones de Docker de varios contenedores, o bien para ejecutar otras operaciones de la CLI de Docker Compose, como se muestra en la figura 5-3.</span><span class="sxs-lookup"><span data-stu-id="271da-149">It also adds a Docker Compose task that you can use to build, push, and run multi-container Docker applications, or run other operations offered by the Docker Compose CLI, as shown in Figure 5-3.</span></span>

![Captura de pantalla de la canalización de CI de Docker en Azure DevOps.](./media/docker-application-outer-loop-devops-workflow/docker-ci-pipeline-azure-devops.png)

<span data-ttu-id="271da-151">**Figura 5-3**.</span><span class="sxs-lookup"><span data-stu-id="271da-151">**Figure 5-3**.</span></span> <span data-ttu-id="271da-152">Canalización de CI de Docker en Azure DevOps Services, incluidas las plantillas de compilación y versión y tareas asociadas</span><span class="sxs-lookup"><span data-stu-id="271da-152">The Docker CI pipeline in Azure DevOps Services including Build & Release Templates and associated tasks.</span></span>

<span data-ttu-id="271da-153">Puede usar estas plantillas y tareas a fin de construir artefactos de CI/CD para realizar la compilación, prueba e implementación en Azure Service Fabric, Azure Kubernetes Service y ofertas similares.</span><span class="sxs-lookup"><span data-stu-id="271da-153">You can use these templates and tasks to construct your CI/CD artifacts to Build / Test and Deploy in Azure Service Fabric, Azure Kubernetes Service, and similar offerings.</span></span>

<span data-ttu-id="271da-154">Con estas tareas de Visual Studio Team Services, un host o máquina virtual de Docker de Linux de compilación aprovisionados en Azure y su registro de Docker preferido (Azure Container Registry, Docker Hub, DTR de Docker privado o cualquier otro registro de Docker), puede ensamblar su canalización de CI de Docker de forma coherente.</span><span class="sxs-lookup"><span data-stu-id="271da-154">With these Visual Studio Team Services tasks, a build Linux-Docker Host/VM provisioned in Azure and your preferred Docker registry (Azure Container Registry, Docker Hub, private Docker DTR, or any other Docker registry) you can assemble your Docker CI pipeline in a very consistent way.</span></span>

<span data-ttu-id="271da-155">\**_Requisitos:_* _</span><span class="sxs-lookup"><span data-stu-id="271da-155">\**_Requirements:_* _</span></span>

- <span data-ttu-id="271da-156">Azure DevOps Services o, para instalaciones locales, Team Foundation Server 2015 Update 3 o una versión posterior.</span><span class="sxs-lookup"><span data-stu-id="271da-156">Azure DevOps Services, or for on-premises installations, Team Foundation Server 2015 Update 3 or later.</span></span>

- <span data-ttu-id="271da-157">Un agente de Azure DevOps Services que tenga los archivos binarios de Docker.</span><span class="sxs-lookup"><span data-stu-id="271da-157">An Azure DevOps Services agent that has the Docker binaries.</span></span>

  <span data-ttu-id="271da-158">Una manera fácil de crear uno de estos agentes consiste en usar Docker para ejecutar un contenedor basado en la imagen de Docker del agente de Azure DevOps Services.</span><span class="sxs-lookup"><span data-stu-id="271da-158">An easy way to create one of these agents is to use Docker to run a container based on the Azure DevOps Services agent Docker image.</span></span>

> <span data-ttu-id="271da-159">[INFORMACIÓN] Para obtener más detalles sobre cómo ensamblar una canalización de CI de Docker de Azure DevOps Services y consultar los tutoriales, visite estos sitios:</span><span class="sxs-lookup"><span data-stu-id="271da-159">[!INFORMATION] To read more about assembling an Azure DevOps Services Docker CI pipeline and view the walkthroughs, visit these sites:</span></span>
>
> - <span data-ttu-id="271da-160">Ejecución de un agente de Visual Studio Team Services (ahora Azure DevOps Services) como un contenedor de Docker: </span><span class="sxs-lookup"><span data-stu-id="271da-160">Running a Visual Studio Team Services (Now Azure DevOps Services) agent as a Docker container: </span></span>\
>   <https://hub.docker.com/_/microsoft-azure-pipelines-vsts-agent>
>
> - <span data-ttu-id="271da-161">Creación de imágenes de Docker de Linux para .NET con Azure DevOps Services: </span><span class="sxs-lookup"><span data-stu-id="271da-161">Building .NET Linux Docker images with Azure DevOps Services: </span></span>\
>   <https://docs.microsoft.com/archive/blogs/stevelasker/building-net-core-linux-docker-images-with-visual-studio-team-services>
>
> - <span data-ttu-id="271da-162">Creación de una máquina de compilación de Visual Studio Team Services basada en Linux con compatibilidad con Docker: </span><span class="sxs-lookup"><span data-stu-id="271da-162">Building a Linux-based Visual Studio Team Service build machine with Docker support: </span></span>\
>   <https://www.donovanbrown.com/post/Building-a-Linux-Based-Visual-Studio-Team-Service-Build-Machine-with-Docker-Support>

### <a name="integrate-test-and-validate-multi-container-docker-applications"></a><span data-ttu-id="271da-163">Integración, prueba y validación de aplicaciones de Docker de varios contenedores</span><span class="sxs-lookup"><span data-stu-id="271da-163">Integrate, test, and validate multi-container Docker applications</span></span>

<span data-ttu-id="271da-164">Normalmente, la mayoría de las aplicaciones de Docker se componen de varios contenedores, en lugar de uno solo.</span><span class="sxs-lookup"><span data-stu-id="271da-164">Typically, most Docker applications are composed of multiple containers rather than a single container.</span></span> <span data-ttu-id="271da-165">Un buen ejemplo es una aplicación orientada a microservicios que tenga un contenedor por microservicio.</span><span class="sxs-lookup"><span data-stu-id="271da-165">A good example is a microservices-oriented application for which you would have one container per microservice.</span></span> <span data-ttu-id="271da-166">Pero incluso si no se sigue estrictamente una filosofía basada en microservicios, es probable que una aplicación de Docker esté compuesta de varios contenedores o servicios.</span><span class="sxs-lookup"><span data-stu-id="271da-166">But, even without strictly following the microservices approach patterns, it's probable that your Docker application would be composed of multiple containers or services.</span></span>

<span data-ttu-id="271da-167">Por lo tanto, después de compilar los contenedores de aplicación en la canalización de CI, también deberá implementar, integrar y probar la aplicación en su conjunto con todos sus contenedores en un host de Docker de integración, o incluso en un clúster de prueba en el que se distribuyan los contenedores.</span><span class="sxs-lookup"><span data-stu-id="271da-167">Therefore, after building the application containers in the CI pipeline, you also need to deploy, integrate, and test the application as a whole with all of its containers within an integration Docker host or even into a test cluster to which your containers are distributed.</span></span>

<span data-ttu-id="271da-168">Si usa un solo host, puede recurrir a comandos de Docker como docker-compose para compilar e implementar contenedores relacionados a fin de probar y validar el entorno de Docker en una sola máquina virtual.</span><span class="sxs-lookup"><span data-stu-id="271da-168">If you're using a single host, you can use Docker commands such as docker-compose to build and deploy related containers to test and validate the Docker environment in a single VM.</span></span> <span data-ttu-id="271da-169">Aun así, si trabaja con un clúster de orquestador como DC/OS, Kubernetes o Docker Swarm, deberá implementar los contenedores mediante un mecanismo u orquestador diferentes, en función del clúster o programador que haya seleccionado.</span><span class="sxs-lookup"><span data-stu-id="271da-169">But, if you're working with an orchestrator cluster like DC/OS, Kubernetes, or Docker Swarm, you need to deploy your containers through a different mechanism or orchestrator, depending on your selected cluster/scheduler.</span></span>

<span data-ttu-id="271da-170">A continuación se muestran varios tipos de pruebas que se pueden ejecutar en contenedores de Docker:</span><span class="sxs-lookup"><span data-stu-id="271da-170">The following are several types of tests that you can run against Docker containers:</span></span>

- <span data-ttu-id="271da-171">Pruebas unitarias para contenedores de Docker</span><span class="sxs-lookup"><span data-stu-id="271da-171">Unit tests for Docker containers</span></span>

- <span data-ttu-id="271da-172">Pruebas de grupos de aplicaciones o microservicios interrelacionados</span><span class="sxs-lookup"><span data-stu-id="271da-172">Testing groups of interrelated applications or microservices</span></span>

- <span data-ttu-id="271da-173">Pruebas en versiones de producción y de lanzamiento controlado</span><span class="sxs-lookup"><span data-stu-id="271da-173">Test in production and "canary" releases</span></span>

<span data-ttu-id="271da-174">Lo importante al ejecutar las pruebas funcionales y de integración es que las realice desde fuera de los contenedores.</span><span class="sxs-lookup"><span data-stu-id="271da-174">The important point is that when running integration and functional tests, you must run those tests from outside of the containers.</span></span> <span data-ttu-id="271da-175">Las pruebas no se incluyen ni se ejecutan en los contenedores que va a implementar, porque los contenedores se basan en imágenes estáticas que deberían ser exactamente iguales a las que implementará en producción.</span><span class="sxs-lookup"><span data-stu-id="271da-175">Tests are not contained or run in the containers you're deploying, because the containers are based on static images that should be exactly like the ones you'll be deploying to production.</span></span>

<span data-ttu-id="271da-176">Una opción práctica al realizar las pruebas en escenarios más avanzados, como cuando se incluyen varios clústeres (clúster de prueba, de almacenamiento provisional y de producción), consiste en publicar las imágenes en un registro, de modo que se pueda probar en varios clústeres.</span><span class="sxs-lookup"><span data-stu-id="271da-176">A practical option when testing more advanced scenarios, like including several clusters (test cluster, staging cluster, and production cluster) is to publish the images to a registry, so it can be tested in various clusters.</span></span>

### <a name="push-the-custom-application-docker-image-into-your-global-docker-registry"></a><span data-ttu-id="271da-177">Inserción de imágenes de Docker de aplicación personalizadas en el registro de Docker global</span><span class="sxs-lookup"><span data-stu-id="271da-177">Push the custom application Docker image into your global Docker Registry</span></span>

<span data-ttu-id="271da-178">Una vez que se hayan probado y validado las imágenes de Docker, querrá etiquetarlas y publicarlas en el registro de Docker.</span><span class="sxs-lookup"><span data-stu-id="271da-178">After the Docker images have been tested and validated, you'll want to tag and publish them to your Docker registry.</span></span> <span data-ttu-id="271da-179">El registro de Docker es un elemento fundamental en el ciclo de vida de la aplicación de Docker, ya que es la ubicación central en la que se almacena la prueba personalizada (también conocida como "imagen designada") que se implementará en entornos de producción y control de calidad.</span><span class="sxs-lookup"><span data-stu-id="271da-179">The Docker registry is a critical piece in the Docker application life cycle because it's the central place where you store your custom test (also known as "blessed images") to be deployed into QA and production environments.</span></span>

<span data-ttu-id="271da-180">Del mismo modo que el código de la aplicación almacenado en el repositorio de SCC (GIT, etc.) es el "origen fiable", el registro de Docker es el "origen fiable" de la aplicación binaria o los bits que se implementarán en los entornos de producción o control de calidad.</span><span class="sxs-lookup"><span data-stu-id="271da-180">Similar to how the application code stored in your SCC repository (Git, etc.) is your "source of truth," the Docker registry is your "source of truth" for your binary application or bits to be deployed to the QA or production environments.</span></span>

<span data-ttu-id="271da-181">Normalmente, le interesa tener los repositorios privados para las imágenes personalizadas en un repositorio privado en Azure Container Registry, en un registro local como Docker Trusted Registry o en un registro de nube pública con acceso restringido (por ejemplo, Docker Hub), aunque en este último caso, si no se trata de código abierto, debe confiar en la seguridad del proveedor.</span><span class="sxs-lookup"><span data-stu-id="271da-181">Typically, you might want to have your private repositories for your custom images either in a private repository in Azure Container Registry or in an on-premises registry like Docker Trusted Registry, or in a public-cloud registry with restricted access (like Docker Hub), although in this last case if your code is not open source, you must trust the vendor's security.</span></span> <span data-ttu-id="271da-182">En cualquier caso, el método que use es similar y se basa en el comando `docker push`, como se muestra en la figura 5-4.</span><span class="sxs-lookup"><span data-stu-id="271da-182">Either way, the method you use is similar and is based on the `docker push` command, as shown in Figure 5-4.</span></span>

![Diagrama que muestra la extracción de imágenes personalizadas a un registro de contenedor.](./media/docker-application-outer-loop-devops-workflow/docker-push-custom-images.png)

<span data-ttu-id="271da-184">_\*Figura 5-4\*\*.</span><span class="sxs-lookup"><span data-stu-id="271da-184">_\*Figure 5-4\*\*.</span></span> <span data-ttu-id="271da-185">Publicación de imágenes personalizadas en el registro de Docker</span><span class="sxs-lookup"><span data-stu-id="271da-185">Publishing custom images to Docker Registry</span></span>

<span data-ttu-id="271da-186">En el paso 3, para la compilación, la integración y las pruebas (CI), podría interesarle publicar las imágenes de Docker resultantes en un registro privado o público.</span><span class="sxs-lookup"><span data-stu-id="271da-186">In step 3, for building integration and testing (CI) you might publish the resulting docker images to a private or public registry.</span></span> <span data-ttu-id="271da-187">Existen proveedores de nube que ofrecen diversos registros de Docker, como Azure Container Registry, Amazon Web Services Container Registry, Google Container Registry, Quay Registry, etc.</span><span class="sxs-lookup"><span data-stu-id="271da-187">There are multiple offerings of Docker registries from cloud vendors like Azure Container Registry, Amazon Web Services Container Registry, Google Container Registry, Quay Registry, and so on.</span></span>

<span data-ttu-id="271da-188">Mediante el uso de tareas de Docker, puede insertar un conjunto de imágenes de servicio definidas por un archivo `docker-compose.yml`, con varias etiquetas, en un registro de Docker autenticado (como Azure Container Registry), tal como se muestra en la figura 5-5.</span><span class="sxs-lookup"><span data-stu-id="271da-188">Using the Docker tasks, you can push a set of service images defined by a `docker-compose.yml` file, with multiple tags, to an authenticated Docker registry (like Azure Container Registry), as shown in Figure 5-5.</span></span>

![Captura de pantalla que muestra el paso para publicar imágenes en un registro.](./media/docker-application-outer-loop-devops-workflow/publish-custom-image-to-docker-registry.png)

<span data-ttu-id="271da-190">**Figura 5-5**.</span><span class="sxs-lookup"><span data-stu-id="271da-190">**Figure 5-5**.</span></span> <span data-ttu-id="271da-191">Uso de Azure DevOps Services para publicar imágenes personalizadas en un registro de Docker</span><span class="sxs-lookup"><span data-stu-id="271da-191">Using Azure DevOps Services to publishing custom images to a Docker Registry</span></span>

> <span data-ttu-id="271da-192">[INFORMACIÓN] Para obtener más detalles sobre Azure Container Registry, vea <https://aka.ms/azurecontainerregistry>.</span><span class="sxs-lookup"><span data-stu-id="271da-192">[!INFORMATION] For more information about Azure Container Registry, see <https://aka.ms/azurecontainerregistry>.</span></span>

## <a name="step-4-cd-deploy"></a><span data-ttu-id="271da-193">Paso 4: CD e implementación</span><span class="sxs-lookup"><span data-stu-id="271da-193">Step 4: CD, Deploy</span></span>

<span data-ttu-id="271da-194">La inmutabilidad de las imágenes de Docker garantiza una implementación repetible entre lo que se ha desarrollado, lo que se ha probado a través de CI y lo que se ha ejecutado en producción.</span><span class="sxs-lookup"><span data-stu-id="271da-194">The immutability of Docker images ensures a repeatable deployment with what's developed, tested through CI, and run in production.</span></span> <span data-ttu-id="271da-195">Una vez que las imágenes de Docker de la aplicación se han publicado en el registro de Docker (ya sea privado o público), puede implementarlas en los diversos entornos que tenga (producción, control de calidad, almacenamiento provisional, etc.) desde la canalización de CD mediante el uso de tareas de canalización de Azure DevOps Services o Release Management de Azure DevOps Services.</span><span class="sxs-lookup"><span data-stu-id="271da-195">After you have the application Docker images published in your Docker registry (either private or public), you can deploy them to the several environments that you might have (production, QA, staging, etc.) from your CD pipeline by using Azure DevOps Services pipeline tasks or Azure DevOps Services Release Management.</span></span>

<span data-ttu-id="271da-196">Aun así, este paso depende del tipo de aplicación de Docker que vaya a implementar.</span><span class="sxs-lookup"><span data-stu-id="271da-196">However, at this point it depends on what kind of Docker application you're deploying.</span></span> <span data-ttu-id="271da-197">La implementación de una aplicación sencilla (desde el punto de vista de la composición y la implementación), por ejemplo, una aplicación monolítica que contenga unos pocos contenedores o servicios y que esté implementada en unos pocos servidores o máquinas virtuales, es diferente de la implementación de una aplicación más compleja, como una aplicación orientada a microservicios con funcionalidades de hiperescala.</span><span class="sxs-lookup"><span data-stu-id="271da-197">Deploying a simple application (from a composition and deployment point of view) like a monolithic application comprising a few containers or services and deployed to a few servers or VMs is different from deploying a more complex application like a microservices-oriented application with hyperscale capabilities.</span></span> <span data-ttu-id="271da-198">Estos dos escenarios se explican en las secciones siguientes.</span><span class="sxs-lookup"><span data-stu-id="271da-198">These two scenarios are explained in the following sections.</span></span>

### <a name="deploying-composed-docker-applications-to-multiple-docker-environments"></a><span data-ttu-id="271da-199">Implementación de aplicaciones compuestas de Docker en varios entornos de Docker</span><span class="sxs-lookup"><span data-stu-id="271da-199">Deploying composed Docker applications to multiple Docker environments</span></span>

<span data-ttu-id="271da-200">Veamos primero el escenario menos complejo: la implementación en hosts simples de Docker (máquinas virtuales o servidores) en uno o varios entornos (control de calidad, almacenamiento provisional y producción).</span><span class="sxs-lookup"><span data-stu-id="271da-200">Let's look first at the less-complex scenario: deploying to simple Docker hosts (VMs or servers) in a single environment or multiple environments (QA, staging, and production).</span></span> <span data-ttu-id="271da-201">En este escenario, la canalización de CD puede usar internamente docker-compose (desde las tareas de implementación de Azure DevOps Services) para implementar las aplicaciones de Docker con su conjunto relacionado de contenedores y servicios, como se muestra en la figura 5-6.</span><span class="sxs-lookup"><span data-stu-id="271da-201">In this scenario, internally your CD pipeline can use docker-compose (from your Azure DevOps Services deployment tasks) to deploy the Docker applications with its related set of containers or services, as illustrated in Figure 5-6.</span></span>

![Diagrama que muestra el paso de implementación de CD que se implementa en tres entornos.](./media/docker-application-outer-loop-devops-workflow/deploy-app-containers-to-docker-host-environments.png)

<span data-ttu-id="271da-203">**Figura 5-6**.</span><span class="sxs-lookup"><span data-stu-id="271da-203">**Figure 5-6**.</span></span> <span data-ttu-id="271da-204">Implementación de contenedores de aplicación en el registro de entornos de host de Docker simple</span><span class="sxs-lookup"><span data-stu-id="271da-204">Deploying application containers to simple Docker host environments registry</span></span>

<span data-ttu-id="271da-205">En la figura 5-7 se muestra cómo se pueden conectar la compilación y CI con entornos de control de calidad y pruebas a través de Azure DevOps Services si se hace clic en Docker Compose en el cuadro de diálogo Agregar tarea.</span><span class="sxs-lookup"><span data-stu-id="271da-205">Figure 5-7 highlights how you can connect your build CI to QA/test environments via Azure DevOps Services by clicking Docker Compose in the Add Task dialog box.</span></span> <span data-ttu-id="271da-206">Aun así, al realizar la implementación en entornos de almacenamiento provisional o producción, normalmente usará las características de Release Management para administrar varios entornos (como control de calidad, almacenamiento provisional y producción).</span><span class="sxs-lookup"><span data-stu-id="271da-206">However, when deploying to staging or production environments, you would usually use Release Management features handling multiple environments (like QA, staging, and production).</span></span> <span data-ttu-id="271da-207">Si lleva a cabo la implementación en hosts de Docker únicos, lo hará mediante la tarea "Docker Compose" de Azure DevOps Services (que invoca el comando `docker-compose up` en segundo plano).</span><span class="sxs-lookup"><span data-stu-id="271da-207">If you're deploying to single Docker hosts, it is using the Azure DevOps Services "Docker Compose" task (which is invoking the `docker-compose up` command under the hood).</span></span> <span data-ttu-id="271da-208">Si va a proceder a la implementación en Azure Kubernetes Service (AKS), usará la tarea de implementación de Docker, como se explica en la sección siguiente.</span><span class="sxs-lookup"><span data-stu-id="271da-208">If you're deploying to Azure Kubernetes Service (AKS), it uses the Docker Deployment task, as explained in the section that follows.</span></span>

![Captura de pantalla que muestra el cuadro de diálogo Add tasks (Agregar tareas) de la tarea Docker Compose.](./media/docker-application-outer-loop-devops-workflow/add-tasks-docker-compose.png)

<span data-ttu-id="271da-210">**Figura 5-7**.</span><span class="sxs-lookup"><span data-stu-id="271da-210">**Figure 5-7**.</span></span> <span data-ttu-id="271da-211">Adición de una tarea de Docker Compose en una canalización Azure DevOps Services</span><span class="sxs-lookup"><span data-stu-id="271da-211">Adding a Docker Compose task in an Azure DevOps Services pipeline</span></span>

<span data-ttu-id="271da-212">Cuando se crea una versión en Azure DevOps Services, se toma un conjunto de artefactos de entrada.</span><span class="sxs-lookup"><span data-stu-id="271da-212">When you create a release in Azure DevOps Services, it takes a set of input artifacts.</span></span> <span data-ttu-id="271da-213">Estos artefactos están diseñados para ser inmutables durante la vigencia de la versión y en todos los entornos.</span><span class="sxs-lookup"><span data-stu-id="271da-213">These artifacts are intended to be immutable for the lifetime of the release, across all environments.</span></span> <span data-ttu-id="271da-214">Al introducir contenedores, los artefactos de entrada identifican las imágenes de un registro que se van a implementar.</span><span class="sxs-lookup"><span data-stu-id="271da-214">When you introduce containers, the input artifacts identify images in a registry to deploy.</span></span> <span data-ttu-id="271da-215">Según cómo se identifiquen estas imágenes, no se garantiza que no vayan a cambiar durante la vigencia de la versión. El caso más evidente es cuando se hace referencia a `myimage:latest` desde un archivo `docker-compose`.</span><span class="sxs-lookup"><span data-stu-id="271da-215">Depending on how these images are identified, they are not guaranteed to remain the same throughout the duration of the release, the most obvious case being when you reference `myimage:latest` from a `docker-compose` file.</span></span>

<span data-ttu-id="271da-216">Las plantillas de Azure DevOps Services permiten generar artefactos de compilación que contienen resúmenes de las imágenes específicas del registro, con la garantía de que identifican de manera única cada imagen binaria.</span><span class="sxs-lookup"><span data-stu-id="271da-216">The Azure DevOps Services templates give you the ability to generate build artifacts that contain specific registry image digests that are guaranteed to uniquely identify the same image binary.</span></span> <span data-ttu-id="271da-217">Esto es lo que realmente le interesa usar como entrada para una versión.</span><span class="sxs-lookup"><span data-stu-id="271da-217">These are what you really want to use as input to a release.</span></span>

### <a name="managing-releases-to-docker-environments-by-using-azure-devops-services-release-management"></a><span data-ttu-id="271da-218">Administración de versiones para entornos de Docker mediante el uso de Release Management de Azure DevOps Services</span><span class="sxs-lookup"><span data-stu-id="271da-218">Managing releases to Docker environments by using Azure DevOps Services Release Management</span></span>

<span data-ttu-id="271da-219">A través de las plantillas de Azure DevOps Services, puede crear una imagen, publicarla en un registro de Docker, ejecutarla en hosts de Linux o Windows y usar comandos como `docker-compose` para implementar varios contenedores como una aplicación completa, y todo ello gracias a las funcionalidades de Release Management de Azure DevOps Services destinadas a diversos entornos, como se muestra en la figura 5-8.</span><span class="sxs-lookup"><span data-stu-id="271da-219">Through the Azure DevOps Services templates, you can build a new image, publish it to a Docker registry, run it on Linux or Windows hosts, and use commands such as `docker-compose` to deploy multiple containers as an entire application, all through the Azure DevOps Services Release Management capabilities intended for multiple environments, as shown in Figure 5-8.</span></span>

![Captura de pantalla que muestra la configuración de las versiones de Docker Compose.](./media/docker-application-outer-loop-devops-workflow/configure-docker-compose-release.png)

<span data-ttu-id="271da-221">**Figura 5-8**.</span><span class="sxs-lookup"><span data-stu-id="271da-221">**Figure 5-8**.</span></span> <span data-ttu-id="271da-222">Configuración de tareas de Docker Compose de Azure DevOps Services desde Release Management para Azure DevOps Services</span><span class="sxs-lookup"><span data-stu-id="271da-222">Configuring Azure DevOps Services Docker Compose tasks from Azure DevOps Services Release Management</span></span>

<span data-ttu-id="271da-223">Aun así, tenga en cuenta que el escenario que se muestra en la figura 5-6 y que se implementa en la figura 5-8 es sencillo (se implementa en hosts y máquinas virtuales únicos de Docker y solo habrá un contenedor o instancia por imagen) y probablemente solo debería usarse para escenarios de desarrollo o prueba.</span><span class="sxs-lookup"><span data-stu-id="271da-223">However, keep in mind that the scenario shown in Figure 5-6 and implemented in Figure 5-8 is a simple one (it's deploying to single Docker hosts and VMs, and there will be a single container or instance per image) and probably should be used only for development or test scenarios.</span></span> <span data-ttu-id="271da-224">En la mayoría de los escenarios de producción empresariales, le interesará tener alta disponibilidad y escalabilidad fácil de administrar mediante el equilibrio de carga entre varios nodos, servidores y máquinas virtuales, así como "conmutaciones por error inteligentes" de modo que, si se produce un error en un servidor o un nodo, sus servicios y contenedores se moverán a otro servidor host o máquina virtual.</span><span class="sxs-lookup"><span data-stu-id="271da-224">In most enterprise production scenarios, you would want to have High Availability (HA) and easy-to-manage scalability by load balancing across multiple nodes, servers, and VMs, plus "intelligent failovers" so if a server or node fails, its services and containers will be moved to another host server or VM.</span></span> <span data-ttu-id="271da-225">En ese caso, necesita tecnologías más avanzadas, como clústeres de contenedores, orquestadores y programadores.</span><span class="sxs-lookup"><span data-stu-id="271da-225">In that case, you need more advanced technologies such as container clusters, orchestrators, and schedulers.</span></span> <span data-ttu-id="271da-226">Así pues, la forma de implementar dichos clústeres consiste en controlar los escenarios avanzados que se explican en la sección siguiente.</span><span class="sxs-lookup"><span data-stu-id="271da-226">Thus, the way to deploy to those clusters is by handling the advanced scenarios explained in the next section.</span></span>

### <a name="deploying-docker-applications-to-docker-clusters"></a><span data-ttu-id="271da-227">Implementación de aplicaciones de Docker en clústeres de Docker</span><span class="sxs-lookup"><span data-stu-id="271da-227">Deploying Docker applications to Docker clusters</span></span>

<span data-ttu-id="271da-228">La naturaleza de las aplicaciones distribuidas requiere recursos de proceso también distribuidos.</span><span class="sxs-lookup"><span data-stu-id="271da-228">The nature of distributed applications requires compute resources that are also distributed.</span></span> <span data-ttu-id="271da-229">Para disponer de funcionalidades a escala de producción, debe tener funcionalidades de agrupación en clústeres que proporcionen alta escalabilidad y alta disponibilidad en función de los recursos agrupados.</span><span class="sxs-lookup"><span data-stu-id="271da-229">To have production-scale capabilities, you need to have clustering capabilities that provide high scalability and high availability based on pooled resources.</span></span>

<span data-ttu-id="271da-230">Podría implementar contenedores manualmente en esos clústeres desde una herramienta de CLI o una interfaz web, pero debe reservar este tipo de trabajo manual para detectar las pruebas de implementación o con fines de administración, como el escalado horizontal o la supervisión.</span><span class="sxs-lookup"><span data-stu-id="271da-230">You could deploy containers manually to those clusters from a CLI tool or a web UI, but you should reserve that kind of manual work to spot deployment testing or management purposes like scaling-out or monitoring.</span></span>

<span data-ttu-id="271da-231">Desde el punto de vista de CD, y más concretamente de Azure DevOps Services, puede ejecutar tareas de implementación creadas de forma especial desde los entornos de Release Management de Azure DevOps Services que vayan a implementar las aplicaciones en contenedores en clústeres distribuidos en Container Service, como se muestra en la figura 5-9.</span><span class="sxs-lookup"><span data-stu-id="271da-231">From a CD point of view, and Azure DevOps Services specifically, you can run specially made deployment tasks from your Azure DevOps Services Release Management environments that will deploy your containerized applications to distributed clusters in Container Service, as illustrated in Figure 5-9.</span></span>

![Diagrama que muestra el paso de la implementación de CD que se implementa en los orquestadores.](./media/docker-application-outer-loop-devops-workflow/cd-deploy-to-orchestrators.png)

<span data-ttu-id="271da-233">**Figura 5-9**.</span><span class="sxs-lookup"><span data-stu-id="271da-233">**Figure 5-9**.</span></span> <span data-ttu-id="271da-234">Implementación de aplicaciones distribuidas en Container Service</span><span class="sxs-lookup"><span data-stu-id="271da-234">Deploying distributed applications to Container Service</span></span>

<span data-ttu-id="271da-235">En principio, al implementar en ciertos clústeres u orquestadores, tradicionalmente se usarían mecanismos y scripts de implementación específicos por cada orquestador (es decir, Kubernetes y Service Fabric tienen mecanismos de implementación diferentes), en lugar de la herramienta `docker-compose` (más sencilla y fácil de usar) basada en el archivo de definición `docker-compose.yml`.</span><span class="sxs-lookup"><span data-stu-id="271da-235">Initially, when deploying to certain clusters or orchestrators, you would traditionally use specific deployment scripts and mechanisms per each orchestrator (that is, Kubernetes and Service Fabric have different deployment mechanisms) instead of the simpler and easy-to-use `docker-compose` tool based on the `docker-compose.yml` definition file.</span></span> <span data-ttu-id="271da-236">Aun así, gracias a la tarea de implementación de Docker de Azure DevOps Services, que aparece en la figura 5-10, ahora también puede realizar la implementación en los orquestadores admitidos usando el archivo `docker-compose.yml`, que ya conoce, puesto que la herramienta realiza automáticamente la "traducción" (del archivo `docker-compose.yml` al formato que requiere el orquestador).</span><span class="sxs-lookup"><span data-stu-id="271da-236">However, thanks to the Azure DevOps Services Docker Deploy task, shown in Figure 5-10, now you can also deploy to the supported orchestrators by just using your familiar `docker-compose.yml` file because the tool performs that "translation" for you (from your `docker-compose.yml` file to the format needed by the orchestrator).</span></span>

![Captura de pantalla que muestra la tarea Implementar en Kubernetes.](./media/docker-application-outer-loop-devops-workflow/add-deploy-to-kubernetes-task.png)

<span data-ttu-id="271da-238">**Figura 5-10**.</span><span class="sxs-lookup"><span data-stu-id="271da-238">**Figure 5-10**.</span></span> <span data-ttu-id="271da-239">Adición de la tarea Implementar en Kubernetes al entorno</span><span class="sxs-lookup"><span data-stu-id="271da-239">Adding the Deploy to Kubernetes task to your Environment</span></span>

<span data-ttu-id="271da-240">En la figura 5-11 se muestra cómo se puede modificar la tarea Implementar en Kubernetes con las secciones disponibles para la configuración.</span><span class="sxs-lookup"><span data-stu-id="271da-240">Figure 5-11 demonstrates how you can edit the Deploy to Kubernetes task with the sections available for configuration.</span></span> <span data-ttu-id="271da-241">Esta es la tarea que recuperará las imágenes de Docker personalizadas listas para usar que se implementarán como contenedores en el clúster.</span><span class="sxs-lookup"><span data-stu-id="271da-241">This is the task that will retrieve your ready-to-use custom Docker images to be deployed as containers in the cluster.</span></span>

![Captura de pantalla que muestra la configuración de la tarea Implementar en Kubernetes.](./media/docker-application-outer-loop-devops-workflow/edit-deploy-to-kubernetes-task.png)

<span data-ttu-id="271da-243">**Figura 5-11**.</span><span class="sxs-lookup"><span data-stu-id="271da-243">**Figure 5-11**.</span></span> <span data-ttu-id="271da-244">Definición de la tarea de implementación de Docker implementada en ACS DC/OS</span><span class="sxs-lookup"><span data-stu-id="271da-244">Docker Deploy task definition deploying to ACS DC/OS</span></span>

> <span data-ttu-id="271da-245">[INFORMACIÓN] Para obtener más detalles sobre la canalización de CD con Azure DevOps Services y Docker, visite <https://azure.microsoft.com/services/devops/pipelines>.</span><span class="sxs-lookup"><span data-stu-id="271da-245">[!INFORMATION] To read more about the CD pipeline with Azure DevOps Services and Docker, visit <https://azure.microsoft.com/services/devops/pipelines></span></span>

## <a name="step-5-run-and-manage"></a><span data-ttu-id="271da-246">Paso 5: ejecución y administración</span><span class="sxs-lookup"><span data-stu-id="271da-246">Step 5: Run and manage</span></span>

<span data-ttu-id="271da-247">Dado que la ejecución y la administración de aplicaciones a nivel de producción empresarial es un asunto de gran importancia por sí mismo, y dado el tipo de operaciones y personas que trabajan en este nivel (operaciones de TI), así como el extenso ámbito de esta cuestión, el próximo capítulo está dedicado al completo a explicarlo.</span><span class="sxs-lookup"><span data-stu-id="271da-247">Because running and managing applications at enterprise-production level is a major subject in and of itself, and due to the type of operations and people working at that level (IT operations) as well as the large scope of this area, the entire next chapter is devoted to explaining it.</span></span>

## <a name="step-6-monitor-and-diagnose"></a><span data-ttu-id="271da-248">Paso 6: Supervisión y diagnóstico</span><span class="sxs-lookup"><span data-stu-id="271da-248">Step 6: Monitor and diagnose</span></span>

<span data-ttu-id="271da-249">Este tema también se trata en el capítulo siguiente como parte de las tareas que lleva a cabo el equipo de TI en los sistemas de producción, pero es importante destacar que los conocimientos obtenidos en este paso deben remitirse al equipo de desarrollo para garantizar una mejora constante de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="271da-249">This topic also is covered in the next chapter as part of the tasks that IT performs in production systems; however, is important to highlight that the insights obtained in this step must feed back to the development team so that the application is constantly improved.</span></span> <span data-ttu-id="271da-250">Desde ese punto de vista, también forma parte de DevOps, aunque las tareas y las operaciones suele realizarlas el equipo de TI.</span><span class="sxs-lookup"><span data-stu-id="271da-250">From that point of view, it's also part of DevOps, although the tasks and operations are commonly performed by IT.</span></span>

<span data-ttu-id="271da-251">Solo cuando la supervisión y el diagnóstico se encuentran exclusivamente en el ámbito de DevOps la tarea de llevar a cabo los procesos de supervisión y análisis en los entornos beta o de prueba recae en el equipo de desarrollo.</span><span class="sxs-lookup"><span data-stu-id="271da-251">Only when monitoring and diagnostics are 100% within the realm of DevOps are the monitoring processes and analytics performed by the development team against testing or beta environments.</span></span> <span data-ttu-id="271da-252">Para ello, realizan pruebas de carga o supervisan los entornos beta o de control de calidad en los que se prueban las versiones nuevas.</span><span class="sxs-lookup"><span data-stu-id="271da-252">This is done either by performing load testing or by monitoring beta or QA environments, where beta testers are trying the new versions.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="271da-253">[Anterior](index.md)
>[Siguiente](create-ci-cd-pipelines-azure-devops-services-aspnetcore-kubernetes.md)</span><span class="sxs-lookup"><span data-stu-id="271da-253">[Previous](index.md)
[Next](create-ci-cd-pipelines-azure-devops-services-aspnetcore-kubernetes.md)</span></span>
