---
title: Administrar la simultaneidad con DependentTransaction
ms.date: 03/30/2017
ms.assetid: b85a97d8-8e02-4555-95df-34c8af095148
ms.openlocfilehash: a8ddcab4b065c3400f9f9f7ec9ce04befdd0f29b
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 03/12/2020
ms.locfileid: "79174386"
---
# <a name="managing-concurrency-with-dependenttransaction"></a><span data-ttu-id="07781-102">Administrar la simultaneidad con DependentTransaction</span><span class="sxs-lookup"><span data-stu-id="07781-102">Managing Concurrency with DependentTransaction</span></span>
<span data-ttu-id="07781-103">Se crea un objeto <xref:System.Transactions.Transaction> utilizando el método <xref:System.Transactions.Transaction.DependentClone%2A>.</span><span class="sxs-lookup"><span data-stu-id="07781-103">The <xref:System.Transactions.Transaction> object is created using the <xref:System.Transactions.Transaction.DependentClone%2A> method.</span></span> <span data-ttu-id="07781-104">Su solo propósito es garantizar que la transacción no pueda confirmar mientras algunas otras partes de código (por ejemplo, un subproceso de trabajo) todavía están realizando el trabajo en la transacción.</span><span class="sxs-lookup"><span data-stu-id="07781-104">Its sole purpose is to guarantee that the transaction cannot commit while some other pieces of code (for example, a worker thread) are still performing work on the transaction.</span></span> <span data-ttu-id="07781-105">Cuando finalmente se completa el proceso de la transacción clonada y está preparada para confirmarse, se puede notificar al creador de la transacción con el método <xref:System.Transactions.DependentTransaction.Complete%2A>.</span><span class="sxs-lookup"><span data-stu-id="07781-105">When the work done within the cloned transaction is complete and ready to be committed, it can notify the creator of the transaction using the <xref:System.Transactions.DependentTransaction.Complete%2A> method.</span></span> <span data-ttu-id="07781-106">Así se puede conservar la coherencia y exactitud de los datos.</span><span class="sxs-lookup"><span data-stu-id="07781-106">Thus, you can preserve the consistency and correctness of data.</span></span>  
  
 <span data-ttu-id="07781-107">La clase <xref:System.Transactions.DependentTransaction> también se puede utilizar para administrar la simultaneidad entre las tareas asincrónicas.</span><span class="sxs-lookup"><span data-stu-id="07781-107">The <xref:System.Transactions.DependentTransaction> class can also be used to manage concurrency between asynchronous tasks.</span></span> <span data-ttu-id="07781-108">En este escenario, el elemento primario puede continuar ejecutando cualquier código mientras el clon dependiente funciona en sus propias tareas.</span><span class="sxs-lookup"><span data-stu-id="07781-108">In this scenario, the parent can continue to execute any code while the dependent clone works on its own tasks.</span></span> <span data-ttu-id="07781-109">En otras palabras, no se bloquea la ejecución del elemento primario hasta que el dependiente complete.</span><span class="sxs-lookup"><span data-stu-id="07781-109">In other words, the parent's execution is not blocked until the dependent completes.</span></span>  
  
## <a name="creating-a-dependent-clone"></a><span data-ttu-id="07781-110">Crear un clon dependiente</span><span class="sxs-lookup"><span data-stu-id="07781-110">Creating a Dependent Clone</span></span>  
 <span data-ttu-id="07781-111">Para crear una transacción dependiente, llame al método <xref:System.Transactions.Transaction.DependentClone%2A> y pase la enumeración <xref:System.Transactions.DependentCloneOption> como un parámetro.</span><span class="sxs-lookup"><span data-stu-id="07781-111">To create a dependent transaction, call the <xref:System.Transactions.Transaction.DependentClone%2A> method and pass the <xref:System.Transactions.DependentCloneOption> enumeration as a parameter.</span></span> <span data-ttu-id="07781-112">Este parámetro define el comportamiento de la transacción si se llama `Commit` en la transacción primaria antes de que el clon dependiente indique que está listo para que la transacción se confirme (llamando al método <xref:System.Transactions.DependentTransaction.Complete%2A> ).</span><span class="sxs-lookup"><span data-stu-id="07781-112">This parameter defines the behavior of the transaction if `Commit` is called on the parent transaction before the dependent clone indicates that it is ready for the transaction to commit (by calling the <xref:System.Transactions.DependentTransaction.Complete%2A> method).</span></span> <span data-ttu-id="07781-113">Los valores siguientes son válidos para este parámetro:</span><span class="sxs-lookup"><span data-stu-id="07781-113">The following values are valid for this parameter:</span></span>  
  
- <span data-ttu-id="07781-114"><xref:System.Transactions.DependentCloneOption.BlockCommitUntilComplete>crea una transacción dependiente que bloquea el proceso de confirmación <xref:System.Transactions.DependentTransaction.Complete%2A> de la transacción primaria hasta que se agota el tiempo de espera de la transacción principal o hasta que se llama a todos los dependientes que indican su finalización.</span><span class="sxs-lookup"><span data-stu-id="07781-114"><xref:System.Transactions.DependentCloneOption.BlockCommitUntilComplete> creates a dependent transaction that blocks the commit process of the parent transaction until the parent transaction times out, or until <xref:System.Transactions.DependentTransaction.Complete%2A> is called on all dependents indicating their completion.</span></span> <span data-ttu-id="07781-115">Esto es útil cuando el cliente no desea que la transacción primaria se confirme hasta que las transacciones dependientes se hayan completado.</span><span class="sxs-lookup"><span data-stu-id="07781-115">This is useful when the client does not want the parent transaction to commit until the dependent transactions have completed.</span></span> <span data-ttu-id="07781-116">Si la primaria finaliza su trabajo antes que la transacción dependiente y llama <xref:System.Transactions.CommittableTransaction.Commit%2A> en la transacción, el proceso de la confirmación se bloquea en un estado donde el trabajo adicional se puede hacer en la transacción y se pueden crear nuevas inscripciones, hasta que todos los dependientes llamen <xref:System.Transactions.DependentTransaction.Complete%2A>.</span><span class="sxs-lookup"><span data-stu-id="07781-116">If the parent finishes its work earlier than the dependent transaction and calls <xref:System.Transactions.CommittableTransaction.Commit%2A> on the transaction, the commit process is blocked in a state where additional work can be done on the transaction and new enlistments can be created, until all of the dependents call <xref:System.Transactions.DependentTransaction.Complete%2A>.</span></span> <span data-ttu-id="07781-117">En cuanto todos ellos hayan finalizado su trabajo y llamen a <xref:System.Transactions.DependentTransaction.Complete%2A>, el proceso de la confirmación para la transacción comienza.</span><span class="sxs-lookup"><span data-stu-id="07781-117">As soon as all of them have finished their work and call <xref:System.Transactions.DependentTransaction.Complete%2A>, the commit process for the transaction begins.</span></span>  
  
- <span data-ttu-id="07781-118"><xref:System.Transactions.DependentCloneOption.RollbackIfNotComplete>, por otro lado, crea una transacción dependiente que automáticamente se anula en caso de que se llame a <xref:System.Transactions.CommittableTransaction.Commit%2A> en la transacción primaria antes de que <xref:System.Transactions.DependentTransaction.Complete%2A> se haya llamado.</span><span class="sxs-lookup"><span data-stu-id="07781-118"><xref:System.Transactions.DependentCloneOption.RollbackIfNotComplete>, on the other hand, creates a dependent transaction that automatically aborts if <xref:System.Transactions.CommittableTransaction.Commit%2A> is called on the parent transaction before <xref:System.Transactions.DependentTransaction.Complete%2A> is called.</span></span> <span data-ttu-id="07781-119">En este caso, todo el trabajo hecho en la transacción dependiente está intacto dentro de una duración de la transacción y nadie tiene una oportunidad para simplemente confirmar una parte de él.</span><span class="sxs-lookup"><span data-stu-id="07781-119">In this case, all the work done in the dependent transaction is intact within one transaction lifetime, and no one has a chance to commit just a portion of it.</span></span>  
  
 <span data-ttu-id="07781-120">Se debe llamar al método <xref:System.Transactions.DependentTransaction.Complete%2A> solo una vez cuando su aplicación finaliza su trabajo en la transacción dependiente; de lo contrario, se inicia <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="07781-120">The <xref:System.Transactions.DependentTransaction.Complete%2A> method must be called only once when your application finishes its work on the dependent transaction; otherwise, a <xref:System.InvalidOperationException> is thrown.</span></span> <span data-ttu-id="07781-121">Después de que se invoca esta llamada, no debería intentar realizar ningún trabajo adicional en la transacción o se producirá una excepción.</span><span class="sxs-lookup"><span data-stu-id="07781-121">After this call is invoked, you must not attempt any additional work on the transaction, or an exception is thrown.</span></span>  
  
 <span data-ttu-id="07781-122">El ejemplo de código siguiente muestra cómo crear una transacción dependiente para administrar dos tareas simultáneas clonando una transacción dependiente y pasándola a un subproceso de trabajo.</span><span class="sxs-lookup"><span data-stu-id="07781-122">The following code example shows how to create a dependent transaction to manage two concurrent tasks by cloning a dependent transaction and passing it to a worker thread.</span></span>  
  
```csharp  
public class WorkerThread  
{  
    public void DoWork(DependentTransaction dependentTransaction)  
    {  
        Thread thread = new Thread(ThreadMethod);  
        thread.Start(dependentTransaction);
    }  
  
    public void ThreadMethod(object transaction)
    {
        DependentTransaction dependentTransaction = transaction as DependentTransaction;  
        Debug.Assert(dependentTransaction != null);
        try  
        {  
            using(TransactionScope ts = new TransactionScope(dependentTransaction))  
            {  
                /* Perform transactional work here */
                ts.Complete();  
            }  
        }  
        finally  
        {  
            dependentTransaction.Complete();
             dependentTransaction.Dispose();
        }  
    }  
  
//Client code
using(TransactionScope scope = new TransactionScope())  
{  
    Transaction currentTransaction = Transaction.Current;  
    DependentTransaction dependentTransaction;
    dependentTransaction = currentTransaction.DependentClone(DependentCloneOption.BlockCommitUntilComplete);  
    WorkerThread workerThread = new WorkerThread();  
    workerThread.DoWork(dependentTransaction);  
    /* Do some transactional work here, then: */  
    scope.Complete();  
}  
```  
  
 <span data-ttu-id="07781-123">El código de cliente crea un ámbito transaccional que también establece la transacción ambiente.</span><span class="sxs-lookup"><span data-stu-id="07781-123">The client code creates a transactional scope that also sets the ambient transaction.</span></span> <span data-ttu-id="07781-124">No debería pasar la transacción ambiente al subproceso de trabajo.</span><span class="sxs-lookup"><span data-stu-id="07781-124">You should not pass the ambient transaction to the worker thread.</span></span> <span data-ttu-id="07781-125">En su lugar, debería clonar la transacción actual (ambiente) llamando al método <xref:System.Transactions.Transaction.DependentClone%2A> en la transacción actual y pasar el dependiente al subproceso de trabajo.</span><span class="sxs-lookup"><span data-stu-id="07781-125">Instead, you should clone the current (ambient) transaction by calling the <xref:System.Transactions.Transaction.DependentClone%2A> method on the current transaction, and pass the dependent to the worker thread.</span></span>  
  
 <span data-ttu-id="07781-126">El método `ThreadMethod` se ejecuta en el nuevo subproceso.</span><span class="sxs-lookup"><span data-stu-id="07781-126">The `ThreadMethod` method executes on the new thread.</span></span> <span data-ttu-id="07781-127">El cliente inicia un nuevo subproceso, pasando la transacción dependiente como el parámetro `ThreadMethod`.</span><span class="sxs-lookup"><span data-stu-id="07781-127">The client starts a new thread, passing the dependent transaction as the `ThreadMethod` parameter.</span></span>  
  
 <span data-ttu-id="07781-128">Dado que la transacción dependiente se crea con <xref:System.Transactions.DependentCloneOption.BlockCommitUntilComplete>, se garantiza que no se puede confirmar la transacción hasta que todo el trabajo transaccional hecho en el segundo subproceso esté finalizado y se llame a <xref:System.Transactions.DependentTransaction.Complete%2A> en la transacción dependiente.</span><span class="sxs-lookup"><span data-stu-id="07781-128">Because the dependent transaction is created with <xref:System.Transactions.DependentCloneOption.BlockCommitUntilComplete>, you are guaranteed that the transaction cannot be committed until all of the transactional work done on the second thread is finished and <xref:System.Transactions.DependentTransaction.Complete%2A> is called on the dependent transaction.</span></span> <span data-ttu-id="07781-129">Esto significa que si el ámbito del cliente finaliza (cuando intenta eliminar `using` el objeto de transacción al final de la instrucción) antes de que el nuevo subproceso llame <xref:System.Transactions.DependentTransaction.Complete%2A> a la transacción dependiente, el código de cliente se bloquea hasta que <xref:System.Transactions.DependentTransaction.Complete%2A> se llama en el dependiente.</span><span class="sxs-lookup"><span data-stu-id="07781-129">This means that if the client's scope ends (when it tries to dispose of the transaction object at the end of the `using` statement) before the new thread calls <xref:System.Transactions.DependentTransaction.Complete%2A> on the dependent transaction, the client code blocks until <xref:System.Transactions.DependentTransaction.Complete%2A> is called on the dependent.</span></span> <span data-ttu-id="07781-130">A continuación, la transacción puede terminar de confirmarse o anularse.</span><span class="sxs-lookup"><span data-stu-id="07781-130">Then the transaction can finish committing or aborting.</span></span>  
  
## <a name="concurrency-issues"></a><span data-ttu-id="07781-131">Problemas de simultaneidad</span><span class="sxs-lookup"><span data-stu-id="07781-131">Concurrency Issues</span></span>  
 <span data-ttu-id="07781-132">Existen problemas de simultaneidad adicionales de los que necesita ser consciente al utilizar la clase <xref:System.Transactions.DependentTransaction>:</span><span class="sxs-lookup"><span data-stu-id="07781-132">There are a few additional concurrency issues that you need to be aware of when using the <xref:System.Transactions.DependentTransaction> class:</span></span>  
  
- <span data-ttu-id="07781-133">Si el subproceso de trabajo deshace la transacción pero el elemento primario intenta confirmarlo, se inicia <xref:System.Transactions.TransactionAbortedException>.</span><span class="sxs-lookup"><span data-stu-id="07781-133">If the worker thread rolls back the transaction but the parent tries to commit it, a <xref:System.Transactions.TransactionAbortedException> is thrown.</span></span>  
  
- <span data-ttu-id="07781-134">Debería crear un nuevo clon dependiente para cada subproceso de trabajo en la transacción.</span><span class="sxs-lookup"><span data-stu-id="07781-134">You should create a new dependent clone for each worker thread in the transaction.</span></span> <span data-ttu-id="07781-135">No pase el mismo clon dependiente a varios subprocesos, porque solo uno de ellos puede llamar <xref:System.Transactions.DependentTransaction.Complete%2A> en él.</span><span class="sxs-lookup"><span data-stu-id="07781-135">Do not pass the same dependent clone to multiple threads, because only one of them can call <xref:System.Transactions.DependentTransaction.Complete%2A> on it.</span></span>  
  
- <span data-ttu-id="07781-136">Si el subproceso de trabajo genera un nuevo subproceso de trabajo, asegúrese de crear un clon dependiente a partir del clon dependiente y pasarlo al nuevo subproceso.</span><span class="sxs-lookup"><span data-stu-id="07781-136">If the worker thread spawns a new worker thread, make sure to create a dependent clone from the dependent clone and pass it to the new thread.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="07781-137">Consulte también</span><span class="sxs-lookup"><span data-stu-id="07781-137">See also</span></span>

- <xref:System.Transactions.DependentTransaction>
