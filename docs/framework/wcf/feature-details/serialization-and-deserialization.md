---
title: Serialización y deserialización
description: Obtenga información sobre el motor de serialización de WCF, que se traduce entre .NET Framework objetos y XML, en ambas direcciones.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 3d71814c-bda7-424b-85b7-15084ff9377a
ms.openlocfilehash: b770543eb09ed2edc1a028561e0cf41e74fab1cc
ms.sourcegitcommit: 2543a78be6e246aa010a01decf58889de53d1636
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 07/17/2020
ms.locfileid: "86444500"
---
# <a name="serialization-and-deserialization"></a><span data-ttu-id="19774-103">Serialización y deserialización</span><span class="sxs-lookup"><span data-stu-id="19774-103">Serialization and Deserialization</span></span>
<span data-ttu-id="19774-104">Windows Communication Foundation (WCF) incluye un nuevo motor de serialización, el <xref:System.Runtime.Serialization.DataContractSerializer> .</span><span class="sxs-lookup"><span data-stu-id="19774-104">Windows Communication Foundation (WCF) includes a new serialization engine, the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="19774-105"><xref:System.Runtime.Serialization.DataContractSerializer>Traduce entre .NET Framework objetos y XML, en ambas direcciones.</span><span class="sxs-lookup"><span data-stu-id="19774-105">The <xref:System.Runtime.Serialization.DataContractSerializer> translates between .NET Framework objects and XML, in both directions.</span></span> <span data-ttu-id="19774-106">En este tema se explica cómo funciona el serializador.</span><span class="sxs-lookup"><span data-stu-id="19774-106">This topic explains how the serializer works.</span></span>  
  
 <span data-ttu-id="19774-107">Al serializar .NET Framework objetos, el serializador entiende diversos modelos de programación de la serialización, incluido el nuevo modelo de *contrato de datos* .</span><span class="sxs-lookup"><span data-stu-id="19774-107">When serializing .NET Framework objects, the serializer understands a variety of serialization programming models, including the new *data contract* model.</span></span> <span data-ttu-id="19774-108">Para obtener una lista completa de los tipos admitidos, consulte [Types Supported by the Data Contract Serializer](types-supported-by-the-data-contract-serializer.md).</span><span class="sxs-lookup"><span data-stu-id="19774-108">For a full list of supported types, see [Types Supported by the Data Contract Serializer](types-supported-by-the-data-contract-serializer.md).</span></span> <span data-ttu-id="19774-109">Para obtener una introducción a los contratos de datos, consulte [Using Data Contracts](using-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="19774-109">For an introduction to data contracts, see [Using Data Contracts](using-data-contracts.md).</span></span>  
  
 <span data-ttu-id="19774-110">Al deserializar XML, el serializador utiliza las clases <xref:System.Xml.XmlReader> y <xref:System.Xml.XmlWriter> .</span><span class="sxs-lookup"><span data-stu-id="19774-110">When deserializing XML, the serializer uses the <xref:System.Xml.XmlReader> and <xref:System.Xml.XmlWriter> classes.</span></span> <span data-ttu-id="19774-111">También admite las <xref:System.Xml.XmlDictionaryReader> clases y <xref:System.Xml.XmlDictionaryWriter> para permitirle generar XML optimizado en algunos casos, como cuando se usa el formato XML binario WCF.</span><span class="sxs-lookup"><span data-stu-id="19774-111">It also supports the <xref:System.Xml.XmlDictionaryReader> and <xref:System.Xml.XmlDictionaryWriter> classes to enable it to produce optimized XML in some cases, such as when using the WCF binary XML format.</span></span>  
  
 <span data-ttu-id="19774-112">WCF también incluye un serializador complementario, el <xref:System.Runtime.Serialization.NetDataContractSerializer> .</span><span class="sxs-lookup"><span data-stu-id="19774-112">WCF also includes a companion serializer, the <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span></span> <span data-ttu-id="19774-113">El <xref:System.Runtime.Serialization.NetDataContractSerializer>:</span><span class="sxs-lookup"><span data-stu-id="19774-113">The <xref:System.Runtime.Serialization.NetDataContractSerializer>:</span></span>

* <span data-ttu-id="19774-114">***No*** es seguro.</span><span class="sxs-lookup"><span data-stu-id="19774-114">Is ***not*** secure.</span></span> <span data-ttu-id="19774-115">Para obtener más información, vea la [Guía de seguridad BinaryFormatter](/dotnet/standard/serialization/binaryformatter-security-guide).</span><span class="sxs-lookup"><span data-stu-id="19774-115">For more information, see the [BinaryFormatter security guide](/dotnet/standard/serialization/binaryformatter-security-guide).</span></span>
* <span data-ttu-id="19774-116">Es similar a los <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter> serializadores y porque también emite .NET Framework nombres de tipo como parte de los datos serializados.</span><span class="sxs-lookup"><span data-stu-id="19774-116">Is similar to the <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> and <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter> serializers because it also emits .NET Framework type names as part of the serialized data.</span></span>
* <span data-ttu-id="19774-117">Se usa cuando se comparten los mismos tipos en los extremos de serialización y deserialización.</span><span class="sxs-lookup"><span data-stu-id="19774-117">Is used when the same types are shared on the serializing and the deserializing ends.</span></span>

 <span data-ttu-id="19774-118"><xref:System.Runtime.Serialization.DataContractSerializer>Y <xref:System.Runtime.Serialization.NetDataContractSerializer> derivan de una clase base común, <xref:System.Runtime.Serialization.XmlObjectSerializer> .</span><span class="sxs-lookup"><span data-stu-id="19774-118">Both <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer> derive from a common base class, <xref:System.Runtime.Serialization.XmlObjectSerializer>.</span></span>  
  
> [!WARNING]
> <span data-ttu-id="19774-119"><xref:System.Runtime.Serialization.DataContractSerializer> serializa cadenas que contienen caracteres de control con un valor hexadecimal inferior a 20 como entidades XML.</span><span class="sxs-lookup"><span data-stu-id="19774-119">The <xref:System.Runtime.Serialization.DataContractSerializer> serializes strings containing control characters with a hexadecimal value below 20 as XML entities.</span></span> <span data-ttu-id="19774-120">Esto puede producir un problema con un cliente que no sea de WCF al enviar estos datos a un servicio WCF.</span><span class="sxs-lookup"><span data-stu-id="19774-120">This may cause a problem with a non-WCF client when sending such data to a WCF service.</span></span>  
  
## <a name="creating-a-datacontractserializer-instance"></a><span data-ttu-id="19774-121">Creación de una instancia de DataContractSerializer</span><span class="sxs-lookup"><span data-stu-id="19774-121">Creating a DataContractSerializer Instance</span></span>  
 <span data-ttu-id="19774-122">Construir una instancia de <xref:System.Runtime.Serialization.DataContractSerializer> es un paso importante.</span><span class="sxs-lookup"><span data-stu-id="19774-122">Constructing an instance of the <xref:System.Runtime.Serialization.DataContractSerializer> is an important step.</span></span> <span data-ttu-id="19774-123">Después de la construcción no puede cambiar ninguno de los valores.</span><span class="sxs-lookup"><span data-stu-id="19774-123">After construction, you cannot change any of the settings.</span></span>  
  
### <a name="specifying-the-root-type"></a><span data-ttu-id="19774-124">Especificación del tipo de raíz</span><span class="sxs-lookup"><span data-stu-id="19774-124">Specifying the Root Type</span></span>  
 <span data-ttu-id="19774-125">El *tipo de raíz* es el tipo en el que las instancias se serializan o deserializan.</span><span class="sxs-lookup"><span data-stu-id="19774-125">The *root type* is the type of which instances are serialized or deserialized.</span></span> <span data-ttu-id="19774-126"><xref:System.Runtime.Serialization.DataContractSerializer> tiene muchas sobrecarga del constructor, pero, como mínimo, se debe proporcionar un tipo de raíz utilizando el parámetro `type` .</span><span class="sxs-lookup"><span data-stu-id="19774-126">The <xref:System.Runtime.Serialization.DataContractSerializer> has many constructor overloads, but, at a minimum, a root type must be supplied using the `type` parameter.</span></span>  
  
 <span data-ttu-id="19774-127">Un serializador creado para un tipo de raíz determinado no se puede utilizar para serializar (o deserializar) otro tipo, a menos que el tipo se derive del tipo de raíz.</span><span class="sxs-lookup"><span data-stu-id="19774-127">A serializer created for a certain root type cannot be used to serialize (or deserialize) another type, unless the type is derived from the root type.</span></span> <span data-ttu-id="19774-128">En el ejemplo siguiente se muestran dos clases.</span><span class="sxs-lookup"><span data-stu-id="19774-128">The following example shows two classes.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#1)]
 [!code-vb[c_StandaloneDataContractSerializer#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#1)]  
  
 <span data-ttu-id="19774-129">Este código construye una instancia del `DataContractSerializer` que solo se puede utilizar para serializar o deserializar instancias de la clase `Person` .</span><span class="sxs-lookup"><span data-stu-id="19774-129">This code constructs an instance of the `DataContractSerializer` that can be used only to serialize or deserialize instances of the `Person` class.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#2)]
 [!code-vb[c_StandaloneDataContractSerializer#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#2)]  
  
### <a name="specifying-known-types"></a><span data-ttu-id="19774-130">Especificación de los tipos conocidos</span><span class="sxs-lookup"><span data-stu-id="19774-130">Specifying Known Types</span></span>  
 <span data-ttu-id="19774-131">Si el polimorfismo está implicado en los tipos que se están serializando que aún no se administran usando el atributo <xref:System.Runtime.Serialization.KnownTypeAttribute> o algún otro mecanismo, se ha de pasar una lista de posibles tipos conocidos al constructor del serializador usando el parámetro `knownTypes` .</span><span class="sxs-lookup"><span data-stu-id="19774-131">If polymorphism is involved in the types being serialized that is not already handled using the <xref:System.Runtime.Serialization.KnownTypeAttribute> attribute or some other mechanism, a list of possible known types must be passed to the serializer’s constructor using the `knownTypes` parameter.</span></span> <span data-ttu-id="19774-132">Para obtener más información sobre los tipos conocidos, consulte [Data Contract known Types](data-contract-known-types.md).</span><span class="sxs-lookup"><span data-stu-id="19774-132">For more information about known types, see [Data Contract Known Types](data-contract-known-types.md).</span></span>  
  
 <span data-ttu-id="19774-133">El siguiente ejemplo muestra una clase, `LibraryPatron`, que incluye una colección de un tipo específico, `LibraryItem`.</span><span class="sxs-lookup"><span data-stu-id="19774-133">The following example shows a class, `LibraryPatron`, that includes a collection of a specific type, the `LibraryItem`.</span></span> <span data-ttu-id="19774-134">La segunda clase define el tipo `LibraryItem` .</span><span class="sxs-lookup"><span data-stu-id="19774-134">The second class defines the `LibraryItem` type.</span></span> <span data-ttu-id="19774-135">Las clases tercera y cuarta`Book` y `Newspaper`heredan de la clase `LibraryItem` .</span><span class="sxs-lookup"><span data-stu-id="19774-135">The third and four classes (`Book` and `Newspaper`) inherit from the `LibraryItem` class.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#3)]  
 [!code-vb[c_StandaloneDataContractSerializer#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#3)]  
  
 <span data-ttu-id="19774-136">El siguiente código construye una instancia del serializador utilizando el parámetro `knownTypes` .</span><span class="sxs-lookup"><span data-stu-id="19774-136">The following code constructs an instance of the serializer using the `knownTypes` parameter.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#4)]
 [!code-vb[c_StandaloneDataContractSerializer#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#4)]  
  
### <a name="specifying-the-default-root-name-and-namespace"></a><span data-ttu-id="19774-137">Especificación del espacio de nombres y el nombre de raíz predeterminados</span><span class="sxs-lookup"><span data-stu-id="19774-137">Specifying the Default Root Name and Namespace</span></span>  
 <span data-ttu-id="19774-138">Normalmente, cuando se serializa un objeto, el nombre y espacio de nombres predeterminados del elemento XML extremo se determinan según el nombre y el espacio de nombres del contrato de datos.</span><span class="sxs-lookup"><span data-stu-id="19774-138">Normally, when an object is serialized, the default name and namespace of the outermost XML element are determined according to the data contract name and namespace.</span></span> <span data-ttu-id="19774-139">Los nombres de todos los elementos internos se determinan a partir de los nombres de los miembros de datos y su espacio de nombres es el espacio de nombres del contrato de datos.</span><span class="sxs-lookup"><span data-stu-id="19774-139">The names of all inner elements are determined from data member names, and their namespace is the data contract’s namespace.</span></span> <span data-ttu-id="19774-140">El siguiente ejemplo establece los valores de `Name` y `Namespace` en los constructores de las clases <xref:System.Runtime.Serialization.DataContractAttribute> y <xref:System.Runtime.Serialization.DataMemberAttribute> .</span><span class="sxs-lookup"><span data-stu-id="19774-140">The following example sets `Name` and `Namespace` values in the constructors of the <xref:System.Runtime.Serialization.DataContractAttribute> and <xref:System.Runtime.Serialization.DataMemberAttribute> classes.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#5)]
 [!code-vb[c_StandaloneDataContractSerializer#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#5)]  
  
 <span data-ttu-id="19774-141">Al serializar una instancia de la clase `Person` , se genera código XML similar al siguiente.</span><span class="sxs-lookup"><span data-stu-id="19774-141">Serializing an instance of the `Person` class produces XML similar to the following.</span></span>  
  
```xml  
<PersonContract xmlns="http://schemas.contoso.com">  
  <AddressMember>  
    <StreetMember>123 Main Street</StreetMember>  
   </AddressMember>  
</PersonContract>  
```  
  
 <span data-ttu-id="19774-142">Sin embargo, puede personalizar el nombre y espacio de nombres predeterminado del elemento raíz pasando los valores de los parámetros `rootName` y `rootNamespace` al constructor <xref:System.Runtime.Serialization.DataContractSerializer> .</span><span class="sxs-lookup"><span data-stu-id="19774-142">However, you can customize the default name and namespace of the root element by passing the values of the `rootName` and `rootNamespace` parameters to the <xref:System.Runtime.Serialization.DataContractSerializer> constructor.</span></span> <span data-ttu-id="19774-143">Observe que el `rootNamespace` no afecta al espacio de nombres de los elementos contenidos que corresponden a miembros de datos.</span><span class="sxs-lookup"><span data-stu-id="19774-143">Note that the `rootNamespace` does not affect the namespace of the contained elements that correspond to data members.</span></span> <span data-ttu-id="19774-144">Solo afecta al espacio de nombres del elemento extremo.</span><span class="sxs-lookup"><span data-stu-id="19774-144">It affects only the namespace of the outermost element.</span></span>  
  
 <span data-ttu-id="19774-145">Estos valores se pueden pasar como cadenas o instancias de la clase <xref:System.Xml.XmlDictionaryString> para permitir su optimización mediante el formato XML binario.</span><span class="sxs-lookup"><span data-stu-id="19774-145">These values can be passed as strings or instances of the <xref:System.Xml.XmlDictionaryString> class to allow for their optimization using the binary XML format.</span></span>  
  
### <a name="setting-the-maximum-objects-quota"></a><span data-ttu-id="19774-146">Establecimiento de la cuota de objetos máximos</span><span class="sxs-lookup"><span data-stu-id="19774-146">Setting the Maximum Objects Quota</span></span>  
 <span data-ttu-id="19774-147">Algunas sobrecargas del constructor de `DataContractSerializer` tienen un parámetro `maxItemsInObjectGraph` .</span><span class="sxs-lookup"><span data-stu-id="19774-147">Some `DataContractSerializer` constructor overloads have a `maxItemsInObjectGraph` parameter.</span></span> <span data-ttu-id="19774-148">Este parámetro determina el número máximo de objetos que el serializador serializa o deserializa en una única llamada al método <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> .</span><span class="sxs-lookup"><span data-stu-id="19774-148">This parameter determines the maximum number of objects the serializer serializes or deserializes in a single <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> method call.</span></span> <span data-ttu-id="19774-149">(El método siempre lee un objeto raíz, pero este objeto puede tener otros objetos en sus miembros de datos.</span><span class="sxs-lookup"><span data-stu-id="19774-149">(The method always reads one root object, but this object may have other objects in its data members.</span></span> <span data-ttu-id="19774-150">Esos objetos pueden tener otros objetos, etc.) El valor predeterminado es 65536.</span><span class="sxs-lookup"><span data-stu-id="19774-150">Those objects may have other objects, and so on.) The default is 65536.</span></span> <span data-ttu-id="19774-151">Tenga en cuenta que al serializar o deserializar las matrices, cada entrada de matriz cuenta como un objeto independiente.</span><span class="sxs-lookup"><span data-stu-id="19774-151">Note that when serializing or deserializing arrays, every array entry counts as a separate object.</span></span> <span data-ttu-id="19774-152">Observe también que algunos objetos pueden tener una representación de memoria grande, por lo que esta cuota por sí sola puede no ser suficiente para evitar ataques por denegación de servicio.</span><span class="sxs-lookup"><span data-stu-id="19774-152">Also, note that some objects may have a large memory representation, and so this quota alone may not be sufficient to prevent a denial of service attack.</span></span> <span data-ttu-id="19774-153">Para obtener más información, vea [consideraciones de seguridad para los datos](security-considerations-for-data.md).</span><span class="sxs-lookup"><span data-stu-id="19774-153">For more information, see [Security Considerations for Data](security-considerations-for-data.md).</span></span> <span data-ttu-id="19774-154">Si necesita aumentar esta cuota por encima del valor predeterminado, es importante hacerlo en los lados de envío (serialización) y recepción (deserialización), porque se aplica a ambos al leer y escribir datos.</span><span class="sxs-lookup"><span data-stu-id="19774-154">If you need to increase this quota beyond the default value, it is important to do so both on the sending (serializing) and receiving (deserializing) sides because it applies to both when reading and writing data.</span></span>  
  
### <a name="round-trips"></a><span data-ttu-id="19774-155">Acciones de ida y vuelta</span><span class="sxs-lookup"><span data-stu-id="19774-155">Round Trips</span></span>  
 <span data-ttu-id="19774-156">Una *acción de ida y vuelta (round trip)* se produce cuando un objeto se deserializa y se vuelve a serializar en una operación.</span><span class="sxs-lookup"><span data-stu-id="19774-156">A *round trip* occurs when an object is deserialized and re-serialized in one operation.</span></span> <span data-ttu-id="19774-157">De este modo, va de XML a una instancia de objeto y de vuelta a una secuencia XML.</span><span class="sxs-lookup"><span data-stu-id="19774-157">Thus, it goes from XML to an object instance, and back again into an XML stream.</span></span>  
  
 <span data-ttu-id="19774-158">Algunas sobrecargas del constructor del `DataContractSerializer` tienen un parámetro `ignoreExtensionDataObject` , que está establecido de forma predeterminada en `false` .</span><span class="sxs-lookup"><span data-stu-id="19774-158">Some `DataContractSerializer` constructor overloads have an `ignoreExtensionDataObject` parameter, which is set to `false` by default.</span></span> <span data-ttu-id="19774-159">En este modo predeterminado, los datos se pueden enviar en un viaje de ida y vuelta (round trip) desde una versión más reciente de un contrato de datos a través de una versión anterior y de vuelta a la versión más reciente sin pérdidas, siempre que el contrato de datos implemente la interfaz <xref:System.Runtime.Serialization.IExtensibleDataObject> .</span><span class="sxs-lookup"><span data-stu-id="19774-159">In this default mode, data can be sent on a round trip from a newer version of a data contract through an older version and back to the newer version without loss, as long as the data contract implements the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface.</span></span> <span data-ttu-id="19774-160">Por ejemplo, suponga que la versión 1 del contrato de datos de la `Person` contiene los miembros de datos `Name` y `PhoneNumber` , y la versión 2 agrega un miembro `Nickname` .</span><span class="sxs-lookup"><span data-stu-id="19774-160">For example, suppose version 1 of the `Person` data contract contains the `Name` and `PhoneNumber` data members, and version 2 adds a `Nickname` member.</span></span> <span data-ttu-id="19774-161">Si se implementa `IExtensibleDataObject` al enviar información de la versión 2 a la versión 1, los datos `Nickname` se almacenan y, a continuación, se vuelven a emitir cuando se vuelven a serializar los datos; por tanto, no se pierden datos en el viaje de ida y vuelta.</span><span class="sxs-lookup"><span data-stu-id="19774-161">If `IExtensibleDataObject` is implemented, when sending information from version 2 to version 1, the `Nickname` data is stored, and then re-emitted when the data is serialized again; therefore, no data is lost in the round trip.</span></span> <span data-ttu-id="19774-162">Para obtener más información, consulte los [contratos de datos compatibles con el avance y el control de versiones del](forward-compatible-data-contracts.md) contrato de [datos](data-contract-versioning.md).</span><span class="sxs-lookup"><span data-stu-id="19774-162">For more information, see [Forward-Compatible Data Contracts](forward-compatible-data-contracts.md) and [Data Contract Versioning](data-contract-versioning.md).</span></span>  
  
#### <a name="security-and-schema-validity-concerns-with-round-trips"></a><span data-ttu-id="19774-163">Aspectos a tener en cuenta sobre seguridad y validez del esquema en relación con los viajes de ida y vuelta (round trip)</span><span class="sxs-lookup"><span data-stu-id="19774-163">Security and Schema Validity Concerns with Round Trips</span></span>  
 <span data-ttu-id="19774-164">Los viajes de ida y vuelta pueden tener implicaciones en cuanto a la seguridad.</span><span class="sxs-lookup"><span data-stu-id="19774-164">Round trips may have security implications.</span></span> <span data-ttu-id="19774-165">Por ejemplo, deserializar y almacenar grandes cantidades de datos extraños puede constituir un riesgo para la seguridad.</span><span class="sxs-lookup"><span data-stu-id="19774-165">For example, deserializing and storing large amounts of extraneous data may be a security risk.</span></span> <span data-ttu-id="19774-166">Puede haber problemas de seguridad al reemitir estos datos que no se pueden comprobar, sobre todo si hay firmas digitales implicadas.</span><span class="sxs-lookup"><span data-stu-id="19774-166">There may be security concerns about re-emitting this data that there is no way to verify, especially if digital signatures are involved.</span></span> <span data-ttu-id="19774-167">Por ejemplo, en el escenario anterior, el extremo de versión 1 podría estar firmando un valor `Nickname` que contuviese datos malintencionados.</span><span class="sxs-lookup"><span data-stu-id="19774-167">For example, in the previous scenario, the version 1 endpoint could be signing a `Nickname` value that contains malicious data.</span></span> <span data-ttu-id="19774-168">Por último, puede haber problemas de validez del esquema: un extremo puede desear emitir siempre datos que cumplan de manera estricta el contrato indicado y no valores adicionales.</span><span class="sxs-lookup"><span data-stu-id="19774-168">Finally, there may be schema validity concerns: an endpoint may want to always emit data that strictly adheres to its stated contract and not any extra values.</span></span> <span data-ttu-id="19774-169">En el ejemplo anterior, el contrato del extremo de versión 1 dice que solo emite `Name` y `PhoneNumber`, y si se utiliza la validación de esquema, se produciría un error de validación al emitir el valor `Nickname` adicional.</span><span class="sxs-lookup"><span data-stu-id="19774-169">In the previous example, the version 1 endpoint’s contract says that it emits only `Name` and `PhoneNumber`, and if schema validation is being used, emitting the extra `Nickname` value causes validation to fail.</span></span>  
  
#### <a name="enabling-and-disabling-round-trips"></a><span data-ttu-id="19774-170">Habilitar y deshabilitar los viajes de ida y vuelta</span><span class="sxs-lookup"><span data-stu-id="19774-170">Enabling and Disabling Round Trips</span></span>  
 <span data-ttu-id="19774-171">Para desactivar los viajes de ida y vuelta, no implemente la interfaz <xref:System.Runtime.Serialization.IExtensibleDataObject> .</span><span class="sxs-lookup"><span data-stu-id="19774-171">To turn off round trips, do not implement the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface.</span></span> <span data-ttu-id="19774-172">Si no tiene ningún control sobre los tipos, establezca el parámetro `ignoreExtensionDataObject` en `true` para lograr el mismo efecto.</span><span class="sxs-lookup"><span data-stu-id="19774-172">If you have no control over the types, set the `ignoreExtensionDataObject` parameter to `true` to achieve the same effect.</span></span>  
  
### <a name="object-graph-preservation"></a><span data-ttu-id="19774-173">Preservación de gráfico de objeto</span><span class="sxs-lookup"><span data-stu-id="19774-173">Object Graph Preservation</span></span>  
 <span data-ttu-id="19774-174">Normalmente, el serializador no se preocupa de la identidad del objeto, como en el código siguiente.</span><span class="sxs-lookup"><span data-stu-id="19774-174">Normally, the serializer does not care about object identity, as in the following code.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#6)]
 [!code-vb[c_StandaloneDataContractSerializer#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#6)]  
  
 <span data-ttu-id="19774-175">El siguiente código crea un pedido de compra.</span><span class="sxs-lookup"><span data-stu-id="19774-175">The following code creates a purchase order.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#7)]
 [!code-vb[c_StandaloneDataContractSerializer#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#7)]  
  
 <span data-ttu-id="19774-176">Observe que los campos `billTo` y `shipTo` están establecidos en la misma instancia de objeto.</span><span class="sxs-lookup"><span data-stu-id="19774-176">Notice that `billTo` and `shipTo` fields are set to the same object instance.</span></span> <span data-ttu-id="19774-177">Sin embargo, el XML generado duplica la información duplicada y parece similar al siguiente XML.</span><span class="sxs-lookup"><span data-stu-id="19774-177">However, the generated XML duplicates the information duplicated, and looks similar to the following XML.</span></span>  
  
```xml  
<PurchaseOrder>  
  <billTo><street>123 Main St.</street></billTo>  
  <shipTo><street>123 Main St.</street></shipTo>  
</PurchaseOrder>  
```  
  
 <span data-ttu-id="19774-178">Sin embargo, este enfoque tiene las siguientes características, que puede que no se deseen:</span><span class="sxs-lookup"><span data-stu-id="19774-178">However, this approach has the following characteristics, which may be undesirable:</span></span>  
  
- <span data-ttu-id="19774-179">Rendimiento.</span><span class="sxs-lookup"><span data-stu-id="19774-179">Performance.</span></span> <span data-ttu-id="19774-180">La replicación de datos es ineficaz.</span><span class="sxs-lookup"><span data-stu-id="19774-180">Replicating data is inefficient.</span></span>  
  
- <span data-ttu-id="19774-181">Referencias circulares.</span><span class="sxs-lookup"><span data-stu-id="19774-181">Circular references.</span></span> <span data-ttu-id="19774-182">Si los objetos hacen referencia a ellos mismos, incluso a través de otros objetos, la serialización mediante resultados de replicación resulta en un bucle infinito.</span><span class="sxs-lookup"><span data-stu-id="19774-182">If objects refer to themselves, even through other objects, serializing by replication results in an infinite loop.</span></span> <span data-ttu-id="19774-183">(Si esto sucede, el serializador inicia una <xref:System.Runtime.Serialization.SerializationException> .)</span><span class="sxs-lookup"><span data-stu-id="19774-183">(The serializer throws a <xref:System.Runtime.Serialization.SerializationException> if this happens.)</span></span>  
  
- <span data-ttu-id="19774-184">Semántica.</span><span class="sxs-lookup"><span data-stu-id="19774-184">Semantics.</span></span> <span data-ttu-id="19774-185">A veces es importante conservar el hecho de que se realicen dos referencias al mismo objeto, y no a dos objetos idénticos.</span><span class="sxs-lookup"><span data-stu-id="19774-185">Sometimes it is important to preserve the fact that two references are to the same object, and not to two identical objects.</span></span>  
  
 <span data-ttu-id="19774-186">Por estas razones, algunas sobrecargas del constructor de `DataContractSerializer` tienen un parámetro `preserveObjectReferences` (el valor predeterminado es `false`).</span><span class="sxs-lookup"><span data-stu-id="19774-186">For these reasons, some `DataContractSerializer` constructor overloads have a `preserveObjectReferences` parameter (the default is `false`).</span></span> <span data-ttu-id="19774-187">Cuando este parámetro se establece en `true` , se usa un método especial de codificación de referencias de objeto, que solo es compatible con WCF.</span><span class="sxs-lookup"><span data-stu-id="19774-187">When this parameter is set to `true`, a special method of encoding object references, which only WCF understands, is used.</span></span> <span data-ttu-id="19774-188">Cuando se establece en `true`, el ejemplo de código XML tiene ahora el siguiente aspecto.</span><span class="sxs-lookup"><span data-stu-id="19774-188">When set to `true`, the XML code example now resembles the following.</span></span>  
  
```xml  
<PurchaseOrder ser:id="1">  
  <billTo ser:id="2"><street ser:id="3">123 Main St.</street></billTo>  
  <shipTo ser:ref="2"/>  
</PurchaseOrder>  
```  
  
 <span data-ttu-id="19774-189">El espacio de nombres "ser" hace referencia al espacio de nombres de serialización estándar, `http://schemas.microsoft.com/2003/10/Serialization/` .</span><span class="sxs-lookup"><span data-stu-id="19774-189">The "ser" namespace refers to the standard serialization namespace, `http://schemas.microsoft.com/2003/10/Serialization/`.</span></span> <span data-ttu-id="19774-190">Cada parte de datos se serializa solo una vez y se proporciona un número de identificador a cada una de esas partes de datos, y los posteriores usos resultan en una referencia a los datos ya serializados.</span><span class="sxs-lookup"><span data-stu-id="19774-190">Each piece of data is serialized only once and given an ID number, and subsequent uses result in a reference to the already serialized data.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="19774-191">Si los atributos "id" y "ref" están presentes en el elemento `XMLElement`del contrato de datos, se observa el atributo "ref" y se omite "id".</span><span class="sxs-lookup"><span data-stu-id="19774-191">If both "id" and "ref" attributes are present in the data contract `XMLElement`, then the "ref" attribute is honored and the "id" attribute is ignored.</span></span>  
  
 <span data-ttu-id="19774-192">Es importante conocer las limitaciones de este modo:</span><span class="sxs-lookup"><span data-stu-id="19774-192">It is important to understand the limitations of this mode:</span></span>  
  
- <span data-ttu-id="19774-193">El XML que produce el `DataContractSerializer` con `preserveObjectReferences` establecido en `true` no es interoperable con ninguna otra tecnología y solo puede obtenerse acceso a él mediante otra instancia del `DataContractSerializer` , también con `preserveObjectReferences` establecido en `true`.</span><span class="sxs-lookup"><span data-stu-id="19774-193">The XML the `DataContractSerializer` produces with `preserveObjectReferences` set to `true` is not interoperable with any other technologies, and can be accessed only by another `DataContractSerializer` instance, also with `preserveObjectReferences` set to `true`.</span></span>  
  
- <span data-ttu-id="19774-194">No hay compatibilidad con metadatos (esquema) para esta característica.</span><span class="sxs-lookup"><span data-stu-id="19774-194">There is no metadata (schema) support for this feature.</span></span> <span data-ttu-id="19774-195">El esquema que se genera solo es válido para el caso en que `preserveObjectReferences` está establecido en `false`.</span><span class="sxs-lookup"><span data-stu-id="19774-195">The schema that is produced is valid only for the case when `preserveObjectReferences` is set to `false`.</span></span>  
  
- <span data-ttu-id="19774-196">Esta característica puede hacer que el proceso de serialización y deserialización se ejecuten más lentamente.</span><span class="sxs-lookup"><span data-stu-id="19774-196">This feature may cause the serialization and deserialization process to run slower.</span></span> <span data-ttu-id="19774-197">Aunque los datos no tienen que replicarse, las comparaciones con objetos adicionales se deben realizar en este modo.</span><span class="sxs-lookup"><span data-stu-id="19774-197">Although data does not have to be replicated, extra object comparisons must be performed in this mode.</span></span>  
  
> [!CAUTION]
> <span data-ttu-id="19774-198">Cuando se habilita el modo `preserveObjectReferences` , es especialmente importante establecer el valor `maxItemsInObjectGraph` en la cuota correcta.</span><span class="sxs-lookup"><span data-stu-id="19774-198">When the `preserveObjectReferences` mode is enabled, it is especially important to set the `maxItemsInObjectGraph` value to the correct quota.</span></span> <span data-ttu-id="19774-199">Debido a la manera en la que se administran las matrices en este modo, es fácil que un atacante construya un pequeño mensaje malintencionado que provoque un uso de memoria grande limitado únicamente por la cuota `maxItemsInObjectGraph` .</span><span class="sxs-lookup"><span data-stu-id="19774-199">Due to the way arrays are handled in this mode, it is easy for an attacker to construct a small malicious message that results in large memory consumption limited only by the `maxItemsInObjectGraph` quota.</span></span>  
  
### <a name="specifying-a-data-contract-surrogate"></a><span data-ttu-id="19774-200">Especificación de un contrato de datos suplente</span><span class="sxs-lookup"><span data-stu-id="19774-200">Specifying a Data Contract Surrogate</span></span>  
 <span data-ttu-id="19774-201">Algunas sobrecargas del constructor del `DataContractSerializer` tienen un parámetro `dataContractSurrogate` , que se puede establecer en `null`.</span><span class="sxs-lookup"><span data-stu-id="19774-201">Some `DataContractSerializer` constructor overloads have a `dataContractSurrogate` parameter, which may be set to `null`.</span></span> <span data-ttu-id="19774-202">De lo contrario, puede utilizarlo para especificar un *contrato de datos suplente*, que es un tipo que implementa la interfaz <xref:System.Runtime.Serialization.IDataContractSurrogate> .</span><span class="sxs-lookup"><span data-stu-id="19774-202">Otherwise, you can use it to specify a *data contract surrogate*, which is a type that implements the <xref:System.Runtime.Serialization.IDataContractSurrogate> interface.</span></span> <span data-ttu-id="19774-203">Puede utilizar a continuación la interfaz para personalizar el proceso de serialización y deserialización.</span><span class="sxs-lookup"><span data-stu-id="19774-203">You can then use the interface to customize the serialization and deserialization process.</span></span> <span data-ttu-id="19774-204">Para obtener más información, vea [suplentes del contrato de datos](../extending/data-contract-surrogates.md).</span><span class="sxs-lookup"><span data-stu-id="19774-204">For more information, see [Data Contract Surrogates](../extending/data-contract-surrogates.md).</span></span>  
  
## <a name="serialization"></a><span data-ttu-id="19774-205">Serialización</span><span class="sxs-lookup"><span data-stu-id="19774-205">Serialization</span></span>  
 <span data-ttu-id="19774-206">La siguiente información se aplica a cualquier clase que herede del <xref:System.Runtime.Serialization.XmlObjectSerializer>,incluido las clases <xref:System.Runtime.Serialization.DataContractSerializer> y <xref:System.Runtime.Serialization.NetDataContractSerializer> .</span><span class="sxs-lookup"><span data-stu-id="19774-206">The following information applies to any class that inherits from the <xref:System.Runtime.Serialization.XmlObjectSerializer>, including the <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer> classes.</span></span>  
  
### <a name="simple-serialization"></a><span data-ttu-id="19774-207">Serialización simple</span><span class="sxs-lookup"><span data-stu-id="19774-207">Simple Serialization</span></span>  
 <span data-ttu-id="19774-208">La manera más básica de serializar un objeto es pasarlo al método <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> .</span><span class="sxs-lookup"><span data-stu-id="19774-208">The most basic way to serialize an object is to pass it to the <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> method.</span></span> <span data-ttu-id="19774-209">Hay tres sobrecargas, que permiten escribir en una <xref:System.IO.Stream>, un <xref:System.Xml.XmlWriter>o un <xref:System.Xml.XmlDictionaryWriter>.</span><span class="sxs-lookup"><span data-stu-id="19774-209">There are three overloads, one each for writing to a <xref:System.IO.Stream>, an <xref:System.Xml.XmlWriter>, or an <xref:System.Xml.XmlDictionaryWriter>.</span></span> <span data-ttu-id="19774-210">Con la sobrecarga <xref:System.IO.Stream> , el resultado es XML en la codificación UTF-8.</span><span class="sxs-lookup"><span data-stu-id="19774-210">With the <xref:System.IO.Stream> overload, the output is XML in the UTF-8 encoding.</span></span> <span data-ttu-id="19774-211">Con la sobrecarga <xref:System.Xml.XmlDictionaryWriter> , el serializador optimiza su resultado para XML binario.</span><span class="sxs-lookup"><span data-stu-id="19774-211">With the <xref:System.Xml.XmlDictionaryWriter> overload, the serializer optimizes its output for binary XML.</span></span>  
  
 <span data-ttu-id="19774-212">Cuando se usa el <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> método, el serializador utiliza el nombre y espacio de nombres predeterminados para el elemento contenedor y lo escribe junto con el contenido (vea la sección anterior "Especificación del nombre y espacio de nombres raíz predeterminados").</span><span class="sxs-lookup"><span data-stu-id="19774-212">When using the <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> method, the serializer uses the default name and namespace for the wrapper element and writes it out along with the contents (see the previous "Specifying the Default Root Name and Namespace" section).</span></span>  
  
 <span data-ttu-id="19774-213">En el ejemplo siguiente se muestra la escritura con <xref:System.Xml.XmlDictionaryWriter>.</span><span class="sxs-lookup"><span data-stu-id="19774-213">The following example demonstrates writing with an <xref:System.Xml.XmlDictionaryWriter>.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#8](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#8)]
 [!code-vb[c_StandaloneDataContractSerializer#8](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#8)]  
  
 <span data-ttu-id="19774-214">Esto produce un XML similar al siguiente.</span><span class="sxs-lookup"><span data-stu-id="19774-214">This produces XML similar to the following.</span></span>  
  
```xml  
<Person>  
  <Name>Jay Hamlin</Name>  
  <Address>123 Main St.</Address>  
</Person>  
```  
  
### <a name="step-by-step-serialization"></a><span data-ttu-id="19774-215">Serialización paso a paso</span><span class="sxs-lookup"><span data-stu-id="19774-215">Step-By-Step Serialization</span></span>  
 <span data-ttu-id="19774-216">Utilice los métodos <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A>, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A>y <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> para escribir el elemento de fin, escribir el contenido del objeto y cerrar el elemento contenedor, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="19774-216">Use the <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A>, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A>, and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> methods to write the end element, write the object contents, and close the wrapper element, respectively.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="19774-217">No hay ninguna sobrecarga <xref:System.IO.Stream> de estos métodos.</span><span class="sxs-lookup"><span data-stu-id="19774-217">There are no <xref:System.IO.Stream> overloads of these methods.</span></span>  
  
 <span data-ttu-id="19774-218">Esta serialización paso a paso tiene dos usos extendidos.</span><span class="sxs-lookup"><span data-stu-id="19774-218">This step-by-step serialization has two common uses.</span></span> <span data-ttu-id="19774-219">Uno consiste en insertar contenido como atributos o comentarios entre `WriteStartObject` y `WriteObjectContent`, tal y como se muestra en el siguiente ejemplo.</span><span class="sxs-lookup"><span data-stu-id="19774-219">One is to insert contents such as attributes or comments between `WriteStartObject` and `WriteObjectContent`,  as shown in the following example.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#9](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#9)]
 [!code-vb[c_StandaloneDataContractSerializer#9](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#9)]  
  
 <span data-ttu-id="19774-220">Esto produce un XML similar al siguiente.</span><span class="sxs-lookup"><span data-stu-id="19774-220">This produces XML similar to the following.</span></span>  
  
```xml  
<Person serializedBy="myCode">  
  <Name>Jay Hamlin</Name>  
  <Address>123 Main St.</Address>  
</Person>  
```  
  
 <span data-ttu-id="19774-221">Otro uso común consiste en evitar utilizar <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> y <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> por completo, y escribir su propio elemento contenedor personalizado (o incluso pasar por alto totalmente la escritura de un contenedor), tal y como se muestra en el siguiente código.</span><span class="sxs-lookup"><span data-stu-id="19774-221">Another common use is to avoid using <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> entirely, and to write your own custom wrapper element (or even skip writing a wrapper altogether), as shown in the following code.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#10](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#10)]
 [!code-vb[c_StandaloneDataContractSerializer#10](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#10)]  
  
 <span data-ttu-id="19774-222">Esto produce un XML similar al siguiente.</span><span class="sxs-lookup"><span data-stu-id="19774-222">This produces XML similar to the following.</span></span>  
  
```xml  
<MyCustomWrapper>  
  <Name>Jay Hamlin</Name>  
  <Address>123 Main St.</Address>  
</MyCustomWrapper>  
```  
  
> [!NOTE]
> <span data-ttu-id="19774-223">El uso de la serialización paso a paso puede producir un XML de esquema no válido.</span><span class="sxs-lookup"><span data-stu-id="19774-223">Using step-by-step serialization may result in schema-invalid XML.</span></span>  
  
## <a name="deserialization"></a><span data-ttu-id="19774-224">Deserialización</span><span class="sxs-lookup"><span data-stu-id="19774-224">Deserialization</span></span>  
 <span data-ttu-id="19774-225">La siguiente información se aplica a cualquier clase que herede del <xref:System.Runtime.Serialization.XmlObjectSerializer>,incluido las clases <xref:System.Runtime.Serialization.DataContractSerializer> y <xref:System.Runtime.Serialization.NetDataContractSerializer> .</span><span class="sxs-lookup"><span data-stu-id="19774-225">The following information applies to any class that inherits from the <xref:System.Runtime.Serialization.XmlObjectSerializer>, including the <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer> classes.</span></span>  
  
 <span data-ttu-id="19774-226">La manera más básica de deserializar un objeto consiste en llamar a una de las sobrecargas del método <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> .</span><span class="sxs-lookup"><span data-stu-id="19774-226">The most basic way to deserialize an object is to call one of the <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> method overloads.</span></span> <span data-ttu-id="19774-227">Hay tres sobrecargas, que permiten leer con un <xref:System.Xml.XmlDictionaryReader>, un `XmlReader`o una `Stream`.</span><span class="sxs-lookup"><span data-stu-id="19774-227">There are three overloads, one each for reading with a <xref:System.Xml.XmlDictionaryReader>, an `XmlReader`, or a `Stream`.</span></span> <span data-ttu-id="19774-228">Observe que la sobrecarga `Stream` crea un <xref:System.Xml.XmlDictionaryReader> textual que no está protegido por ninguna cuota, por lo que solo debería utilizarse para leer datos de confianza.</span><span class="sxs-lookup"><span data-stu-id="19774-228">Note that the `Stream` overload creates a textual <xref:System.Xml.XmlDictionaryReader> that is not protected by any quotas, and should be used only to read trusted data.</span></span>  
  
 <span data-ttu-id="19774-229">También tenga en cuenta que el objeto que devuelve el método `ReadObject` debe convertirse al tipo adecuado.</span><span class="sxs-lookup"><span data-stu-id="19774-229">Also note that the object the `ReadObject` method returns must be cast to the appropriate type.</span></span>  
  
 <span data-ttu-id="19774-230">El siguiente código construye una instancia de <xref:System.Runtime.Serialization.DataContractSerializer> y <xref:System.Xml.XmlDictionaryReader>, a continuación, deserializa una instancia de `Person` .</span><span class="sxs-lookup"><span data-stu-id="19774-230">The following code constructs an instance of the <xref:System.Runtime.Serialization.DataContractSerializer> and an <xref:System.Xml.XmlDictionaryReader>, then deserializes a `Person` instance.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#11](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#11)]
 [!code-vb[c_StandaloneDataContractSerializer#11](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#11)]  
  
 <span data-ttu-id="19774-231">Antes de llamar al método <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> , coloque el lector XML en el elemento contenedor o en un nodo de no contenido que preceda al elemento contenedor.</span><span class="sxs-lookup"><span data-stu-id="19774-231">Before calling the <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> method, position the XML reader on the wrapper element or on a non-content node that precedes the wrapper element.</span></span> <span data-ttu-id="19774-232">Puede realizar esto llamando al método <xref:System.Xml.XmlReader.Read%2A> del <xref:System.Xml.XmlReader> o su derivación y probando <xref:System.Xml.XmlReader.NodeType%2A>, tal y como se muestra en el código siguiente.</span><span class="sxs-lookup"><span data-stu-id="19774-232">You can do this by calling the <xref:System.Xml.XmlReader.Read%2A> method of the <xref:System.Xml.XmlReader> or its derivation, and testing the <xref:System.Xml.XmlReader.NodeType%2A>, as shown in the following code.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#12](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#12)]
 [!code-vb[c_StandaloneDataContractSerializer#12](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#12)]  
  
 <span data-ttu-id="19774-233">Observe que puede leer atributos en este elemento contenedor antes de entregar el lector a `ReadObject`.</span><span class="sxs-lookup"><span data-stu-id="19774-233">Note that you can read attributes on this wrapper element before handing the reader to `ReadObject`.</span></span>  
  
 <span data-ttu-id="19774-234">Al utilizar una de las `ReadObject` sobrecargas simples, el deserializador busca el nombre y espacio de nombres predeterminados en el elemento contenedor (vea la sección anterior, "especificar el nombre de raíz y el espacio de nombres predeterminados") e inicia una excepción si encuentra un elemento desconocido.</span><span class="sxs-lookup"><span data-stu-id="19774-234">When using one of the simple `ReadObject` overloads, the deserializer looks for the default name and namespace on the wrapper element (see the preceding section, "Specifying the Default Root Name and Namespace") and throws an exception if it finds an unknown element.</span></span> <span data-ttu-id="19774-235">En el ejemplo anterior se espera el elemento contenedor `<Person>` .</span><span class="sxs-lookup"><span data-stu-id="19774-235">In the preceding example, the `<Person>` wrapper element is expected.</span></span> <span data-ttu-id="19774-236">Se llama al método <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> para comprobar que el lector está ubicado en un elemento que se denomina como esperado.</span><span class="sxs-lookup"><span data-stu-id="19774-236">The <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> method is called to verify that the reader is positioned on an element that is named as expected.</span></span>  
  
 <span data-ttu-id="19774-237">Hay una manera de deshabilitar esta comprobación de nombre del elemento contenedor; algunas sobrecargas del método `ReadObject` toman el parámetro booleano `verifyObjectName`, que está establecido de forma predeterminada en `true` .</span><span class="sxs-lookup"><span data-stu-id="19774-237">There is a way to disable this wrapper element name check; some overloads of the `ReadObject` method take the Boolean parameter `verifyObjectName`, which is set to `true` by default.</span></span> <span data-ttu-id="19774-238">Cuando se establece en `false`, se ignoran el nombre y el espacio de nombres del elemento contenedor.</span><span class="sxs-lookup"><span data-stu-id="19774-238">When set to `false`, the name and namespace of the wrapper element is ignored.</span></span> <span data-ttu-id="19774-239">Esto es útil para leer XML escrito mediante el mecanismo de serialización paso a paso descrito previamente.</span><span class="sxs-lookup"><span data-stu-id="19774-239">This is useful for reading XML that was written using the step-by-step serialization mechanism described previously.</span></span>  
  
## <a name="using-the-netdatacontractserializer"></a><span data-ttu-id="19774-240">Uso del NetDataContractSerializer</span><span class="sxs-lookup"><span data-stu-id="19774-240">Using the NetDataContractSerializer</span></span>  
 <span data-ttu-id="19774-241">La principal diferencia entre `DataContractSerializer` y <xref:System.Runtime.Serialization.NetDataContractSerializer> es que `DataContractSerializer` utiliza los nombres de contrato de datos, mientras que las `NetDataContractSerializer` salidas se completan .NET Framework nombre de ensamblado y tipo en el XML serializado.</span><span class="sxs-lookup"><span data-stu-id="19774-241">The primary difference between the `DataContractSerializer` and the <xref:System.Runtime.Serialization.NetDataContractSerializer> is that the `DataContractSerializer` uses data contract names, whereas the `NetDataContractSerializer` outputs full .NET Framework assembly and type names in the serialized XML.</span></span> <span data-ttu-id="19774-242">Esto significa que se han de compartir exactamente los mismos tipos entre los extremos de serialización y deserialización.</span><span class="sxs-lookup"><span data-stu-id="19774-242">This means that the exact same types must be shared between the serialization and deserialization endpoints.</span></span> <span data-ttu-id="19774-243">Esto significa que el mecanismo de tipos conocidos no se requiere con el `NetDataContractSerializer` , porque siempre se conocen los tipos exactos que se van a deserializar.</span><span class="sxs-lookup"><span data-stu-id="19774-243">This means that the known types mechanism is not required with the `NetDataContractSerializer` because the exact types to be deserialized are always known.</span></span>  
  
 <span data-ttu-id="19774-244">Sin embargo, pueden producirse varios problemas:</span><span class="sxs-lookup"><span data-stu-id="19774-244">However, several problems can occur:</span></span>  
  
- <span data-ttu-id="19774-245">Seguridad.</span><span class="sxs-lookup"><span data-stu-id="19774-245">Security.</span></span> <span data-ttu-id="19774-246">Se carga cualquier tipo en el XML que se esté deserializando.</span><span class="sxs-lookup"><span data-stu-id="19774-246">Any type found in the XML being deserialized is loaded.</span></span> <span data-ttu-id="19774-247">Esto se puede explotar para forzar la carga de tipos malintencionados.</span><span class="sxs-lookup"><span data-stu-id="19774-247">This can be exploited to force the loading of malicious types.</span></span> <span data-ttu-id="19774-248">El uso del `NetDataContractSerializer` con datos que no son de confianza solo se debería realizar si se utiliza un *Enlazador de Serialización* (mediante el parámetro del constructor o la propiedad <xref:System.Runtime.Serialization.NetDataContractSerializer.Binder%2A> ).</span><span class="sxs-lookup"><span data-stu-id="19774-248">Using the `NetDataContractSerializer` with untrusted data should be done only if a *Serialization Binder* is used (using the <xref:System.Runtime.Serialization.NetDataContractSerializer.Binder%2A> property or constructor parameter).</span></span> <span data-ttu-id="19774-249">El enlazador solo permite cargar tipos seguros.</span><span class="sxs-lookup"><span data-stu-id="19774-249">The binder permits only safe types to be loaded.</span></span> <span data-ttu-id="19774-250">El mecanismo del enlazador es idéntico al que utilizan los tipos en el espacio de nombres de <xref:System.Runtime.Serialization> .</span><span class="sxs-lookup"><span data-stu-id="19774-250">The Binder mechanism is identical to the one that types in the <xref:System.Runtime.Serialization> namespace use.</span></span>  
  
- <span data-ttu-id="19774-251">Control de versiones</span><span class="sxs-lookup"><span data-stu-id="19774-251">Versioning.</span></span> <span data-ttu-id="19774-252">El uso de nombres de ensamblado y tipos completos en el XML restringe en gran medida el control de versión de los tipos.</span><span class="sxs-lookup"><span data-stu-id="19774-252">Using full type and assembly names in the XML severely restricts how types can be versioned.</span></span> <span data-ttu-id="19774-253">No se pueden cambiar lo siguientes elementos: nombres de tipos, espacios de nombres, nombres de ensamblados y versiones de ensamblados.</span><span class="sxs-lookup"><span data-stu-id="19774-253">The following cannot be changed: type names, namespaces, assembly names, and assembly versions.</span></span> <span data-ttu-id="19774-254">Establecer la propiedad <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> o el parámetro de constructor en <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple> en lugar del valor predeterminado de <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Full> permite los cambios de versión de ensamblado, pero no para tipos de parámetros genéricos.</span><span class="sxs-lookup"><span data-stu-id="19774-254">Setting the <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> property or constructor parameter to <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple> instead of the default value of <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Full> allows for assembly version changes, but not for generic parameter types.</span></span>  
  
- <span data-ttu-id="19774-255">Interoperabilidad.</span><span class="sxs-lookup"><span data-stu-id="19774-255">Interoperability.</span></span> <span data-ttu-id="19774-256">Dado que .NET Framework nombres de tipo y de ensamblado se incluyen en el XML, las plataformas distintas de la .NET Framework no pueden tener acceso a los datos resultantes.</span><span class="sxs-lookup"><span data-stu-id="19774-256">Because .NET Framework type and assembly names are included in the XML, platforms other than the .NET Framework cannot access the resulting data.</span></span>  
  
- <span data-ttu-id="19774-257">Rendimiento.</span><span class="sxs-lookup"><span data-stu-id="19774-257">Performance.</span></span> <span data-ttu-id="19774-258">Escribir los nombres del ensamblado y el tipo aumenta significativamente el tamaño del XML resultante.</span><span class="sxs-lookup"><span data-stu-id="19774-258">Writing out the type and assembly names significantly increases the size of the resulting XML.</span></span>  
  
 <span data-ttu-id="19774-259">Este mecanismo es similar a la serialización binaria o SOAP utilizada por .NET Framework remoto (concretamente, <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> y <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter> ).</span><span class="sxs-lookup"><span data-stu-id="19774-259">This mechanism is similar to binary or SOAP serialization used by .NET Framework remoting (specifically, the <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> and the <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>).</span></span>  
  
 <span data-ttu-id="19774-260">El uso del `NetDataContractSerializer` es similar al uso del `DataContractSerializer`, con las siguientes diferencias:</span><span class="sxs-lookup"><span data-stu-id="19774-260">Using the `NetDataContractSerializer` is similar to using the `DataContractSerializer`, with the following differences:</span></span>  
  
- <span data-ttu-id="19774-261">Los constructores no le exigen que especifique un tipo de raíz.</span><span class="sxs-lookup"><span data-stu-id="19774-261">The constructors do not require you to specify a root type.</span></span> <span data-ttu-id="19774-262">Puede serializar cualquier tipo con la misma instancia del `NetDataContractSerializer`.</span><span class="sxs-lookup"><span data-stu-id="19774-262">You can serialize any type with the same instance of the `NetDataContractSerializer`.</span></span>  
  
- <span data-ttu-id="19774-263">Los constructores no aceptan ninguna lista de tipos conocidos.</span><span class="sxs-lookup"><span data-stu-id="19774-263">The constructors do not accept a list of known types.</span></span> <span data-ttu-id="19774-264">El mecanismo de tipos conocidos no es necesario si los nombres de tipos se serializan en el XML.</span><span class="sxs-lookup"><span data-stu-id="19774-264">The known types mechanism is unnecessary if type names are serialized into the XML.</span></span>  
  
- <span data-ttu-id="19774-265">Los constructores no aceptan un contrato de datos suplente.</span><span class="sxs-lookup"><span data-stu-id="19774-265">The constructors do not accept a data contract surrogate.</span></span> <span data-ttu-id="19774-266">En su lugar, aceptan un parámetro <xref:System.Runtime.Serialization.ISurrogateSelector> llamado `surrogateSelector` (que asigna a la propiedad <xref:System.Runtime.Serialization.NetDataContractSerializer.SurrogateSelector%2A> ).</span><span class="sxs-lookup"><span data-stu-id="19774-266">Instead, they accept an <xref:System.Runtime.Serialization.ISurrogateSelector> parameter called `surrogateSelector` (which maps to the <xref:System.Runtime.Serialization.NetDataContractSerializer.SurrogateSelector%2A> property).</span></span> <span data-ttu-id="19774-267">Éste es un mecanismo suplente de herencia.</span><span class="sxs-lookup"><span data-stu-id="19774-267">This is a legacy surrogate mechanism.</span></span>  
  
- <span data-ttu-id="19774-268">Los constructores aceptan un parámetro denominado `assemblyFormat` del <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle> que asigna a la propiedad <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> .</span><span class="sxs-lookup"><span data-stu-id="19774-268">The constructors accept a parameter called `assemblyFormat` of the <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle> that maps to the <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> property.</span></span> <span data-ttu-id="19774-269">Tal y como se comentó previamente, esto se puede utilizar para mejorar las capacidades del control de versiones del serializador.</span><span class="sxs-lookup"><span data-stu-id="19774-269">As discussed previously, this can be used to enhance the versioning capabilities of the serializer.</span></span> <span data-ttu-id="19774-270">Esto es idéntico al mecanismo <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle> en la serialización binaria o de SOAP.</span><span class="sxs-lookup"><span data-stu-id="19774-270">This is identical to the <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle> mechanism in binary or SOAP serialization.</span></span>  
  
- <span data-ttu-id="19774-271">Los constructores aceptan un parámetro <xref:System.Runtime.Serialization.StreamingContext> denominado `context` que asigna a la propiedad <xref:System.Runtime.Serialization.NetDataContractSerializer.Context%2A> .</span><span class="sxs-lookup"><span data-stu-id="19774-271">The constructors accept a <xref:System.Runtime.Serialization.StreamingContext> parameter called `context` that maps to the <xref:System.Runtime.Serialization.NetDataContractSerializer.Context%2A> property.</span></span> <span data-ttu-id="19774-272">Puede utilizar esto para pasar información en los tipos que se serializan.</span><span class="sxs-lookup"><span data-stu-id="19774-272">You can use this to pass information into types being serialized.</span></span> <span data-ttu-id="19774-273">Este uso es idéntico al del mecanismo <xref:System.Runtime.Serialization.StreamingContext> utilizado en otras clases <xref:System.Runtime.Serialization> .</span><span class="sxs-lookup"><span data-stu-id="19774-273">This usage is identical to that of the <xref:System.Runtime.Serialization.StreamingContext> mechanism used in other <xref:System.Runtime.Serialization> classes.</span></span>  
  
- <span data-ttu-id="19774-274">Los métodos <xref:System.Runtime.Serialization.NetDataContractSerializer.Serialize%2A> y <xref:System.Runtime.Serialization.NetDataContractSerializer.Deserialize%2A> son alias de los métodos <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> y <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> .</span><span class="sxs-lookup"><span data-stu-id="19774-274">The <xref:System.Runtime.Serialization.NetDataContractSerializer.Serialize%2A> and <xref:System.Runtime.Serialization.NetDataContractSerializer.Deserialize%2A> methods are aliases for the <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> and <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> methods.</span></span> <span data-ttu-id="19774-275">Éstos existen para proporcionar un modelo de programación con serialización binaria o de SOAP más coherente.</span><span class="sxs-lookup"><span data-stu-id="19774-275">These exist to provide a more consistent programming model with binary or SOAP serialization.</span></span>  
  
 <span data-ttu-id="19774-276">Para obtener más información sobre estas características, vea [serialización binaria](../../../standard/serialization/binary-serialization.md).</span><span class="sxs-lookup"><span data-stu-id="19774-276">For more information about these features, see [Binary Serialization](../../../standard/serialization/binary-serialization.md).</span></span>  
  
 <span data-ttu-id="19774-277">Generalmente, los formatos XML que usan el `NetDataContractSerializer` y el `DataContractSerializer` no son compatibles.</span><span class="sxs-lookup"><span data-stu-id="19774-277">The XML formats that the `NetDataContractSerializer` and the `DataContractSerializer` use are normally not compatible.</span></span> <span data-ttu-id="19774-278">Es decir, intentar serializar con uno de estos serializadores y deserializar con el otro no es un escenario admitido.</span><span class="sxs-lookup"><span data-stu-id="19774-278">That is, attempting to serialize with one of these serializers and deserialize with the other is not a supported scenario.</span></span>  
  
 <span data-ttu-id="19774-279">Además, tenga en cuenta que el no `NetDataContractSerializer` genera el tipo de .NET Framework completo y el nombre de ensamblado para cada nodo del gráfico de objetos.</span><span class="sxs-lookup"><span data-stu-id="19774-279">Also, note that the `NetDataContractSerializer` does not output the full .NET Framework type and assembly name for each node in the object graph.</span></span> <span data-ttu-id="19774-280">Solo genera esa información cuando hay ambigüedad.</span><span class="sxs-lookup"><span data-stu-id="19774-280">It outputs that information only where it is ambiguous.</span></span> <span data-ttu-id="19774-281">Es decir, produce el resultado en el nivel del objeto raíz y para cualquier caso polimórfico.</span><span class="sxs-lookup"><span data-stu-id="19774-281">That is, it outputs at the root object level and for any polymorphic cases.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="19774-282">Vea también</span><span class="sxs-lookup"><span data-stu-id="19774-282">See also</span></span>

- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Runtime.Serialization.NetDataContractSerializer>
- <xref:System.Runtime.Serialization.XmlObjectSerializer>
- [<span data-ttu-id="19774-283">Serialización binaria</span><span class="sxs-lookup"><span data-stu-id="19774-283">Binary Serialization</span></span>](../../../standard/serialization/binary-serialization.md)
- [<span data-ttu-id="19774-284">Tipos admitidos por el serializador de contratos de datos</span><span class="sxs-lookup"><span data-stu-id="19774-284">Types Supported by the Data Contract Serializer</span></span>](types-supported-by-the-data-contract-serializer.md)
