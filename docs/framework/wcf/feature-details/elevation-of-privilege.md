---
title: Elevación de privilegios
ms.date: 03/30/2017
helpviewer_keywords:
- elevation of privilege [WCF]
- security [WCF], elevation of privilege
ms.assetid: 146e1c66-2a76-4ed3-98a5-fd77851a06d9
ms.openlocfilehash: 823b41f86080d4802f76fe69865279a7c3506238
ms.sourcegitcommit: cdb295dd1db589ce5169ac9ff096f01fd0c2da9d
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 06/09/2020
ms.locfileid: "84597415"
---
# <a name="elevation-of-privilege"></a><span data-ttu-id="bc4e1-102">Elevación de privilegios</span><span class="sxs-lookup"><span data-stu-id="bc4e1-102">Elevation of Privilege</span></span>
<span data-ttu-id="bc4e1-103">La *elevación de privilegios* resulta de conceder a un atacante permisos de autorización más allá de los concedidos inicialmente.</span><span class="sxs-lookup"><span data-stu-id="bc4e1-103">*Elevation of privilege* results from giving an attacker authorization permissions beyond those initially granted.</span></span> <span data-ttu-id="bc4e1-104">Por ejemplo, un atacante con un conjunto de privilegios de permisos de "solo lectura" eleva de algún modo el conjunto para incluir la "lectura y escritura".</span><span class="sxs-lookup"><span data-stu-id="bc4e1-104">For example, an attacker with a privilege set of "read only" permissions somehow elevates the set to include "read and write."</span></span>  
  
## <a name="trusted-sts-should-sign-saml-token-claims"></a><span data-ttu-id="bc4e1-105">El STS de confianza debería firmar las notificaciones de tokens de SAML</span><span class="sxs-lookup"><span data-stu-id="bc4e1-105">Trusted STS Should Sign SAML Token Claims</span></span>  
 <span data-ttu-id="bc4e1-106">Un token del lenguaje de marcado de aserción de seguridad (SAML) es un token XML genérico que es del tipo predeterminado para tokens emitidos.</span><span class="sxs-lookup"><span data-stu-id="bc4e1-106">A Security Assertions Markup Language (SAML) token is a generic XML token that is the default type for issued tokens.</span></span> <span data-ttu-id="bc4e1-107">Un servicio de tokens de seguridad (STS) puede construir un token SAML en el que confíe el servicio web final en un intercambio típico.</span><span class="sxs-lookup"><span data-stu-id="bc4e1-107">A SAML token can be constructed by a Security Token Service (STS) that the end Web service trusts in a typical exchange.</span></span> <span data-ttu-id="bc4e1-108">Los tokens SAML contienen las notificaciones en declaraciones.</span><span class="sxs-lookup"><span data-stu-id="bc4e1-108">SAML tokens contain claims in statements.</span></span> <span data-ttu-id="bc4e1-109">Un atacante puede copiar las notificaciones desde un token válido, crear un nuevo token SAML y firmarlo con un emisor diferente.</span><span class="sxs-lookup"><span data-stu-id="bc4e1-109">An attacker may copy the claims from a valid token, create a new SAML token, and sign it with a different issuer.</span></span> <span data-ttu-id="bc4e1-110">El objetivo es determinar si el servidor está validando a los emisores y, si no, utilizar esa debilidad para construir tokens SAML que concedan privilegios más allá de los proporcionados por un STS de confianza.</span><span class="sxs-lookup"><span data-stu-id="bc4e1-110">The intent is to determine whether the server is validating issuers and, if not, utilize the weakness to construct SAML tokens that allow privileges beyond those intended by a trusted STS.</span></span>  
  
 <span data-ttu-id="bc4e1-111">La clase <xref:System.IdentityModel.Tokens.SamlAssertion> comprueba la firma digital contenida dentro de un token de SAML y el <xref:System.IdentityModel.Selectors.SamlSecurityTokenAuthenticator> predeterminado necesita que los tokens de SAML estén firmados por un certificado X.509 que sea válido cuando el <xref:System.ServiceModel.Security.IssuedTokenServiceCredential.CertificateValidationMode%2A> de la clase <xref:System.ServiceModel.Security.IssuedTokenServiceCredential> se establezca en <xref:System.ServiceModel.Security.X509CertificateValidationMode.ChainTrust>.</span><span class="sxs-lookup"><span data-stu-id="bc4e1-111">The <xref:System.IdentityModel.Tokens.SamlAssertion> class verifies the digital signature contained within a SAML token, and the default <xref:System.IdentityModel.Selectors.SamlSecurityTokenAuthenticator> requires that SAML tokens be signed by an X.509 certificate that is valid when the <xref:System.ServiceModel.Security.IssuedTokenServiceCredential.CertificateValidationMode%2A> of the <xref:System.ServiceModel.Security.IssuedTokenServiceCredential> class is set to <xref:System.ServiceModel.Security.X509CertificateValidationMode.ChainTrust>.</span></span> <span data-ttu-id="bc4e1-112">El modo `ChainTrust` solo no es suficiente para determinar si el emisor del token de SAML es de confianza.</span><span class="sxs-lookup"><span data-stu-id="bc4e1-112">`ChainTrust` mode alone is insufficient to determine whether the issuer of the SAML token is trusted.</span></span> <span data-ttu-id="bc4e1-113">Los servicios que requieren un modelo de confianza más específico pueden usar directivas de autorización y cumplimiento para comprobar el emisor de los conjuntos de notificaciones producidos mediante la autenticación de tokens emitidos o usar los valores de validación X.509 en <xref:System.ServiceModel.Security.IssuedTokenServiceCredential> para restringir el conjunto de certificados de firma permitidos.</span><span class="sxs-lookup"><span data-stu-id="bc4e1-113">Services that require a more granular trust model can either use authorization and enforcement policies to check the issuer of the claim sets produced by issued token authentication or use the X.509 validation settings on <xref:System.ServiceModel.Security.IssuedTokenServiceCredential> to restrict the set of allowed signing certificates.</span></span> <span data-ttu-id="bc4e1-114">Para obtener más información, consulte [Administración de notificaciones y autorización con el modelo de identidades](managing-claims-and-authorization-with-the-identity-model.md) y [Federación y tokens emitidos](federation-and-issued-tokens.md).</span><span class="sxs-lookup"><span data-stu-id="bc4e1-114">For more information, see [Managing Claims and Authorization with the Identity Model](managing-claims-and-authorization-with-the-identity-model.md) and [Federation and Issued Tokens](federation-and-issued-tokens.md).</span></span>  
  
## <a name="switching-identity-without-a-security-context"></a><span data-ttu-id="bc4e1-115">Intercambio de identidad sin un contexto de seguridad</span><span class="sxs-lookup"><span data-stu-id="bc4e1-115">Switching Identity Without a Security Context</span></span>  
 <span data-ttu-id="bc4e1-116">Lo siguiente se aplica únicamente a WinFX.</span><span class="sxs-lookup"><span data-stu-id="bc4e1-116">The following applies only to WinFX.</span></span>  
  
 <span data-ttu-id="bc4e1-117">Cuando se establece una conexión entre un cliente y un servidor, la identidad del cliente no cambia, excepto en una situación: después de abrir el cliente WCF, si se cumplen todas las condiciones siguientes:</span><span class="sxs-lookup"><span data-stu-id="bc4e1-117">When a connection is established between a client and server, the identity of the client does not change, except in one situation: after the WCF client is opened, if all of the following conditions are true:</span></span>  
  
- <span data-ttu-id="bc4e1-118">Los procedimientos para establecer un contexto de seguridad (mediante una sesión de seguridad de transporte o una sesión de seguridad de mensajes) se desactivan (la <xref:System.ServiceModel.NonDualMessageSecurityOverHttp.EstablishSecurityContext%2A> propiedad se establece `false` en en caso de seguridad de mensaje o el transporte no es capaz de establecer sesiones de seguridad se utiliza en el caso de seguridad de transporte.</span><span class="sxs-lookup"><span data-stu-id="bc4e1-118">The procedures to establish a security context (using a transport security session or message security session) is switched off (<xref:System.ServiceModel.NonDualMessageSecurityOverHttp.EstablishSecurityContext%2A> property is set to `false` in case of message security or transport not capable of establishing security sessions is used in transport security case.</span></span> <span data-ttu-id="bc4e1-119">HTTPS es un ejemplo de dicho transporte).</span><span class="sxs-lookup"><span data-stu-id="bc4e1-119">HTTPS is one example of such transport).</span></span>  
  
- <span data-ttu-id="bc4e1-120">Está utilizando la autenticación de Windows.</span><span class="sxs-lookup"><span data-stu-id="bc4e1-120">You are using Windows authentication.</span></span>  
  
- <span data-ttu-id="bc4e1-121">No establece explícitamente la credencial.</span><span class="sxs-lookup"><span data-stu-id="bc4e1-121">You do not explicitly set the credential.</span></span>  
  
- <span data-ttu-id="bc4e1-122">Está llamando al servicio bajo el contexto de seguridad suplantado.</span><span class="sxs-lookup"><span data-stu-id="bc4e1-122">You are calling the service under the impersonated security context.</span></span>  
  
 <span data-ttu-id="bc4e1-123">Si se cumplen estas condiciones, la identidad que se usa para autenticar el cliente en el servicio podría cambiar (puede que no sea la identidad suplantada pero la identidad del proceso en su lugar) después de que se abra el cliente WCF.</span><span class="sxs-lookup"><span data-stu-id="bc4e1-123">If these conditions are true, the identity used to authenticate the client to the service might change (it might not be the impersonated identity but the process identity instead) after the WCF client is opened.</span></span> <span data-ttu-id="bc4e1-124">Esto ocurre porque la credencial de Windows utilizada para autenticar el cliente en el servicio se transmite con cada mensaje, y la credencial utilizada para la autenticación se obtiene a partir de la identidad de Windows del subproceso actual.</span><span class="sxs-lookup"><span data-stu-id="bc4e1-124">This occurs because the Windows credential used to authenticate the client to the service is transmitted with every message, and the credential used for authentication is obtained from the current thread's Windows identity.</span></span> <span data-ttu-id="bc4e1-125">Si la identidad de Windows del subproceso actual cambia (por ejemplo, suplantando a un llamador diferente), la credencial adjunta al mensaje y utilizada para autenticar el cliente en el servicio también podría cambiar.</span><span class="sxs-lookup"><span data-stu-id="bc4e1-125">If the Windows identity of the current thread changes (for example, by impersonating a different caller), the credential that is attached to the message and used to authenticate the client to the service might also change.</span></span>  
  
 <span data-ttu-id="bc4e1-126">Si desea tener un comportamiento determinista al utilizar la autenticación de Windows junto con la suplantación, debe establecer explícitamente la credencial de Windows o debe establecer un contexto de seguridad con el servicio.</span><span class="sxs-lookup"><span data-stu-id="bc4e1-126">If you want to have deterministic behavior when using Windows authentication together with impersonation you need to explicitly set the Windows credential or you need to establish a security context with the service.</span></span> <span data-ttu-id="bc4e1-127">Para ello, utilice una sesión de seguridad de mensajes o una sesión de seguridad de transporte.</span><span class="sxs-lookup"><span data-stu-id="bc4e1-127">To do this, use a message security session or a transport security session.</span></span> <span data-ttu-id="bc4e1-128">Por ejemplo, el transporte net.tcp puede proporcionar una sesión de seguridad de transporte.</span><span class="sxs-lookup"><span data-stu-id="bc4e1-128">For example, the net.tcp transport can provide a transport security session.</span></span> <span data-ttu-id="bc4e1-129">Además, debe utilizar solo una versión sincrónica de operaciones de cliente al llamar al servicio.</span><span class="sxs-lookup"><span data-stu-id="bc4e1-129">Additionally, you must use only a synchronous version of client operations when calling the service.</span></span> <span data-ttu-id="bc4e1-130">Si establece un contexto de seguridad de mensajes, no debería mantener abierta la conexión con el servicio más tiempo del periodo de renovación de sesión configurado, puesto que la identidad también puede cambiar durante el proceso de renovación de sesión.</span><span class="sxs-lookup"><span data-stu-id="bc4e1-130">If you establish a message security context, you should not keep the connection to the service open longer than the configured session renewal period, because the identity can also change during the session renewal process.</span></span>  
  
### <a name="credentials-capture"></a><span data-ttu-id="bc4e1-131">Captura de credenciales</span><span class="sxs-lookup"><span data-stu-id="bc4e1-131">Credentials Capture</span></span>  
 <span data-ttu-id="bc4e1-132">Lo siguiente se aplica a .NET Framework 3,5 y versiones posteriores.</span><span class="sxs-lookup"><span data-stu-id="bc4e1-132">The following applies to .NET Framework 3.5, and subsequent versions.</span></span>  
  
 <span data-ttu-id="bc4e1-133">Las credenciales utilizadas por el cliente o el servicio se basan en el subproceso de contexto actual.</span><span class="sxs-lookup"><span data-stu-id="bc4e1-133">Credentials used by the client or the service are based on the current context thread.</span></span> <span data-ttu-id="bc4e1-134">Las credenciales se obtienen cuando se llama al método `Open` (o `BeginOpen`, para las llamadas asincrónicas) del cliente o servicio.</span><span class="sxs-lookup"><span data-stu-id="bc4e1-134">The credentials are obtained when the `Open` method (or `BeginOpen`, for asynchronous calls) of the client or service is called.</span></span> <span data-ttu-id="bc4e1-135">Para las clases <xref:System.ServiceModel.ServiceHost> y <xref:System.ServiceModel.ClientBase%601>, los métodos `Open` y `BeginOpen` heredan de los métodos <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> y <xref:System.ServiceModel.Channels.CommunicationObject.BeginOpen%2A> de la clase <xref:System.ServiceModel.Channels.CommunicationObject>.</span><span class="sxs-lookup"><span data-stu-id="bc4e1-135">For both the <xref:System.ServiceModel.ServiceHost> and <xref:System.ServiceModel.ClientBase%601> classes, the `Open` and `BeginOpen` methods inherit from the <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> and <xref:System.ServiceModel.Channels.CommunicationObject.BeginOpen%2A> methods of the <xref:System.ServiceModel.Channels.CommunicationObject> class.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="bc4e1-136">Al utilizar el método `BeginOpen`, no se puede garantizar que las credenciales capturadas sean las credenciales del proceso que llama al método.</span><span class="sxs-lookup"><span data-stu-id="bc4e1-136">When using the `BeginOpen` method, the credentials captured cannot be guaranteed to be the credentials of the process that calls the method.</span></span>  
  
## <a name="token-caches-allow-replay-using-obsolete-data"></a><span data-ttu-id="bc4e1-137">Las cachés de tokens permiten la repetición mediante datos obsoletos</span><span class="sxs-lookup"><span data-stu-id="bc4e1-137">Token Caches Allow Replay Using Obsolete Data</span></span>  
 <span data-ttu-id="bc4e1-138">WCF usa la función de autoridad de seguridad local (LSA) `LogonUser` para autenticar a los usuarios por nombre de usuario y contraseña.</span><span class="sxs-lookup"><span data-stu-id="bc4e1-138">WCF uses the local security authority (LSA) `LogonUser` function to authenticate users by user name and password.</span></span> <span data-ttu-id="bc4e1-139">Dado que la función Logon es una operación costosa, WCF le permite almacenar en caché los tokens que representan a los usuarios autenticados para aumentar el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="bc4e1-139">Because the logon function is a costly operation, WCF allows you to cache tokens that represent authenticated users to increase performance.</span></span> <span data-ttu-id="bc4e1-140">El mecanismo de almacenamiento en caché guarda los resultados de `LogonUser` para los usos posteriores.</span><span class="sxs-lookup"><span data-stu-id="bc4e1-140">The caching mechanism saves the results from `LogonUser` for subsequent uses.</span></span> <span data-ttu-id="bc4e1-141">Este mecanismo está deshabilitado de forma predeterminada; para habilitarla, establezca la <xref:System.ServiceModel.Security.UserNamePasswordServiceCredential.CacheLogonTokens%2A> propiedad en `true` o utilice el `cacheLogonTokens` atributo de [\<userNameAuthentication>](../../configure-apps/file-schema/wcf/usernameauthentication.md) .</span><span class="sxs-lookup"><span data-stu-id="bc4e1-141">This mechanism is disabled by default; to enable it, set the <xref:System.ServiceModel.Security.UserNamePasswordServiceCredential.CacheLogonTokens%2A> property to `true`, or use the `cacheLogonTokens` attribute of the [\<userNameAuthentication>](../../configure-apps/file-schema/wcf/usernameauthentication.md).</span></span>  
  
 <span data-ttu-id="bc4e1-142">Puede establecer un período de vida (TTL) para los tokens almacenados en memoria caché estableciendo la propiedad <xref:System.ServiceModel.Security.UserNamePasswordServiceCredential.CachedLogonTokenLifetime%2A> en <xref:System.TimeSpan> o utilizar el atributo `cachedLogonTokenLifetime` del elemento `userNameAuthentication`; el valor predeterminado es de 15 minutos.</span><span class="sxs-lookup"><span data-stu-id="bc4e1-142">You can set a Time to Live (TTL) for the cached tokens by setting the <xref:System.ServiceModel.Security.UserNamePasswordServiceCredential.CachedLogonTokenLifetime%2A> property to a <xref:System.TimeSpan>, or use the `cachedLogonTokenLifetime` attribute of the `userNameAuthentication` element; the default is 15 minutes.</span></span> <span data-ttu-id="bc4e1-143">Tenga en cuenta que mientras un token esté almacenado en memoria caché, cualquier cliente que presente el mismo nombre de usuario y contraseña podrá utilizar el token, aunque la cuenta de usuario se elimine de Windows o se haya cambiado su contraseña.</span><span class="sxs-lookup"><span data-stu-id="bc4e1-143">Note that while a token is cached, any client that presents the same user name and password can use the token, even if the user account is deleted from Windows or if its password has been changed.</span></span> <span data-ttu-id="bc4e1-144">Hasta que expire el TTL y el token se quite de la memoria caché, WCF permite que el usuario (posiblemente malintencionado) se autentique.</span><span class="sxs-lookup"><span data-stu-id="bc4e1-144">Until the TTL expires and the token is removed from the cache, WCF allows the (possibly malicious) user to authenticate.</span></span>  
  
 <span data-ttu-id="bc4e1-145">Para paliar esto: disminuya la ventana de ataque estableciendo el valor de `cachedLogonTokenLifetime` en el intervalo de tiempo más corto que necesiten sus usuarios.</span><span class="sxs-lookup"><span data-stu-id="bc4e1-145">To mitigate this: Decrease the attack window by setting the `cachedLogonTokenLifetime` value to the shortest time span your users need.</span></span>  
  
## <a name="issued-token-authorization-expiration-reset-to-large-value"></a><span data-ttu-id="bc4e1-146">Autorización de tokens emitidos: restablecimiento de la expiración a un valor mayor</span><span class="sxs-lookup"><span data-stu-id="bc4e1-146">Issued Token Authorization: Expiration Reset to Large Value</span></span>  
 <span data-ttu-id="bc4e1-147">Bajo ciertas condiciones, la propiedad <xref:System.IdentityModel.Policy.AuthorizationContext.ExpirationTime%2A> del <xref:System.IdentityModel.Policy.AuthorizationContext> puede establecerse en un valor inesperadamente mayor (el valor del campo <xref:System.DateTime.MaxValue> menos un día o el 20 de diciembre de 9999).</span><span class="sxs-lookup"><span data-stu-id="bc4e1-147">Under certain conditions, the <xref:System.IdentityModel.Policy.AuthorizationContext.ExpirationTime%2A> property of the <xref:System.IdentityModel.Policy.AuthorizationContext> may be set to an unexpectedly larger value (the <xref:System.DateTime.MaxValue> field value minus one day, or December 20, 9999).</span></span>  
  
 <span data-ttu-id="bc4e1-148">Esto ocurre al utilizar el <xref:System.ServiceModel.WSFederationHttpBinding> y cualquiera de los enlaces proporcionados por el sistema que tengan un token emitido como el tipo de credencial de cliente.</span><span class="sxs-lookup"><span data-stu-id="bc4e1-148">This occurs when using the <xref:System.ServiceModel.WSFederationHttpBinding> and any of the system-provided bindings that have an issued token as the client credential type.</span></span>  
  
 <span data-ttu-id="bc4e1-149">Esto también ocurre al crear enlaces personalizados utilizando uno de los siguientes métodos:</span><span class="sxs-lookup"><span data-stu-id="bc4e1-149">This also occurs when you create custom bindings by using one of the following methods:</span></span>  
  
- <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenBindingElement%2A>  
  
- <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenForCertificateBindingElement%2A>  
  
- <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenForSslBindingElement%2A>  
  
- <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenOverTransportBindingElement%2A>  
  
 <span data-ttu-id="bc4e1-150">Para paliar esto, la directiva de autorización debe comprobar la acción y la hora de la expiración de cada directiva de autorización.</span><span class="sxs-lookup"><span data-stu-id="bc4e1-150">To mitigate this, the authorization policy must check the action and the expiration time of each authorization policy.</span></span>  
  
## <a name="the-service-uses-a-different-certificate-than-the-client-intended"></a><span data-ttu-id="bc4e1-151">El Servicio utiliza un certificado diferente del que el cliente pretendía</span><span class="sxs-lookup"><span data-stu-id="bc4e1-151">The Service Uses a Different Certificate Than the Client Intended</span></span>  
 <span data-ttu-id="bc4e1-152">Bajo ciertas condiciones, un cliente puede firmar digitalmente un mensaje con un certificado X.509 y hacer que el servicio recupere un certificado diferente del deseado.</span><span class="sxs-lookup"><span data-stu-id="bc4e1-152">Under certain conditions, a client can digitally sign a message with an X.509 certificate and have the service retrieve a different certificate than the intended one.</span></span>  
  
 <span data-ttu-id="bc4e1-153">Esto puede suceder bajo las siguientes circunstancias:</span><span class="sxs-lookup"><span data-stu-id="bc4e1-153">This can occur under the following circumstances:</span></span>  
  
- <span data-ttu-id="bc4e1-154">El cliente firma digitalmente un mensaje mediante un certificado X.509 y no adjunta el certificado X.509 al mensaje, sino que solo hace referencia al certificado utilizando su identificador de clave de sujeto.</span><span class="sxs-lookup"><span data-stu-id="bc4e1-154">The client digitally signs a message using an X.509 certificate and does not attach the X.509 certificate to the message, but rather just references the certificate using its subject key identifier.</span></span>  
  
- <span data-ttu-id="bc4e1-155">El equipo del servicio contiene dos o más certificados con la misma clave pública, pero contienen información diferente.</span><span class="sxs-lookup"><span data-stu-id="bc4e1-155">The service's computer contains two or more certificates with the same public key, but they contain different information.</span></span>  
  
- <span data-ttu-id="bc4e1-156">El servicio recupera un certificado que coincide con el identificador de clave de sujeto (SKI), pero no es el que el cliente pensaba utilizar.</span><span class="sxs-lookup"><span data-stu-id="bc4e1-156">The service retrieves a certificate that matches the subject key identifier, but it is not the one the client intended to use.</span></span> <span data-ttu-id="bc4e1-157">Cuando WCF recibe el mensaje y comprueba la firma, WCF asigna la información en el certificado X. 509 no deseado a un conjunto de notificaciones que son diferentes y que pueden ser elevadas de lo que esperaba el cliente.</span><span class="sxs-lookup"><span data-stu-id="bc4e1-157">When WCF receives the message and verifies the signature, WCF maps the information in the unintended X.509 certificate to a set of claims that are different and potentially elevated from what the client expected.</span></span>  
  
 <span data-ttu-id="bc4e1-158">Para mitigar esto, haga referencia al certificado X.509 de otra manera, como, por ejemplo, mediante <xref:System.ServiceModel.Security.Tokens.X509KeyIdentifierClauseType.IssuerSerial>.</span><span class="sxs-lookup"><span data-stu-id="bc4e1-158">To mitigate this, reference the X.509 certificate another way, such as using <xref:System.ServiceModel.Security.Tokens.X509KeyIdentifierClauseType.IssuerSerial>.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="bc4e1-159">Vea también</span><span class="sxs-lookup"><span data-stu-id="bc4e1-159">See also</span></span>

- [<span data-ttu-id="bc4e1-160">Consideraciones sobre la seguridad</span><span class="sxs-lookup"><span data-stu-id="bc4e1-160">Security Considerations</span></span>](security-considerations-in-wcf.md)
- [<span data-ttu-id="bc4e1-161">Divulgación de información</span><span class="sxs-lookup"><span data-stu-id="bc4e1-161">Information Disclosure</span></span>](information-disclosure.md)
- [<span data-ttu-id="bc4e1-162">Denegación de servicio</span><span class="sxs-lookup"><span data-stu-id="bc4e1-162">Denial of Service</span></span>](denial-of-service.md)
- [<span data-ttu-id="bc4e1-163">Ataques por repetición</span><span class="sxs-lookup"><span data-stu-id="bc4e1-163">Replay Attacks</span></span>](replay-attacks.md)
- [<span data-ttu-id="bc4e1-164">Alteración de datos</span><span class="sxs-lookup"><span data-stu-id="bc4e1-164">Tampering</span></span>](tampering.md)
- [<span data-ttu-id="bc4e1-165">Escenarios no admitidos</span><span class="sxs-lookup"><span data-stu-id="bc4e1-165">Unsupported Scenarios</span></span>](unsupported-scenarios.md)
