---
description: 'Más información sobre: consideraciones de seguridad para los datos'
title: Consideraciones de seguridad para datos
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: a7eb98da-4a93-4692-8b59-9d670c79ffb2
ms.openlocfilehash: 6e0bf681ad8dd141ad030ef850c3e50c1d6e65c8
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 02/06/2021
ms.locfileid: "99632625"
---
# <a name="security-considerations-for-data"></a><span data-ttu-id="696d4-103">Consideraciones de seguridad para datos</span><span class="sxs-lookup"><span data-stu-id="696d4-103">Security Considerations for Data</span></span>

<span data-ttu-id="696d4-104">Al trabajar con datos en Windows Communication Foundation (WCF), debe tener en cuenta varias categorías de amenazas.</span><span class="sxs-lookup"><span data-stu-id="696d4-104">When dealing with data in Windows Communication Foundation (WCF), you must consider a number of threat categories.</span></span> <span data-ttu-id="696d4-105">En la siguiente lista se muestran las clases de amenazas más importantes relacionadas con el procesamiento de datos.</span><span class="sxs-lookup"><span data-stu-id="696d4-105">The following list shows the most important threat classes that relate to data processing.</span></span> <span data-ttu-id="696d4-106">WCF proporciona herramientas para mitigar estas amenazas.</span><span class="sxs-lookup"><span data-stu-id="696d4-106">WCF provides tools to mitigate these threats.</span></span>

* <span data-ttu-id="696d4-107">Denegación de servicio</span><span class="sxs-lookup"><span data-stu-id="696d4-107">Denial of service</span></span>

  <span data-ttu-id="696d4-108">Al recibir datos que no son de confianza, los datos pueden hacer que el lado receptor tenga acceso a una cantidad desproporcionada de varios recursos, como memoria, subprocesos, conexiones disponibles o ciclos de procesador produciendo largos cálculos.</span><span class="sxs-lookup"><span data-stu-id="696d4-108">When receiving untrusted data, the data may cause the receiving side to access a disproportionate amount of various resources, such as memory, threads, available connections, or processor cycles by causing lengthy computations.</span></span> <span data-ttu-id="696d4-109">Un ataque por denegación de servicio contra un servidor puede provocar que se bloquee y no pueda procesar los mensajes de otros clientes legítimos.</span><span class="sxs-lookup"><span data-stu-id="696d4-109">A denial-of-service attack against a server may cause it to crash and be unable to process messages from other, legitimate clients.</span></span>

* <span data-ttu-id="696d4-110">Ejecución de código malintencionado</span><span class="sxs-lookup"><span data-stu-id="696d4-110">Malicious code execution</span></span>

  <span data-ttu-id="696d4-111">Los datos entrantes que no son de confianza provocan que el lado receptor ejecute código que no pretendía ejecutar.</span><span class="sxs-lookup"><span data-stu-id="696d4-111">Incoming untrusted data causes the receiving side to run code it did not intend to.</span></span>

* <span data-ttu-id="696d4-112">Divulgación de información</span><span class="sxs-lookup"><span data-stu-id="696d4-112">Information disclosure</span></span>

  <span data-ttu-id="696d4-113">El atacante remoto obliga a la parte receptora a que responda a sus solicitudes de manera que divulga más información de la que pretende.</span><span class="sxs-lookup"><span data-stu-id="696d4-113">The remote attacker forces the receiving party to respond to its requests in such a way as to disclose more information than it intends to.</span></span>

## <a name="user-provided-code-and-code-access-security"></a><span data-ttu-id="696d4-114">Código proporcionado por usuario y seguridad de acceso del código</span><span class="sxs-lookup"><span data-stu-id="696d4-114">User-Provided Code and Code Access Security</span></span>

<span data-ttu-id="696d4-115">Varios lugares de la infraestructura de Windows Communication Foundation (WCF) ejecutan código proporcionado por el usuario.</span><span class="sxs-lookup"><span data-stu-id="696d4-115">A number of places in the Windows Communication Foundation (WCF) infrastructure run code that is provided by the user.</span></span> <span data-ttu-id="696d4-116">Por ejemplo, el motor de serialización <xref:System.Runtime.Serialization.DataContractSerializer> puede llamar a los descriptores de acceso de propiedad proporcionados por el usuario `set` y a los descriptores de acceso `get` .</span><span class="sxs-lookup"><span data-stu-id="696d4-116">For example, the <xref:System.Runtime.Serialization.DataContractSerializer> serialization engine may call user-provided property `set` accessors and `get` accessors.</span></span> <span data-ttu-id="696d4-117">La infraestructura del canal de WCF también puede llamar a clases derivadas proporcionadas por el usuario de la <xref:System.ServiceModel.Channels.Message> clase.</span><span class="sxs-lookup"><span data-stu-id="696d4-117">The WCF channel infrastructure may also call into user-provided derived classes of the <xref:System.ServiceModel.Channels.Message> class.</span></span>

<span data-ttu-id="696d4-118">Es responsabilidad del autor del código asegurarse de que no existan vulnerabilidades de seguridad.</span><span class="sxs-lookup"><span data-stu-id="696d4-118">It is the responsibility of the code author to ensure that no security vulnerabilities exist.</span></span> <span data-ttu-id="696d4-119">Por ejemplo, si crea un tipo de contrato de datos con una propiedad de miembro de datos de tipo entero, y en la implementación del descriptor de acceso `set` asigna una matriz basada en el valor de propiedad, expondrá la posibilidad de un ataque por denegación de servicio si un mensaje malintencionado contiene un valor sumamente grande para este miembro de datos.</span><span class="sxs-lookup"><span data-stu-id="696d4-119">For example, if you create a data contract type with a data member property of type integer, and in the `set` accessor implementation allocate an array based on the property value, you expose the possibility of a denial-of-service attack if a malicious message contains an extremely large value for this data member.</span></span> <span data-ttu-id="696d4-120">En general, evite cualquier asignación basada en datos entrantes o el procesamiento largo en código proporcionado por el usuario (sobre todo si una cantidad pequeña de los datos entrantes puede provocar un procesamiento largo).</span><span class="sxs-lookup"><span data-stu-id="696d4-120">In general, avoid any allocations based on incoming data or lengthy processing in user-provided code (especially if lengthy processing can be caused by a small amount of incoming data).</span></span> <span data-ttu-id="696d4-121">Al realizar análisis de seguridad de código proporcionado por usuario, asegúrese de considerar también todos los casos de error (es decir, todas las bifurcaciones de código donde se produzcan excepciones).</span><span class="sxs-lookup"><span data-stu-id="696d4-121">When performing security analysis of user-provided code, make sure to also consider all failure cases (that is, all code branches where exceptions are thrown).</span></span>

<span data-ttu-id="696d4-122">El ejemplo último de código proporcionado por usuario es el código dentro de su implementación del servicio para cada operación.</span><span class="sxs-lookup"><span data-stu-id="696d4-122">The ultimate example of user-provided code is the code inside your service implementation for each operation.</span></span> <span data-ttu-id="696d4-123">La seguridad de su implementación del servicio es su responsabilidad.</span><span class="sxs-lookup"><span data-stu-id="696d4-123">The security of your service implementation is your responsibility.</span></span> <span data-ttu-id="696d4-124">Es fácil crear inadvertidamente implementaciones de la operación inseguras que puedan producir vulnerabilidades de la denegación de servicio.</span><span class="sxs-lookup"><span data-stu-id="696d4-124">It is easy to inadvertently create insecure operation implementations that may result in denial-of-service vulnerabilities.</span></span> <span data-ttu-id="696d4-125">Por ejemplo, una operación que toma una cadena y devuelve la lista de clientes de una base de datos cuyo nombre empieza con esa cadena.</span><span class="sxs-lookup"><span data-stu-id="696d4-125">For example, an operation that takes a string and returns the list of customers from a database whose name starts with that string.</span></span> <span data-ttu-id="696d4-126">Si está trabajando con una base de datos grande y la cadena que se pasa simplemente es una letra única, su código puede intentar crear un mensaje mayor que toda la memoria disponible, haciendo que se produzca un error en el servicio completo.</span><span class="sxs-lookup"><span data-stu-id="696d4-126">If you are working with a large database and the string being passed is just a single letter, your code may attempt to create a message larger than all available memory, causing the entire service to fail.</span></span> <span data-ttu-id="696d4-127">(Un <xref:System.OutOfMemoryException> no es recuperable en el .NET Framework y siempre da lugar a la finalización de la aplicación).</span><span class="sxs-lookup"><span data-stu-id="696d4-127">(An <xref:System.OutOfMemoryException> is not recoverable in the .NET Framework and always results in the termination of your application.)</span></span>

<span data-ttu-id="696d4-128">Debería asegurarse de que ningún código malintencionado esté conectado a los varios puntos de la extensibilidad.</span><span class="sxs-lookup"><span data-stu-id="696d4-128">You should ensure that no malicious code is plugged in to the various extensibility points.</span></span> <span data-ttu-id="696d4-129">Esto es especialmente importante cuando la ejecución se realiza con confianza parcial, al tratar con tipos de ensamblados de confianza parcial, o al crear componentes que puede utilizar código de confianza parcial.</span><span class="sxs-lookup"><span data-stu-id="696d4-129">This is especially relevant when running under partial trust, dealing with types from partially-trusted assemblies, or creating components usable by partially-trusted code.</span></span> <span data-ttu-id="696d4-130">Para obtener más información, vea "Amenazas de confianza parcial" en una sección posterior.</span><span class="sxs-lookup"><span data-stu-id="696d4-130">For more information, see "Partial Trust Threats" in a later section.</span></span>

<span data-ttu-id="696d4-131">Tenga en cuenta que cuando se realiza la ejecución en confianza parcial, la infraestructura de serialización del contrato de datos solo admite un subconjunto limitado de modelos de programación de contratos de datos, por ejemplo, no se admiten miembros de datos privados o tipos que utilizan el atributo <xref:System.SerializableAttribute> .</span><span class="sxs-lookup"><span data-stu-id="696d4-131">Note that when running in partial trust, the data contract serialization infrastructure supports only a limited subset of the data contract programming model - for example, private data members or types using the <xref:System.SerializableAttribute> attribute are not supported.</span></span> <span data-ttu-id="696d4-132">Para obtener más información, vea [confianza parcial](partial-trust.md).</span><span class="sxs-lookup"><span data-stu-id="696d4-132">For more information, see [Partial Trust](partial-trust.md).</span></span>

## <a name="avoiding-unintentional-information-disclosure"></a><span data-ttu-id="696d4-133">Evitar la divulgación involuntaria de información</span><span class="sxs-lookup"><span data-stu-id="696d4-133">Avoiding Unintentional Information Disclosure</span></span>

<span data-ttu-id="696d4-134">Al diseñar los tipos serializables con seguridad en mente, la divulgación de información es una posible preocupación.</span><span class="sxs-lookup"><span data-stu-id="696d4-134">When designing serializable types with security in mind, information disclosure is a possible concern.</span></span>

<span data-ttu-id="696d4-135">Tenga en cuenta lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="696d4-135">Consider the following points:</span></span>

- <span data-ttu-id="696d4-136">El modelo de programación <xref:System.Runtime.Serialization.DataContractSerializer> permite la exposición de datos privados e internos fuera del tipo o ensamblado durante la serialización.</span><span class="sxs-lookup"><span data-stu-id="696d4-136">The <xref:System.Runtime.Serialization.DataContractSerializer> programming model allows the exposure of private and internal data outside of the type or assembly during serialization.</span></span> <span data-ttu-id="696d4-137">Además, la forma de un tipo puede exponerse durante la exportación del esquema.</span><span class="sxs-lookup"><span data-stu-id="696d4-137">Additionally, the shape of a type can be exposed during schema export.</span></span> <span data-ttu-id="696d4-138">Asegúrese de entender la proyección de la serialización de su tipo.</span><span class="sxs-lookup"><span data-stu-id="696d4-138">Be sure to understand your type's serialization projection.</span></span> <span data-ttu-id="696d4-139">Si no desea nada expuesto, deshabilite la serialización (por ejemplo, no aplicando el atributo <xref:System.Runtime.Serialization.DataMemberAttribute> en el caso de un contrato de datos).</span><span class="sxs-lookup"><span data-stu-id="696d4-139">If you do not want anything exposed, disable serializing it (for example, by not applying the <xref:System.Runtime.Serialization.DataMemberAttribute> attribute in the case of a data contract).</span></span>

- <span data-ttu-id="696d4-140">Sea consciente de que el mismo tipo puede tener varias proyecciones de serialización, dependiendo del serializador en uso.</span><span class="sxs-lookup"><span data-stu-id="696d4-140">Be aware that the same type may have multiple serialization projections, depending on the serializer in use.</span></span> <span data-ttu-id="696d4-141">El mismo tipo puede exponer un conjunto de datos cuando se utiliza con <xref:System.Runtime.Serialization.DataContractSerializer> y otro conjunto de datos cuando se utiliza con <xref:System.Xml.Serialization.XmlSerializer>.</span><span class="sxs-lookup"><span data-stu-id="696d4-141">The same type may expose one set of data when used with the <xref:System.Runtime.Serialization.DataContractSerializer> and another set of data when used with the <xref:System.Xml.Serialization.XmlSerializer>.</span></span> <span data-ttu-id="696d4-142">La utilización accidental del serializador equivocado puede provocar la divulgación de información.</span><span class="sxs-lookup"><span data-stu-id="696d4-142">Accidentally using the wrong serializer may lead to information disclosure.</span></span>

- <span data-ttu-id="696d4-143">Al utilizar <xref:System.Xml.Serialization.XmlSerializer> en modo de llamada a procedimiento remoto (RPC)/codificado heredado, puede exponer involuntariamente la forma del gráfico de objeto en el lado emisor al lado receptor.</span><span class="sxs-lookup"><span data-stu-id="696d4-143">Using the <xref:System.Xml.Serialization.XmlSerializer> in legacy remote procedure call (RPC)/encoded mode may unintentionally expose the shape of the object graph on the sending side to the receiving side.</span></span>

## <a name="preventing-denial-of-service-attacks"></a><span data-ttu-id="696d4-144">Prevenir ataques de denegación de servicio</span><span class="sxs-lookup"><span data-stu-id="696d4-144">Preventing Denial-of-Service Attacks</span></span>

### <a name="quotas"></a><span data-ttu-id="696d4-145">Cuotas</span><span class="sxs-lookup"><span data-stu-id="696d4-145">Quotas</span></span>

<span data-ttu-id="696d4-146">Hacer que el lado receptor asigne una cantidad de memoria significativa es un ataque por denegación de servicio potencial.</span><span class="sxs-lookup"><span data-stu-id="696d4-146">Causing the receiving side to allocate a significant amount of memory is a potential denial-of-service attack.</span></span> <span data-ttu-id="696d4-147">Mientras esta sección se concentra en problemas de consumo de la memoria emite derivados de los mensajes grandes, se pueden producir otros ataques.</span><span class="sxs-lookup"><span data-stu-id="696d4-147">While this section concentrates on memory consumption issues arising from large messages, other attacks may occur.</span></span> <span data-ttu-id="696d4-148">Por ejemplo, los mensajes pueden utilizar una cantidad desproporcionada de tiempo de proceso.</span><span class="sxs-lookup"><span data-stu-id="696d4-148">For example, messages may use a disproportionate amount of processing time.</span></span>

<span data-ttu-id="696d4-149">Los ataques por denegación de servicio normalmente se mitigan utilizando las cuotas.</span><span class="sxs-lookup"><span data-stu-id="696d4-149">Denial-of-service attacks are usually mitigated using quotas.</span></span> <span data-ttu-id="696d4-150">Cuando se supera una cuota, normalmente se produce una excepción <xref:System.ServiceModel.QuotaExceededException> .</span><span class="sxs-lookup"><span data-stu-id="696d4-150">When a quota is exceeded, a <xref:System.ServiceModel.QuotaExceededException> exception is normally thrown.</span></span> <span data-ttu-id="696d4-151">Sin la cuota, un mensaje malintencionado puede provocar que se tenga acceso a toda la memoria disponible, provocando una excepción <xref:System.OutOfMemoryException> o que se tenga acceso a todas las pilas disponibles, lo que daría lugar a una <xref:System.StackOverflowException>.</span><span class="sxs-lookup"><span data-stu-id="696d4-151">Without the quota, a malicious message may cause all available memory to be accessed, resulting in an <xref:System.OutOfMemoryException> exception, or all available stacks to be accessed, resulting in a <xref:System.StackOverflowException>.</span></span>

<span data-ttu-id="696d4-152">El escenario de cuota superada es recuperable; si se encuentra en un servicio en ejecución, se descarta el mensaje que se está procesando actualmente y el servicio sigue ejecutándose y procesa otros mensajes.</span><span class="sxs-lookup"><span data-stu-id="696d4-152">The quota exceeded scenario is recoverable; if encountered in a running service, the message currently being processed is discarded and the service keeps running and processes further messages.</span></span> <span data-ttu-id="696d4-153">Sin embargo, los escenarios de memoria insuficiente y de desbordamiento de pila no se pueden recuperar en ningún lugar del .NET Framework; el servicio finaliza si encuentra tales excepciones.</span><span class="sxs-lookup"><span data-stu-id="696d4-153">The out-of-memory and stack overflow scenarios, however, are not recoverable anywhere in the .NET Framework; the service terminates if it encounters such exceptions.</span></span>

<span data-ttu-id="696d4-154">Las cuotas en WCF no implican ninguna asignación previa.</span><span class="sxs-lookup"><span data-stu-id="696d4-154">Quotas in WCF do not involve any pre-allocation.</span></span> <span data-ttu-id="696d4-155">Por ejemplo, si la cuota <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> (presente en varias clases) está establecida en 128 KB, no significa que 128 KB se asigne automáticamente a cada mensaje.</span><span class="sxs-lookup"><span data-stu-id="696d4-155">For example, if the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> quota (found on various classes) is set to 128 KB, it does not mean that 128 KB is automatically allocated for each message.</span></span> <span data-ttu-id="696d4-156">La cantidad real asignada depende del tamaño del mensaje entrante real.</span><span class="sxs-lookup"><span data-stu-id="696d4-156">The actual amount allocated depends on the actual incoming message size.</span></span>

<span data-ttu-id="696d4-157">Muchas cuotas están disponibles en el nivel de transporte.</span><span class="sxs-lookup"><span data-stu-id="696d4-157">Many quotas are available at the transport layer.</span></span> <span data-ttu-id="696d4-158">Son cuotas exigidas por el canal de transporte concreto en uso (HTTP, TCP, etc.).</span><span class="sxs-lookup"><span data-stu-id="696d4-158">These are quotas enforced by the specific transport channel in use (HTTP, TCP, and so on).</span></span> <span data-ttu-id="696d4-159">Aunque en este tema se abordan algunas de estas cuotas, estas se describen en detalle en [Transport Quotas](transport-quotas.md).</span><span class="sxs-lookup"><span data-stu-id="696d4-159">While this topic discusses some of these quotas, these quotas are described in detail in [Transport Quotas](transport-quotas.md).</span></span>

### <a name="hashtable-vulnerability"></a><span data-ttu-id="696d4-160">Vulnerabilidad del objeto hashtable</span><span class="sxs-lookup"><span data-stu-id="696d4-160">Hashtable Vulnerability</span></span>

<span data-ttu-id="696d4-161">Existe vulnerabilidad cuando los contratos de datos contienen tablas de objeto hashtable o colecciones.</span><span class="sxs-lookup"><span data-stu-id="696d4-161">A vulnerability exists when data contracts contain hashtables or collections.</span></span> <span data-ttu-id="696d4-162">El problema aparece si un gran número de valores se insertan en un objeto hashtable donde muchos de los valores producen el mismo valor hash.</span><span class="sxs-lookup"><span data-stu-id="696d4-162">The problem occurs if a large number of values are inserted into a hashtable where a large number of those values generate the same hash value.</span></span> <span data-ttu-id="696d4-163">Se puede usar como un ataque de DOS.</span><span class="sxs-lookup"><span data-stu-id="696d4-163">This can be used as a DOS attack.</span></span>  <span data-ttu-id="696d4-164">Esta vulnerabilidad se puede mitigar estableciendo la cuota de enlace MaxReceivedMessageSize.</span><span class="sxs-lookup"><span data-stu-id="696d4-164">This vulnerability can be mitigated by setting the MaxReceivedMessageSize binding quota.</span></span> <span data-ttu-id="696d4-165">Hay que tener cuidado al establecer esta quota para evitar estos ataques.</span><span class="sxs-lookup"><span data-stu-id="696d4-165">Care must be taken while setting this quota in order to prevent such attacks.</span></span> <span data-ttu-id="696d4-166">Esta cuota coloca un límite en el tamaño del mensaje de WCF.</span><span class="sxs-lookup"><span data-stu-id="696d4-166">This quota puts an upper limit on the size of WCF message.</span></span> <span data-ttu-id="696d4-167">Además, evite usar tablas de objeto hashtable o colecciones en los contratos de datos.</span><span class="sxs-lookup"><span data-stu-id="696d4-167">Additionally, avoid using hashtables or collections in your data contracts.</span></span>

## <a name="limiting-memory-consumption-without-streaming"></a><span data-ttu-id="696d4-168">Limitar el consumo de la memoria sin transmisión por secuencias</span><span class="sxs-lookup"><span data-stu-id="696d4-168">Limiting Memory Consumption Without Streaming</span></span>

<span data-ttu-id="696d4-169">El modelo de seguridad alrededor de los mensajes grandes depende de si se utiliza la transmisión por secuencias.</span><span class="sxs-lookup"><span data-stu-id="696d4-169">The security model around large messages depends on whether streaming is in use.</span></span> <span data-ttu-id="696d4-170">En el caso básico, sin transmisión por secuencias, los mensajes están almacenados en el búfer de la memoria.</span><span class="sxs-lookup"><span data-stu-id="696d4-170">In the basic, non-streamed case, messages are buffered into memory.</span></span> <span data-ttu-id="696d4-171">En este caso, utilice la cuota <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> de <xref:System.ServiceModel.Channels.TransportBindingElement> o en los enlaces proporcionados por el sistema, para protegerse frente a mensajes grandes limitando el tamaño máximo del mensaje al que se obtiene acceso.</span><span class="sxs-lookup"><span data-stu-id="696d4-171">In this case, use the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> quota on the <xref:System.ServiceModel.Channels.TransportBindingElement> or on the system-provided bindings to protect against large messages by limiting the maximum message size to access.</span></span> <span data-ttu-id="696d4-172">Tenga en cuenta que un servicio puede procesar varios mensajes al mismo tiempo, en cuyo caso todos estarán en memoria.</span><span class="sxs-lookup"><span data-stu-id="696d4-172">Note that a service may be processing multiple messages at the same time, in which case they are all in memory.</span></span> <span data-ttu-id="696d4-173">Utilice la característica de limitación de peticiones para mitigar esta amenaza.</span><span class="sxs-lookup"><span data-stu-id="696d4-173">Use the throttling feature to mitigate this threat.</span></span>

<span data-ttu-id="696d4-174">También observe que `MaxReceivedMessageSize` no coloca un límite superior en consumo de la memoria por mensaje, pero lo limita dentro de un factor constante.</span><span class="sxs-lookup"><span data-stu-id="696d4-174">Also note that `MaxReceivedMessageSize` does not place an upper bound on per-message memory consumption, but limits it to within a constant factor.</span></span> <span data-ttu-id="696d4-175">Por ejemplo, si el `MaxReceivedMessageSize` es de 1 MB, se recibe un mensaje de 1 MB y, a continuación, se deserializa, se necesitará memoria adicional para contener el gráfico de objeto deserializado, lo que provocará un consumo total de la memoria de más de 1 MB.</span><span class="sxs-lookup"><span data-stu-id="696d4-175">For example, if the `MaxReceivedMessageSize` is 1 MB and a 1-MB message is received and then deserialized, additional memory is required to contain the deserialized object graph, resulting in total memory consumption well over 1 MB.</span></span> <span data-ttu-id="696d4-176">Por esta razón, evite crear tipos serializable que podrían provocar un consumo significativo de la memoria sin muchos datos entrantes.</span><span class="sxs-lookup"><span data-stu-id="696d4-176">For this reason, avoid creating serializable types that could result in significant memory consumption without much incoming data.</span></span> <span data-ttu-id="696d4-177">Por ejemplo, se podría crear una instancia de un contrato de datos "DataContract" con los campos de miembro de datos opcionales 50 y otros 100 campos privados adicionales con la construcción de XML " \<MyContract/> ".</span><span class="sxs-lookup"><span data-stu-id="696d4-177">For example, a data contract "MyContract" with 50 optional data member fields and an additional 100 private fields could be instantiated with the XML construction "\<MyContract/>".</span></span> <span data-ttu-id="696d4-178">Este XML provocará que se obtenga acceso a la memoria para 150 campos.</span><span class="sxs-lookup"><span data-stu-id="696d4-178">This XML results in memory being accessed for 150 fields.</span></span> <span data-ttu-id="696d4-179">Observe que los miembros de datos son de forma predeterminada opcionales.</span><span class="sxs-lookup"><span data-stu-id="696d4-179">Note that data members are optional by default.</span></span> <span data-ttu-id="696d4-180">El problema se produce cuando un tipo de estas características forma parte de una matriz.</span><span class="sxs-lookup"><span data-stu-id="696d4-180">The problem is compounded when such a type is part of an array.</span></span>

<span data-ttu-id="696d4-181">`MaxReceivedMessageSize` solo no es bastante para evitar todos los ataques por denegación de servicio.</span><span class="sxs-lookup"><span data-stu-id="696d4-181">`MaxReceivedMessageSize` alone is not enough to prevent all denial-of-service attacks.</span></span> <span data-ttu-id="696d4-182">Por ejemplo, un mensaje entrante puede obligar al deserializador a deserializar un gráfico de objetos anidado de manera profunda (un objeto que contiene otro objeto que también contiene otro, etc.).</span><span class="sxs-lookup"><span data-stu-id="696d4-182">For example, the deserializer may be forced to deserialize a deeply-nested object graph (an object that contains another object that contains yet another one, and so on) by an incoming message.</span></span> <span data-ttu-id="696d4-183"><xref:System.Runtime.Serialization.DataContractSerializer> y <xref:System.Xml.Serialization.XmlSerializer> llaman a los métodos de una manera anidada para deserializar tales gráficos.</span><span class="sxs-lookup"><span data-stu-id="696d4-183">Both the <xref:System.Runtime.Serialization.DataContractSerializer> and the <xref:System.Xml.Serialization.XmlSerializer> call methods in a nested way to deserialize such graphs.</span></span> <span data-ttu-id="696d4-184">El anidamiento profundo de llamadas al método puede producir un <xref:System.StackOverflowException>irrecuperable.</span><span class="sxs-lookup"><span data-stu-id="696d4-184">Deep nesting of method calls may result in an unrecoverable <xref:System.StackOverflowException>.</span></span> <span data-ttu-id="696d4-185">Esta amenaza se mitiga estableciendo la cuota <xref:System.ServiceModel.Configuration.XmlDictionaryReaderQuotasElement.MaxDepth%2A> para limitar el nivel de anidamiento de XML, como se aborda en la sección "Utilizar XML con seguridad" más adelante en este tema.</span><span class="sxs-lookup"><span data-stu-id="696d4-185">This threat is mitigated by setting the <xref:System.ServiceModel.Configuration.XmlDictionaryReaderQuotasElement.MaxDepth%2A> quota to limit the level of XML nesting, as discussed in the "Using XML Safely" section later in the topic.</span></span>

<span data-ttu-id="696d4-186">Establecer las cuotas adicionales en `MaxReceivedMessageSize` es especialmente importante al utilizar codificación XML binaria.</span><span class="sxs-lookup"><span data-stu-id="696d4-186">Setting additional quotas to `MaxReceivedMessageSize` is especially important when using binary XML encoding.</span></span> <span data-ttu-id="696d4-187">Utilizar la codificación binaria equivalente de algún modo a la compresión: un grupo pequeño de bytes en el mensaje entrante puede representar muchos datos.</span><span class="sxs-lookup"><span data-stu-id="696d4-187">Using binary encoding is somewhat equivalent to compression: a small group of bytes in the incoming message may represent a lot of data.</span></span> <span data-ttu-id="696d4-188">Por lo tanto, incluso un mensaje que se ajuste al límite `MaxReceivedMessageSize` puede ocupar mucha más memoria en su forma totalmente expandida.</span><span class="sxs-lookup"><span data-stu-id="696d4-188">Thus, even a message fitting into the `MaxReceivedMessageSize` limit may take up much more memory in fully expanded form.</span></span> <span data-ttu-id="696d4-189">Para mitigar tales amenazas específicas del XML, todas las cuotas del lector XML se deben establecer correctamente, como se aborda en la sección en la "Utilizar XML con seguridad" más adelante en este tema.</span><span class="sxs-lookup"><span data-stu-id="696d4-189">To mitigate such XML-specific threats, all of the XML reader quotas must be set correctly, as discussed in the "Using XML Safely" section later in this topic.</span></span>

## <a name="limiting-memory-consumption-with-streaming"></a><span data-ttu-id="696d4-190">Limitar el consumo de la memoria con transmisión por secuencias</span><span class="sxs-lookup"><span data-stu-id="696d4-190">Limiting Memory Consumption with Streaming</span></span>

<span data-ttu-id="696d4-191">Al tener transmisión por secuencias, puede utilizar un valor `MaxReceivedMessageSize` pequeño para protegerse contra los ataques por denegación de servicio.</span><span class="sxs-lookup"><span data-stu-id="696d4-191">When streaming, you may use a small `MaxReceivedMessageSize` setting to protect against denial-of-service attacks.</span></span> <span data-ttu-id="696d4-192">Sin embargo, con la transmisión por secuencias se pueden dar más escenarios complicados.</span><span class="sxs-lookup"><span data-stu-id="696d4-192">However, more complicated scenarios are possible with streaming.</span></span> <span data-ttu-id="696d4-193">Por ejemplo, un servicio de carga de archivo acepta archivos mayores que la memoria total disponible.</span><span class="sxs-lookup"><span data-stu-id="696d4-193">For example, a file upload service accepts files larger than all available memory.</span></span> <span data-ttu-id="696d4-194">En este caso, establezca el `MaxReceivedMessageSize` con un valor sumamente grande, esperando que casi ningún dato se almacene en búfer en memoria y que el mensaje se transmita por secuencias directamente al disco.</span><span class="sxs-lookup"><span data-stu-id="696d4-194">In this case, set the `MaxReceivedMessageSize` to an extremely large value, expecting that almost no data is buffered in memory and the message streams directly to disk.</span></span> <span data-ttu-id="696d4-195">Si un mensaje malintencionado puede forzar de algún modo a WCF a almacenar en búfer los datos en lugar de transmitirlos en este caso, `MaxReceivedMessageSize` ya no protege contra el mensaje que tiene acceso a toda la memoria disponible.</span><span class="sxs-lookup"><span data-stu-id="696d4-195">If a malicious message can somehow force WCF to buffer data instead of streaming it in this case, `MaxReceivedMessageSize` no longer protects against the message accessing all available memory.</span></span>

<span data-ttu-id="696d4-196">Para mitigar esta amenaza, existen valores de cuota específicos en varios componentes de procesamiento de datos de WCF que limitan el almacenamiento en búfer.</span><span class="sxs-lookup"><span data-stu-id="696d4-196">To mitigate this threat, specific quota settings exist on various WCF data-processing components that limit buffering.</span></span> <span data-ttu-id="696d4-197">El más importante es la propiedad `MaxBufferSize` en varios elementos de enlace del transporte y enlaces estándares.</span><span class="sxs-lookup"><span data-stu-id="696d4-197">The most important of these is the `MaxBufferSize` property on various transport binding elements and standard bindings.</span></span> <span data-ttu-id="696d4-198">Al transmitir por secuencias, esta cuota se debería establecer teniendo cuenta la cantidad de memoria máxima que quiere asignar por mensaje.</span><span class="sxs-lookup"><span data-stu-id="696d4-198">When streaming, this quota should be set taking into account the maximum amount of memory you are willing to allocate per message.</span></span> <span data-ttu-id="696d4-199">Como con `MaxReceivedMessageSize`, el valor no coloca un máximo absoluto en consumo de la memoria sino que solo lo limita dentro de un factor constante.</span><span class="sxs-lookup"><span data-stu-id="696d4-199">As with `MaxReceivedMessageSize`, the setting does not put an absolute maximum on memory consumption but only limits it to within a constant factor.</span></span> <span data-ttu-id="696d4-200">También, como con `MaxReceivedMessageSize`, sea consciente de la posibilidad de varios mensajes que se procesen simultáneamente.</span><span class="sxs-lookup"><span data-stu-id="696d4-200">Also, as with `MaxReceivedMessageSize`, be aware of the possibility of multiple messages being processed simultaneously.</span></span>

### <a name="maxbuffersize-details"></a><span data-ttu-id="696d4-201">Detalles de MaxBufferSize</span><span class="sxs-lookup"><span data-stu-id="696d4-201">MaxBufferSize Details</span></span>

<span data-ttu-id="696d4-202">La `MaxBufferSize` propiedad limita cualquier WCF de almacenamiento en búfer masivo.</span><span class="sxs-lookup"><span data-stu-id="696d4-202">The `MaxBufferSize` property limits any bulk buffering WCF does.</span></span> <span data-ttu-id="696d4-203">Por ejemplo, WCF siempre almacena en búfer encabezados SOAP y errores de SOAP, así como las partes MIME que no se encuentran en el orden de lectura natural en un mensaje del mecanismo de optimización de transmisión de mensajes (MTOM).</span><span class="sxs-lookup"><span data-stu-id="696d4-203">For example, WCF always buffers SOAP headers and SOAP faults, as well as any MIME parts found to be not in the natural reading order in an Message Transmission Optimization Mechanism (MTOM) message.</span></span> <span data-ttu-id="696d4-204">Este valor limita la cantidad de almacenamiento en búfer en todos estos casos.</span><span class="sxs-lookup"><span data-stu-id="696d4-204">This setting limits the amount of buffering in all these cases.</span></span>

<span data-ttu-id="696d4-205">WCF consigue esto pasando el `MaxBufferSize` valor a los distintos componentes que pueden almacenar en búfer.</span><span class="sxs-lookup"><span data-stu-id="696d4-205">WCF accomplishes this by passing the `MaxBufferSize` value to the various components that may buffer.</span></span> <span data-ttu-id="696d4-206">Por ejemplo, algunas sobrecargas de <xref:System.ServiceModel.Channels.Message.CreateMessage%2A> de la clase <xref:System.ServiceModel.Channels.Message> toman un parámetro `maxSizeOfHeaders` .</span><span class="sxs-lookup"><span data-stu-id="696d4-206">For example, some <xref:System.ServiceModel.Channels.Message.CreateMessage%2A> overloads of the <xref:System.ServiceModel.Channels.Message> class take a `maxSizeOfHeaders` parameter.</span></span> <span data-ttu-id="696d4-207">WCF pasa el `MaxBufferSize` valor a este parámetro para limitar la cantidad de almacenamiento en búfer del encabezado SOAP.</span><span class="sxs-lookup"><span data-stu-id="696d4-207">WCF passes the `MaxBufferSize` value to this parameter to limit the amount of SOAP header buffering.</span></span> <span data-ttu-id="696d4-208">Es importante establecer este parámetro al utilizar directamente la clase <xref:System.ServiceModel.Channels.Message> .</span><span class="sxs-lookup"><span data-stu-id="696d4-208">It is important to set this parameter when using the <xref:System.ServiceModel.Channels.Message> class directly.</span></span> <span data-ttu-id="696d4-209">En general, al utilizar un componente en WCF que toma parámetros de cuota, es importante comprender las implicaciones de seguridad de estos parámetros y establecerlos correctamente.</span><span class="sxs-lookup"><span data-stu-id="696d4-209">In general, when using a component in WCF that takes quota parameters, it is important to understand the security implications of these parameters and set them correctly.</span></span>

<span data-ttu-id="696d4-210">El codificador del mensaje de MTOM también tiene un valor `MaxBufferSize` .</span><span class="sxs-lookup"><span data-stu-id="696d4-210">The MTOM message encoder also has a `MaxBufferSize` setting.</span></span> <span data-ttu-id="696d4-211">Al utilizar enlaces estándares, esto se establece automáticamente en el valor del nivel de transporte `MaxBufferSize` .</span><span class="sxs-lookup"><span data-stu-id="696d4-211">When using standard bindings, this is set automatically to the transport-level `MaxBufferSize` value.</span></span> <span data-ttu-id="696d4-212">Sin embargo, al utilizar el elemento de enlace de codificador del mensaje de MTOM para construir un enlace personalizado, es importante establecer la propiedad `MaxBufferSize` en un valor seguro cuando se utiliza la transmisión por secuencias.</span><span class="sxs-lookup"><span data-stu-id="696d4-212">However, when using the MTOM message encoder binding element to construct a custom binding, it is important to set the `MaxBufferSize` property to a safe value when streaming is used.</span></span>

## <a name="xml-based-streaming-attacks"></a><span data-ttu-id="696d4-213">Ataques de la transmisión por secuencias basados en XML</span><span class="sxs-lookup"><span data-stu-id="696d4-213">XML-Based Streaming Attacks</span></span>

<span data-ttu-id="696d4-214">`MaxBufferSize` por sí solo no es suficiente para asegurarse de que no se puede forzar a WCF en el almacenamiento en búfer cuando se espera la transmisión por secuencias.</span><span class="sxs-lookup"><span data-stu-id="696d4-214">`MaxBufferSize` alone is not enough to ensure that WCF cannot be forced into buffering when streaming is expected.</span></span> <span data-ttu-id="696d4-215">Por ejemplo, los lectores XML de WCF siempre almacenan en búfer la etiqueta inicial del elemento XML completa al empezar a leer un nuevo elemento.</span><span class="sxs-lookup"><span data-stu-id="696d4-215">For example, the WCF XML readers always buffer the entire XML element start tag when starting to read a new element.</span></span> <span data-ttu-id="696d4-216">Se hace esto para que se procesen los espacios de nombres y atributos correctamente.</span><span class="sxs-lookup"><span data-stu-id="696d4-216">This is done so that namespaces and attributes are properly processed.</span></span> <span data-ttu-id="696d4-217">Si `MaxReceivedMessageSize` se configura para ser grande (por ejemplo, para habilitar un escenario de transmisión por secuencias de archivo grande directo a disco), se puede construir un mensaje malintencionado donde el cuerpo entero del mensaje sea una etiqueta inicial de elemento XML grande.</span><span class="sxs-lookup"><span data-stu-id="696d4-217">If `MaxReceivedMessageSize` is configured to be large (for example, to enable a direct-to-disk large file streaming scenario), a malicious message may be constructed where the entire message body is a large XML element start tag.</span></span> <span data-ttu-id="696d4-218">Un intento para leerlo provocará <xref:System.OutOfMemoryException>.</span><span class="sxs-lookup"><span data-stu-id="696d4-218">An attempt to read it results in an <xref:System.OutOfMemoryException>.</span></span> <span data-ttu-id="696d4-219">Se trata de uno de los muchos posibles ataques de denegación de servicio basados en XML que se pueden mitigar mediante cuotas de lector XML, que se describen en la sección "usar XML con seguridad" más adelante en este tema.</span><span class="sxs-lookup"><span data-stu-id="696d4-219">This is one of many possible XML-based denial-of-service attacks that can all be mitigated using XML reader quotas, discussed in the "Using XML Safely" section later in this topic.</span></span> <span data-ttu-id="696d4-220">En la transmisión por secuencias, es especialmente importante establecer todas estas cuotas.</span><span class="sxs-lookup"><span data-stu-id="696d4-220">When streaming, it is especially important to set all of these quotas.</span></span>

### <a name="mixing-streaming-and-buffering-programming-models"></a><span data-ttu-id="696d4-221">Mezclar los modelos de programación de transmisión por secuencias y almacenamiento en búfer</span><span class="sxs-lookup"><span data-stu-id="696d4-221">Mixing Streaming and Buffering Programming Models</span></span>

<span data-ttu-id="696d4-222">Muchos posibles ataques surgen de mezclar los modelos de programación de transmisión por secuencias y sin secuencias en el mismo servicio.</span><span class="sxs-lookup"><span data-stu-id="696d4-222">Many possible attacks arise from mixing streaming and non-streaming programming models in the same service.</span></span> <span data-ttu-id="696d4-223">Suponga que hay un contrato de servicios con dos operaciones: uno toma <xref:System.IO.Stream> y otro toma una matriz de algún tipo personalizado.</span><span class="sxs-lookup"><span data-stu-id="696d4-223">Suppose there is a service contract with two operations: one takes a <xref:System.IO.Stream> and another takes an array of some custom type.</span></span> <span data-ttu-id="696d4-224">También suponga que `MaxReceivedMessageSize` está establecido en un valor grande para habilitar la primera operación para procesar las secuencias grandes.</span><span class="sxs-lookup"><span data-stu-id="696d4-224">Suppose also that `MaxReceivedMessageSize` is set to a large value to enable the first operation to process large streams.</span></span> <span data-ttu-id="696d4-225">Desgraciadamente, esto significa que los mensajes grandes se pueden enviar también a la segunda operación, y el deserializador almacena en búfer los datos en memoria como una matriz antes de que se llame a la operación.</span><span class="sxs-lookup"><span data-stu-id="696d4-225">Unfortunately, this means that large messages can now be sent to the second operation as well, and the deserializer buffers data in memory as an array before the operation is called.</span></span> <span data-ttu-id="696d4-226">Éste es un ataque por denegación de servicio potencial: la cuota `MaxBufferSize` no limita el tamaño del cuerpo del mensaje, que es con lo que trabaja el deserializador.</span><span class="sxs-lookup"><span data-stu-id="696d4-226">This is a potential denial-of-service attack: the `MaxBufferSize` quota does not limit the size of the message body, which is what the deserializer works with.</span></span>

<span data-ttu-id="696d4-227">Por esta razón, evite mezclar operaciones basadas en secuencias y operaciones sin secuencias en el mismo contrato.</span><span class="sxs-lookup"><span data-stu-id="696d4-227">For this reason, avoid mixing stream-based and non-streamed operations in the same contract.</span></span> <span data-ttu-id="696d4-228">Si debe mezclar necesariamente los dos modelos de programación, utilice las precauciones siguientes:</span><span class="sxs-lookup"><span data-stu-id="696d4-228">If you absolutely must mix the two programming models, use the following precautions:</span></span>

- <span data-ttu-id="696d4-229">Desactive la característica <xref:System.Runtime.Serialization.IExtensibleDataObject> estableciendo la propiedad <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> de <xref:System.ServiceModel.ServiceBehaviorAttribute> en `true`.</span><span class="sxs-lookup"><span data-stu-id="696d4-229">Turn off the <xref:System.Runtime.Serialization.IExtensibleDataObject> feature by setting the <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> property of the <xref:System.ServiceModel.ServiceBehaviorAttribute> to `true`.</span></span> <span data-ttu-id="696d4-230">Esto garantiza que solo se deserializan los miembros que forman una parte del contrato.</span><span class="sxs-lookup"><span data-stu-id="696d4-230">This ensures that only members that are a part of the contract are deserialized.</span></span>

- <span data-ttu-id="696d4-231">Establezca la propiedad <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> de <xref:System.Runtime.Serialization.DataContractSerializer> en un valor seguro.</span><span class="sxs-lookup"><span data-stu-id="696d4-231">Set the <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> property of the <xref:System.Runtime.Serialization.DataContractSerializer> to a safe value.</span></span> <span data-ttu-id="696d4-232">Esta cuota también está disponible en el atributo <xref:System.ServiceModel.ServiceBehaviorAttribute> o a través de la configuración.</span><span class="sxs-lookup"><span data-stu-id="696d4-232">This quota is also available on the <xref:System.ServiceModel.ServiceBehaviorAttribute> attribute or through configuration.</span></span> <span data-ttu-id="696d4-233">Esta cuota limita el número de objetos que se deserializan en un episodio de deserialización.</span><span class="sxs-lookup"><span data-stu-id="696d4-233">This quota limits the number of objects that are deserialized in one deserialization episode.</span></span> <span data-ttu-id="696d4-234">Normalmente, cada parámetro de operación o parte del cuerpo del mensaje en un contrato del mensaje se deserializa en un episodio.</span><span class="sxs-lookup"><span data-stu-id="696d4-234">Normally, each operation parameter or message body part in a message contract is deserialized in one episode.</span></span> <span data-ttu-id="696d4-235">Al deserializar matrices, cada entrada de matriz se cuenta como un objeto independiente.</span><span class="sxs-lookup"><span data-stu-id="696d4-235">When deserializing arrays, each array entry is counted as a separate object.</span></span>

- <span data-ttu-id="696d4-236">Establezca todas las cuotas del lector XML en valores seguros.</span><span class="sxs-lookup"><span data-stu-id="696d4-236">Set all of the XML reader quotas to safe values.</span></span> <span data-ttu-id="696d4-237">Preste atención a <xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A>, <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>y <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A> , y evite las cadenas en operaciones de transmisión sin secuencias.</span><span class="sxs-lookup"><span data-stu-id="696d4-237">Pay attention to <xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A>, <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>, and <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A> and avoid strings in non-streaming operations.</span></span>

- <span data-ttu-id="696d4-238">Revise la lista de tipos conocidos, teniendo presente que se puede crear una instancia de ellos en cualquier momento (vea la sección “Evitar que se carguen tipos imprevistos” más adelante en este tema).</span><span class="sxs-lookup"><span data-stu-id="696d4-238">Review the list of known types, keeping in mind that any one of them can be instantiated at any time (see the "Preventing Unintended Types from Being Loaded" section later in this topic).</span></span>

- <span data-ttu-id="696d4-239">No utilice tipos que implementen la interfaz <xref:System.Xml.Serialization.IXmlSerializable> que almacena en búfer muchos datos.</span><span class="sxs-lookup"><span data-stu-id="696d4-239">Do not use any types that implement the <xref:System.Xml.Serialization.IXmlSerializable> interface that buffer a lot of data.</span></span> <span data-ttu-id="696d4-240">No agregue tales tipos a la lista de tipos conocidos.</span><span class="sxs-lookup"><span data-stu-id="696d4-240">Do not add such types to the list of known types.</span></span>

- <span data-ttu-id="696d4-241">No utilice las matrices <xref:System.Xml.XmlElement>, <xref:System.Xml.XmlNode> , matrices <xref:System.Byte> o tipos que implementen <xref:System.Runtime.Serialization.ISerializable> en un contrato.</span><span class="sxs-lookup"><span data-stu-id="696d4-241">Do not use the <xref:System.Xml.XmlElement>, <xref:System.Xml.XmlNode> arrays, <xref:System.Byte> arrays, or types that implement <xref:System.Runtime.Serialization.ISerializable> in a contract.</span></span>

- <span data-ttu-id="696d4-242">No utilice las matrices <xref:System.Xml.XmlElement>, <xref:System.Xml.XmlNode> , matrices <xref:System.Byte> o tipos que implementen <xref:System.Runtime.Serialization.ISerializable> en la lista de tipos conocidos.</span><span class="sxs-lookup"><span data-stu-id="696d4-242">Do not use the <xref:System.Xml.XmlElement>, <xref:System.Xml.XmlNode> arrays, <xref:System.Byte> arrays, or types that implement <xref:System.Runtime.Serialization.ISerializable> in the list of known types.</span></span>

<span data-ttu-id="696d4-243">Las precauciones anteriores se aplican cuando la operación sin transmisión por secuencias utiliza <xref:System.Runtime.Serialization.DataContractSerializer>.</span><span class="sxs-lookup"><span data-stu-id="696d4-243">The preceding precautions apply when the non-streamed operation uses the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="696d4-244">Nunca mezcle los modelos de programación de transmisión por secuencias y sin secuencias en el mismo servicio si está utilizando el <xref:System.Xml.Serialization.XmlSerializer>, porque no tiene la protección de la cuota <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.MaxItemsInObjectGraph%2A> .</span><span class="sxs-lookup"><span data-stu-id="696d4-244">Never mix streaming and non-streaming programming models on the same service if you are using the <xref:System.Xml.Serialization.XmlSerializer>, because it does not have the protection of the <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.MaxItemsInObjectGraph%2A> quota.</span></span>

### <a name="slow-stream-attacks"></a><span data-ttu-id="696d4-245">Ataques de secuencia lentos</span><span class="sxs-lookup"><span data-stu-id="696d4-245">Slow Stream Attacks</span></span>

<span data-ttu-id="696d4-246">Una clase de ataques por denegación de servicio de transmisión por secuencias no implica el consumo de la memoria.</span><span class="sxs-lookup"><span data-stu-id="696d4-246">A class of streaming denial-of-service attacks does not involve memory consumption.</span></span> <span data-ttu-id="696d4-247">En su lugar, el ataque implica un envío o una recepción lenta de los datos.</span><span class="sxs-lookup"><span data-stu-id="696d4-247">Instead, the attack involves a slow sender or receiver of data.</span></span> <span data-ttu-id="696d4-248">Mientras se espera a que los datos se envíen o reciban, se agotan los recursos como subprocesos y las conexiones disponibles.</span><span class="sxs-lookup"><span data-stu-id="696d4-248">While waiting for the data to be sent or received, resources such as threads and available connections are exhausted.</span></span> <span data-ttu-id="696d4-249">Esta situación se podría presentar como resultado de un ataque malintencionado o de un remitente/receptor legítimo en una conexión de red lenta.</span><span class="sxs-lookup"><span data-stu-id="696d4-249">This situation could arise either as a result of a malicious attack or from a legitimate sender/receiver on a slow network connection.</span></span>

<span data-ttu-id="696d4-250">Para mitigar estos ataques, establezca correctamente los tiempos de espera de transporte.</span><span class="sxs-lookup"><span data-stu-id="696d4-250">To mitigate these attacks, set the transport time-outs correctly.</span></span> <span data-ttu-id="696d4-251">Para obtener más información, consulte [cuotas de transporte](transport-quotas.md).</span><span class="sxs-lookup"><span data-stu-id="696d4-251">For more information, see [Transport Quotas](transport-quotas.md).</span></span> <span data-ttu-id="696d4-252">En segundo lugar, nunca utilice operaciones sincrónicas `Read` u `Write` operaciones al trabajar con secuencias en WCF.</span><span class="sxs-lookup"><span data-stu-id="696d4-252">Secondly, never use synchronous `Read` or `Write` operations when working with streams in WCF.</span></span>

## <a name="using-xml-safely"></a><span data-ttu-id="696d4-253">Utilizar XML con seguridad</span><span class="sxs-lookup"><span data-stu-id="696d4-253">Using XML Safely</span></span>

> [!NOTE]
> <span data-ttu-id="696d4-254">Aunque esta sección trata acerca de XML, la información también se aplica a documentos de la notación de objetos JavaScript (JSON).</span><span class="sxs-lookup"><span data-stu-id="696d4-254">Although this section is about XML, the information also applies to JavaScript Object Notation (JSON) documents.</span></span> <span data-ttu-id="696d4-255">Las cuotas funcionan de manera similar, con [Mapping Between JSON and XML](mapping-between-json-and-xml.md).</span><span class="sxs-lookup"><span data-stu-id="696d4-255">The quotas work similarly, using [Mapping Between JSON and XML](mapping-between-json-and-xml.md).</span></span>

### <a name="secure-xml-readers"></a><span data-ttu-id="696d4-256">Lectores XML seguros</span><span class="sxs-lookup"><span data-stu-id="696d4-256">Secure XML Readers</span></span>

<span data-ttu-id="696d4-257">El conjunto de código XML constituye la base de todo el procesamiento de mensajes en WCF.</span><span class="sxs-lookup"><span data-stu-id="696d4-257">The XML Infoset forms the basis of all message processing in WCF.</span></span> <span data-ttu-id="696d4-258">Al aceptar los datos XML de un origen que no es de confianza, existen varias posibilidades de ataque por denegación de servicio que se deben mitigar.</span><span class="sxs-lookup"><span data-stu-id="696d4-258">When accepting XML data from an untrusted source, a number of denial-of-service attack possibilities exist that must be mitigated.</span></span> <span data-ttu-id="696d4-259">WCF proporciona lectores XML especiales y seguros.</span><span class="sxs-lookup"><span data-stu-id="696d4-259">WCF provides special, secure XML readers.</span></span> <span data-ttu-id="696d4-260">Estos lectores se crean automáticamente al utilizar una de las codificaciones estándar en WCF (texto, binario o MTOM).</span><span class="sxs-lookup"><span data-stu-id="696d4-260">These readers are created automatically when using one of the standard encodings in WCF (text, binary, or MTOM).</span></span>

<span data-ttu-id="696d4-261">Algunas de las características de seguridad en estos lectores siempre están activas.</span><span class="sxs-lookup"><span data-stu-id="696d4-261">Some of the security features on these readers are always active.</span></span> <span data-ttu-id="696d4-262">Por ejemplo, los lectores nunca procesan definiciones de tipo de documento (DTD), que son un origen potencial de ataques por denegación de servicio y nunca deberían aparecer en mensajes SOAP legítimos.</span><span class="sxs-lookup"><span data-stu-id="696d4-262">For example, the readers never process document type definitions (DTDs), which are a potential source of denial-of-service attacks and should never appear in legitimate SOAP messages.</span></span> <span data-ttu-id="696d4-263">Otras características de seguridad incluyen cuotas del lector que se deben configurar, que se describen en la sección siguiente.</span><span class="sxs-lookup"><span data-stu-id="696d4-263">Other security features include reader quotas that must be configured, which are described in the following section.</span></span>

<span data-ttu-id="696d4-264">Al trabajar directamente con lectores XML (como al escribir su propio Codificador personalizado o al trabajar directamente con la <xref:System.ServiceModel.Channels.Message> clase), utilice siempre los lectores seguros de WCF cuando exista la posibilidad de trabajar con datos que no son de confianza.</span><span class="sxs-lookup"><span data-stu-id="696d4-264">When working directly with XML readers (such as when writing your own custom encoder or when working directly with the <xref:System.ServiceModel.Channels.Message> class), always use the WCF secure readers when there is a chance of working with untrusted data.</span></span> <span data-ttu-id="696d4-265">Cree los lectores seguros llamando a una de las sobrecargas estáticas del método del generador de <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A>, <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A>o <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> en la clase <xref:System.Xml.XmlDictionaryReader> .</span><span class="sxs-lookup"><span data-stu-id="696d4-265">Create the secure readers by calling one of the static factory method overloads of <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A>, <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A>, or <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> on the <xref:System.Xml.XmlDictionaryReader> class.</span></span> <span data-ttu-id="696d4-266">Al crear un lector, pase valores de cuota seguros.</span><span class="sxs-lookup"><span data-stu-id="696d4-266">When creating a reader, pass in secure quota values.</span></span> <span data-ttu-id="696d4-267">No llame a las sobrecargas de método `Create` .</span><span class="sxs-lookup"><span data-stu-id="696d4-267">Do not call the `Create` method overloads.</span></span> <span data-ttu-id="696d4-268">Estos no crean un lector de WCF.</span><span class="sxs-lookup"><span data-stu-id="696d4-268">These do not create a WCF reader.</span></span> <span data-ttu-id="696d4-269">En su lugar, se crea un lector que no está protegido por las características de seguridad descritas en esta sección.</span><span class="sxs-lookup"><span data-stu-id="696d4-269">Instead, a reader is created that is not protected by the security features described in this section.</span></span>

### <a name="reader-quotas"></a><span data-ttu-id="696d4-270">Cuotas del lector</span><span class="sxs-lookup"><span data-stu-id="696d4-270">Reader Quotas</span></span>

<span data-ttu-id="696d4-271">Los lectores XML seguros tienen cinco cuotas configurables.</span><span class="sxs-lookup"><span data-stu-id="696d4-271">The secure XML readers have five configurable quotas.</span></span> <span data-ttu-id="696d4-272">Normalmente se configuran utilizando la propiedad `ReaderQuotas` en los elementos de enlace de la codificación o enlaces estándares, o utilizando un objeto <xref:System.Xml.XmlDictionaryReaderQuotas> pasado al crear un lector.</span><span class="sxs-lookup"><span data-stu-id="696d4-272">These are normally configured using the `ReaderQuotas` property on the encoding binding elements or standard bindings, or by using an <xref:System.Xml.XmlDictionaryReaderQuotas> object passed when creating a reader.</span></span>

#### <a name="maxbytesperread"></a><span data-ttu-id="696d4-273">MaxBytesPerRead</span><span class="sxs-lookup"><span data-stu-id="696d4-273">MaxBytesPerRead</span></span>

<span data-ttu-id="696d4-274">Esta cuota limita el número de bytes que se leen en una operación `Read` única al leer la etiqueta de inicio de elemento y sus atributos.</span><span class="sxs-lookup"><span data-stu-id="696d4-274">This quota limits the number of bytes that are read in a single `Read` operation when reading the element start tag and its attributes.</span></span> <span data-ttu-id="696d4-275">(En los casos en que no haya transmisión, el propio nombre del elemento no se cuenta para la cuota). <xref:System.Xml.XmlDictionaryReaderQuotas.MaxBytesPerRead%2A> es importante por los motivos siguientes:</span><span class="sxs-lookup"><span data-stu-id="696d4-275">(In non-streamed cases, the element name itself is not counted against the quota.) <xref:System.Xml.XmlDictionaryReaderQuotas.MaxBytesPerRead%2A> is important for the following reasons:</span></span>

- <span data-ttu-id="696d4-276">El nombre de elemento y sus atributos siempre están almacenados en búfer en memoria cuando se leen.</span><span class="sxs-lookup"><span data-stu-id="696d4-276">The element name and its attributes are always buffered in memory when they are being read.</span></span> <span data-ttu-id="696d4-277">Por consiguiente, es importante establecer correctamente esta cuota en modo de transmisión por secuencias para evitar el almacenado en búfer excesivo.</span><span class="sxs-lookup"><span data-stu-id="696d4-277">Therefore, it is important to set this quota correctly in streaming mode to prevent excessive buffering when streaming is expected.</span></span> <span data-ttu-id="696d4-278">Vea la sección de la cuota `MaxDepth` para obtener información acerca de la cantidad real de almacenamiento en búfer que tiene lugar.</span><span class="sxs-lookup"><span data-stu-id="696d4-278">See the `MaxDepth` quota section for information about the actual amount of buffering that takes place.</span></span>

- <span data-ttu-id="696d4-279">Tener demasiados atributos XML puede usar un tiempo de proceso desproporcionado porque se tiene que comprobar la unicidad de los nombres de atributo.</span><span class="sxs-lookup"><span data-stu-id="696d4-279">Having too many XML attributes may use up disproportionate processing time because attribute names have to be checked for uniqueness.</span></span> <span data-ttu-id="696d4-280">`MaxBytesPerRead` mitiga esta amenaza.</span><span class="sxs-lookup"><span data-stu-id="696d4-280">`MaxBytesPerRead` mitigates this threat.</span></span>

#### <a name="maxdepth"></a><span data-ttu-id="696d4-281">MaxDepth</span><span class="sxs-lookup"><span data-stu-id="696d4-281">MaxDepth</span></span>

<span data-ttu-id="696d4-282">Esta cuota limita la profundidad máxima del anidamiento de elementos XML.</span><span class="sxs-lookup"><span data-stu-id="696d4-282">This quota limits the maximum nesting depth of XML elements.</span></span> <span data-ttu-id="696d4-283">Por ejemplo, el documento " \<A> \<B> \<C/> \</B> \</A> " tiene una profundidad de anidamiento de tres.</span><span class="sxs-lookup"><span data-stu-id="696d4-283">For example, the document "\<A>\<B>\<C/>\</B>\</A>" has a nesting depth of three.</span></span> <span data-ttu-id="696d4-284"><xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A> es importante por los motivos siguientes:</span><span class="sxs-lookup"><span data-stu-id="696d4-284"><xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A> is important for the following reasons:</span></span>

- <span data-ttu-id="696d4-285">`MaxDepth` interactúa con `MaxBytesPerRead`: el lector siempre mantiene los datos en memoria para el elemento vigente y todos sus antecesores, por lo que el consumo máximo de la memoria del lector es proporcional al producto de estos dos valores.</span><span class="sxs-lookup"><span data-stu-id="696d4-285">`MaxDepth` interacts with `MaxBytesPerRead`: the reader always keeps data in memory for the current element and all of its ancestors, so the maximum memory consumption of the reader is proportional to the product of these two settings.</span></span>

- <span data-ttu-id="696d4-286">Al deserializar un gráfico de objetos profundamente anidado, el deserializador se ve obligado a obtener acceso a la pila completa e iniciar una <xref:System.StackOverflowException>irrecuperable.</span><span class="sxs-lookup"><span data-stu-id="696d4-286">When deserializing a deeply-nested object graph, the deserializer is forced to access the entire stack and throw an unrecoverable <xref:System.StackOverflowException>.</span></span> <span data-ttu-id="696d4-287">Existe una correlación directa entre anidamiento de XML y anidamiento de objeto para <xref:System.Runtime.Serialization.DataContractSerializer> y <xref:System.Xml.Serialization.XmlSerializer>.</span><span class="sxs-lookup"><span data-stu-id="696d4-287">A direct correlation exists between XML nesting and object nesting for both the <xref:System.Runtime.Serialization.DataContractSerializer> and the <xref:System.Xml.Serialization.XmlSerializer>.</span></span> <span data-ttu-id="696d4-288">Utilice `MaxDepth` para mitigar esta amenaza.</span><span class="sxs-lookup"><span data-stu-id="696d4-288">Use `MaxDepth` to mitigate this threat.</span></span>

#### <a name="maxnametablecharcount"></a><span data-ttu-id="696d4-289">MaxNameTableCharCount</span><span class="sxs-lookup"><span data-stu-id="696d4-289">MaxNameTableCharCount</span></span>

<span data-ttu-id="696d4-290">Esta cuota limita el tamaño de la *tabla de nombres* del lector.</span><span class="sxs-lookup"><span data-stu-id="696d4-290">This quota limits the size of the reader’s *nametable*.</span></span> <span data-ttu-id="696d4-291">La tabla de nombres contiene ciertas cadenas (como espacios de nombres y prefijos) que se encuentran al procesar un documento XML.</span><span class="sxs-lookup"><span data-stu-id="696d4-291">The nametable contains certain strings (such as namespaces and prefixes) that are encountered when processing an XML document.</span></span> <span data-ttu-id="696d4-292">Puesto que estas cadenas están almacenadas en búfer en memoria, establezca esta cuota para evitar el almacenamiento en búfer excesivo cuando se espera la transmisión por secuencias.</span><span class="sxs-lookup"><span data-stu-id="696d4-292">As these strings are buffered in memory, set this quota to prevent excessive buffering when streaming is expected.</span></span>

#### <a name="maxstringcontentlength"></a><span data-ttu-id="696d4-293">MaxStringContentLength</span><span class="sxs-lookup"><span data-stu-id="696d4-293">MaxStringContentLength</span></span>

<span data-ttu-id="696d4-294">Esta cuota limita el tamaño máximo de la cadena que el lector XML devuelve.</span><span class="sxs-lookup"><span data-stu-id="696d4-294">This quota limits the maximum string size that the XML reader returns.</span></span> <span data-ttu-id="696d4-295">Esta cuota no limita el consumo de la memoria en el propio lector XML, sino en el componente que está utilizando el lector.</span><span class="sxs-lookup"><span data-stu-id="696d4-295">This quota does not limit memory consumption in the XML reader itself, but in the component that is using the reader.</span></span> <span data-ttu-id="696d4-296">Por ejemplo, cuando <xref:System.Runtime.Serialization.DataContractSerializer> utiliza un lector protegido con <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>, no deserializa cadenas mayores que esta cuota.</span><span class="sxs-lookup"><span data-stu-id="696d4-296">For example, when the <xref:System.Runtime.Serialization.DataContractSerializer> uses a reader secured with <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>, it does not deserialize strings larger than this quota.</span></span> <span data-ttu-id="696d4-297">Al utilizar directamente la clase <xref:System.Xml.XmlDictionaryReader> , no todos los métodos respetan esta cuota, solo los métodos que están diseñados específicamente para leer cadenas, como el método <xref:System.Xml.XmlDictionaryReader.ReadContentAsString%2A> .</span><span class="sxs-lookup"><span data-stu-id="696d4-297">When using the <xref:System.Xml.XmlDictionaryReader> class directly, not all methods respect this quota, but only the methods that are specifically designed to read strings, such as the <xref:System.Xml.XmlDictionaryReader.ReadContentAsString%2A> method.</span></span> <span data-ttu-id="696d4-298">Esta cuota no afecta a la propiedad <xref:System.Xml.XmlReader.Value%2A> en el lector y por lo tanto no se debería utilizar cuando la protección que proporciona esta cuota es necesaria.</span><span class="sxs-lookup"><span data-stu-id="696d4-298">The <xref:System.Xml.XmlReader.Value%2A> property on the reader is not affected by this quota, and thus should not be used when the protection this quota provides is necessary.</span></span>

#### <a name="maxarraylength"></a><span data-ttu-id="696d4-299">MaxArrayLength</span><span class="sxs-lookup"><span data-stu-id="696d4-299">MaxArrayLength</span></span>

<span data-ttu-id="696d4-300">Esta cuota limita el tamaño máximo de una matriz de primitivas que devuelve el lector XML, incluidas las matrices de bytes.</span><span class="sxs-lookup"><span data-stu-id="696d4-300">This quota limits the maximum size of an array of primitives that the XML reader returns, including byte arrays.</span></span> <span data-ttu-id="696d4-301">Esta cuota no limita el consumo de la memoria en el propio lector XML, sino en cualquier componente que esté utilizando el lector.</span><span class="sxs-lookup"><span data-stu-id="696d4-301">This quota does not limit memory consumption in the XML reader itself, but in whatever component that is using the reader.</span></span> <span data-ttu-id="696d4-302">Por ejemplo, cuando <xref:System.Runtime.Serialization.DataContractSerializer> utiliza un lector protegido con <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A>, no deserializa matrices de bytes mayores que esta cuota.</span><span class="sxs-lookup"><span data-stu-id="696d4-302">For example, when the <xref:System.Runtime.Serialization.DataContractSerializer> uses a reader secured with <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A>, it does not deserialize byte arrays larger than this quota.</span></span> <span data-ttu-id="696d4-303">Es importante establecer esta cuota al intentar mezclar modelos de programación de transmisión por secuencias y almacenamiento en búfer en un contrato único.</span><span class="sxs-lookup"><span data-stu-id="696d4-303">It is important to set this quota when attempting to mix streaming and buffered programming models in a single contract.</span></span> <span data-ttu-id="696d4-304">Tenga presente que al utilizar directamente la clase <xref:System.Xml.XmlDictionaryReader> , solo los métodos que están diseñados específicamente para leer matrices de tamaño arbitrario de ciertos tipos primitivos, como <xref:System.Xml.XmlDictionaryReader.ReadInt32Array%2A>, respetan esta cuota.</span><span class="sxs-lookup"><span data-stu-id="696d4-304">Keep in mind that when using the <xref:System.Xml.XmlDictionaryReader> class directly, only the methods that are specifically designed to read arrays of arbitrary size of certain primitive types, such as <xref:System.Xml.XmlDictionaryReader.ReadInt32Array%2A>, respect this quota.</span></span>

## <a name="threats-specific-to-the-binary-encoding"></a><span data-ttu-id="696d4-305">Amenazas específicas a la codificación binaria</span><span class="sxs-lookup"><span data-stu-id="696d4-305">Threats Specific to the Binary Encoding</span></span>

<span data-ttu-id="696d4-306">La codificación XML binaria WCF compatible con incluye una característica de *cadenas de diccionario* .</span><span class="sxs-lookup"><span data-stu-id="696d4-306">The binary XML encoding WCF supports includes a *dictionary strings* feature.</span></span> <span data-ttu-id="696d4-307">Una cadena grande puede estar codificada utilizando solo unos bytes.</span><span class="sxs-lookup"><span data-stu-id="696d4-307">A large string may be encoded using only a few bytes.</span></span> <span data-ttu-id="696d4-308">Esto permite considerables ganancias de rendimiento, pero introduce nuevas amenazas de la denegación de servicio que se deben mitigar.</span><span class="sxs-lookup"><span data-stu-id="696d4-308">This enables significant performance gains, but introduces new denial-of-service threats that must be mitigated.</span></span>

<span data-ttu-id="696d4-309">Hay dos tipos de diccionarios: *estático* y *dinámico*.</span><span class="sxs-lookup"><span data-stu-id="696d4-309">There are two kinds of dictionaries: *static* and *dynamic*.</span></span> <span data-ttu-id="696d4-310">El diccionario estático es una lista integrada de cadenas largas que se puede representar utilizando un código corto en la codificación binaria.</span><span class="sxs-lookup"><span data-stu-id="696d4-310">The static dictionary is a built-in list of long strings that may be represented using a short code in the binary encoding.</span></span> <span data-ttu-id="696d4-311">Esta lista de cadenas se fija cuando el lector se crea y no se puede modificar.</span><span class="sxs-lookup"><span data-stu-id="696d4-311">This list of strings is fixed when the reader is created and cannot be modified.</span></span> <span data-ttu-id="696d4-312">Ninguna de las cadenas del diccionario estático que WCF utiliza de forma predeterminada es lo suficientemente grande como para suponer una amenaza grave de denegación de servicio, aunque todavía se pueden utilizar en un ataque de expansión de diccionario.</span><span class="sxs-lookup"><span data-stu-id="696d4-312">None of the strings in the static dictionary that WCF uses by default are sufficiently large to pose a serious denial-of-service threat, although they may still be used in a dictionary expansion attack.</span></span> <span data-ttu-id="696d4-313">En escenarios avanzados donde proporciona su propio diccionario estático, vaya con cuidado al introducir cadenas de diccionario grandes.</span><span class="sxs-lookup"><span data-stu-id="696d4-313">In advanced scenarios where you supply your own static dictionary, be careful when introducing large dictionary strings.</span></span>

<span data-ttu-id="696d4-314">La característica de diccionarios dinámicos permite a los mensajes definir sus propias cadenas y asociarlas a códigos cortos.</span><span class="sxs-lookup"><span data-stu-id="696d4-314">The dynamic dictionaries feature allows messages to define their own strings and associate them with short codes.</span></span> <span data-ttu-id="696d4-315">Estas asignaciones de cadena a código se mantienen en memoria durante la sesión completa de comunicación, de manera que los mensajes subsiguientes no tienen que reenviar las cadenas y pueden utilizar los códigos ya definidos.</span><span class="sxs-lookup"><span data-stu-id="696d4-315">These string-to-code mappings are kept in memory during the entire communication session, such that subsequent messages do not have to resend the strings and can utilize codes that are already defined.</span></span> <span data-ttu-id="696d4-316">Estas cadenas pueden ser de longitud arbitraria y por consiguiente provocar una amenaza más seria que aquellas en el diccionario estático.</span><span class="sxs-lookup"><span data-stu-id="696d4-316">These strings may be of arbitrary length and thus pose a more serious threat than those in the static dictionary.</span></span>

<span data-ttu-id="696d4-317">La primera amenaza que se debe mitigar es la posibilidad de que el diccionario dinámico (la tabla de asignación de cadena a código) se vuelva demasiado grande.</span><span class="sxs-lookup"><span data-stu-id="696d4-317">The first threat that must be mitigated is the possibility of the dynamic dictionary (the string-to-code mapping table) becoming too large.</span></span> <span data-ttu-id="696d4-318">Este diccionario se puede expandir a lo largo del curso de varios mensajes y así que la cuota `MaxReceivedMessageSize` no proporciona ninguna protección porque solo se aplica separadamente a cada mensaje.</span><span class="sxs-lookup"><span data-stu-id="696d4-318">This dictionary may be expanded over the course of several messages, and so the `MaxReceivedMessageSize` quota offers no protection because it applies only to each message separately.</span></span> <span data-ttu-id="696d4-319">Por consiguiente, existe una propiedad <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> independiente en <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> que limita el tamaño del diccionario.</span><span class="sxs-lookup"><span data-stu-id="696d4-319">Therefore, a separate <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> property exists on the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> that limits the size of the dictionary.</span></span>

<span data-ttu-id="696d4-320">A diferencia de la mayoría de las otras cuotas, esta cuota también se aplica al escribir los mensajes.</span><span class="sxs-lookup"><span data-stu-id="696d4-320">Unlike most other quotas, this quota also applies when writing messages.</span></span> <span data-ttu-id="696d4-321">Si se supera al leer un mensaje, se inicia `QuotaExceededException` como de costumbre.</span><span class="sxs-lookup"><span data-stu-id="696d4-321">If it is exceeded when reading a message, the `QuotaExceededException` is thrown as usual.</span></span> <span data-ttu-id="696d4-322">Si se supera al escribir un mensaje, cualquier cadena que provoque que la cuota se supere se escribe como es, sin utilizar la característica de diccionarios dinámicos.</span><span class="sxs-lookup"><span data-stu-id="696d4-322">If it is exceeded when writing a message, any strings that cause the quota to be exceeded are written as-is, without using the dynamic dictionaries feature.</span></span>

### <a name="dictionary-expansion-threats"></a><span data-ttu-id="696d4-323">Amenazas de expansión de diccionario</span><span class="sxs-lookup"><span data-stu-id="696d4-323">Dictionary Expansion Threats</span></span>

<span data-ttu-id="696d4-324">Una clase significativa de ataques específicos binarios deriva de la expansión del diccionario.</span><span class="sxs-lookup"><span data-stu-id="696d4-324">A significant class of binary-specific attacks arises from dictionary expansion.</span></span> <span data-ttu-id="696d4-325">Un mensaje pequeño en formato binario se puede convertir en un mensaje muy grande en forma textual totalmente expandida si realiza uso extenso de la característica de diccionarios de cadena.</span><span class="sxs-lookup"><span data-stu-id="696d4-325">A small message in binary form may turn into a very large message in fully expanded textual form if it makes extensive use of the string dictionaries feature.</span></span> <span data-ttu-id="696d4-326">La cuota <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> limita el factor de expansión para las cadenas del diccionario dinámico, ya que ninguna cadena del diccionario dinámico supera el tamaño máximo del diccionario completo.</span><span class="sxs-lookup"><span data-stu-id="696d4-326">The expansion factor for dynamic dictionary strings is limited by the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> quota, because no dynamic dictionary string exceeds the maximum size of the entire dictionary.</span></span>

<span data-ttu-id="696d4-327">Las propiedades <xref:System.Xml.XmlDictionaryReaderQuotas.MaxNameTableCharCount%2A>, `MaxStringContentLength`y `MaxArrayLength` solo limitan el consumo de memoria.</span><span class="sxs-lookup"><span data-stu-id="696d4-327">The <xref:System.Xml.XmlDictionaryReaderQuotas.MaxNameTableCharCount%2A>, `MaxStringContentLength`, and `MaxArrayLength` properties only limit memory consumption.</span></span> <span data-ttu-id="696d4-328">Normalmente no se necesitan para mitigar ninguna amenaza en el uso de transmisión sin secuencias porque `MaxReceivedMessageSize`ya limita la utilización de memoria.</span><span class="sxs-lookup"><span data-stu-id="696d4-328">They are normally not required to mitigate any threats in the non-streamed usage because memory usage is already limited by `MaxReceivedMessageSize`.</span></span> <span data-ttu-id="696d4-329">Sin embargo, `MaxReceivedMessageSize` cuenta los bytes de la pre-expansión.</span><span class="sxs-lookup"><span data-stu-id="696d4-329">However, `MaxReceivedMessageSize` counts pre-expansion bytes.</span></span> <span data-ttu-id="696d4-330">Cuando se utiliza la codificación binaria, el consumo de la memoria podría exceder potencialmente `MaxReceivedMessageSize`, limitado solo por un factor de <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A>.</span><span class="sxs-lookup"><span data-stu-id="696d4-330">When binary encoding is in use, memory consumption could potentially go beyond `MaxReceivedMessageSize`, limited only by a factor of <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A>.</span></span> <span data-ttu-id="696d4-331">Por esta razón, es importante establecer siempre todas las cuotas del lector (sobre todo <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>) al utilizar la codificación binaria.</span><span class="sxs-lookup"><span data-stu-id="696d4-331">For this reason, it is important to always set all of the reader quotas (especially <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>) when using the binary encoding.</span></span>

<span data-ttu-id="696d4-332">Al utilizar la codificación binaria junto con <xref:System.Runtime.Serialization.DataContractSerializer>, la interfaz `IExtensibleDataObject` se puede emplear mal para organizar un ataque de expansión de diccionario.</span><span class="sxs-lookup"><span data-stu-id="696d4-332">When using binary encoding together with the <xref:System.Runtime.Serialization.DataContractSerializer>, the `IExtensibleDataObject` interface can be misused to mount a dictionary expansion attack.</span></span> <span data-ttu-id="696d4-333">Esta interfaz proporciona esencialmente el almacenamiento ilimitado para datos arbitrarios que no forman parte del contrato.</span><span class="sxs-lookup"><span data-stu-id="696d4-333">This interface essentially provides unlimited storage for arbitrary data that is not a part of the contract.</span></span> <span data-ttu-id="696d4-334">Si no se pueden establecer las cuotas suficientemente bajas de manera que `MaxSessionSize` multiplicado por `MaxReceivedMessageSize` no suponga un problema, deshabilite la característica `IExtensibleDataObject` al utilizar la codificación binaria.</span><span class="sxs-lookup"><span data-stu-id="696d4-334">If quotas cannot be set low enough such that `MaxSessionSize` multiplied by `MaxReceivedMessageSize` does not pose a problem, disable the `IExtensibleDataObject` feature when using the binary encoding.</span></span> <span data-ttu-id="696d4-335">Establezca la `IgnoreExtensionDataObject` propiedad en `true` en el `ServiceBehaviorAttribute` atributo.</span><span class="sxs-lookup"><span data-stu-id="696d4-335">Set the `IgnoreExtensionDataObject` property to `true` on the `ServiceBehaviorAttribute` attribute.</span></span> <span data-ttu-id="696d4-336">Alternativamente, no implemente la interfaz `IExtensibleDataObject` .</span><span class="sxs-lookup"><span data-stu-id="696d4-336">Alternatively, do not implement the `IExtensibleDataObject` interface.</span></span> <span data-ttu-id="696d4-337">Para obtener más información, vea [Forward-Compatible Data Contracts](forward-compatible-data-contracts.md) (Contratos de datos compatibles con el reenvío).</span><span class="sxs-lookup"><span data-stu-id="696d4-337">For more information, see [Forward-Compatible Data Contracts](forward-compatible-data-contracts.md).</span></span>

### <a name="quotas-summary"></a><span data-ttu-id="696d4-338">Resumen de las cuotas</span><span class="sxs-lookup"><span data-stu-id="696d4-338">Quotas Summary</span></span>

<span data-ttu-id="696d4-339">La tabla siguiente resume la guía sobre las cuotas.</span><span class="sxs-lookup"><span data-stu-id="696d4-339">The following table summarizes the guidance about quotas.</span></span>

|<span data-ttu-id="696d4-340">Condición</span><span class="sxs-lookup"><span data-stu-id="696d4-340">Condition</span></span>|<span data-ttu-id="696d4-341">Cuotas importantes a establecer</span><span class="sxs-lookup"><span data-stu-id="696d4-341">Important quotas to set</span></span>|
|---------------|-----------------------------|
|<span data-ttu-id="696d4-342">Ninguna transmisión por secuencias o transmisión por secuencias de mensajes pequeños, texto o codificación de MTOM</span><span class="sxs-lookup"><span data-stu-id="696d4-342">No streaming or streaming small messages, text, or MTOM encoding</span></span>|<span data-ttu-id="696d4-343">`MaxReceivedMessageSize`, `MaxBytesPerRead` y `MaxDepth`</span><span class="sxs-lookup"><span data-stu-id="696d4-343">`MaxReceivedMessageSize`, `MaxBytesPerRead`, and `MaxDepth`</span></span>|
|<span data-ttu-id="696d4-344">Ninguna transmisión por secuencias o transmisión por secuencias de mensajes pequeños, codificación binaria</span><span class="sxs-lookup"><span data-stu-id="696d4-344">No streaming or streaming small messages, binary encoding</span></span>|<span data-ttu-id="696d4-345">`MaxReceivedMessageSize`, `MaxSessionSize`y todas las `ReaderQuotas`</span><span class="sxs-lookup"><span data-stu-id="696d4-345">`MaxReceivedMessageSize`, `MaxSessionSize`, and all `ReaderQuotas`</span></span>|
|<span data-ttu-id="696d4-346">Transmisión por secuencias de mensajes grandes, texto o codificación de MTOM</span><span class="sxs-lookup"><span data-stu-id="696d4-346">Streaming large messages, text, or MTOM encoding</span></span>|<span data-ttu-id="696d4-347">`MaxBufferSize` y todas las `ReaderQuotas`</span><span class="sxs-lookup"><span data-stu-id="696d4-347">`MaxBufferSize` and all `ReaderQuotas`</span></span>|
|<span data-ttu-id="696d4-348">Transmisión por secuencias de mensajes grandes, codificación binaria</span><span class="sxs-lookup"><span data-stu-id="696d4-348">Streaming large messages, binary encoding</span></span>|<span data-ttu-id="696d4-349">`MaxBufferSize`, `MaxSessionSize`y todas las `ReaderQuotas`</span><span class="sxs-lookup"><span data-stu-id="696d4-349">`MaxBufferSize`, `MaxSessionSize`, and all `ReaderQuotas`</span></span>|

- <span data-ttu-id="696d4-350">Siempre se deben establecer tiempos de espera del nivel de transporte y no se debe utilizar nunca la lectura/escritura sincrónica cuando se utilice la transmisión por secuencias, independientemente de si está transmitiendo por secuencias mensajes grandes o pequeños.</span><span class="sxs-lookup"><span data-stu-id="696d4-350">Transport-level time-outs must always be set and never use synchronous reads/writes when streaming is in use, regardless of whether you are streaming large or small messages.</span></span>

- <span data-ttu-id="696d4-351">Cuando dude sobre una cuota, establézcala en un valor seguro en lugar de dejarla abierta.</span><span class="sxs-lookup"><span data-stu-id="696d4-351">When in doubt about a quota, set it to a safe value rather than leaving it open.</span></span>

## <a name="preventing-malicious-code-execution"></a><span data-ttu-id="696d4-352">Evitar la ejecución de código malintencionado</span><span class="sxs-lookup"><span data-stu-id="696d4-352">Preventing Malicious Code Execution</span></span>

<span data-ttu-id="696d4-353">Las clases generales siguientes de amenazas pueden ejecutar código y tener los efectos imprevistos:</span><span class="sxs-lookup"><span data-stu-id="696d4-353">The following general classes of threats can execute code and have unintended effects:</span></span>

- <span data-ttu-id="696d4-354">El deserializador carga un tipo malintencionado, no seguro o que afecta a la seguridad.</span><span class="sxs-lookup"><span data-stu-id="696d4-354">The deserializer loads a malicious, unsafe, or security-sensitive type.</span></span>

- <span data-ttu-id="696d4-355">Un mensaje entrante hace que el deserializador construya una instancia de un tipo normalmente seguro de de manera que tiene consecuencias imprevistas.</span><span class="sxs-lookup"><span data-stu-id="696d4-355">An incoming message causes the deserializer to construct an instance of a normally safe type in such a way that it has unintended consequences.</span></span>

<span data-ttu-id="696d4-356">Las secciones siguientes abordan detalladamente estas clases de amenazas.</span><span class="sxs-lookup"><span data-stu-id="696d4-356">The following sections discuss these classes of threats further.</span></span>

## <a name="datacontractserializer"></a><span data-ttu-id="696d4-357">DataContractSerializer</span><span class="sxs-lookup"><span data-stu-id="696d4-357">DataContractSerializer</span></span>

<span data-ttu-id="696d4-358">(Para obtener información de seguridad en <xref:System.Xml.Serialization.XmlSerializer> , vea la documentación correspondiente). El modelo de seguridad para <xref:System.Xml.Serialization.XmlSerializer> es similar al de <xref:System.Runtime.Serialization.DataContractSerializer> y difiere principalmente en detalles.</span><span class="sxs-lookup"><span data-stu-id="696d4-358">(For security information on the <xref:System.Xml.Serialization.XmlSerializer>, see the relevant documentation.) The security model for the <xref:System.Xml.Serialization.XmlSerializer> is similar to that of the <xref:System.Runtime.Serialization.DataContractSerializer>, and differs mostly in details.</span></span> <span data-ttu-id="696d4-359">Por ejemplo, el atributo <xref:System.Xml.Serialization.XmlIncludeAttribute> se utiliza para la inclusión de tipo en lugar del atributo <xref:System.Runtime.Serialization.KnownTypeAttribute> .</span><span class="sxs-lookup"><span data-stu-id="696d4-359">For example, the <xref:System.Xml.Serialization.XmlIncludeAttribute> attribute is used for type inclusion instead of the <xref:System.Runtime.Serialization.KnownTypeAttribute> attribute.</span></span> <span data-ttu-id="696d4-360">Sin embargo, algunas amenazas únicas de <xref:System.Xml.Serialization.XmlSerializer> se discuten más adelante en este tema.</span><span class="sxs-lookup"><span data-stu-id="696d4-360">However, some threats unique to the <xref:System.Xml.Serialization.XmlSerializer> are discussed later in this topic.</span></span>

### <a name="preventing-unintended-types-from-being-loaded"></a><span data-ttu-id="696d4-361">Evitar que se carguen tipos imprevistos</span><span class="sxs-lookup"><span data-stu-id="696d4-361">Preventing Unintended Types from Being Loaded</span></span>

<span data-ttu-id="696d4-362">Cargar tipos imprevistos puede tener consecuencias significativas, tanto si el tipo es malintencionado o simplemente tiene efectos secundarios que afectan a la seguridad.</span><span class="sxs-lookup"><span data-stu-id="696d4-362">Loading unintended types may have significant consequences, whether the type is malicious or just has security-sensitive side effects.</span></span> <span data-ttu-id="696d4-363">Un tipo puede contener vulnerabilidad de seguridad explotable, realizar acciones que afecten a la seguridad en su constructor o constructor de clase, tener una superficie de memoria grande que facilite los ataques por denegación de servicio, o bien puede provocar excepciones no recuperables.</span><span class="sxs-lookup"><span data-stu-id="696d4-363">A type may contain exploitable security vulnerability, perform security-sensitive actions in its constructor or class constructor, have a large memory footprint that facilitates denial-of-service attacks, or may throw non-recoverable exceptions.</span></span> <span data-ttu-id="696d4-364">Los tipos pueden tener constructores de clase que se ejecutan en cuanto se cargue el tipo y antes de que se cree cualquier instancia.</span><span class="sxs-lookup"><span data-stu-id="696d4-364">Types may have class constructors that run as soon as the type is loaded and before any instances are created.</span></span> <span data-ttu-id="696d4-365">Por estas razones, es importante controlar el conjunto de tipos que el deserializador puede cargar.</span><span class="sxs-lookup"><span data-stu-id="696d4-365">For these reasons, it is important to control the set of types that the deserializer may load.</span></span>

<span data-ttu-id="696d4-366"><xref:System.Runtime.Serialization.DataContractSerializer> deserializa con acoplamiento separado.</span><span class="sxs-lookup"><span data-stu-id="696d4-366">The <xref:System.Runtime.Serialization.DataContractSerializer> deserializes in a loosely coupled way.</span></span> <span data-ttu-id="696d4-367">Nunca lee el tipo de Common Language Runtime (CLR) y los nombres de ensamblado de los datos entrantes.</span><span class="sxs-lookup"><span data-stu-id="696d4-367">It never reads common language runtime (CLR) type and assembly names from the incoming data.</span></span> <span data-ttu-id="696d4-368">Esto es similar al comportamiento de <xref:System.Xml.Serialization.XmlSerializer>, pero difiere del comportamiento de <xref:System.Runtime.Serialization.NetDataContractSerializer>, <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>, y <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>.</span><span class="sxs-lookup"><span data-stu-id="696d4-368">This is similar to the behavior of the <xref:System.Xml.Serialization.XmlSerializer>, but differs from the behavior of the <xref:System.Runtime.Serialization.NetDataContractSerializer>, <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>, and the <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>.</span></span> <span data-ttu-id="696d4-369">El acoplamiento separado introduce un grado de seguridad, porque el atacante remoto no puede indicar que se cargue un tipo arbitrario simplemente denominando ese tipo en el mensaje.</span><span class="sxs-lookup"><span data-stu-id="696d4-369">Loose coupling introduces a degree of safety, because the remote attacker cannot indicate an arbitrary type to load just by naming that type in the message.</span></span>

<span data-ttu-id="696d4-370">Siempre se permite que <xref:System.Runtime.Serialization.DataContractSerializer> cargue un tipo que se espera actualmente según el contrato.</span><span class="sxs-lookup"><span data-stu-id="696d4-370">The <xref:System.Runtime.Serialization.DataContractSerializer> is always allowed to load a type that is currently expected according to the contract.</span></span> <span data-ttu-id="696d4-371">Por ejemplo, si un contrato de datos tiene un miembro de datos de tipo `Customer`, <xref:System.Runtime.Serialization.DataContractSerializer> puede cargar el tipo `Customer` cuando deserializa este miembro de datos.</span><span class="sxs-lookup"><span data-stu-id="696d4-371">For example, if a data contract has a data member of type `Customer`, the <xref:System.Runtime.Serialization.DataContractSerializer> is allowed to load the `Customer` type when it deserializes this data member.</span></span>

<span data-ttu-id="696d4-372">Además, <xref:System.Runtime.Serialization.DataContractSerializer> admite el polimorfismo.</span><span class="sxs-lookup"><span data-stu-id="696d4-372">Additionally, the <xref:System.Runtime.Serialization.DataContractSerializer> supports polymorphism.</span></span> <span data-ttu-id="696d4-373">Un miembro de datos se puede declarar como <xref:System.Object>, pero los datos entrantes pueden contener una instancia `Customer` .</span><span class="sxs-lookup"><span data-stu-id="696d4-373">A data member may be declared as <xref:System.Object>, but the incoming data may contain a `Customer` instance.</span></span> <span data-ttu-id="696d4-374">Esto solo es posible si el tipo `Customer` se ha dado a conocer al deserializador a través de uno de estos mecanismos:</span><span class="sxs-lookup"><span data-stu-id="696d4-374">This is possible only if the `Customer` type has been made "known" to the deserializer through one of these mechanisms:</span></span>

- <span data-ttu-id="696d4-375">Atributo<xref:System.Runtime.Serialization.KnownTypeAttribute> aplicado al tipo.</span><span class="sxs-lookup"><span data-stu-id="696d4-375"><xref:System.Runtime.Serialization.KnownTypeAttribute> attribute applied to a type.</span></span>

- <span data-ttu-id="696d4-376">Atributo`KnownTypeAttribute` que especifica un método que devuelve una lista de tipos.</span><span class="sxs-lookup"><span data-stu-id="696d4-376">`KnownTypeAttribute` attribute specifying a method that returns a list of types.</span></span>

- <span data-ttu-id="696d4-377">Atributo`ServiceKnownTypeAttribute` .</span><span class="sxs-lookup"><span data-stu-id="696d4-377">`ServiceKnownTypeAttribute` attribute.</span></span>

- <span data-ttu-id="696d4-378">Sección de configuración `KnownTypes` .</span><span class="sxs-lookup"><span data-stu-id="696d4-378">The `KnownTypes` configuration section.</span></span>

- <span data-ttu-id="696d4-379">Una lista de tipos conocidos pasada explícitamente a <xref:System.Runtime.Serialization.DataContractSerializer> durante la construcción, si se utiliza directamente el serializador.</span><span class="sxs-lookup"><span data-stu-id="696d4-379">A list of known types explicitly passed to the <xref:System.Runtime.Serialization.DataContractSerializer> during construction, if using the serializer directly.</span></span>

<span data-ttu-id="696d4-380">Cada uno de estos mecanismos aumenta el área de superficie introduciendo más tipos que el deserializador puede cargar.</span><span class="sxs-lookup"><span data-stu-id="696d4-380">Each of these mechanisms increases the surface area by introducing more types that the deserializer can load.</span></span> <span data-ttu-id="696d4-381">Controle cada uno de estos mecanismos para asegurarse de que ningún tipo malintencionado o imprevisto se agregue a la lista de tipos conocidos.</span><span class="sxs-lookup"><span data-stu-id="696d4-381">Control each of these mechanisms to ensure no malicious or unintended types are added to the known types list.</span></span>

<span data-ttu-id="696d4-382">Una vez un tipo conocido está en el ámbito, se puede cargar en cualquier momento y se pueden crear las instancias del tipo, aun cuando el contrato prohíba realmente utilizarlo.</span><span class="sxs-lookup"><span data-stu-id="696d4-382">Once a known type is in scope, it can be loaded at any time, and instances of the type can be created, even if the contract forbids actually using it.</span></span> <span data-ttu-id="696d4-383">Por ejemplo, suponga que el tipo "MyDangerousType" se agregue a la lista de tipos conocidos utilizando uno de los mecanismos anteriores.</span><span class="sxs-lookup"><span data-stu-id="696d4-383">For example, suppose the type "MyDangerousType" is added to the known types list using one of the mechanisms above.</span></span> <span data-ttu-id="696d4-384">Esto significa que:</span><span class="sxs-lookup"><span data-stu-id="696d4-384">This means that:</span></span>

- <span data-ttu-id="696d4-385">Se carga`MyDangerousType` y su constructor de clase se ejecuta.</span><span class="sxs-lookup"><span data-stu-id="696d4-385">`MyDangerousType` is loaded and its class constructor runs.</span></span>

- <span data-ttu-id="696d4-386">Incluso al deserializar un contrato de datos con un miembro de datos de cadena, un mensaje malintencionado puede provocar la creación de una instancia de `MyDangerousType` .</span><span class="sxs-lookup"><span data-stu-id="696d4-386">Even when deserializing a data contract with a string data member, a malicious message may still cause an instance of `MyDangerousType` to create.</span></span> <span data-ttu-id="696d4-387">El código en `MyDangerousType`, como establecedores de propiedades, se puede ejecutar.</span><span class="sxs-lookup"><span data-stu-id="696d4-387">Code in `MyDangerousType`, such as property setters, may run.</span></span> <span data-ttu-id="696d4-388">Una vez hecho, el deserializador intenta asignar esta instancia al miembro de dato de cadena y se produce un error con una excepción.</span><span class="sxs-lookup"><span data-stu-id="696d4-388">After this is done, the deserializer tries to assign this instance to the string data member and fail with an exception.</span></span>

<span data-ttu-id="696d4-389">Al escribir un método que devuelve una lista de tipos conocidos o al pasar directamente una lista al constructor <xref:System.Runtime.Serialization.DataContractSerializer> , asegúrese de que el código que prepara la lista sea seguro y funcione solo en datos que sean de confianza.</span><span class="sxs-lookup"><span data-stu-id="696d4-389">When writing a method that returns a list of known types, or when passing a list directly to the <xref:System.Runtime.Serialization.DataContractSerializer> constructor, ensure that the code that prepares the list is secure and operates only on trusted data.</span></span>

<span data-ttu-id="696d4-390">Si especifica los tipos conocidos en configuración, asegúrese de que el archivo de configuración sea seguro.</span><span class="sxs-lookup"><span data-stu-id="696d4-390">If specifying known types in configuration, ensure that the configuration file is secure.</span></span> <span data-ttu-id="696d4-391">Utilice siempre nombres seguros en configuración (especificando la clave pública del ensamblado firmado donde el tipo reside), pero no especifique la versión del tipo a cargar.</span><span class="sxs-lookup"><span data-stu-id="696d4-391">Always use strong names in configuration (by specifying the public key of the signed assembly where the type resides), but do not specify the version of the type to load.</span></span> <span data-ttu-id="696d4-392">El cargador de tipo escoge automáticamente la última versión, si es posible.</span><span class="sxs-lookup"><span data-stu-id="696d4-392">The type loader automatically picks the latest version, if possible.</span></span> <span data-ttu-id="696d4-393">Si especifica una versión determinada en configuración, corre el riesgo siguiente: un tipo puede tener una vulnerabilidad de seguridad que se puede fijar en una versión futura, pero la versión vulnerable todavía se carga porque está explícitamente especificado en configuración.</span><span class="sxs-lookup"><span data-stu-id="696d4-393">If you specify a particular version in configuration, you run the following risk: A type may have a security vulnerability that may be fixed in a future version, but the vulnerable version still loads because it is explicitly specified in configuration.</span></span>

<span data-ttu-id="696d4-394">Tener demasiados tipos conocidos tiene otra consecuencia: <xref:System.Runtime.Serialization.DataContractSerializer> crea una memoria caché de código de serialización/deserialización en el dominio de aplicación, con una entrada para cada tipo que debe serializar y deserializar.</span><span class="sxs-lookup"><span data-stu-id="696d4-394">Having too many known types has another consequence: The <xref:System.Runtime.Serialization.DataContractSerializer> creates a cache of serialization/deserialization code in the application domain, with an entry for each type it must serialize and deserialize.</span></span> <span data-ttu-id="696d4-395">Esta memoria caché nunca se borra mientras se esté ejecutando el dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="696d4-395">This cache is never cleared as long as the application domain is running.</span></span> <span data-ttu-id="696d4-396">Por consiguiente, un atacante que es consciente que una aplicación utiliza muchos tipos conocidos puede desencadenar la deserialización de todos estos tipos, haciendo que la caché utilice una cantidad desproporcionadamente grande de memoria.</span><span class="sxs-lookup"><span data-stu-id="696d4-396">Therefore, an attacker who is aware that an application uses many known types can cause the deserialization of all these types, causing the cache to consume a disproportionately large amount of memory.</span></span>

### <a name="preventing-types-from-being-in-an-unintended-state"></a><span data-ttu-id="696d4-397">Evitando que los tipos estén en un estado imprevisto</span><span class="sxs-lookup"><span data-stu-id="696d4-397">Preventing Types from Being in an Unintended State</span></span>

<span data-ttu-id="696d4-398">Un tipo puede tener restricciones de coherencia internas que se deban cumplir.</span><span class="sxs-lookup"><span data-stu-id="696d4-398">A type may have internal consistency constraints that must be enforced.</span></span> <span data-ttu-id="696d4-399">Se debe proceder con cuidado para evitar la ruptura de estas restricciones durante la deserialización.</span><span class="sxs-lookup"><span data-stu-id="696d4-399">Care must be taken to avoid breaking these constraints during deserialization.</span></span>

<span data-ttu-id="696d4-400">El siguiente ejemplo de un tipo representa el estado de una cámara estanca en una nave espacial y exige la restricción de que las puertas internas y externas no pueden abrirse al mismo tiempo.</span><span class="sxs-lookup"><span data-stu-id="696d4-400">The following example of a type represents the state of an airlock on a spacecraft, and enforces the constraint that both the inner and the outer doors cannot be open at the same time.</span></span>

[!code-csharp[DataContractAttribute#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/datacontractattribute/cs/overview.cs#3)]
[!code-vb[DataContractAttribute#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/datacontractattribute/vb/overview.vb#3)]

<span data-ttu-id="696d4-401">Un atacante puede enviar un mensaje malintencionado como esté, evitando las restricciones y poniendo el objeto en un estado no válido, lo que puede tener consecuencias imprevistas e imprevisibles.</span><span class="sxs-lookup"><span data-stu-id="696d4-401">An attacker may send a malicious message like this, getting around the constraints and getting the object into an invalid state, which may have unintended and unpredictable consequences.</span></span>

```xml
<SpaceStationAirlock>
    <innerDoorOpen>true</innerDoorOpen>
    <outerDoorOpen>true</outerDoorOpen>
</SpaceStationAirlock>
```

<span data-ttu-id="696d4-402">Esta situación se puede evitar siendo consciente de los puntos siguientes:</span><span class="sxs-lookup"><span data-stu-id="696d4-402">This situation can be avoided by being aware of the following points:</span></span>

- <span data-ttu-id="696d4-403">Cuando <xref:System.Runtime.Serialization.DataContractSerializer> deserializa la mayoría de las clases, los constructores no se ejecutan.</span><span class="sxs-lookup"><span data-stu-id="696d4-403">When the <xref:System.Runtime.Serialization.DataContractSerializer> deserializes most classes, constructors do not run.</span></span> <span data-ttu-id="696d4-404">Por consiguiente, no confíe en cualquier administración de estados hecha en el constructor.</span><span class="sxs-lookup"><span data-stu-id="696d4-404">Therefore, do not rely on any state management done in the constructor.</span></span>

- <span data-ttu-id="696d4-405">Utilice las devoluciones de llamada para asegurarse de que el objeto esté en un estado válido.</span><span class="sxs-lookup"><span data-stu-id="696d4-405">Use callbacks to ensure that the object is in a valid state.</span></span> <span data-ttu-id="696d4-406">La devolución de llamada marcada con el atributo <xref:System.Runtime.Serialization.OnDeserializedAttribute> es especialmente útil porque se ejecuta después de que la deserialización se haya completado y tiene una oportunidad para examinar y corregir el estado total.</span><span class="sxs-lookup"><span data-stu-id="696d4-406">The callback marked with the <xref:System.Runtime.Serialization.OnDeserializedAttribute> attribute is especially useful because it runs after deserialization is complete and has a chance to examine and correct the overall state.</span></span> <span data-ttu-id="696d4-407">Para obtener más información, consulte [devoluciones de llamada de serialización tolerante a versiones](version-tolerant-serialization-callbacks.md).</span><span class="sxs-lookup"><span data-stu-id="696d4-407">For more information, see [Version-Tolerant Serialization Callbacks](version-tolerant-serialization-callbacks.md).</span></span>

- <span data-ttu-id="696d4-408">No diseñe los tipos de contrato de datos para confiar en cualquier orden determinado en el que se deba llamar a los establecedores de propiedad.</span><span class="sxs-lookup"><span data-stu-id="696d4-408">Do not design data contract types to rely on any particular order in which property setters must be called.</span></span>

- <span data-ttu-id="696d4-409">Tenga cuidado utilizando los tipos heredados marcado con el atributo <xref:System.SerializableAttribute> .</span><span class="sxs-lookup"><span data-stu-id="696d4-409">Take care using legacy types marked with the <xref:System.SerializableAttribute> attribute.</span></span> <span data-ttu-id="696d4-410">Muchos de ellos se diseñaron para trabajar con .NET Framework la comunicación remota para su uso solo con datos de confianza.</span><span class="sxs-lookup"><span data-stu-id="696d4-410">Many of them were designed to work with .NET Framework remoting for use with trusted data only.</span></span> <span data-ttu-id="696d4-411">Los tipos existentes marcados con este atributo pueden no haber sido diseñados con la seguridad del estado en mente.</span><span class="sxs-lookup"><span data-stu-id="696d4-411">Existing types marked with this attribute may not have been designed with state safety in mind.</span></span>

- <span data-ttu-id="696d4-412">No confíe en la propiedad <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> del atributo <xref:System.Runtime.Serialization.DataMemberAttribute> para garantizar la presencia de datos en lo relativo a la seguridad del estado.</span><span class="sxs-lookup"><span data-stu-id="696d4-412">Do not rely on the <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> property of the <xref:System.Runtime.Serialization.DataMemberAttribute> attribute to guarantee presence of data as far as state safety is concerned.</span></span> <span data-ttu-id="696d4-413">Los datos siempre podrían ser `null`, `zero`o `invalid`.</span><span class="sxs-lookup"><span data-stu-id="696d4-413">Data could always be `null`, `zero`, or `invalid`.</span></span>

- <span data-ttu-id="696d4-414">Nunca confíe en un gráfico de objeto deserializado de un origen de datos que no es de confianza sin validarlo primero.</span><span class="sxs-lookup"><span data-stu-id="696d4-414">Never trust an object graph deserialized from an untrusted data source without validating it first.</span></span> <span data-ttu-id="696d4-415">Cada objeto individual puede estar en un estado coherente, pero el gráfico de objeto en conjunto puede no estarlo.</span><span class="sxs-lookup"><span data-stu-id="696d4-415">Each individual object may be in a consistent state, but the object graph as a whole may not be.</span></span> <span data-ttu-id="696d4-416">Además, aun cuando el modo de preservación de gráfico de objeto está deshabilitado, el gráfico deserializado puede tener varias referencias al mismo objeto o tener referencias circulares.</span><span class="sxs-lookup"><span data-stu-id="696d4-416">Furthermore, even if the object graph preservation mode is disabled, the deserialized graph may have multiple references to the same object or have circular references.</span></span> <span data-ttu-id="696d4-417">Para obtener más información, vea [serialización y deserialización](serialization-and-deserialization.md).</span><span class="sxs-lookup"><span data-stu-id="696d4-417">For more information, see [Serialization and Deserialization](serialization-and-deserialization.md).</span></span>

### <a name="using-the-netdatacontractserializer-securely"></a><span data-ttu-id="696d4-418">Utilizar NetDataContractSerializer con seguridad</span><span class="sxs-lookup"><span data-stu-id="696d4-418">Using the NetDataContractSerializer Securely</span></span>

<span data-ttu-id="696d4-419"><xref:System.Runtime.Serialization.NetDataContractSerializer> es un motor de serialización que utiliza el acoplamiento apretado a los tipos.</span><span class="sxs-lookup"><span data-stu-id="696d4-419">The <xref:System.Runtime.Serialization.NetDataContractSerializer> is a serialization engine that uses tight coupling to types.</span></span> <span data-ttu-id="696d4-420">Es similar a <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> y <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>.</span><span class="sxs-lookup"><span data-stu-id="696d4-420">This is similar to the <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> and the <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>.</span></span> <span data-ttu-id="696d4-421">Es decir, determina el tipo del que se crea una instancia leyendo el .NET Framework ensamblado y el nombre de tipo de los datos entrantes.</span><span class="sxs-lookup"><span data-stu-id="696d4-421">That is, it determines which type to instantiate by reading the .NET Framework assembly and type name from the incoming data.</span></span> <span data-ttu-id="696d4-422">Aunque forma parte de WCF, no hay ninguna manera proporcionada de conectarse a este motor de serialización; se debe escribir código personalizado.</span><span class="sxs-lookup"><span data-stu-id="696d4-422">Although it is a part of WCF, there is no supplied way of plugging in this serialization engine; custom code must be written.</span></span> <span data-ttu-id="696d4-423">`NetDataContractSerializer`Se proporciona principalmente para facilitar la migración de .NET Framework comunicación remota a WCF.</span><span class="sxs-lookup"><span data-stu-id="696d4-423">The `NetDataContractSerializer` is provided primarily to ease migration from .NET Framework remoting to WCF.</span></span> <span data-ttu-id="696d4-424">Para obtener más información, vea la sección correspondiente en [serialización y deserialización](serialization-and-deserialization.md).</span><span class="sxs-lookup"><span data-stu-id="696d4-424">For more information, see the relevant section in [Serialization and Deserialization](serialization-and-deserialization.md).</span></span>

<span data-ttu-id="696d4-425">Dado que el propio mensaje puede indicar que se puede cargar cualquier tipo, el mecanismo <xref:System.Runtime.Serialization.NetDataContractSerializer> es inherentemente inseguro y debería utilizarse solo con datos que sean de confianza.</span><span class="sxs-lookup"><span data-stu-id="696d4-425">Because the message itself may indicate any type can be loaded, the <xref:System.Runtime.Serialization.NetDataContractSerializer> mechanism is inherently insecure and should be used only with trusted data.</span></span> <span data-ttu-id="696d4-426">Para obtener más información, vea la [Guía de seguridad BinaryFormatter](../../../standard/serialization/binaryformatter-security-guide.md).</span><span class="sxs-lookup"><span data-stu-id="696d4-426">For more information, see the [BinaryFormatter security guide](../../../standard/serialization/binaryformatter-security-guide.md).</span></span>

<span data-ttu-id="696d4-427">Incluso cuando se utiliza con datos que son de confianza, los datos entrantes pueden especificar de forma insuficiente el tipo que se debe cargar, sobre todo si la propiedad <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> está establecida en <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple>.</span><span class="sxs-lookup"><span data-stu-id="696d4-427">Even when used with trusted data, the incoming data may insufficiently specify the type to load, especially if the <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> property is set to <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple>.</span></span> <span data-ttu-id="696d4-428">Cualquiera con acceso al directorio de la aplicación o a la caché global de ensamblados puede sustituir un tipo malintencionado en lugar del que se supone que debe cargarse.</span><span class="sxs-lookup"><span data-stu-id="696d4-428">Anyone with access to the application’s directory or to the global assembly cache can substitute a malicious type in place of the one that is supposed to load.</span></span> <span data-ttu-id="696d4-429">Garantice siempre la seguridad del directorio de su aplicación y de la caché global de ensamblados estableciendo correctamente los permisos.</span><span class="sxs-lookup"><span data-stu-id="696d4-429">Always ensure the security of your application’s directory and of the global assembly cache by correctly setting permissions.</span></span>

<span data-ttu-id="696d4-430">En general, si permite que el código de confianza parcial tenga acceso a la instancia de `NetDataContractSerializer` o controle de algún otro modo el selector de suplentes (<xref:System.Runtime.Serialization.ISurrogateSelector>) o el enlazador de serialización (<xref:System.Runtime.Serialization.SerializationBinder>), el código puede ejercer un gran control sobre el proceso de serialización o deserialización.</span><span class="sxs-lookup"><span data-stu-id="696d4-430">In general, if you allow partially trusted code access to your `NetDataContractSerializer` instance or otherwise control the surrogate selector (<xref:System.Runtime.Serialization.ISurrogateSelector>) or the serialization binder (<xref:System.Runtime.Serialization.SerializationBinder>), the code may exercise a great deal of control over the serialization/deserialization process.</span></span> <span data-ttu-id="696d4-431">Por ejemplo, puede insertar tipos arbitrarios, provocar la divulgación de información, manipular el gráfico de objetos resultante o los datos serializados, o bien desbordar la secuencia serializada resultante.</span><span class="sxs-lookup"><span data-stu-id="696d4-431">For example, it may inject arbitrary types, lead to information disclosure, tamper with the resulting object graph or serialized data, or overflow the resultant serialized stream.</span></span>

<span data-ttu-id="696d4-432">Otra preocupación de seguridad con `NetDataContractSerializer` es una denegación de servicio, no una amenaza de ejecución de código malintencionado.</span><span class="sxs-lookup"><span data-stu-id="696d4-432">Another security concern with the `NetDataContractSerializer` is a denial of service, not a malicious code execution threat.</span></span> <span data-ttu-id="696d4-433">Al utilizar `NetDataContractSerializer`, establezca siempre la cuota <xref:System.Runtime.Serialization.NetDataContractSerializer.MaxItemsInObjectGraph%2A> en un valor seguro.</span><span class="sxs-lookup"><span data-stu-id="696d4-433">When using the `NetDataContractSerializer`, always set the <xref:System.Runtime.Serialization.NetDataContractSerializer.MaxItemsInObjectGraph%2A> quota to a safe value.</span></span> <span data-ttu-id="696d4-434">Es fácil construir un mensaje malintencionado pequeño que asigne una matriz de objetos cuyo tamaño está solo limitado por esta cuota.</span><span class="sxs-lookup"><span data-stu-id="696d4-434">It is easy to construct a small malicious message that allocates an array of objects whose size is limited only by this quota.</span></span>

### <a name="xmlserializer-specific-threats"></a><span data-ttu-id="696d4-435">Amenazas específicas de XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="696d4-435">XmlSerializer-Specific Threats</span></span>

<span data-ttu-id="696d4-436">El modelo de seguridad <xref:System.Xml.Serialization.XmlSerializer> es similar al de <xref:System.Runtime.Serialization.DataContractSerializer>.</span><span class="sxs-lookup"><span data-stu-id="696d4-436">The <xref:System.Xml.Serialization.XmlSerializer> security model is similar to that of the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="696d4-437">Sin embargo, algunas amenazas son exclusivas de <xref:System.Xml.Serialization.XmlSerializer>.</span><span class="sxs-lookup"><span data-stu-id="696d4-437">A few threats, however, are unique to the <xref:System.Xml.Serialization.XmlSerializer>.</span></span>

<span data-ttu-id="696d4-438"><xref:System.Xml.Serialization.XmlSerializer> genera *ensamblados de serialización* en tiempo de ejecución que contienen código que realmente serializa y deserializa; estos ensamblados se crean en un directorio de archivos temporales.</span><span class="sxs-lookup"><span data-stu-id="696d4-438">The <xref:System.Xml.Serialization.XmlSerializer> generates *serialization assemblies* at runtime that contain code that actually serializes and deserializes; these assemblies are created in a temporary files directory.</span></span> <span data-ttu-id="696d4-439">Si algún otro proceso o usuario tiene derechos de acceso a ese directorio, pueden sobrescribir el código de serialización/deserialización con código arbitrario.</span><span class="sxs-lookup"><span data-stu-id="696d4-439">If some other process or user has access rights to that directory, they may overwrite the serialization/deserialization code with arbitrary code.</span></span> <span data-ttu-id="696d4-440"><xref:System.Xml.Serialization.XmlSerializer> ejecuta a continuación este código utilizando su contexto de seguridad, en lugar del código de serialización/deserialización.</span><span class="sxs-lookup"><span data-stu-id="696d4-440">The <xref:System.Xml.Serialization.XmlSerializer> then runs this code using its security context, instead of the serialization/deserialization code.</span></span> <span data-ttu-id="696d4-441">Asegúrese de que los permisos estén correctamente establecidos en el directorio de archivos temporales para evitar que esto suceda.</span><span class="sxs-lookup"><span data-stu-id="696d4-441">Make sure the permissions are set correctly on the temporary files directory to prevent this from happening.</span></span>

<span data-ttu-id="696d4-442"><xref:System.Xml.Serialization.XmlSerializer> también tiene un modo en el que utiliza los ensamblados de serialización generados previamente en lugar de generarlos en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="696d4-442">The <xref:System.Xml.Serialization.XmlSerializer> also has a mode in which it uses pre-generated serialization assemblies instead of generating them at runtime.</span></span> <span data-ttu-id="696d4-443">Este modo se activa cuando <xref:System.Xml.Serialization.XmlSerializer> puede encontrar un ensamblado de serialización conveniente.</span><span class="sxs-lookup"><span data-stu-id="696d4-443">This mode is triggered whenever the <xref:System.Xml.Serialization.XmlSerializer> can find a suitable serialization assembly.</span></span> <span data-ttu-id="696d4-444"><xref:System.Xml.Serialization.XmlSerializer> comprueba si se firmó o no el ensamblado de serialización con la misma clave utilizada para firmar el ensamblado que contiene los tipos que se están serializando.</span><span class="sxs-lookup"><span data-stu-id="696d4-444">The <xref:System.Xml.Serialization.XmlSerializer> checks whether or not the serialization assembly was signed by the same key that was used to sign the assembly that contains the types being serialized.</span></span> <span data-ttu-id="696d4-445">Esto proporciona protección e impide que los ensamblados malintencionados se oculten como ensamblados de serialización.</span><span class="sxs-lookup"><span data-stu-id="696d4-445">This offers protection from malicious assemblies being disguised as serialization assemblies.</span></span> <span data-ttu-id="696d4-446">Sin embargo, si no se firma el ensamblado que contiene los tipos serializables, <xref:System.Xml.Serialization.XmlSerializer> no puede realizar esta comprobación y utiliza cualquier ensamblado con el nombre correcto.</span><span class="sxs-lookup"><span data-stu-id="696d4-446">However, if the assembly that contains your serializable types is not signed, the <xref:System.Xml.Serialization.XmlSerializer> cannot perform this check and uses any assembly with the correct name.</span></span> <span data-ttu-id="696d4-447">Esto hace que sea posible ejecutar código malintencionado.</span><span class="sxs-lookup"><span data-stu-id="696d4-447">This makes running malicious code possible.</span></span> <span data-ttu-id="696d4-448">Firme siempre los ensamblados que contienen sus tipos serializables o controle bien el acceso al directorio de su aplicación y la caché global de ensamblados para evitar la introducción de ensamblados malintencionados.</span><span class="sxs-lookup"><span data-stu-id="696d4-448">Always sign the assemblies that contain your serializable types, or tightly control access to your application’s directory and the global assembly cache to prevent the introduction of malicious assemblies.</span></span>

<span data-ttu-id="696d4-449"><xref:System.Xml.Serialization.XmlSerializer> puede estar sujeto a un ataque por denegación de servicio.</span><span class="sxs-lookup"><span data-stu-id="696d4-449">The <xref:System.Xml.Serialization.XmlSerializer> can be subject to a denial of service attack.</span></span> <span data-ttu-id="696d4-450"><xref:System.Xml.Serialization.XmlSerializer> no tiene una cuota `MaxItemsInObjectGraph` (como está disponible en <xref:System.Runtime.Serialization.DataContractSerializer>).</span><span class="sxs-lookup"><span data-stu-id="696d4-450">The <xref:System.Xml.Serialization.XmlSerializer> does not have a `MaxItemsInObjectGraph` quota (as is available on the <xref:System.Runtime.Serialization.DataContractSerializer>).</span></span> <span data-ttu-id="696d4-451">Por lo tanto, deserializará una cantidad arbitraria de objetos, limitada solo por el tamaño del mensaje.</span><span class="sxs-lookup"><span data-stu-id="696d4-451">Thus, it deserializes an arbitrary amount of objects, limited only by the message size.</span></span>

### <a name="partial-trust-threats"></a><span data-ttu-id="696d4-452">Otras amenazas de confianza parcial</span><span class="sxs-lookup"><span data-stu-id="696d4-452">Partial Trust Threats</span></span>

<span data-ttu-id="696d4-453">Tenga en cuenta las preocupaciones siguientes con respecto a las amenazas de código ejecutado con confianza parcial.</span><span class="sxs-lookup"><span data-stu-id="696d4-453">Note the following concerns regarding threats related to code running with partial trust.</span></span> <span data-ttu-id="696d4-454">Estas amenazas incluyen el código malintencionado de confianza parcial así como el código malintencionado de confianza parcial en combinación con otros escenarios de ataque, por ejemplo, código de confianza parcial que construye una cadena concreta y después la deserializa.</span><span class="sxs-lookup"><span data-stu-id="696d4-454">These threats include malicious partially-trusted code as well as malicious partially-trusted code in combination with other attack scenarios (for example, partially-trusted code that constructs a specific string and then deserializing it).</span></span>

- <span data-ttu-id="696d4-455">Al utilizar cualquier componente de serialización, nunca valide ningún permiso antes del uso, incluso si el escenario de serialización completo esté dentro del ámbito de su validez y no esté tratando con datos u objetos que no son de confianza.</span><span class="sxs-lookup"><span data-stu-id="696d4-455">When using any serialization components, never assert any permissions before such usage, even if the entire serialization scenario is within the scope of your assert, and you are not dealing with any untrusted data or objects.</span></span> <span data-ttu-id="696d4-456">Tal uso puede provocar vulnerabilidades de seguridad.</span><span class="sxs-lookup"><span data-stu-id="696d4-456">Such usage may lead to security vulnerabilities.</span></span>

- <span data-ttu-id="696d4-457">En los casos en los que el código de confianza parcial tiene control sobre el proceso de serialización, bien a través de puntos de extensibilidad (suplentes), tipos que se están serializando o de otra manera, el código de confianza parcial puede provocar que el serializador produzca una gran cantidad de datos en la secuencia serializada, lo que podría dar lugar a la denegación del servicio (DoS) al receptor de la secuencia.</span><span class="sxs-lookup"><span data-stu-id="696d4-457">In cases where partially-trusted code has control over the serialization process, either through extensibility points (surrogates), types being serialized, or through other means, the partially-trusted code may cause the serializer to output a large amount of data into the serialized stream, which may cause Denial of Service (DoS) to the receiver of this stream.</span></span> <span data-ttu-id="696d4-458">Si serializa datos previstos para un destino vulnerable a las amenazas de denegación de servicio, no serialice tipos de confianza parcial o bien permita que el código de confianza parcial controle la serialización.</span><span class="sxs-lookup"><span data-stu-id="696d4-458">If you are serializing data intended for a target that is sensitive to DoS threats, do not serialize partially-trusted types or otherwise let partially-trusted code control serialization.</span></span>

- <span data-ttu-id="696d4-459">Si permite el acceso del código de confianza parcial a la <xref:System.Runtime.Serialization.DataContractSerializer> instancia de o controle de algún otro modo los [suplentes del contrato de datos](../extending/data-contract-surrogates.md), puede ejercer un gran control sobre el proceso de serialización y deserialización.</span><span class="sxs-lookup"><span data-stu-id="696d4-459">If you allow partially-trusted code access to your <xref:System.Runtime.Serialization.DataContractSerializer> instance or otherwise control the [Data Contract Surrogates](../extending/data-contract-surrogates.md), it may exercise a great deal of control over the serialization/deserialization process.</span></span> <span data-ttu-id="696d4-460">Por ejemplo, puede insertar tipos arbitrarios, provocar la divulgación de información, manipular el gráfico de objetos resultante o los datos serializados, o bien desbordar la secuencia serializada resultante.</span><span class="sxs-lookup"><span data-stu-id="696d4-460">For example, it may inject arbitrary types, lead to information disclosure, tamper with the resulting object graph or serialized data, or overflow the resultant serialized stream.</span></span> <span data-ttu-id="696d4-461">Se describe una amenaza <xref:System.Runtime.Serialization.NetDataContractSerializer> equivalente en la sección "Utilizar NetDataContractSerializer con seguridad".</span><span class="sxs-lookup"><span data-stu-id="696d4-461">An equivalent <xref:System.Runtime.Serialization.NetDataContractSerializer> threat is described in the "Using the NetDataContractSerializer Securely" section.</span></span>

- <span data-ttu-id="696d4-462">Si el atributo <xref:System.Runtime.Serialization.DataContractAttribute> se aplica a un tipo (o el tipo marcado como <xref:System.SerializableAttribute> pero no es <xref:System.Runtime.Serialization.ISerializable>), el deserializador puede crear una instancia de este tipo aun cuando todos los constructores no sean públicos o estén protegidos por peticiones.</span><span class="sxs-lookup"><span data-stu-id="696d4-462">If the <xref:System.Runtime.Serialization.DataContractAttribute> attribute is applied to a type (or the type marked as <xref:System.SerializableAttribute> but is not <xref:System.Runtime.Serialization.ISerializable>), the deserializer can create an instance of such a type even if all constructors are non-public or protected by demands.</span></span>

- <span data-ttu-id="696d4-463">Nunca confíe en el resultado de la deserialización salvo que los datos que se deserializan sean de confianza y esté seguro de que todos los tipos conocidos son de su confianza.</span><span class="sxs-lookup"><span data-stu-id="696d4-463">Never trust the result of deserialization unless the data to be deserialized is trusted and you are certain that all known types are types that you trust.</span></span> <span data-ttu-id="696d4-464">Tenga en cuenta que cuando se realiza la ejecución en confianza parcial, los tipos conocidos no se cargan desde el archivo de configuración de la aplicación, sino desde el archivo de configuración del equipo.</span><span class="sxs-lookup"><span data-stu-id="696d4-464">Note that known types are not loaded from the application configuration file, (but are loaded from the computer configuration file) when running in partial trust.</span></span>

- <span data-ttu-id="696d4-465">Si pasa una instancia de <xref:System.Runtime.Serialization.DataContractSerializer> con un suplente agregado a un código de confianza parcial, el código puede cambiar cualquier valor modificable de ese suplente.</span><span class="sxs-lookup"><span data-stu-id="696d4-465">If you pass a <xref:System.Runtime.Serialization.DataContractSerializer> instance with a surrogate added to partially-trusted code, the code can change any modifiable settings on that surrogate.</span></span>

- <span data-ttu-id="696d4-466">Para un objeto deserializado, si el lector XML (o los datos que contiene) procede del código de confianza parcial, trate el objeto deserializado resultante como datos que no son de confianza.</span><span class="sxs-lookup"><span data-stu-id="696d4-466">For a deserialized object, if the XML reader (or the data therein) comes from partially-trusted code, treat the resulting deserialized object as untrusted data.</span></span>

- <span data-ttu-id="696d4-467">El hecho de que el tipo <xref:System.Runtime.Serialization.ExtensionDataObject> no tenga ningún miembro público no significa que los datos dentro de él sean seguros.</span><span class="sxs-lookup"><span data-stu-id="696d4-467">The fact that the <xref:System.Runtime.Serialization.ExtensionDataObject> type has no public members does not mean that data within it is secure.</span></span> <span data-ttu-id="696d4-468">Por ejemplo, si deserializa desde un origen de datos privilegiado a un objeto en el que residen algunos datos, entregue el objeto al código de confianza parcial, éste puede leer los datos del `ExtensionDataObject` serializando el objeto.</span><span class="sxs-lookup"><span data-stu-id="696d4-468">For example, if you deserialize from a privileged data source into an object in which some data resides, then hand that object to partially-trusted code, the partially-trusted code can read the data in the `ExtensionDataObject` by serializing the object.</span></span> <span data-ttu-id="696d4-469">Considere establecer <xref:System.Runtime.Serialization.DataContractSerializer.IgnoreExtensionDataObject%2A> en `true` cuando realice la deserialización desde un origen de datos con privilegios en un objeto que se pase después al código de confianza parcial.</span><span class="sxs-lookup"><span data-stu-id="696d4-469">Consider setting <xref:System.Runtime.Serialization.DataContractSerializer.IgnoreExtensionDataObject%2A> to `true` when deserializing from a privileged data source into an object that is later passed to partially-trusted code.</span></span>

- <span data-ttu-id="696d4-470"><xref:System.Runtime.Serialization.DataContractSerializer> y <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> admiten la serialización de miembros privados, protegidos, internos y públicos con plena confianza.</span><span class="sxs-lookup"><span data-stu-id="696d4-470"><xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> support the serialization of private, protected, internal, and public members in full trust.</span></span> <span data-ttu-id="696d4-471">Sin embargo, en confianza parcial, solo se pueden serializar los miembros públicos.</span><span class="sxs-lookup"><span data-stu-id="696d4-471">However, in partial trust, only public members can be serialized.</span></span> <span data-ttu-id="696d4-472">Se inicia una excepción <xref:System.Security.SecurityException> si una aplicación intenta serializar un miembro no público.</span><span class="sxs-lookup"><span data-stu-id="696d4-472">A <xref:System.Security.SecurityException> is thrown if an application attempts to serialize a non-public member.</span></span>

    <span data-ttu-id="696d4-473">Para permitir la serialización de los miembros internos o los miembros internos protegidos con confianza parcial, utilice el atributo de ensamblado <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> .</span><span class="sxs-lookup"><span data-stu-id="696d4-473">To allow internal or protected internal members to be serialized in partial trust, use the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> assembly attribute.</span></span> <span data-ttu-id="696d4-474">Este atributo permite a un ensamblado declarar que sus miembros internos están visibles para algún otro ensamblado.</span><span class="sxs-lookup"><span data-stu-id="696d4-474">This attribute allows an assembly to declare that its internal members are visible to some other assembly.</span></span> <span data-ttu-id="696d4-475">En este caso, un ensamblado que desee la serialización de sus miembros internos declara que sus miembros internos estén visibles para System.Runtime.Serialization.dll.</span><span class="sxs-lookup"><span data-stu-id="696d4-475">In this case, an assembly that wants to have its internal members serialized declares that its internal members are visible to System.Runtime.Serialization.dll.</span></span>

    <span data-ttu-id="696d4-476">La ventaja de este enfoque es que no requiere una ruta de acceso de generación de código elevada.</span><span class="sxs-lookup"><span data-stu-id="696d4-476">The advantage of this approach is that it does not require an elevated code generation path.</span></span>

    <span data-ttu-id="696d4-477">Al mismo tiempo, hay dos inconvenientes importantes.</span><span class="sxs-lookup"><span data-stu-id="696d4-477">At the same time, there are two major disadvantages.</span></span>

    <span data-ttu-id="696d4-478">El primero es que la propiedad de participación del atributo <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> afecta a todo el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="696d4-478">The first disadvantage is that the opt-in property of the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> attribute is assembly-wide.</span></span> <span data-ttu-id="696d4-479">Es decir, no puede especificar que solo se serialicen los miembros internos de una clase determinada.</span><span class="sxs-lookup"><span data-stu-id="696d4-479">That is, you cannot specify that only a certain class can have its internal members serialized.</span></span> <span data-ttu-id="696d4-480">No cabe duda de que todavía puede decidir no serializar un miembro interno concreto. Basta con no agregar un atributo <xref:System.Runtime.Serialization.DataMemberAttribute> a ese miembro.</span><span class="sxs-lookup"><span data-stu-id="696d4-480">Of course, you can still choose not to serialize a specific internal member, by simply not adding a <xref:System.Runtime.Serialization.DataMemberAttribute> attribute to that member.</span></span> <span data-ttu-id="696d4-481">De igual forma, un desarrollador también puede decidir que un miembro sea interno en lugar de privado o protegido, con ligeros problemas de visibilidad.</span><span class="sxs-lookup"><span data-stu-id="696d4-481">Similarly, a developer can also choose to make a member internal rather than private or protected, with slight visibility concerns.</span></span>

    <span data-ttu-id="696d4-482">El segundo inconveniente es que todavía no se admiten miembros privados o protegidos.</span><span class="sxs-lookup"><span data-stu-id="696d4-482">The second disadvantage is that it still does not support private or protected members.</span></span>

    <span data-ttu-id="696d4-483">Para mostrar el uso del atributo <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> en confianza parcial, considere el siguiente programa:</span><span class="sxs-lookup"><span data-stu-id="696d4-483">To illustrate the use of the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> attribute in partial trust, consider the following program:</span></span>

    [!code-csharp[CDF_WCF_SecurityConsiderationsForData#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/cdf_wcf_securityconsiderationsfordata/cs/program.cs#1)]

    <span data-ttu-id="696d4-484">En el ejemplo anterior, `PermissionsHelper.InternetZone` corresponde a <xref:System.Security.PermissionSet> para confianza parcial.</span><span class="sxs-lookup"><span data-stu-id="696d4-484">In the example above, `PermissionsHelper.InternetZone` corresponds to the <xref:System.Security.PermissionSet> for partial trust.</span></span> <span data-ttu-id="696d4-485">Ahora, sin el <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> atributo, se producirá un error en la aplicación y se iniciará una excepción que <xref:System.Security.SecurityException> indica que los miembros no públicos no se pueden serializar en confianza parcial.</span><span class="sxs-lookup"><span data-stu-id="696d4-485">Now, without the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> attribute, the application will fail, throwing a <xref:System.Security.SecurityException> indicating that non-public members cannot be serialized in partial trust.</span></span>

    <span data-ttu-id="696d4-486">Sin embargo, si agregamos la siguiente línea al archivo de código fuente, el programa se ejecuta correctamente.</span><span class="sxs-lookup"><span data-stu-id="696d4-486">However, if we add the following line to the source file, the program runs successfully.</span></span>

    [!code-csharp[CDF_WCF_SecurityConsiderationsForData#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/cdf_wcf_securityconsiderationsfordata/cs/program.cs#2)]

## <a name="other-state-management-concerns"></a><span data-ttu-id="696d4-487">Otros problemas relativos a la administración de estados</span><span class="sxs-lookup"><span data-stu-id="696d4-487">Other State Management Concerns</span></span>

<span data-ttu-id="696d4-488">Cabe mencionar otros problemas relacionados con la administración de los estados de objeto:</span><span class="sxs-lookup"><span data-stu-id="696d4-488">A few other concerns regarding object state management are worth mentioning:</span></span>

- <span data-ttu-id="696d4-489">Al utilizar el modelo de programación basado en secuencias con un transporte de transmisión por secuencias, el procesamiento del mensaje se produce cuando llega el mensaje.</span><span class="sxs-lookup"><span data-stu-id="696d4-489">When using the stream-based programming model with a streaming transport, processing of the message occurs as the message arrives.</span></span> <span data-ttu-id="696d4-490">El remitente del mensaje puede anular la operación de envío en medio de la secuencia, dejando su código en un estado imprevisible si se esperaba más contenido.</span><span class="sxs-lookup"><span data-stu-id="696d4-490">The sender of the message may abort the send operation in the middle of the stream, leaving your code in an unpredictable state if more content was expected.</span></span> <span data-ttu-id="696d4-491">En general, no confíe en que la secuencia sea completa y no realice ningún trabajo en una operación basada en secuencias que no se pueda deshacer en caso de que se anule la secuencia.</span><span class="sxs-lookup"><span data-stu-id="696d4-491">In general, do not rely on the stream being complete, and do not perform any work in a stream-based operation that cannot be rolled back in case the stream is aborted.</span></span> <span data-ttu-id="696d4-492">Esto también se aplica a la situación donde un mensaje puede estar malformado después del cuerpo de transmisión por secuencias (por ejemplo, puede faltar una etiqueta de cierre para el sobre SOAP o puede tener un segundo cuerpo del mensaje).</span><span class="sxs-lookup"><span data-stu-id="696d4-492">This also applies to the situation where a message may be malformed after the streaming body (for example, it may be missing an end tag for the SOAP envelope or may have a second message body).</span></span>

- <span data-ttu-id="696d4-493">Utilizar la característica `IExtensibleDataObject` puede provocar que se emitan datos confidenciales.</span><span class="sxs-lookup"><span data-stu-id="696d4-493">Using the `IExtensibleDataObject` feature may cause sensitive data to be emitted.</span></span> <span data-ttu-id="696d4-494">Si está aceptando datos desde un origen que no es de confianza a los contratos de datos con `IExtensibleObjectData` y después vuelve a emitir en un canal seguro en el que se firman los mensajes, está respondiendo potencialmente de datos sobre los que no sabe absolutamente nada.</span><span class="sxs-lookup"><span data-stu-id="696d4-494">If you are accepting data from an untrusted source into data contracts with `IExtensibleObjectData` and later re-emitting it on a secure channel where messages are signed, you are potentially vouching for data you know nothing about.</span></span> <span data-ttu-id="696d4-495">Es más, el estado total que está enviando puede no ser válido si tiene en cuenta tanto las partes conocidas como desconocidas de los datos.</span><span class="sxs-lookup"><span data-stu-id="696d4-495">Moreover, the overall state you are sending may be invalid if you take both the known and unknown pieces of data into account.</span></span> <span data-ttu-id="696d4-496">Evite esta situación estableciendo selectivamente la propiedad de datos de extensión en `null` o deshabilitando selectivamente la característica `IExtensibleObjectData` .</span><span class="sxs-lookup"><span data-stu-id="696d4-496">Avoid this situation by either selectively setting the extension data property to `null` or by selectively disabling the `IExtensibleObjectData` feature.</span></span>

## <a name="schema-import"></a><span data-ttu-id="696d4-497">Importación de esquema</span><span class="sxs-lookup"><span data-stu-id="696d4-497">Schema Import</span></span>

<span data-ttu-id="696d4-498">Normalmente, el proceso de importar el esquema para generar los tipos solo sucede en tiempo de diseño, por ejemplo, al usar [ServiceModel Metadata Utility Tool (Svcutil.exe)](../servicemodel-metadata-utility-tool-svcutil-exe.md) en un servicio Web para generar una clase de cliente.</span><span class="sxs-lookup"><span data-stu-id="696d4-498">Normally, the process of importing schema to generate types happens only at design time, for example, when using the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../servicemodel-metadata-utility-tool-svcutil-exe.md) on a Web service to generate a client class.</span></span> <span data-ttu-id="696d4-499">Sin embargo, en escenarios más avanzados, puede procesar el esquema en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="696d4-499">However, in more advanced scenarios, you may process schema at runtime.</span></span> <span data-ttu-id="696d4-500">Tenga en cuenta que hacerlo puede exponerle a los riesgos de la denegación de servicio.</span><span class="sxs-lookup"><span data-stu-id="696d4-500">Be aware that doing so can expose you to denial-of-service risks.</span></span> <span data-ttu-id="696d4-501">Algunos esquemas pueden tardar mucho tiempo en importarse.</span><span class="sxs-lookup"><span data-stu-id="696d4-501">Some schema may take a long time to be imported.</span></span> <span data-ttu-id="696d4-502">No utilice nunca el componente de importación de esquema <xref:System.Xml.Serialization.XmlSerializer> en tales escenarios si es posible que los esquemas procedan de un origen que no es de confianza.</span><span class="sxs-lookup"><span data-stu-id="696d4-502">Never use the <xref:System.Xml.Serialization.XmlSerializer> schema import component in such scenarios if schemas are possibly coming from an untrusted source.</span></span>

## <a name="threats-specific-to-aspnet-ajax-integration"></a><span data-ttu-id="696d4-503">Amenazas específicas de la integración de AJAX de ASP.NET</span><span class="sxs-lookup"><span data-stu-id="696d4-503">Threats Specific to ASP.NET AJAX Integration</span></span>

<span data-ttu-id="696d4-504">Cuando el usuario implementa <xref:System.ServiceModel.Description.WebScriptEnablingBehavior> o <xref:System.ServiceModel.Description.WebHttpBehavior> , WCF expone un punto de conexión que puede aceptar mensajes XML y JSON.</span><span class="sxs-lookup"><span data-stu-id="696d4-504">When the user implements <xref:System.ServiceModel.Description.WebScriptEnablingBehavior> or <xref:System.ServiceModel.Description.WebHttpBehavior>, WCF exposes an endpoint that can accept both XML and JSON messages.</span></span> <span data-ttu-id="696d4-505">No obstante, solo existe un conjunto de cuotas de lector, utilizado tanto por el lector XML como por el lector JSON.</span><span class="sxs-lookup"><span data-stu-id="696d4-505">However, there is only one set of reader quotas, used both by the XML reader and the JSON reader.</span></span> <span data-ttu-id="696d4-506">Algunos valores de cuota pueden ser apropiados para un lector pero demasiado grandes para otro.</span><span class="sxs-lookup"><span data-stu-id="696d4-506">Some quota settings may be appropriate for one reader but too large for the other.</span></span>

<span data-ttu-id="696d4-507">Al implementar `WebScriptEnablingBehavior`, el usuario tiene la opción de exponer un proxy de JavaScript en el extremo.</span><span class="sxs-lookup"><span data-stu-id="696d4-507">When implementing `WebScriptEnablingBehavior`, the user has the option to expose a JavaScript proxy at the endpoint.</span></span> <span data-ttu-id="696d4-508">Deben tenerse en cuenta las siguientes cuestiones relacionadas con la seguridad:</span><span class="sxs-lookup"><span data-stu-id="696d4-508">The following security issues must be considered:</span></span>

- <span data-ttu-id="696d4-509">Puede obtenerse información acerca del servicio (nombres de operación, nombres de parámetro, etc.) mediante el examen del proxy de JavaScript.</span><span class="sxs-lookup"><span data-stu-id="696d4-509">Information about the service (operation names, parameter names, and so on) can be obtained by examining the JavaScript proxy.</span></span>

- <span data-ttu-id="696d4-510">Al utilizar el extremo de JavaScript, la información confidencial y privada puede retenerse en la memoria caché del explorador web cliente.</span><span class="sxs-lookup"><span data-stu-id="696d4-510">When using the JavaScript endpoint, sensitive and private information might be retained in the client Web browser cache.</span></span>

## <a name="a-note-on-components"></a><span data-ttu-id="696d4-511">Un nota sobre componentes</span><span class="sxs-lookup"><span data-stu-id="696d4-511">A Note on Components</span></span>

<span data-ttu-id="696d4-512">WCF es un sistema flexible y personalizable.</span><span class="sxs-lookup"><span data-stu-id="696d4-512">WCF is a flexible and customizable system.</span></span> <span data-ttu-id="696d4-513">La mayor parte del contenido de este tema se centra en los escenarios de uso más comunes de WCF.</span><span class="sxs-lookup"><span data-stu-id="696d4-513">Most of the contents of this topic focus on the most common WCF usage scenarios.</span></span> <span data-ttu-id="696d4-514">Sin embargo, es posible crear componentes que WCF proporciona de muchas maneras diferentes.</span><span class="sxs-lookup"><span data-stu-id="696d4-514">However, it is possible to compose components WCF provides in many different ways.</span></span> <span data-ttu-id="696d4-515">Es importante entender las implicaciones de seguridad de utilizar cada componente.</span><span class="sxs-lookup"><span data-stu-id="696d4-515">It is important to understand the security implications of using each component.</span></span> <span data-ttu-id="696d4-516">En concreto:</span><span class="sxs-lookup"><span data-stu-id="696d4-516">In particular:</span></span>

- <span data-ttu-id="696d4-517">Cuando deba utilizar lectores XML, utilice los lectores que la clase <xref:System.Xml.XmlDictionaryReader> proporciona en oposición a cualquier otro lector.</span><span class="sxs-lookup"><span data-stu-id="696d4-517">When you must use XML readers, use the readers the <xref:System.Xml.XmlDictionaryReader> class provides as opposed to any other readers.</span></span> <span data-ttu-id="696d4-518">Los lectores seguros se crean utilizando los métodos <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A>, <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A>o <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> .</span><span class="sxs-lookup"><span data-stu-id="696d4-518">Safe readers are created using <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A>, <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A>, or <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> methods.</span></span> <span data-ttu-id="696d4-519">No utilice el método <xref:System.Xml.XmlReader.Create%2A> .</span><span class="sxs-lookup"><span data-stu-id="696d4-519">Do not use the <xref:System.Xml.XmlReader.Create%2A> method.</span></span> <span data-ttu-id="696d4-520">Configure siempre los lectores con cuotas seguras.</span><span class="sxs-lookup"><span data-stu-id="696d4-520">Always configure the readers with safe quotas.</span></span> <span data-ttu-id="696d4-521">Los motores de serialización en WCF solo son seguros cuando se utilizan con lectores XML seguros de WCF.</span><span class="sxs-lookup"><span data-stu-id="696d4-521">The serialization engines in WCF are secure only when used with secure XML readers from WCF.</span></span>

- <span data-ttu-id="696d4-522">Al utilizar <xref:System.Runtime.Serialization.DataContractSerializer> para deserializar los datos que potencialmente no son de confianza, establezca siempre la propiedad <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> .</span><span class="sxs-lookup"><span data-stu-id="696d4-522">When using the <xref:System.Runtime.Serialization.DataContractSerializer> to deserialize potentially untrusted data, always set the <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> property.</span></span>

- <span data-ttu-id="696d4-523">Al crear un mensaje, establezca el parámetro `maxSizeOfHeaders` si `MaxReceivedMessageSize` no proporciona protección suficiente.</span><span class="sxs-lookup"><span data-stu-id="696d4-523">When creating a message, set the `maxSizeOfHeaders` parameter if `MaxReceivedMessageSize` does not offer enough protection.</span></span>

- <span data-ttu-id="696d4-524">Al crear un codificador, configure siempre las cuotas pertinentes, como `MaxSessionSize` y `MaxBufferSize`.</span><span class="sxs-lookup"><span data-stu-id="696d4-524">When creating an encoder, always configure the relevant quotas, such as `MaxSessionSize` and `MaxBufferSize`.</span></span>

- <span data-ttu-id="696d4-525">Al utilizar un filtro de mensajes XPath, establezca <xref:System.ServiceModel.Dispatcher.XPathMessageFilter.NodeQuota%2A> para limitar la cantidad de nodos XML que el filtro visita.</span><span class="sxs-lookup"><span data-stu-id="696d4-525">When using an XPath message filter, set the <xref:System.ServiceModel.Dispatcher.XPathMessageFilter.NodeQuota%2A> to limit the amount of XML nodes the filter visits.</span></span> <span data-ttu-id="696d4-526">No utilice expresiones XPath que podrían tardar mucho tiempo en calcularse sin visitar muchos nodos.</span><span class="sxs-lookup"><span data-stu-id="696d4-526">Do not use XPath expressions that could take a long time to compute without visiting many nodes.</span></span>

- <span data-ttu-id="696d4-527">En general, al utilizar cualquier componente que acepte una cuota, entienda sus implicaciones de seguridad y establézcalo en un valor seguro.</span><span class="sxs-lookup"><span data-stu-id="696d4-527">In general, when using any component that accepts a quota, understand its security implications and set it to a safe value.</span></span>

## <a name="see-also"></a><span data-ttu-id="696d4-528">Vea también</span><span class="sxs-lookup"><span data-stu-id="696d4-528">See also</span></span>

- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Xml.XmlDictionaryReader>
- <xref:System.Xml.Serialization.XmlSerializer>
- [<span data-ttu-id="696d4-529">Tipos conocidos de contratos de datos</span><span class="sxs-lookup"><span data-stu-id="696d4-529">Data Contract Known Types</span></span>](data-contract-known-types.md)
