---
description: 'Más información sobre: control de versiones de contratos de datos'
title: Versiones de contratos de datos
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- versioning [WCF], data contracts
- versioning [WCF]
- data contracts [WCF], versioning
ms.assetid: 4a0700cb-5f5f-4137-8705-3a3ecf06461f
ms.openlocfilehash: 89b99ccad1671d33383cfce8d25b241d71788670
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 02/06/2021
ms.locfileid: "99756609"
---
# <a name="data-contract-versioning"></a><span data-ttu-id="dad67-103">Versiones de contratos de datos</span><span class="sxs-lookup"><span data-stu-id="dad67-103">Data Contract Versioning</span></span>

<span data-ttu-id="dad67-104">A medida que las aplicaciones evolucionan, es posible que tenga que cambiar los contratos de datos que utilizan los servicios.</span><span class="sxs-lookup"><span data-stu-id="dad67-104">As applications evolve, you may also have to change the data contracts the services use.</span></span> <span data-ttu-id="dad67-105">En este tema se explica cómo controlar las versiones de los contratos de datos.</span><span class="sxs-lookup"><span data-stu-id="dad67-105">This topic explains how to version data contracts.</span></span> <span data-ttu-id="dad67-106">En este tema se describen los mecanismos de control de versiones de los contratos de datos.</span><span class="sxs-lookup"><span data-stu-id="dad67-106">This topic describes the data contract versioning mechanisms.</span></span> <span data-ttu-id="dad67-107">Para obtener información general completa y una guía de versiones prescriptiva, vea [procedimientos recomendados: control de versiones de contratos de datos](../best-practices-data-contract-versioning.md).</span><span class="sxs-lookup"><span data-stu-id="dad67-107">For a complete overview and prescriptive versioning guidance, see [Best Practices: Data Contract Versioning](../best-practices-data-contract-versioning.md).</span></span>  
  
## <a name="breaking-vs-nonbreaking-changes"></a><span data-ttu-id="dad67-108">Cambios con interrupción y sin interrupción</span><span class="sxs-lookup"><span data-stu-id="dad67-108">Breaking vs. Nonbreaking Changes</span></span>  

 <span data-ttu-id="dad67-109">Los cambios en un contrato de datos pueden ser con o sin interrupción.</span><span class="sxs-lookup"><span data-stu-id="dad67-109">Changes to a data contract can be breaking or nonbreaking.</span></span> <span data-ttu-id="dad67-110">Cuando un contrato de datos se cambia de una manera sin interrupción, una aplicación que use la versión anterior del contrato puede comunicarse con una aplicación utilizando la versión más reciente y una aplicación que utilice la versión más reciente del contrato puede comunicarse con una aplicación que utilice la versión anterior.</span><span class="sxs-lookup"><span data-stu-id="dad67-110">When a data contract is changed in a nonbreaking way, an application using the older version of the contract can communicate with an application using the newer version, and an application using the newer version of the contract can communicate with an application using the older version.</span></span> <span data-ttu-id="dad67-111">Por otro lado, un cambio con interrupción evita la comunicación en una o ambas direcciones.</span><span class="sxs-lookup"><span data-stu-id="dad67-111">On the other hand, a breaking change prevents communication in one or both directions.</span></span>  
  
 <span data-ttu-id="dad67-112">Los cambios realizados en un tipo que no afecten a la forma de la transmisión y recepción son cambios sin interrupción.</span><span class="sxs-lookup"><span data-stu-id="dad67-112">Any changes to a type that do not affect how it is transmitted and received are nonbreaking.</span></span> <span data-ttu-id="dad67-113">Tales cambios no cambian el contrato de datos, solo el tipo subyacente.</span><span class="sxs-lookup"><span data-stu-id="dad67-113">Such changes do not change the data contract, only the underlying type.</span></span> <span data-ttu-id="dad67-114">Por ejemplo, puede cambiar el nombre de un campo de una manera sin interrupción si establece a continuación la propiedad <xref:System.Runtime.Serialization.DataMemberAttribute.Name%2A> de <xref:System.Runtime.Serialization.DataMemberAttribute> en el nombre de la versión anterior.</span><span class="sxs-lookup"><span data-stu-id="dad67-114">For example, you can change the name of a field in a nonbreaking way if you then set the <xref:System.Runtime.Serialization.DataMemberAttribute.Name%2A> property of the <xref:System.Runtime.Serialization.DataMemberAttribute> to the older version name.</span></span> <span data-ttu-id="dad67-115">El código siguiente muestra la versión 1 de un contrato de datos.</span><span class="sxs-lookup"><span data-stu-id="dad67-115">The following code shows version 1 of a data contract.</span></span>  
  
 [!code-csharp[C_DataContractVersioning#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_datacontractversioning/cs/source.cs#1)]
 [!code-vb[C_DataContractVersioning#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_datacontractversioning/vb/source.vb#1)]  
  
 <span data-ttu-id="dad67-116">El código siguiente muestra un cambio sin interrupción.</span><span class="sxs-lookup"><span data-stu-id="dad67-116">The following code shows a nonbreaking change.</span></span>  
  
 [!code-csharp[C_DataContractVersioning#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_datacontractversioning/cs/source.cs#2)]
 [!code-vb[C_DataContractVersioning#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_datacontractversioning/vb/source.vb#2)]  
  
 <span data-ttu-id="dad67-117">Algunos cambios modifican los datos transmitidos, pero puede que sean o no cambios con interrupción.</span><span class="sxs-lookup"><span data-stu-id="dad67-117">Some changes do modify the transmitted data, but may or may not be breaking.</span></span> <span data-ttu-id="dad67-118">Los siguientes cambios siempre son con interrupción:</span><span class="sxs-lookup"><span data-stu-id="dad67-118">The following changes are always breaking:</span></span>  
  
- <span data-ttu-id="dad67-119">Cambio del valor <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A> o <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A> de un contrato de datos.</span><span class="sxs-lookup"><span data-stu-id="dad67-119">Changing the <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A> or <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A> value of a data contract.</span></span>  
  
- <span data-ttu-id="dad67-120">Cambio del orden de miembros de datos utilizando la propiedad <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A> de <xref:System.Runtime.Serialization.DataMemberAttribute>.</span><span class="sxs-lookup"><span data-stu-id="dad67-120">Changing the order of data members by using the <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A> property of the <xref:System.Runtime.Serialization.DataMemberAttribute>.</span></span>  
  
- <span data-ttu-id="dad67-121">Cambio de nombre de un miembro de datos.</span><span class="sxs-lookup"><span data-stu-id="dad67-121">Renaming a data member.</span></span>  
  
- <span data-ttu-id="dad67-122">Cambio del contrato de datos de un miembro de datos.</span><span class="sxs-lookup"><span data-stu-id="dad67-122">Changing the data contract of a data member.</span></span> <span data-ttu-id="dad67-123">Por ejemplo, cambiar el tipo de miembro de datos de entero a cadena, o de un tipo con un contrato de datos denominado "Cliente" a un tipo con un contrato de datos denominado "Persona."</span><span class="sxs-lookup"><span data-stu-id="dad67-123">For example, changing the type of data member from an integer to a string, or from a type with a data contract named "Customer" to a type with a data contract named "Person".</span></span>  
  
 <span data-ttu-id="dad67-124">Los cambios siguientes también son posibles.</span><span class="sxs-lookup"><span data-stu-id="dad67-124">The following changes are also possible.</span></span>  
  
## <a name="adding-and-removing-data-members"></a><span data-ttu-id="dad67-125">Agregar y eliminar miembros de datos</span><span class="sxs-lookup"><span data-stu-id="dad67-125">Adding and Removing Data Members</span></span>  

 <span data-ttu-id="dad67-126">En la mayoría de los casos, agregar o eliminar un miembro de datos no es un cambio con interrupción, a menos que requiera validez estricta de esquema (las nuevas instancias se validan frente al esquema anterior).</span><span class="sxs-lookup"><span data-stu-id="dad67-126">In most cases, adding or removing a data member is not a breaking change, unless you require strict schema validity (new instances validating against the old schema).</span></span>  
  
 <span data-ttu-id="dad67-127">Cuando un tipo con un campo adicional se deserializa en un tipo con un campo que falta, se pasa por alto la información adicional.</span><span class="sxs-lookup"><span data-stu-id="dad67-127">When a type with an extra field is deserialized into a type with a missing field, the extra information is ignored.</span></span> <span data-ttu-id="dad67-128">(También puede almacenarse para fines de ida y vuelta; para obtener más información, consulte [contratos de datos compatibles con el avance](forward-compatible-data-contracts.md)).</span><span class="sxs-lookup"><span data-stu-id="dad67-128">(It may also be stored for round-tripping purposes; for more information, see [Forward-Compatible Data Contracts](forward-compatible-data-contracts.md)).</span></span>  
  
 <span data-ttu-id="dad67-129">Cuando un tipo con un campo que falta se deserializa en un tipo con un campo adicional, el campo adicional se deja en su valor predeterminado, normalmente cero o `null`.</span><span class="sxs-lookup"><span data-stu-id="dad67-129">When a type with a missing field is deserialized into a type with an extra field, the extra field is left at its default value, usually zero or `null`.</span></span> <span data-ttu-id="dad67-130">(Se puede cambiar el valor predeterminado; para obtener más información, vea [devoluciones de llamada de serialización tolerante a versiones](version-tolerant-serialization-callbacks.md)).</span><span class="sxs-lookup"><span data-stu-id="dad67-130">(The default value may be changed; for more information, see [Version-Tolerant Serialization Callbacks](version-tolerant-serialization-callbacks.md).)</span></span>  
  
 <span data-ttu-id="dad67-131">Por ejemplo, puede utilizar la clase `CarV1` en un cliente y la clase `CarV2` en un servicio, o puede utilizar la clase `CarV1` en un servicio y la clase `CarV2` en un cliente.</span><span class="sxs-lookup"><span data-stu-id="dad67-131">For example, you can use the `CarV1` class on a client and the `CarV2` class on a service, or you can use the `CarV1` class on a service and the `CarV2` class on a client.</span></span>  
  
 [!code-csharp[C_DataContractVersioning#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_datacontractversioning/cs/source.cs#3)]
 [!code-vb[C_DataContractVersioning#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_datacontractversioning/vb/source.vb#3)]  
  
 <span data-ttu-id="dad67-132">El punto de conexión de versión 2 puede enviar datos correctamente al punto de conexión de versión 1.</span><span class="sxs-lookup"><span data-stu-id="dad67-132">The version 2 endpoint can successfully send data to the version 1 endpoint.</span></span> <span data-ttu-id="dad67-133">La serialización de la versión 2 del contrato de datos de `Car` produce un XML similar al siguiente.</span><span class="sxs-lookup"><span data-stu-id="dad67-133">Serializing version 2 of the `Car` data contract yields XML similar to the following.</span></span>  
  
```xml  
<Car>  
    <Model>Porsche</Model>  
    <HorsePower>300</HorsePower>  
</Car>  
```  
  
 <span data-ttu-id="dad67-134">El motor de deserialización en V1 no encuentra un miembro de datos coincidente para el campo `HorsePower` y descarta esos datos.</span><span class="sxs-lookup"><span data-stu-id="dad67-134">The deserialization engine on V1 does not find a matching data member for the `HorsePower` field, and discards that data.</span></span>  
  
 <span data-ttu-id="dad67-135">Asimismo, el punto de conexión de versión 1 puede enviar datos al punto de conexión de versión 2.</span><span class="sxs-lookup"><span data-stu-id="dad67-135">Also, the version 1 endpoint can send data to the version 2 endpoint.</span></span> <span data-ttu-id="dad67-136">La serialización de la versión 1 del contrato de datos de `Car` produce un XML similar al siguiente.</span><span class="sxs-lookup"><span data-stu-id="dad67-136">Serializing version 1 of the `Car` data contract yields XML similar to the following.</span></span>  
  
```xml  
<Car>  
    <Model>Porsche</Model>  
</Car>  
```  
  
 <span data-ttu-id="dad67-137">El deserializador de versión 2 no sabe qué valor asignar al campo `HorsePower`, porque no hay datos coincidentes en el XML de entrada.</span><span class="sxs-lookup"><span data-stu-id="dad67-137">The version 2 deserializer does not know what to set the `HorsePower` field to, because there is no matching data in the incoming XML.</span></span> <span data-ttu-id="dad67-138">En su lugar, el campo se establece en el valor predeterminado de 0.</span><span class="sxs-lookup"><span data-stu-id="dad67-138">Instead, the field is set to the default value of 0.</span></span>  
  
## <a name="required-data-members"></a><span data-ttu-id="dad67-139">Miembros de datos necesarios</span><span class="sxs-lookup"><span data-stu-id="dad67-139">Required Data Members</span></span>  

 <span data-ttu-id="dad67-140">Un miembro de datos se puede marcar como necesario estableciendo la propiedad <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> de <xref:System.Runtime.Serialization.DataMemberAttribute> en `true`.</span><span class="sxs-lookup"><span data-stu-id="dad67-140">A data member may be marked as being required by setting the <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> property of the <xref:System.Runtime.Serialization.DataMemberAttribute> to `true`.</span></span> <span data-ttu-id="dad67-141">Si faltan datos necesarios al deserializar, se genera una excepción en lugar de establecer el miembro de datos en su valor predeterminado.</span><span class="sxs-lookup"><span data-stu-id="dad67-141">If required data is missing while deserializing, an exception is thrown instead of setting the data member to its default value.</span></span>  
  
 <span data-ttu-id="dad67-142">Agregar un miembro de datos necesario es un cambio con interrupción.</span><span class="sxs-lookup"><span data-stu-id="dad67-142">Adding a required data member is a breaking change.</span></span> <span data-ttu-id="dad67-143">Es decir, el tipo más nuevo todavía puede enviarse a los puntos de conexión con el tipo anterior, pero no al revés.</span><span class="sxs-lookup"><span data-stu-id="dad67-143">That is, the newer type can still be sent to endpoints with the older type, but not the other way around.</span></span> <span data-ttu-id="dad67-144">Eliminar un miembro de datos marcado como necesario en cualquier versión anterior también es un cambio con interrupción.</span><span class="sxs-lookup"><span data-stu-id="dad67-144">Removing a data member that was marked as required in any prior version is also a breaking change.</span></span>  
  
 <span data-ttu-id="dad67-145">Cambiar el valor de la propiedad <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> de `true` a `false` no es un cambio con interrupción, pero cambiarlo de `false` a `true` puede ser un cambio con interrupción si cualquier versión anterior del tipo no tiene el miembro de datos en cuestión.</span><span class="sxs-lookup"><span data-stu-id="dad67-145">Changing the <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> property value from `true` to `false` is not breaking, but changing it from `false` to `true` may be breaking if any prior versions of the type do not have the data member in question.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="dad67-146">Aunque la propiedad <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> se establezca en `true`, el dato entrante puede ser nulo o cero, y se debe preparar un tipo para afrontar esta posibilidad.</span><span class="sxs-lookup"><span data-stu-id="dad67-146">Although the <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> property is set to `true`, the incoming data may be null or zero, and a type must be prepared to handle this possibility.</span></span> <span data-ttu-id="dad67-147">No utilice <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> como mecanismo de seguridad frente a datos entrante no válidos.</span><span class="sxs-lookup"><span data-stu-id="dad67-147">Do not use <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> as a security mechanism to protect against bad incoming data.</span></span>  
  
## <a name="omitted-default-values"></a><span data-ttu-id="dad67-148">Valores predeterminados ignorados</span><span class="sxs-lookup"><span data-stu-id="dad67-148">Omitted Default Values</span></span>  

 <span data-ttu-id="dad67-149">Es posible (aunque no se recomienda) establecer la `EmitDefaultValue` propiedad en el atributo DataMemberAttribute en `false` , tal y como se describe en [valores predeterminados de los miembros de datos](data-member-default-values.md).</span><span class="sxs-lookup"><span data-stu-id="dad67-149">It is possible (although not recommended) to set the `EmitDefaultValue` property on the DataMemberAttribute attribute to `false`, as described in [Data Member Default Values](data-member-default-values.md).</span></span> <span data-ttu-id="dad67-150">Si este valor es `false`, no se emitirá el miembro de datos si está establecido en su valor predeterminado (normalmente null o cero).</span><span class="sxs-lookup"><span data-stu-id="dad67-150">If this setting is `false`, the data member will not be emitted if it is set to its default value (usually null or zero).</span></span> <span data-ttu-id="dad67-151">Esto no es compatible con miembros de datos necesarios en versiones diferentes de dos maneras:</span><span class="sxs-lookup"><span data-stu-id="dad67-151">This is not compatible with required data members in different versions in two ways:</span></span>  
  
- <span data-ttu-id="dad67-152">Un contrato de datos con un miembro de datos necesario en una versión no puede recibir datos predeterminados (null o cero) de una versión diferente en la que el miembro de datos tenga `EmitDefaultValue` establecido en `false`.</span><span class="sxs-lookup"><span data-stu-id="dad67-152">A data contract with a data member that is required in one version cannot receive default (null or zero) data from a different version in which the data member has `EmitDefaultValue` set to `false`.</span></span>  
  
- <span data-ttu-id="dad67-153">Un miembro de datos necesario que tiene `EmitDefaultValue` establecido en `false` no se puede utilizar para serializar su valor predeterminado (null o cero), pero puede recibir este tipo de valor en la deserialización.</span><span class="sxs-lookup"><span data-stu-id="dad67-153">A required data member that has `EmitDefaultValue` set to `false` cannot be used to serialize its default (null or zero) value, but can receive such a value on deserialization.</span></span> <span data-ttu-id="dad67-154">Esto crea un problema de ida y vuelta (los datos se pueden leer pero los mismos datos no se pueden escribir a continuación).</span><span class="sxs-lookup"><span data-stu-id="dad67-154">This creates a round-tripping problem (data can be read in but the same data cannot then be written out).</span></span> <span data-ttu-id="dad67-155">Por consiguiente, si `IsRequired` es `true` y `EmitDefaultValue` es `false` en una versión, la misma combinación se debería aplicar al resto de versiones, de tal manera que ninguna versión del contrato de datos pudiese generar un valor que no resulte en un recorrido de ida y vuelta.</span><span class="sxs-lookup"><span data-stu-id="dad67-155">Therefore, if `IsRequired` is `true` and `EmitDefaultValue` is `false` in one version, the same combination should apply to all other versions such that no version of the data contract would be able to produce a value that does not result in a round trip.</span></span>  
  
## <a name="schema-considerations"></a><span data-ttu-id="dad67-156">Consideraciones del esquema</span><span class="sxs-lookup"><span data-stu-id="dad67-156">Schema Considerations</span></span>  

 <span data-ttu-id="dad67-157">Para obtener una explicación del esquema que se genera para los tipos de contrato de datos, vea [referencia de esquema de contrato de datos](data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="dad67-157">For an explanation of what schema is produced for data contract types, see [Data Contract Schema Reference](data-contract-schema-reference.md).</span></span>  
  
 <span data-ttu-id="dad67-158">El esquema que WCF genera para los tipos de contrato de datos no hace ninguna disposición para el control de versiones.</span><span class="sxs-lookup"><span data-stu-id="dad67-158">The schema WCF produces for data contract types makes no provisions for versioning.</span></span> <span data-ttu-id="dad67-159">Es decir, el esquema exportado desde una cierta versión de un tipo contiene solo esos miembros de datos presentes en esa versión.</span><span class="sxs-lookup"><span data-stu-id="dad67-159">That is, the schema exported from a certain version of a type contains only those data members present in that version.</span></span> <span data-ttu-id="dad67-160">La implementación de la interfaz <xref:System.Runtime.Serialization.IExtensibleDataObject>, no cambia el esquema de un tipo.</span><span class="sxs-lookup"><span data-stu-id="dad67-160">Implementing the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface does not change the schema for a type.</span></span>  
  
 <span data-ttu-id="dad67-161">Los miembros de datos se exportan de forma predeterminada al esquema como elementos opcionales.</span><span class="sxs-lookup"><span data-stu-id="dad67-161">Data members are exported to the schema as optional elements by default.</span></span> <span data-ttu-id="dad67-162">Es decir, el valor de `minOccurs` (atributo XML) se establece en 0.</span><span class="sxs-lookup"><span data-stu-id="dad67-162">That is, the `minOccurs` (XML attribute) value is set to 0.</span></span> <span data-ttu-id="dad67-163">Los miembros de datos necesarios se exportan con `minOccurs` establecido en 1.</span><span class="sxs-lookup"><span data-stu-id="dad67-163">Required data members are exported with `minOccurs` set to 1.</span></span>  
  
 <span data-ttu-id="dad67-164">Muchos de los cambios considerados como cambios sin interrupción son, en realidad, cambios con interrupción si se requiere una adherencia estricta al esquema.</span><span class="sxs-lookup"><span data-stu-id="dad67-164">Many of the changes considered to be nonbreaking are actually breaking if strict adherence to the schema is required.</span></span> <span data-ttu-id="dad67-165">En el ejemplo anterior, una instancia de `CarV1` simplemente con el elemento `Model` validaría frente al esquema `CarV2` (que tiene `Model` y `Horsepower`, pero ambos son opcionales).</span><span class="sxs-lookup"><span data-stu-id="dad67-165">In the preceding example, a `CarV1` instance with just the `Model` element would validate against the `CarV2` schema (which has both `Model` and `Horsepower`, but both are optional).</span></span> <span data-ttu-id="dad67-166">Sin embargo, lo inverso no es cierto: una instancia de `CarV2` produciría un error en la validación frente al esquema `CarV1`.</span><span class="sxs-lookup"><span data-stu-id="dad67-166">However, the reverse is not true: a `CarV2` instance would fail validation against the `CarV1` schema.</span></span>  
  
 <span data-ttu-id="dad67-167">El recorrido de ida y vuelta implica algunas consideraciones adicionales.</span><span class="sxs-lookup"><span data-stu-id="dad67-167">Round-tripping also entails some additional considerations.</span></span> <span data-ttu-id="dad67-168">Para obtener más información, vea la sección "consideraciones del esquema" en [contratos de datos compatibles con versiones posteriores](forward-compatible-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="dad67-168">For more information, see the "Schema Considerations" section in [Forward-Compatible Data Contracts](forward-compatible-data-contracts.md).</span></span>  
  
### <a name="other-permitted-changes"></a><span data-ttu-id="dad67-169">Otros cambios permitidos</span><span class="sxs-lookup"><span data-stu-id="dad67-169">Other Permitted Changes</span></span>  

 <span data-ttu-id="dad67-170">Implementar la interfaz <xref:System.Runtime.Serialization.IExtensibleDataObject> es un cambio sin interrupción.</span><span class="sxs-lookup"><span data-stu-id="dad67-170">Implementing the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface is a nonbreaking change.</span></span> <span data-ttu-id="dad67-171">Sin embargo, la compatibilidad con el recorrido de ida y vuelta no existe para las versiones del tipo anterior a la versión en la que <xref:System.Runtime.Serialization.IExtensibleDataObject> se implementó.</span><span class="sxs-lookup"><span data-stu-id="dad67-171">However, round-tripping support does not exist for versions of the type prior to the version in which <xref:System.Runtime.Serialization.IExtensibleDataObject> was implemented.</span></span> <span data-ttu-id="dad67-172">Para obtener más información, vea [Forward-Compatible Data Contracts](forward-compatible-data-contracts.md) (Contratos de datos compatibles con el reenvío).</span><span class="sxs-lookup"><span data-stu-id="dad67-172">For more information, see [Forward-Compatible Data Contracts](forward-compatible-data-contracts.md).</span></span>  
  
## <a name="enumerations"></a><span data-ttu-id="dad67-173">Enumeraciones</span><span class="sxs-lookup"><span data-stu-id="dad67-173">Enumerations</span></span>  

 <span data-ttu-id="dad67-174">Agregar o eliminar un miembro de enumeración es un cambio con interrupción.</span><span class="sxs-lookup"><span data-stu-id="dad67-174">Adding or removing an enumeration member is a breaking change.</span></span> <span data-ttu-id="dad67-175">Cambiar el nombre de un miembro de enumeración es un cambio con interrupción, a menos que su nombre de contrato se mantenga igual que en la versión anterior mediante el atributo `EnumMemberAttribute`.</span><span class="sxs-lookup"><span data-stu-id="dad67-175">Changing the name of an enumeration member is breaking, unless its contract name is kept the same as in the old version by using the `EnumMemberAttribute` attribute.</span></span> <span data-ttu-id="dad67-176">Para obtener más información, vea [tipos de enumeración en contratos de datos](enumeration-types-in-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="dad67-176">For more information, see [Enumeration Types in Data Contracts](enumeration-types-in-data-contracts.md).</span></span>  
  
## <a name="collections"></a><span data-ttu-id="dad67-177">Colecciones</span><span class="sxs-lookup"><span data-stu-id="dad67-177">Collections</span></span>  

 <span data-ttu-id="dad67-178">La mayoría de los cambios de colección son cambios sin interrupción, puesto que la mayoría de los tipos de colección son intercambiables entre sí en el modelo del contrato de datos.</span><span class="sxs-lookup"><span data-stu-id="dad67-178">Most collection changes are nonbreaking because most collection types are interchangeable with each other in the data contract model.</span></span> <span data-ttu-id="dad67-179">Sin embargo, personalizar una colección no personalizada o viceversa es un cambio con interrupción.</span><span class="sxs-lookup"><span data-stu-id="dad67-179">However, making a noncustomized collection customized or vice versa is a breaking change.</span></span> <span data-ttu-id="dad67-180">Asimismo, cambiar la configuración de personalización de la colección es un cambio brusco; es decir, implica cambiar su espacio de nombres y nombre de contrato de datos, repitiendo el nombre del elemento, el nombre del elemento de la clave y el nombre del elemento del valor.</span><span class="sxs-lookup"><span data-stu-id="dad67-180">Also, changing the collection's customization settings is a breaking change; that is, changing its data contract name and namespace, repeating element name, key element name, and value element name.</span></span> <span data-ttu-id="dad67-181">Para obtener más información sobre la personalización de colecciones, vea [tipos de colección en contratos de datos](collection-types-in-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="dad67-181">For more information about collection customization, see [Collection Types in Data Contracts](collection-types-in-data-contracts.md).</span></span>  
<span data-ttu-id="dad67-182">Naturalmente, cambiar el contrato de datos del contenido de una colección (por ejemplo, cambiar de una lista de enteros a una lista de cadenas) es un cambio brusco.</span><span class="sxs-lookup"><span data-stu-id="dad67-182">Naturally, changing the data contract of contents of a collection (for example, changing from a list of integers to a list of strings) is a breaking change.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="dad67-183">Vea también</span><span class="sxs-lookup"><span data-stu-id="dad67-183">See also</span></span>

- <xref:System.Runtime.Serialization.DataMemberAttribute.Name%2A>
- <xref:System.Runtime.Serialization.DataMemberAttribute>
- <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A>
- <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A>
- <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A>
- <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A>
- <xref:System.Runtime.Serialization.SerializationException>
- <xref:System.Runtime.Serialization.IExtensibleDataObject>
- [<span data-ttu-id="dad67-184">Devoluciones de llamadas en la serialización tolerante a versiones</span><span class="sxs-lookup"><span data-stu-id="dad67-184">Version-Tolerant Serialization Callbacks</span></span>](version-tolerant-serialization-callbacks.md)
- [<span data-ttu-id="dad67-185">Procedimientos recomendados: Versiones de contratos de datos</span><span class="sxs-lookup"><span data-stu-id="dad67-185">Best Practices: Data Contract Versioning</span></span>](../best-practices-data-contract-versioning.md)
- [<span data-ttu-id="dad67-186">Utilización de contratos de datos</span><span class="sxs-lookup"><span data-stu-id="dad67-186">Using Data Contracts</span></span>](using-data-contracts.md)
- [<span data-ttu-id="dad67-187">Equivalencia del contrato de datos</span><span class="sxs-lookup"><span data-stu-id="dad67-187">Data Contract Equivalence</span></span>](data-contract-equivalence.md)
- [<span data-ttu-id="dad67-188">Contratos de datos compatibles con el reenvío</span><span class="sxs-lookup"><span data-stu-id="dad67-188">Forward-Compatible Data Contracts</span></span>](forward-compatible-data-contracts.md)
