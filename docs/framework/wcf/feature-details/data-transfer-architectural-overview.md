---
title: Información general sobre la arquitectura de transferencia de datos
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- data transfer [WCF], architectural overview
ms.assetid: 343c2ca2-af53-4936-a28c-c186b3524ee9
ms.openlocfilehash: f34bf82ec44140827c5d8da59911afe10ab7a853
ms.sourcegitcommit: cdb295dd1db589ce5169ac9ff096f01fd0c2da9d
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 06/09/2020
ms.locfileid: "84576478"
---
# <a name="data-transfer-architectural-overview"></a><span data-ttu-id="97902-102">Información general sobre la arquitectura de transferencia de datos</span><span class="sxs-lookup"><span data-stu-id="97902-102">Data Transfer Architectural Overview</span></span>
<span data-ttu-id="97902-103">Windows Communication Foundation (WCF) se puede considerar como una infraestructura de mensajería.</span><span class="sxs-lookup"><span data-stu-id="97902-103">Windows Communication Foundation (WCF) can be thought of as a messaging infrastructure.</span></span> <span data-ttu-id="97902-104">Puede recibir mensajes, procesarlos y enviarlos al código de usuario para realizar acciones adicionales o puede construir mensajes a partir de los datos proporcionados por el código de usuario y entregarlos en un destino.</span><span class="sxs-lookup"><span data-stu-id="97902-104">It can receive messages, process them, and dispatch them to user code for further action, or it can construct messages from data given by user code and deliver them to a destination.</span></span> <span data-ttu-id="97902-105">Este tema, que está dirigido a desarrolladores avanzados, describe la arquitectura para el manejo de mensajes y los datos contenidos.</span><span class="sxs-lookup"><span data-stu-id="97902-105">This topic, which is intended for advanced developers, describes the architecture for handling messages and the contained data.</span></span> <span data-ttu-id="97902-106">Para obtener una vista más sencilla y orientada a tareas sobre cómo enviar y recibir datos, consulte [Specifying Data Transfer in Service Contracts](specifying-data-transfer-in-service-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="97902-106">For a simpler, task-oriented view of how to send and receive data, see [Specifying Data Transfer in Service Contracts](specifying-data-transfer-in-service-contracts.md).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="97902-107">En este tema se describen los detalles de la implementación de WCF que no son visibles al examinar el modelo de objetos WCF.</span><span class="sxs-lookup"><span data-stu-id="97902-107">This topic discusses WCF implementation details that are not visible by examining the WCF object model.</span></span> <span data-ttu-id="97902-108">Dos consejos se han de dar en relación a los detalles de implementación documentados.</span><span class="sxs-lookup"><span data-stu-id="97902-108">Two words of caution are in order with regard to documented implementation details.</span></span> <span data-ttu-id="97902-109">Primero, se simplifican las descripciones; la implementación real puede ser más compleja debido a optimizaciones u otras razones.</span><span class="sxs-lookup"><span data-stu-id="97902-109">First, the descriptions are simplified; actual implementation may be more complex due to optimizations or other reasons.</span></span> <span data-ttu-id="97902-110">Segundo, nunca debería basarse en detalles de implementación concretos, ni siquiera los documentados, porque puede que éstos cambien sin aviso de una versión a otra o incluso en un lanzamiento del servicio.</span><span class="sxs-lookup"><span data-stu-id="97902-110">Second, you should never rely on specific implementation details, even documented ones, because these may change without notice from version to version or even in a servicing release.</span></span>  
  
## <a name="basic-architecture"></a><span data-ttu-id="97902-111">Arquitectura básica</span><span class="sxs-lookup"><span data-stu-id="97902-111">Basic Architecture</span></span>  
 <span data-ttu-id="97902-112">En el núcleo de las funcionalidades de control de mensajes de WCF se encuentra la <xref:System.ServiceModel.Channels.Message> clase, que se describe en detalle en [el uso de la clase de mensaje](using-the-message-class.md).</span><span class="sxs-lookup"><span data-stu-id="97902-112">At the core of WCF message-handling capabilities is the <xref:System.ServiceModel.Channels.Message> class, which is described in detail in [Using the Message Class](using-the-message-class.md).</span></span> <span data-ttu-id="97902-113">Los componentes en tiempo de ejecución de WCF se pueden dividir en dos partes principales: la pila de canales y el marco de trabajo de servicio, con la <xref:System.ServiceModel.Channels.Message> clase como punto de conexión.</span><span class="sxs-lookup"><span data-stu-id="97902-113">The run-time components of WCF can be divided into two major parts: the channel stack and the service framework, with the <xref:System.ServiceModel.Channels.Message> class being the connection point.</span></span>  
  
 <span data-ttu-id="97902-114">La pila de canales es la responsable de la conversión entre una instancia <xref:System.ServiceModel.Channels.Message> válida y alguna acción que corresponda al envío o recepción de datos de mensajes.</span><span class="sxs-lookup"><span data-stu-id="97902-114">The channel stack is responsible for converting between a valid <xref:System.ServiceModel.Channels.Message> instance and some action that corresponds to the sending or receiving of message data.</span></span> <span data-ttu-id="97902-115">En el lado del envío, la pila de canales toma una instancia <xref:System.ServiceModel.Channels.Message> válida y, después de algo de procesado, realiza alguna acción que corresponde lógicamente con el envío del mensaje.</span><span class="sxs-lookup"><span data-stu-id="97902-115">On the sending side, the channel stack takes a valid <xref:System.ServiceModel.Channels.Message> instance and, after some processing, performs some action that logically corresponds to sending the message.</span></span> <span data-ttu-id="97902-116">La acción puede consistir en enviar paquetes TCP o HTTP, poner en cola el mensaje en Message Queuing, escribir el mensaje en una base de datos, guardarlo en un recurso compartido de archivos, o cualquier otra acción, dependiendo de la implementación.</span><span class="sxs-lookup"><span data-stu-id="97902-116">The action may be sending TCP or HTTP packets, queuing the message in Message Queuing, writing the message to a database, saving it to a file share, or any other action, depending on the implementation.</span></span> <span data-ttu-id="97902-117">La acción más común es la de enviar el mensaje sobre un protocolo de red.</span><span class="sxs-lookup"><span data-stu-id="97902-117">The most common action is sending the message over a network protocol.</span></span> <span data-ttu-id="97902-118">En el lado de recepción, sucede lo contrario: se detecta una acción (que puede ser la llegada de paquetes TCP o HTTP o cualquier otra acción) y, tras el procesado, la pila de canales convierte esta acción en una instancia <xref:System.ServiceModel.Channels.Message> válida.</span><span class="sxs-lookup"><span data-stu-id="97902-118">On the receive side, the opposite happens—an action is detected (which may be TCP or HTTP packets arriving or any other action), and, after processing, the channel stack converts this action into a valid <xref:System.ServiceModel.Channels.Message> instance.</span></span>  
  
 <span data-ttu-id="97902-119">Puede usar WCF mediante la <xref:System.ServiceModel.Channels.Message> clase y la pila de canales directamente.</span><span class="sxs-lookup"><span data-stu-id="97902-119">You can use WCF by using the <xref:System.ServiceModel.Channels.Message> class and the channel stack directly.</span></span> <span data-ttu-id="97902-120">Sin embargo, hacer esto es difícil y exige mucho tiempo.</span><span class="sxs-lookup"><span data-stu-id="97902-120">However, doing so is difficult and time-consuming.</span></span> <span data-ttu-id="97902-121">Además, el <xref:System.ServiceModel.Channels.Message> objeto no proporciona compatibilidad con metadatos, por lo que no puede generar clientes WCF fuertemente tipados si usa WCF de esta manera.</span><span class="sxs-lookup"><span data-stu-id="97902-121">Additionally, the <xref:System.ServiceModel.Channels.Message> object provides no metadata support, so you cannot generate strongly typed WCF clients if you use WCF in this manner.</span></span>  
  
 <span data-ttu-id="97902-122">Por lo tanto, WCF incluye un marco de trabajo de servicio que proporciona un modelo de programación fácil de usar que puede usar para construir y recibir `Message` objetos.</span><span class="sxs-lookup"><span data-stu-id="97902-122">Therefore, WCF includes a service framework that provides an easy-to-use programming model that you can use to construct and receive `Message` objects.</span></span> <span data-ttu-id="97902-123">El marco de trabajo de servicio asigna servicios a los tipos .NET Framework a través de la noción de contratos de servicios y envía mensajes a las operaciones de usuario que simplemente .NET Framework métodos marcados con el <xref:System.ServiceModel.OperationContractAttribute> atributo (para más información, consulte [diseño de contratos de servicio](../designing-service-contracts.md)).</span><span class="sxs-lookup"><span data-stu-id="97902-123">The service framework maps services to .NET Framework types through the notion of service contracts, and dispatches messages to user operations that are simply .NET Framework methods marked with the <xref:System.ServiceModel.OperationContractAttribute> attribute (for more details, see [Designing Service Contracts](../designing-service-contracts.md)).</span></span> <span data-ttu-id="97902-124">Estos métodos pueden tener parámetros y valores devueltos.</span><span class="sxs-lookup"><span data-stu-id="97902-124">These methods may have parameters and return values.</span></span> <span data-ttu-id="97902-125">En el lado del servicio, el marco de trabajo de servicio convierte las instancias <xref:System.ServiceModel.Channels.Message> de entrada en parámetros y convierte los valores devueltos en instancias <xref:System.ServiceModel.Channels.Message> de salida.</span><span class="sxs-lookup"><span data-stu-id="97902-125">On the service side, the service framework converts incoming <xref:System.ServiceModel.Channels.Message> instances into parameters and converts return values into outgoing <xref:System.ServiceModel.Channels.Message> instances.</span></span> <span data-ttu-id="97902-126">En el lado de cliente, hace lo contrario.</span><span class="sxs-lookup"><span data-stu-id="97902-126">On the client side, it does the opposite.</span></span> <span data-ttu-id="97902-127">Por ejemplo, considere la operación `FindAirfare` descrita abajo.</span><span class="sxs-lookup"><span data-stu-id="97902-127">For example, consider the `FindAirfare` operation below.</span></span>  
  
 [!code-csharp[c_DataArchitecture#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#1)]
 [!code-vb[c_DataArchitecture#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#1)]  
  
 <span data-ttu-id="97902-128">Suponga que `FindAirfare` se llama en el cliente.</span><span class="sxs-lookup"><span data-stu-id="97902-128">Suppose `FindAirfare` is called on the client.</span></span> <span data-ttu-id="97902-129">El marco de trabajo de servicio en el cliente convierte los parámetros `FromCity` y `ToCity` en una instancia de <xref:System.ServiceModel.Channels.Message> de salida y la pasa a la pila de canales que se va a enviar.</span><span class="sxs-lookup"><span data-stu-id="97902-129">The service framework on the client converts the `FromCity` and `ToCity` parameters into an outgoing <xref:System.ServiceModel.Channels.Message> instance and passes it to the channel stack to be sent.</span></span>  
  
 <span data-ttu-id="97902-130">En el lado del servicio, cuando una instancia de <xref:System.ServiceModel.Channels.Message> llega de la pila de canales, el marco de trabajo de servicio extrae los datos pertinentes del mensaje para rellenar los parámetros `FromCity` y `ToCity` y, a continuación, llama al método `FindAirfare` de lado de servicio.</span><span class="sxs-lookup"><span data-stu-id="97902-130">On the service side, when a <xref:System.ServiceModel.Channels.Message> instance arrives from the channel stack, the service framework extracts the relevant data from the message to populate the `FromCity` and `ToCity` parameters and then calls the service-side `FindAirfare` method.</span></span> <span data-ttu-id="97902-131">Cuando el método vuelve, el marco de trabajo de servicio toma el valor entero devuelto y el parámetro de salida `IsDirectFlight` y crea una instancia de objeto de <xref:System.ServiceModel.Channels.Message> que contiene esta información.</span><span class="sxs-lookup"><span data-stu-id="97902-131">When the method returns, the service framework takes the returned integer value and the `IsDirectFlight` output parameter and creates a <xref:System.ServiceModel.Channels.Message> object instance that contains this information.</span></span> <span data-ttu-id="97902-132">A continuación, pasa la instancia `Message` a la pila de canales que se va a devolver al cliente.</span><span class="sxs-lookup"><span data-stu-id="97902-132">It then passes the `Message` instance to the channel stack to be sent back to the client.</span></span>  
  
 <span data-ttu-id="97902-133">En el lado de cliente, una instancia de <xref:System.ServiceModel.Channels.Message> que contiene el mensaje de respuesta emerge de la pila de canales.</span><span class="sxs-lookup"><span data-stu-id="97902-133">On the client side, a <xref:System.ServiceModel.Channels.Message> instance that contains the response message emerges from the channel stack.</span></span> <span data-ttu-id="97902-134">El marco de trabajo de servicio extrae el valor devuelto y el valor de `IsDirectFlight` y los devuelve al llamador del cliente.</span><span class="sxs-lookup"><span data-stu-id="97902-134">The service framework extracts the return value and the `IsDirectFlight` value and returns these to the caller of the client.</span></span>  
  
## <a name="message-class"></a><span data-ttu-id="97902-135">Message (clase)</span><span class="sxs-lookup"><span data-stu-id="97902-135">Message Class</span></span>  
 <span data-ttu-id="97902-136">La clase <xref:System.ServiceModel.Channels.Message> pretende ser una representación abstracta de un mensaje, pero su diseño está unido fuertemente al mensaje SOAP.</span><span class="sxs-lookup"><span data-stu-id="97902-136">The <xref:System.ServiceModel.Channels.Message> class is intended to be an abstract representation of a message, but its design is strongly tied to the SOAP message.</span></span> <span data-ttu-id="97902-137"><xref:System.ServiceModel.Channels.Message> contiene tres partes principales de información: un cuerpo del mensaje, encabezados del mensaje y propiedades de mensaje.</span><span class="sxs-lookup"><span data-stu-id="97902-137">A <xref:System.ServiceModel.Channels.Message> contains three major pieces of information: a message body, message headers, and message properties.</span></span>  
  
## <a name="message-body"></a><span data-ttu-id="97902-138">Cuerpo del mensaje</span><span class="sxs-lookup"><span data-stu-id="97902-138">Message Body</span></span>  
 <span data-ttu-id="97902-139">El objetivo del cuerpo del mensaje es representar la carga útil real del mensaje.</span><span class="sxs-lookup"><span data-stu-id="97902-139">The message body is intended to represent the actual data payload of the message.</span></span> <span data-ttu-id="97902-140">El cuerpo del mensaje siempre se representa como un conjunto de información XML.</span><span class="sxs-lookup"><span data-stu-id="97902-140">The message body is always represented as an XML Infoset.</span></span> <span data-ttu-id="97902-141">Esto no significa que todos los mensajes creados o recibidos en WCF deben estar en formato XML.</span><span class="sxs-lookup"><span data-stu-id="97902-141">This does not mean that all messages created or received in WCF must be in XML format.</span></span> <span data-ttu-id="97902-142">Depende de la pila de canales decidir cómo interpretar el cuerpo del mensaje.</span><span class="sxs-lookup"><span data-stu-id="97902-142">It is up to the channel stack to decide how to interpret the message body.</span></span> <span data-ttu-id="97902-143">Puede emitirlo como XML, convertirlo a algún otro formato o incluso omitirlo completamente.</span><span class="sxs-lookup"><span data-stu-id="97902-143">It may emit it as XML, convert it to some other format, or even omit it entirely.</span></span> <span data-ttu-id="97902-144">Por supuesto, con la mayoría de los enlaces que WCF proporciona, el cuerpo del mensaje se representa como contenido XML en la sección de cuerpo de una envoltura SOAP.</span><span class="sxs-lookup"><span data-stu-id="97902-144">Of course, with most of the bindings WCF supplies, the message body is represented as XML content in the body section of a SOAP envelope.</span></span>  
  
 <span data-ttu-id="97902-145">Es importante comprender que la clase `Message` no necesariamente contiene un búfer con datos XML que representan el cuerpo.</span><span class="sxs-lookup"><span data-stu-id="97902-145">It is important to realize that the `Message` class does not necessarily contain a buffer with XML data representing the body.</span></span> <span data-ttu-id="97902-146">Lógicamente, `Message` contiene un conjunto de información XML, pero este conjunto de información puede construirse dinámicamente y no existir nunca físicamente en memoria.</span><span class="sxs-lookup"><span data-stu-id="97902-146">Logically, `Message` contains an XML Infoset, but this Infoset may be dynamically constructed and may never physically exist in memory.</span></span>  
  
### <a name="putting-data-into-the-message-body"></a><span data-ttu-id="97902-147">Colocar datos en el cuerpo del mensaje</span><span class="sxs-lookup"><span data-stu-id="97902-147">Putting Data into the Message Body</span></span>  
 <span data-ttu-id="97902-148">No hay ningún mecanismo uniforme para colocar los datos en el cuerpo de un mensaje.</span><span class="sxs-lookup"><span data-stu-id="97902-148">There is no uniform mechanism to put data into a message body.</span></span> <span data-ttu-id="97902-149">La clase <xref:System.ServiceModel.Channels.Message> tiene un método abstracto, <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29>, que toma un <xref:System.Xml.XmlDictionaryWriter>.</span><span class="sxs-lookup"><span data-stu-id="97902-149">The <xref:System.ServiceModel.Channels.Message> class has an abstract method, <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29>, which takes an <xref:System.Xml.XmlDictionaryWriter>.</span></span> <span data-ttu-id="97902-150">Cada subclase de la clase <xref:System.ServiceModel.Channels.Message> es responsable de la invalidación de este método y de la escritura fuera de su propio contenido.</span><span class="sxs-lookup"><span data-stu-id="97902-150">Each subclass of the <xref:System.ServiceModel.Channels.Message> class is responsible for overriding this method and writing out its own contents.</span></span> <span data-ttu-id="97902-151">El cuerpo del mensaje contiene lógicamente el conjunto de información XML que genera `OnWriteBodyContent` .</span><span class="sxs-lookup"><span data-stu-id="97902-151">The message body logically contains the XML Infoset that `OnWriteBodyContent` produces.</span></span> <span data-ttu-id="97902-152">Por ejemplo, considere la siguiente subclase `Message` .</span><span class="sxs-lookup"><span data-stu-id="97902-152">For example, consider the following `Message` subclass.</span></span>  
  
 [!code-csharp[c_DataArchitecture#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#2)]
 [!code-vb[c_DataArchitecture#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#2)]  
  
 <span data-ttu-id="97902-153">Físicamente, una instancia `AirfareRequestMessage` contiene solo dos cadenas ("fromCity" y "toCity").</span><span class="sxs-lookup"><span data-stu-id="97902-153">Physically, an `AirfareRequestMessage` instance contains only two strings ("fromCity" and "toCity").</span></span> <span data-ttu-id="97902-154">Sin embargo, lógicamente el mensaje contiene el siguiente conjunto de información XML:</span><span class="sxs-lookup"><span data-stu-id="97902-154">However, logically the message contains the following XML infoset:</span></span>  
  
```xml  
<airfareRequest>  
    <from>Tokyo</from>  
    <to>London</to>  
</airfareRequest>  
```  
  
 <span data-ttu-id="97902-155">Por supuesto, no crearía normalmente mensajes de esta manera, porque puede utilizar el marco de trabajo del servicio para crear un mensaje como el anterior a partir de parámetros de contrato de operaciones.</span><span class="sxs-lookup"><span data-stu-id="97902-155">Of course, you would normally not create messages in this manner, because you can use the service framework to create a message like the preceding one from operation contract parameters.</span></span> <span data-ttu-id="97902-156">Además, la clase <xref:System.ServiceModel.Channels.Message> tiene métodos `CreateMessage` estáticos que puede utilizar para crear mensajes con tipos comunes de contenido: un mensaje vacío, un mensaje que contiene un objeto serializado a XML con <xref:System.Runtime.Serialization.DataContractSerializer>, un mensaje que contiene un error de SOAP, un mensaje que contiene XML representado por <xref:System.Xml.XmlReader>, etc.</span><span class="sxs-lookup"><span data-stu-id="97902-156">Additionally, the <xref:System.ServiceModel.Channels.Message> class has static `CreateMessage` methods that you can use to create messages with common types of content: an empty message, a message that contains an object serialized to XML with the <xref:System.Runtime.Serialization.DataContractSerializer>, a message that contains a SOAP fault, a message that contains XML represented by an <xref:System.Xml.XmlReader>, and so on.</span></span>  
  
### <a name="getting-data-from-a-message-body"></a><span data-ttu-id="97902-157">Obtención de datos del cuerpo de un mensaje</span><span class="sxs-lookup"><span data-stu-id="97902-157">Getting Data from a Message Body</span></span>  
 <span data-ttu-id="97902-158">Puede extraer los datos almacenados en el cuerpo de un mensaje principalmente de dos maneras:</span><span class="sxs-lookup"><span data-stu-id="97902-158">You can extract the data stored in a message body in two main ways:</span></span>  
  
- <span data-ttu-id="97902-159">Puede obtener una vez el cuerpo del mensaje al completo llamando al método <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29> y pasando un sistema de escritura de XML.</span><span class="sxs-lookup"><span data-stu-id="97902-159">You can get the entire message body at one time by calling the <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29> method and passing in an XML writer.</span></span> <span data-ttu-id="97902-160">El cuerpo del mensaje al completo se escribe en este sistema de escritura.</span><span class="sxs-lookup"><span data-stu-id="97902-160">The complete message body is written out to this writer.</span></span> <span data-ttu-id="97902-161">Obtener el cuerpo del mensaje al completo de una vez también se llama *escribir un mensaje*.</span><span class="sxs-lookup"><span data-stu-id="97902-161">Getting the entire message body at one time is also called *writing a message*.</span></span> <span data-ttu-id="97902-162">El canal de pilas realiza principalmente la escritura al enviar mensajes; una parte de la pila de canales tendrá, por lo general, acceso a todo el cuerpo del mensaje, lo codificará y enviará.</span><span class="sxs-lookup"><span data-stu-id="97902-162">Writing is done primarily by the channel stack when sending messages—some part of the channel stack will usually get access to the entire message body, encode it, and send it.</span></span>  
  
- <span data-ttu-id="97902-163">Otra manera de extraer información del cuerpo del mensaje es llamar <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents> y obtener un lector XML.</span><span class="sxs-lookup"><span data-stu-id="97902-163">Another way to get information out of the message body is to call <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents> and get an XML reader.</span></span> <span data-ttu-id="97902-164">A continuación, se puede tener acceso al cuerpo del mensaje de manera consecutiva tanto como sea necesario llamando a los métodos en el lector.</span><span class="sxs-lookup"><span data-stu-id="97902-164">The message body can then be accessed sequentially as needed by calling methods on the reader.</span></span> <span data-ttu-id="97902-165">Obtener el cuerpo del mensaje parte por parte también se llama *leer un mensaje*.</span><span class="sxs-lookup"><span data-stu-id="97902-165">Getting the message body piece-by-piece is also called *reading a message*.</span></span> <span data-ttu-id="97902-166">La lectura del mensaje es utilizada principalmente por el marco de trabajo de servicio al recibir mensajes.</span><span class="sxs-lookup"><span data-stu-id="97902-166">Reading the message is primarily used by the service framework when receiving messages.</span></span> <span data-ttu-id="97902-167">Por ejemplo, cuando <xref:System.Runtime.Serialization.DataContractSerializer> se está utilizando, el marco de trabajo de servicio obtendrá un lector XML sobre el cuerpo y lo pasará al motor de deserialización, que comenzará, a continuación, a leer el mensaje elemento a elemento y a construir el gráfico de objeto correspondiente.</span><span class="sxs-lookup"><span data-stu-id="97902-167">For example, when the <xref:System.Runtime.Serialization.DataContractSerializer> is in use, the service framework will get an XML reader over the body and pass it to the deserialization engine, which will then start reading the message element-by-element and constructing the corresponding object graph.</span></span>  
  
 <span data-ttu-id="97902-168">Solo se puede recuperar un cuerpo de mensaje una vez.</span><span class="sxs-lookup"><span data-stu-id="97902-168">A message body can be retrieved only once.</span></span> <span data-ttu-id="97902-169">Esto permite trabajar con secuencias de solo avance.</span><span class="sxs-lookup"><span data-stu-id="97902-169">This makes it possible to work with forward-only streams.</span></span> <span data-ttu-id="97902-170">Por ejemplo, puede escribir una invalidación <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> que lee de <xref:System.IO.FileStream> y devuelve los resultados como un conjunto de información XML.</span><span class="sxs-lookup"><span data-stu-id="97902-170">For example, you can write an <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> override that reads from a <xref:System.IO.FileStream> and returns the results as an XML Infoset.</span></span> <span data-ttu-id="97902-171">Nunca necesitará "rebobinar" al principio del archivo.</span><span class="sxs-lookup"><span data-stu-id="97902-171">You will never need to "rewind" to the beginning of the file.</span></span>  
  
 <span data-ttu-id="97902-172">Los métodos `WriteBodyContents` y `GetReaderAtBodyContents` simplemente comprueban que el cuerpo del mensaje no se ha recuperado antes y, a continuación, llaman a `OnWriteBodyContents` o a `OnGetReaderAtBodyContents`, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="97902-172">The `WriteBodyContents` and `GetReaderAtBodyContents` methods simply check that the message body has never been retrieved before, and then call `OnWriteBodyContents` or `OnGetReaderAtBodyContents`, respectively.</span></span>  
  
## <a name="message-usage-in-wcf"></a><span data-ttu-id="97902-173">Uso de mensajes en WCF</span><span class="sxs-lookup"><span data-stu-id="97902-173">Message Usage in WCF</span></span>  
 <span data-ttu-id="97902-174">La mayoría de los mensajes pueden estar clasificados como *salientes* (aquéllos que crea el marco de trabajo de servicio para que la pila de canales los envíe) o *entrantes* (aquéllos que llegan desde pilas de canales y son interpretados por parte del marco de trabajo de servicio).</span><span class="sxs-lookup"><span data-stu-id="97902-174">Most messages can be classified as either *outgoing* (those that are created by the service framework to be sent by the channel stack) or *incoming* (those that arrive from the channel stack and are interpreted by the service framework).</span></span> <span data-ttu-id="97902-175">Aún más, la pila de canales puede funcionar en modo almacenado en búfer o modo de transmisión por secuencias.</span><span class="sxs-lookup"><span data-stu-id="97902-175">Furthermore, the channel stack can operate in either buffered or streaming mode.</span></span> <span data-ttu-id="97902-176">El marco de trabajo de servicio también puede exponer un modelo de programación de transmisión por secuencias o sin transmisión por secuencias.</span><span class="sxs-lookup"><span data-stu-id="97902-176">The service framework may also expose a streamed or nonstreamed programming model.</span></span> <span data-ttu-id="97902-177">Esto nos lleva a los casos enumerados en la siguiente tabla, junto con detalles simplificados de su implementación.</span><span class="sxs-lookup"><span data-stu-id="97902-177">This leads to the cases listed in the following table, along with simplified details of their implementation.</span></span>  
  
|<span data-ttu-id="97902-178">Tipo de mensaje</span><span class="sxs-lookup"><span data-stu-id="97902-178">Message type</span></span>|<span data-ttu-id="97902-179">Datos del cuerpo en mensaje</span><span class="sxs-lookup"><span data-stu-id="97902-179">Body data in message</span></span>|<span data-ttu-id="97902-180">Implementación de escritura (OnWriteBodyContents)</span><span class="sxs-lookup"><span data-stu-id="97902-180">Write (OnWriteBodyContents) implementation</span></span>|<span data-ttu-id="97902-181">Implementación de lectura (OnGetReaderAtBodyContents)</span><span class="sxs-lookup"><span data-stu-id="97902-181">Read (OnGetReaderAtBodyContents) Implementation</span></span>|  
|------------------|--------------------------|--------------------------------------------------|-------------------------------------------------------|  
|<span data-ttu-id="97902-182">Saliente, creado a partir del modelo de programación sin transmisión por secuencias</span><span class="sxs-lookup"><span data-stu-id="97902-182">Outgoing, created from nonstreamed programming model</span></span>|<span data-ttu-id="97902-183">Los datos tienen que escribir el mensaje (por ejemplo, un objeto y la instancia de <xref:System.Runtime.Serialization.DataContractSerializer> necesarios para serializarlo)\*</span><span class="sxs-lookup"><span data-stu-id="97902-183">The data needed to write the message (for example, an object and the <xref:System.Runtime.Serialization.DataContractSerializer> instance needed to serialize it)\*</span></span>|<span data-ttu-id="97902-184">Lógica personalizada para escribir el mensaje en función de los datos almacenados (por ejemplo, llamar `WriteObject` en `DataContractSerializer` si ése es el serializador en uso)\*</span><span class="sxs-lookup"><span data-stu-id="97902-184">Custom logic to write out the message based on the stored data (for example, call `WriteObject` on the `DataContractSerializer` if that is the serializer in use)\*</span></span>|<span data-ttu-id="97902-185">Llamar `OnWriteBodyContents`, almacenar en búfer los resultados, devolver un lector XML sobre el búfer</span><span class="sxs-lookup"><span data-stu-id="97902-185">Call `OnWriteBodyContents`, buffer the results, return an XML reader over the buffer</span></span>|  
|<span data-ttu-id="97902-186">Saliente, creado a partir del modelo de programación de transmisión por secuencias</span><span class="sxs-lookup"><span data-stu-id="97902-186">Outgoing, created from streamed programming model</span></span>|<span data-ttu-id="97902-187">La `Stream` con los datos que se han de escribir\*</span><span class="sxs-lookup"><span data-stu-id="97902-187">The `Stream` with the data to be written\*</span></span>|<span data-ttu-id="97902-188">Escriba los datos de la secuencia almacenada utilizando el mecanismo <xref:System.Xml.IStreamProvider> \*</span><span class="sxs-lookup"><span data-stu-id="97902-188">Write out data from the stored stream using the <xref:System.Xml.IStreamProvider> mechanism\*</span></span>|<span data-ttu-id="97902-189">Llamar `OnWriteBodyContents`, almacenar en búfer los resultados, devolver un lector XML sobre el búfer</span><span class="sxs-lookup"><span data-stu-id="97902-189">Call `OnWriteBodyContents`, buffer the results, return an XML reader over the buffer</span></span>|  
|<span data-ttu-id="97902-190">Entrante a partir de la pila de canales de transmisión por secuencias</span><span class="sxs-lookup"><span data-stu-id="97902-190">Incoming from streaming channel stack</span></span>|<span data-ttu-id="97902-191">Un objeto `Stream` que representa los datos que entran a través de la red con <xref:System.Xml.XmlReader> sobre él</span><span class="sxs-lookup"><span data-stu-id="97902-191">A `Stream` object that represents the data coming in over the network with an <xref:System.Xml.XmlReader> over it</span></span>|<span data-ttu-id="97902-192">Escriba fuera el contenido del `XmlReader` almacenado utilizando `WriteNode`</span><span class="sxs-lookup"><span data-stu-id="97902-192">Write out the contents from the stored `XmlReader` using `WriteNode`</span></span>|<span data-ttu-id="97902-193">Devuelve el `XmlReader`almacenado</span><span class="sxs-lookup"><span data-stu-id="97902-193">Returns the stored `XmlReader`</span></span>|  
|<span data-ttu-id="97902-194">Entrante a partir de la pila de canales sin transmisión por secuencias</span><span class="sxs-lookup"><span data-stu-id="97902-194">Incoming from nonstreaming channel stack</span></span>|<span data-ttu-id="97902-195">Un búfer que contiene datos del cuerpo con un `XmlReader` sobre él</span><span class="sxs-lookup"><span data-stu-id="97902-195">A buffer that contains body data with an `XmlReader` over it</span></span>|<span data-ttu-id="97902-196">Escribe fuera el contenido del `XmlReader` almacenado utilizando `WriteNode`</span><span class="sxs-lookup"><span data-stu-id="97902-196">Writes out the contents from the stored `XmlReader` using `WriteNode`</span></span>|<span data-ttu-id="97902-197">Devuelve el lenguaje almacenado</span><span class="sxs-lookup"><span data-stu-id="97902-197">Returns the stored lang</span></span>|  
  
 <span data-ttu-id="97902-198">\*Estos elementos no se implementan directamente en las `Message` subclases, sino en las subclases de la <xref:System.ServiceModel.Channels.BodyWriter> clase.</span><span class="sxs-lookup"><span data-stu-id="97902-198">\* These items are not implemented directly in `Message` subclasses, but in subclasses of the <xref:System.ServiceModel.Channels.BodyWriter> class.</span></span> <span data-ttu-id="97902-199">Para obtener más información acerca de <xref:System.ServiceModel.Channels.BodyWriter>, vea [Using the Message Class](using-the-message-class.md).</span><span class="sxs-lookup"><span data-stu-id="97902-199">For more information about the <xref:System.ServiceModel.Channels.BodyWriter>, see [Using the Message Class](using-the-message-class.md).</span></span>  
  
## <a name="message-headers"></a><span data-ttu-id="97902-200">Encabezados de mensajes</span><span class="sxs-lookup"><span data-stu-id="97902-200">Message Headers</span></span>  
 <span data-ttu-id="97902-201">Un mensaje puede contener encabezados.</span><span class="sxs-lookup"><span data-stu-id="97902-201">A message may contain headers.</span></span> <span data-ttu-id="97902-202">Un encabezado se compone lógicamente de un conjunto de información XML asociado a un nombre, un espacio de nombres y algunas propiedades.</span><span class="sxs-lookup"><span data-stu-id="97902-202">A header logically consists of an XML Infoset that is associated with a name, a namespace, and a few other properties.</span></span> <span data-ttu-id="97902-203">Se tiene acceso a los encabezados del mensaje utilizando la propiedad `Headers` en <xref:System.ServiceModel.Channels.Message>.</span><span class="sxs-lookup"><span data-stu-id="97902-203">Message headers are accessed using the `Headers` property on <xref:System.ServiceModel.Channels.Message>.</span></span> <span data-ttu-id="97902-204">Cada encabezado está representado por una clase <xref:System.ServiceModel.Channels.MessageHeader> .</span><span class="sxs-lookup"><span data-stu-id="97902-204">Each header is represented by a <xref:System.ServiceModel.Channels.MessageHeader> class.</span></span> <span data-ttu-id="97902-205">Normalmente, los encabezados de mensajes están asignados a encabezados de mensaje SOAP al utilizar una pila de canales configurada para que funcione con mensajes SOAP.</span><span class="sxs-lookup"><span data-stu-id="97902-205">Normally, message headers are mapped to SOAP message headers when using a channel stack configured to work with SOAP messages.</span></span>  
  
 <span data-ttu-id="97902-206">Colocar información en un encabezado de mensaje y extraer información de él es similar a utilizar el cuerpo del mensaje.</span><span class="sxs-lookup"><span data-stu-id="97902-206">Putting information into a message header and extracting information from it is similar to using the message body.</span></span> <span data-ttu-id="97902-207">Se simplifica un poco el proceso porque no se admite la transmisión por secuencias.</span><span class="sxs-lookup"><span data-stu-id="97902-207">The process is somewhat simplified because streaming is not supported.</span></span> <span data-ttu-id="97902-208">Es posible tener acceso más de una vez al contenido del mismo encabezado y se puede tener acceso a los encabezados en orden aleatorio, lo que hace que siempre estén almacenados en búfer.</span><span class="sxs-lookup"><span data-stu-id="97902-208">It is possible to access the contents of the same header more than once, and headers can be accessed in arbitrary order, forcing headers to always be buffered.</span></span> <span data-ttu-id="97902-209">No hay ningún mecanismo de uso general disponible para obtener un lector XML sobre un encabezado, pero hay una `MessageHeader` subclase interna a WCF que representa un encabezado legible con una funcionalidad de este tipo.</span><span class="sxs-lookup"><span data-stu-id="97902-209">There is no general-purpose mechanism available to get an XML reader over a header, but there is a `MessageHeader` subclass internal to WCF that represents a readable header with such a capability.</span></span> <span data-ttu-id="97902-210">La pila del canal crea este tipo de `MessageHeader` cuando llega un mensaje con encabezados personalizados de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="97902-210">This type of `MessageHeader` is created by the channel stack when a message with custom application headers comes in.</span></span> <span data-ttu-id="97902-211">Esto permite al marco de trabajo del servicio usar un motor de deserialización, como <xref:System.Runtime.Serialization.DataContractSerializer>, para interpretar estos encabezados.</span><span class="sxs-lookup"><span data-stu-id="97902-211">This enables the service framework to use a deserialization engine, such as the <xref:System.Runtime.Serialization.DataContractSerializer>, to interpret these headers.</span></span>  
  
 <span data-ttu-id="97902-212">Para obtener más información, vea [usar la clase de mensaje](using-the-message-class.md).</span><span class="sxs-lookup"><span data-stu-id="97902-212">For more information, see [Using the Message Class](using-the-message-class.md).</span></span>  
  
## <a name="message-properties"></a><span data-ttu-id="97902-213">Message (propiedades)</span><span class="sxs-lookup"><span data-stu-id="97902-213">Message Properties</span></span>  
 <span data-ttu-id="97902-214">Un mensaje puede contener propiedades.</span><span class="sxs-lookup"><span data-stu-id="97902-214">A message may contain properties.</span></span> <span data-ttu-id="97902-215">Una *propiedad* es cualquier objeto .NET Framework asociado a un nombre de cadena.</span><span class="sxs-lookup"><span data-stu-id="97902-215">A *property* is any .NET Framework object that is associated with a string name.</span></span> <span data-ttu-id="97902-216">Se tiene acceso a las propiedades a través de la propiedad `Properties` en `Message`.</span><span class="sxs-lookup"><span data-stu-id="97902-216">Properties are accessed through the `Properties` property on `Message`.</span></span>  
  
 <span data-ttu-id="97902-217">A diferencia del cuerpo del mensaje y los encabezados del mensaje (que se asignan normalmente al cuerpo de SOAP y encabezados SOAP, respectivamente), las propiedades de mensajes normalmente no se envían ni reciben junto con los mensajes.</span><span class="sxs-lookup"><span data-stu-id="97902-217">Unlike the message body and message headers (which normally map to the SOAP body and SOAP headers, respectively), message properties are normally not sent or received along with the messages.</span></span> <span data-ttu-id="97902-218">Las propiedades de los mensajes existen principalmente como un mecanismo de comunicación para pasar datos sobre el mensaje entre los diversos canales de la pila de canales y entre la pila de canales y el modelo de servicio.</span><span class="sxs-lookup"><span data-stu-id="97902-218">Message properties exist primarily as a communication mechanism to pass data about the message between the various channels in the channel stack, and between the channel stack and the service model.</span></span>  
  
 <span data-ttu-id="97902-219">Por ejemplo, el canal de transporte HTTP incluido como parte de WCF es capaz de generar varios códigos de Estado HTTP, como "404 (no encontrado)" y "500 (error interno del servidor)", cuando envía respuestas a los clientes.</span><span class="sxs-lookup"><span data-stu-id="97902-219">For example, the HTTP transport channel included as part of WCF is capable of producing various HTTP status codes, such as "404 (Not Found)" and "500 (Internal Server Error)," when it sends replies to clients.</span></span> <span data-ttu-id="97902-220">Antes de enviar un mensaje de respuesta, comprueba para ver si el `Properties` de `Message` contiene una propiedad denominada "httpResponse" que contiene un objeto de tipo <xref:System.ServiceModel.Channels.HttpResponseMessageProperty> .</span><span class="sxs-lookup"><span data-stu-id="97902-220">Before sending a reply message, it checks to see whether the `Properties` of the `Message` contain a property called "httpResponse" that contains an object of type <xref:System.ServiceModel.Channels.HttpResponseMessageProperty>.</span></span> <span data-ttu-id="97902-221">Si se encuentra este tipo de propiedad, mirará en la propiedad <xref:System.ServiceModel.Channels.HttpResponseMessageProperty.StatusCode%2A> y utilizará ese código de estado.</span><span class="sxs-lookup"><span data-stu-id="97902-221">If such a property is found, it will look at the <xref:System.ServiceModel.Channels.HttpResponseMessageProperty.StatusCode%2A> property and use that status code.</span></span> <span data-ttu-id="97902-222">Si no se encuentra, se utiliza el código "200 (Aceptar)" predeterminado.</span><span class="sxs-lookup"><span data-stu-id="97902-222">If it is not found, the default "200 (OK)" code is used.</span></span>  
  
 <span data-ttu-id="97902-223">Para obtener más información, vea [usar la clase de mensaje](using-the-message-class.md).</span><span class="sxs-lookup"><span data-stu-id="97902-223">For more information, see [Using the Message Class](using-the-message-class.md).</span></span>  
  
### <a name="the-message-as-a-whole"></a><span data-ttu-id="97902-224">El mensaje en conjunto</span><span class="sxs-lookup"><span data-stu-id="97902-224">The Message as a Whole</span></span>  
 <span data-ttu-id="97902-225">Hasta ahora, hemos discutido los métodos para tener acceso a las diversas partes del mensaje aislado.</span><span class="sxs-lookup"><span data-stu-id="97902-225">So far, we have discussed methods for accessing the various parts of the message in isolation.</span></span> <span data-ttu-id="97902-226">Sin embargo, la clase <xref:System.ServiceModel.Channels.Message> también proporciona métodos para trabajar con el mensaje completo como un todo.</span><span class="sxs-lookup"><span data-stu-id="97902-226">However, the <xref:System.ServiceModel.Channels.Message> class also provides methods to work with the entire message as a whole.</span></span> <span data-ttu-id="97902-227">Por ejemplo, el método `WriteMessage` escribe el mensaje completo en un sistema de escritura XML.</span><span class="sxs-lookup"><span data-stu-id="97902-227">For example, the `WriteMessage` method writes out the entire message to an XML writer.</span></span>  
  
 <span data-ttu-id="97902-228">Para que esto sea posible, se debe definir una asignación entre la instancia `Message` completa y un conjunto de información XML.</span><span class="sxs-lookup"><span data-stu-id="97902-228">For this to be possible, a mapping must be defined between the entire `Message` instance and an XML Infoset.</span></span> <span data-ttu-id="97902-229">Este tipo de asignación, de hecho, existe: WCF usa el estándar SOAP para definir esta asignación.</span><span class="sxs-lookup"><span data-stu-id="97902-229">Such a mapping, in fact, exists: WCF uses the SOAP standard to define this mapping.</span></span> <span data-ttu-id="97902-230">Cuando una instancia `Message` se escribe como un conjunto de información XML, el conjunto de información resultante es la envoltura SOAP válida que contiene el mensaje.</span><span class="sxs-lookup"><span data-stu-id="97902-230">When a `Message` instance is written out as an XML Infoset, the resulting Infoset is the valid SOAP envelope that contains the message.</span></span> <span data-ttu-id="97902-231">Así, `WriteMessage` realizaría normalmente los siguientes pasos:</span><span class="sxs-lookup"><span data-stu-id="97902-231">Thus, `WriteMessage` would normally perform the following steps:</span></span>  
  
1. <span data-ttu-id="97902-232">Escribir la etiqueta de apertura del elemento de envoltura SOAP.</span><span class="sxs-lookup"><span data-stu-id="97902-232">Write the SOAP envelope element opening tag.</span></span>  
  
2. <span data-ttu-id="97902-233">Escribir la etiqueta de apertura de elemento de encabezado SOAP, escribir todos los encabezados y cerrar el elemento de encabezado.</span><span class="sxs-lookup"><span data-stu-id="97902-233">Write the SOAP header element opening tag, write out all of the headers, and close the header element.</span></span>  
  
3. <span data-ttu-id="97902-234">Escribir la etiqueta de apertura del elemento de cuerpo SOAP.</span><span class="sxs-lookup"><span data-stu-id="97902-234">Write the SOAP body element opening tag.</span></span>  
  
4. <span data-ttu-id="97902-235">Llamar a `WriteBodyContents` o a un método equivalente para escribir el cuerpo.</span><span class="sxs-lookup"><span data-stu-id="97902-235">Call `WriteBodyContents` or an equivalent method to write out the body.</span></span>  
  
5. <span data-ttu-id="97902-236">Cerrar los elementos de envoltura y cuerpo.</span><span class="sxs-lookup"><span data-stu-id="97902-236">Close the body and envelope elements.</span></span>  
  
 <span data-ttu-id="97902-237">Los pasos anteriores están estrechamente unidos a la norma de SOAP.</span><span class="sxs-lookup"><span data-stu-id="97902-237">The preceding steps are closely tied to the SOAP standard.</span></span> <span data-ttu-id="97902-238">Esto es complicado, por el hecho de que existen múltiples versiones de SOAP, por ejemplo, es imposible escribir correctamente el elemento de envoltura de SOAP sin conocer la versión SOAP que se está utilizando.</span><span class="sxs-lookup"><span data-stu-id="97902-238">This is complicated by the fact that multiple versions of SOAP exist, for example, it is impossible to write out the SOAP envelope element correctly without knowing the SOAP version in use.</span></span> <span data-ttu-id="97902-239">Asimismo, en algunos casos, puede ser deseable desactivar completamente esta compleja asignación específica del SOAP.</span><span class="sxs-lookup"><span data-stu-id="97902-239">Also, in some cases, it may be desirable to turn off this complex SOAP-specific mapping completely.</span></span>  
  
 <span data-ttu-id="97902-240">Para ello, se proporciona una propiedad `Version` en `Message`.</span><span class="sxs-lookup"><span data-stu-id="97902-240">For these purposes, a `Version` property is provided on `Message`.</span></span> <span data-ttu-id="97902-241">Puede establecerse como la versión de SOAP que se va a utilizar cuando se escriba el mensaje, o puede establecerse como `None` para evitar cualquier asignación específica de SOAP.</span><span class="sxs-lookup"><span data-stu-id="97902-241">It can be set to the SOAP version to use when writing out the message, or it can be set to `None` to prevent any SOAP-specific mappings.</span></span> <span data-ttu-id="97902-242">Si la propiedad `Version` se define como `None`, los métodos que operan con todo el mensaje actúan como si el mensaje solo estuviera compuesto de su cuerpo, por ejemplo, `WriteMessage` llamaría simplemente a `WriteBodyContents` en lugar de realizar los diversos pasos enumerados anteriormente.</span><span class="sxs-lookup"><span data-stu-id="97902-242">If the `Version` property is set to `None`, methods that work with the entire message act as if the message consisted of its body only, for example, `WriteMessage` would simply call `WriteBodyContents` instead of performing the multiple steps listed above.</span></span> <span data-ttu-id="97902-243">Se espera que en los mensajes entrantes, `Version` se detecte automáticamente y defina correctamente.</span><span class="sxs-lookup"><span data-stu-id="97902-243">It is expected that on incoming messages, `Version` will be auto-detected and set correctly.</span></span>  
  
## <a name="the-channel-stack"></a><span data-ttu-id="97902-244">La pila de canales</span><span class="sxs-lookup"><span data-stu-id="97902-244">The Channel Stack</span></span>  
  
### <a name="channels"></a><span data-ttu-id="97902-245">Canales</span><span class="sxs-lookup"><span data-stu-id="97902-245">Channels</span></span>  
 <span data-ttu-id="97902-246">Tal y como se dijo antes, la pila de canales es responsable de la conversión de instancias <xref:System.ServiceModel.Channels.Message> salientes en alguna acción (como enviar paquetes a través de la red) o de la conversión alguna acción (como recibir paquetes de la red) en instancias `Message` entrantes.</span><span class="sxs-lookup"><span data-stu-id="97902-246">As stated before, the channel stack is responsible for converting outgoing <xref:System.ServiceModel.Channels.Message> instances into some action (such as sending packets over the network), or converting some action (such as receiving network packets) into incoming `Message` instances.</span></span>  
  
 <span data-ttu-id="97902-247">La pila de canales consta de uno o más canales ordenados en una secuencia.</span><span class="sxs-lookup"><span data-stu-id="97902-247">The channel stack is composed of one or more channels ordered in a sequence.</span></span> <span data-ttu-id="97902-248">Una instancia de `Message` saliente se pasa al primer canal de la pila (también llamado *canal más alto*), que lo pasa al siguiente canal que esté por debajo en la pila, y así sucesivamente.</span><span class="sxs-lookup"><span data-stu-id="97902-248">An outgoing `Message` instance is passed to the first channel in the stack (also called the *topmost channel*), which passes it to the next channel down in stack, and so on.</span></span> <span data-ttu-id="97902-249">El mensaje finaliza en el último canal, que se denomina el *canal de transporte*.</span><span class="sxs-lookup"><span data-stu-id="97902-249">The message terminates in the last channel, which is called the *transport channel*.</span></span> <span data-ttu-id="97902-250">Los mensajes entrantes se originan en el canal de transporte y se pasan de canal en canal hacia arriba en la pila.</span><span class="sxs-lookup"><span data-stu-id="97902-250">Incoming messages originate in the transport channel and are passed from channel to channel up the stack.</span></span> <span data-ttu-id="97902-251">Desde el canal más alto, el mensaje se pasa normalmente al marco de trabajo de servicio.</span><span class="sxs-lookup"><span data-stu-id="97902-251">From the topmost channel, the message is usually passed into the service framework.</span></span> <span data-ttu-id="97902-252">Aunque éste es el patrón usual para los mensajes de aplicaciones, algunos canales pueden trabajar de manera algo diferente, por ejemplo, pueden enviar sus propios mensajes de infraestructura sin tener que pasar un mensaje de un canal superior.</span><span class="sxs-lookup"><span data-stu-id="97902-252">While this is the usual pattern for application messages, some channels may work slightly differently, for example, they may send their own infrastructure messages without being passed a message from a channel above.</span></span>  
  
 <span data-ttu-id="97902-253">Los canales pueden funcionar en el mensaje de varias maneras a medida que atraviesa la pila.</span><span class="sxs-lookup"><span data-stu-id="97902-253">Channels may operate on the message in various ways as it passes through the stack.</span></span> <span data-ttu-id="97902-254">La operación más común es agregar un encabezado a un mensaje saliente y leer los encabezados en un mensaje entrante.</span><span class="sxs-lookup"><span data-stu-id="97902-254">The most common operation is adding a header to an outgoing message and reading headers on an incoming message.</span></span> <span data-ttu-id="97902-255">Por ejemplo, un canal puede calcular la firma digital de un mensaje y agregarla como un encabezado.</span><span class="sxs-lookup"><span data-stu-id="97902-255">For example, a channel may compute the digital signature of a message and add it as a header.</span></span> <span data-ttu-id="97902-256">Un canal también puede inspeccionar este encabezado de firma digital en los mensajes entrantes y bloquear los mensajes que no tienen una firma para que no asciendan en la pila de canales.</span><span class="sxs-lookup"><span data-stu-id="97902-256">A channel may also inspect this digital signature header on incoming messages and block messages that do not have a valid signature from making their way up the channel stack.</span></span> <span data-ttu-id="97902-257">Los canales también definen o inspeccionan a menudo las propiedades de mensajes.</span><span class="sxs-lookup"><span data-stu-id="97902-257">Channels also often set or inspect message properties.</span></span> <span data-ttu-id="97902-258">Normalmente, el cuerpo del mensaje no se modifica, aunque se permite, por ejemplo, el canal de seguridad de WCF puede cifrar el cuerpo del mensaje.</span><span class="sxs-lookup"><span data-stu-id="97902-258">The message body is usually not modified, although this is allowed, for example, the WCF security channel can encrypt the message body.</span></span>  
  
### <a name="transport-channels-and-message-encoders"></a><span data-ttu-id="97902-259">Canales de transporte y codificadores de mensajes</span><span class="sxs-lookup"><span data-stu-id="97902-259">Transport Channels and Message Encoders</span></span>  
 <span data-ttu-id="97902-260">El canal más bajo de la pila es el responsable de la transformación real de un <xref:System.ServiceModel.Channels.Message>saliente, tal y como lo modificaron otros canales, en alguna acción.</span><span class="sxs-lookup"><span data-stu-id="97902-260">The bottommost channel in the stack is responsible for actually transforming an outgoing <xref:System.ServiceModel.Channels.Message>, as modified by other channels, into some action.</span></span> <span data-ttu-id="97902-261">En el lado de recepción, éste es el canal que convierte alguna acción en un `Message` que otros canales procesan.</span><span class="sxs-lookup"><span data-stu-id="97902-261">On the receive side, this is the channel that converts some action into a `Message` that other channels process.</span></span>  
  
 <span data-ttu-id="97902-262">Como se dijo anteriormente, se pueden variar las acciones: envío o recepción de paquetes de red a través de varios protocolos, lectura o escritura del mensaje en una base de datos o puesta o eliminación de la cola en una cola de Message Queuing, por mencionar unos pocos ejemplos.</span><span class="sxs-lookup"><span data-stu-id="97902-262">As stated previously, the actions may be varied: sending or receiving network packets over various protocols, reading or writing the message in a database, or queuing or dequeuing the message in a Message Queuing queue, to provide but a few examples.</span></span> <span data-ttu-id="97902-263">Todas estas acciones tienen algo en común: requieren una transformación entre la instancia de WCF `Message` y un grupo real de bytes que se puede enviar, recibir, leer, escribir, poner en cola o quitar de la cola.</span><span class="sxs-lookup"><span data-stu-id="97902-263">All these actions have one thing in common: they require a transformation between the WCF`Message` instance and an actual group of bytes that can be sent, received, read, written, queued, or dequeued.</span></span> <span data-ttu-id="97902-264">El proceso de conversión de un `Message` en un grupo de bytes se denomina *codificación*y el proceso inverso de crear `Message` a partir de un grupo de bytes se denomina *decodificación*.</span><span class="sxs-lookup"><span data-stu-id="97902-264">The process of converting a `Message` into a group of bytes is called *encoding*, and the reverse process of creating a `Message` from a group of bytes is called *decoding*.</span></span>  
  
 <span data-ttu-id="97902-265">La mayoría de los canales de transporte usan componentes llamados *codificadores de mensajes* para realizar las tareas de codificación y decodificación.</span><span class="sxs-lookup"><span data-stu-id="97902-265">Most transport channels use components called *message encoders* to accomplish the encoding and decoding work.</span></span> <span data-ttu-id="97902-266">Un codificador de mensajes es una subclase de la clase <xref:System.ServiceModel.Channels.MessageEncoder> .</span><span class="sxs-lookup"><span data-stu-id="97902-266">A message encoder is a subclass of the <xref:System.ServiceModel.Channels.MessageEncoder> class.</span></span> <span data-ttu-id="97902-267">`MessageEncoder` incluye varias sobrecargas de método `ReadMessage` y `WriteMessage` para convertir entre `Message` y grupos de bytes.</span><span class="sxs-lookup"><span data-stu-id="97902-267">`MessageEncoder` includes various `ReadMessage` and `WriteMessage` method overloads to convert between `Message` and groups of bytes.</span></span>  
  
 <span data-ttu-id="97902-268">En el lado de envío, un canal de transporte de almacenado en búfer pasa el objeto `Message` que recibió de un canal situado sobre él para `WriteMessage`.</span><span class="sxs-lookup"><span data-stu-id="97902-268">On the sending side, a buffering transport channel passes the `Message` object that it received from a channel above it to `WriteMessage`.</span></span> <span data-ttu-id="97902-269">Recibe una matriz de bytes, que utiliza a continuación para realizar su acción (como empaquetar estos bytes como paquetes TCP válidos y enviarlos al destino correcto).</span><span class="sxs-lookup"><span data-stu-id="97902-269">It gets back an array of bytes, which it then uses to perform its action (such as packaging these bytes as valid TCP packets and sending them to the correct destination).</span></span> <span data-ttu-id="97902-270">Un canal de transporte de transmisión por secuencia crea primero una `Stream` (por ejemplo, sobre la conexión TCP de salida) y, a continuación, pasa la `Stream` y el `Message` que necesita para enviar a la sobrecarga `WriteMessage` adecuada, que escribe el mensaje.</span><span class="sxs-lookup"><span data-stu-id="97902-270">A streaming transport channel first creates a `Stream` (for example, over the outgoing TCP connection), and then passes both the `Stream` and the `Message` it needs to send to the appropriate `WriteMessage` overload, which writes out the message.</span></span>  
  
 <span data-ttu-id="97902-271">En el lado de recepción, un canal de transporte de almacenado en búfer extrae los bytes de entrada (por ejemplo, de los paquetes TCP entrantes) en una matriz y llama `ReadMessage` para obtener un objeto `Message` que puede pasar hacia arriba en la pila de canales.</span><span class="sxs-lookup"><span data-stu-id="97902-271">On the receiving side, a buffering transport channel extracts incoming bytes (for example, from incoming TCP packets) into an array and calls `ReadMessage` to get a `Message` object that it can pass further up the channel stack.</span></span> <span data-ttu-id="97902-272">Un canal de transporte de transmisión por secuencias crea un objeto `Stream` (por ejemplo, una secuencia de red sobre la conexión TCP entrante) y pasa eso a `ReadMessage` para recibir un objeto `Message` .</span><span class="sxs-lookup"><span data-stu-id="97902-272">A streaming transport channel creates a `Stream` object (for example, a network stream over the incoming TCP connection) and passes that to `ReadMessage` to get back a `Message` object.</span></span>  
  
 <span data-ttu-id="97902-273">La separación entre los canales de transporte y el codificador de mensajes no es obligatoria; es posible escribir un canal de transporte que no use un codificador de mensajes.</span><span class="sxs-lookup"><span data-stu-id="97902-273">The separation between the transport channels and the message encoder is not mandatory; it is possible to write a transport channel that does not use a message encoder.</span></span> <span data-ttu-id="97902-274">Sin embargo, la ventaja de esta separación es la facilidad de composición.</span><span class="sxs-lookup"><span data-stu-id="97902-274">However, the advantage of this separation is ease of composition.</span></span> <span data-ttu-id="97902-275">Siempre y cuando un canal de transporte use solo la base <xref:System.ServiceModel.Channels.MessageEncoder> , puede funcionar con cualquier codificador de mensajes de WCF o de otro fabricante.</span><span class="sxs-lookup"><span data-stu-id="97902-275">As long as a transport channel uses only the base <xref:System.ServiceModel.Channels.MessageEncoder>, it can work with any WCF or third-party message encoder.</span></span> <span data-ttu-id="97902-276">De igual modo, el mismo codificador puede usarse normalmente en cualquier canal de transporte.</span><span class="sxs-lookup"><span data-stu-id="97902-276">Likewise, the same encoder can normally be used in any transport channel.</span></span>  
  
### <a name="message-encoder-operation"></a><span data-ttu-id="97902-277">Operación del codificador de mensajes</span><span class="sxs-lookup"><span data-stu-id="97902-277">Message Encoder Operation</span></span>  
 <span data-ttu-id="97902-278">Para describir la operación típica de un codificador, es útil considerar los cuatro casos siguientes.</span><span class="sxs-lookup"><span data-stu-id="97902-278">To describe the typical operation of an encoder, it is useful to consider the following four cases.</span></span>  
  
|<span data-ttu-id="97902-279">Operación</span><span class="sxs-lookup"><span data-stu-id="97902-279">Operation</span></span>|<span data-ttu-id="97902-280">Comentario</span><span class="sxs-lookup"><span data-stu-id="97902-280">Comment</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="97902-281">Codificación, almacenado en búfer</span><span class="sxs-lookup"><span data-stu-id="97902-281">Encoding, Buffered</span></span>|<span data-ttu-id="97902-282">En el modo de almacenado en búfer, el codificador crea normalmente un búfer de tamaño variable y, a continuación, crea un sistema de escritura de XML sobre él.</span><span class="sxs-lookup"><span data-stu-id="97902-282">In buffered mode, the encoder normally creates a variable-size buffer and then creates an XML writer over it.</span></span> <span data-ttu-id="97902-283">A continuación, llama a <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> en el mensaje que se está codificando que escribe los encabezados y, a continuación, el cuerpo mediante <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29>, como se explicó en la sección anterior sobre `Message` en este tema.</span><span class="sxs-lookup"><span data-stu-id="97902-283">It then calls <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> on the message being encoded, which writes out the headers and then the body using <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29>, as explained in the preceding section about `Message` in this topic.</span></span> <span data-ttu-id="97902-284">El contenido del búfer (representado como una matriz de bytes) es devuelto a continuación para que lo use el canal de transporte.</span><span class="sxs-lookup"><span data-stu-id="97902-284">The contents of the buffer (represented as an array of bytes) are then returned for the transport channel to use.</span></span>|  
|<span data-ttu-id="97902-285">Codificación, secuenciada</span><span class="sxs-lookup"><span data-stu-id="97902-285">Encoding, Streamed</span></span>|<span data-ttu-id="97902-286">En modo secuenciado, la operación es similar a la anterior, pero más sencilla.</span><span class="sxs-lookup"><span data-stu-id="97902-286">In streamed mode, the operation is similar to the above, but simpler.</span></span> <span data-ttu-id="97902-287">No hay necesidad de un búfer.</span><span class="sxs-lookup"><span data-stu-id="97902-287">There is no need for a buffer.</span></span> <span data-ttu-id="97902-288">Un sistema de escritura de XML se crea normalmente sobre la secuencia y se llama a <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> en el `Message` para escribirlo en este sistema de escritura.</span><span class="sxs-lookup"><span data-stu-id="97902-288">An XML writer is normally created over the stream and <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> is called on the `Message` to write it out to this writer.</span></span>|  
|<span data-ttu-id="97902-289">Decodificación, almacenado en búfer</span><span class="sxs-lookup"><span data-stu-id="97902-289">Decoding, Buffered</span></span>|<span data-ttu-id="97902-290">Al decodificar en modo de almacenado en búfer, se crea normalmente una subclase `Message` especial que contiene los datos almacenados en búfer.</span><span class="sxs-lookup"><span data-stu-id="97902-290">When decoding in buffered mode, a special `Message` subclass that contains the buffered data is normally created.</span></span> <span data-ttu-id="97902-291">Se leen los encabezados del mensaje y se crea un lector XML colocado en el cuerpo del mensaje.</span><span class="sxs-lookup"><span data-stu-id="97902-291">The headers of the message are read, and an XML reader positioned on the message body is created.</span></span> <span data-ttu-id="97902-292">Éste es el lector que se devolverá con <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents>.</span><span class="sxs-lookup"><span data-stu-id="97902-292">This is the reader that will be returned with <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents>.</span></span>|  
|<span data-ttu-id="97902-293">Decodificación, secuenciada</span><span class="sxs-lookup"><span data-stu-id="97902-293">Decoding, Streamed</span></span>|<span data-ttu-id="97902-294">Al decodificar en modo secuenciado, se crea normalmente una subclase Message especial.</span><span class="sxs-lookup"><span data-stu-id="97902-294">When decoding in streamed mode, a special Message subclass is normally created.</span></span> <span data-ttu-id="97902-295">La secuencia se avanza lo suficiente para leer todos los encabezados y colocarlos en el cuerpo del mensaje.</span><span class="sxs-lookup"><span data-stu-id="97902-295">The stream is advanced just enough to read all the headers and position it on the message body.</span></span> <span data-ttu-id="97902-296">A continuación, se crea un lector XML sobre la secuencia.</span><span class="sxs-lookup"><span data-stu-id="97902-296">An XML reader is then created over the stream.</span></span> <span data-ttu-id="97902-297">Éste es el lector que se devolverá con <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents>.</span><span class="sxs-lookup"><span data-stu-id="97902-297">This is the reader that will be returned with <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents>.</span></span>|  
  
 <span data-ttu-id="97902-298">Los codificadores también pueden realizar otras funciones.</span><span class="sxs-lookup"><span data-stu-id="97902-298">Encoders can perform other functions as well.</span></span> <span data-ttu-id="97902-299">Por ejemplo, los codificadores pueden agrupar sistemas de lectura y escritura XML.</span><span class="sxs-lookup"><span data-stu-id="97902-299">For example, the encoders can pool XML readers and writers.</span></span> <span data-ttu-id="97902-300">Es caro crear un nuevo sistema de lectura o escritura XML cada vez que se necesita.</span><span class="sxs-lookup"><span data-stu-id="97902-300">It is expensive to create a new XML reader or writer every time one is needed.</span></span> <span data-ttu-id="97902-301">Por consiguiente, los codificadores mantienen normalmente un grupo de sistemas de lectura y escritura de tamaño configurable.</span><span class="sxs-lookup"><span data-stu-id="97902-301">Therefore, encoders normally maintain a pool of readers and a pool of writers of configurable size.</span></span> <span data-ttu-id="97902-302">En las descripciones de la operación del codificador descrita anteriormente, cada vez que se usa la frase "crear un lector/escritor XML", normalmente significa "tomar una del grupo o crear una si no hay ninguna disponible".</span><span class="sxs-lookup"><span data-stu-id="97902-302">In the descriptions of encoder operation described previously, whenever the phrase "create an XML reader/writer" is used, it normally means "take one from the pool, or create one if one is not available."</span></span> <span data-ttu-id="97902-303">El codificador, así como las subclases `Message` que se crean con la descodificación, contienen la lógica para devolver sistemas de lectura y escritura a los grupos cuando ya no se necesitan, por ejemplo, cuando se cierra el `Message` ).</span><span class="sxs-lookup"><span data-stu-id="97902-303">The encoder (and the `Message` subclasses it creates while decoding) contain logic to return readers and writers to the pools once they are no longer needed (for example, when the `Message` is closed).</span></span>  
  
 <span data-ttu-id="97902-304">WCF proporciona tres codificadores de mensajes, aunque es posible crear tipos personalizados adicionales.</span><span class="sxs-lookup"><span data-stu-id="97902-304">WCF provides three message encoders, although it is possible to create additional custom types.</span></span> <span data-ttu-id="97902-305">Los tipos proporcionados son Texto, Binario y Mecanismo de optimización de transmisión de mensajes (MTOM).</span><span class="sxs-lookup"><span data-stu-id="97902-305">The supplied types are Text, Binary, and Message Transmission Optimization Mechanism (MTOM).</span></span> <span data-ttu-id="97902-306">Estos se describen en detalle en [Choosing a Message Encoder](choosing-a-message-encoder.md).</span><span class="sxs-lookup"><span data-stu-id="97902-306">These are described in detail in [Choosing a Message Encoder](choosing-a-message-encoder.md).</span></span>  
  
### <a name="the-istreamprovider-interface"></a><span data-ttu-id="97902-307">La interfaz IStreamProvider</span><span class="sxs-lookup"><span data-stu-id="97902-307">The IStreamProvider Interface</span></span>  
 <span data-ttu-id="97902-308">Al escribir un mensaje saliente que contiene un cuerpo transmitido a un sistema de escritura XML, <xref:System.ServiceModel.Channels.Message> utilizará una secuencia de llamadas similar a la siguiente en su implementación <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> :</span><span class="sxs-lookup"><span data-stu-id="97902-308">When writing an outgoing message that contains a streamed body to an XML writer, the <xref:System.ServiceModel.Channels.Message> uses a sequence of calls similar to the following in its <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> implementation:</span></span>  
  
- <span data-ttu-id="97902-309">Escriba cualquier información necesaria que preceda a la secuencia (por ejemplo, la etiqueta de apertura XML)</span><span class="sxs-lookup"><span data-stu-id="97902-309">Write any necessary information preceding the stream (for example, the opening XML tag).</span></span>  
  
- <span data-ttu-id="97902-310">Escriba la secuencia.</span><span class="sxs-lookup"><span data-stu-id="97902-310">Write the stream.</span></span>  
  
- <span data-ttu-id="97902-311">Escriba cualquier información que siga a la secuencia (por ejemplo, la etiqueta de cierre XML)</span><span class="sxs-lookup"><span data-stu-id="97902-311">Write any information following the stream (for example, the closing XML tag).</span></span>  
  
 <span data-ttu-id="97902-312">Esto funciona bien con codificaciones similares a la codificación XML textual.</span><span class="sxs-lookup"><span data-stu-id="97902-312">This works well with encodings that are similar to the textual XML encoding.</span></span> <span data-ttu-id="97902-313">Sin embargo, hay algunas codificaciones que no proporcionan información del conjunto de información XML (por ejemplo, etiquetas para iniciar y finalizar elementos XML) junto con los datos contenidos en los elementos.</span><span class="sxs-lookup"><span data-stu-id="97902-313">However, some encodings do not place XML Infoset information (for example, tags for starting and ending XML elements) together with the data contained within elements.</span></span> <span data-ttu-id="97902-314">Por ejemplo, para la codificación MTOM, la codificación del mensaje se divide en varias partes.</span><span class="sxs-lookup"><span data-stu-id="97902-314">For example, in the MTOM encoding, the message is split into multiple parts.</span></span> <span data-ttu-id="97902-315">Una parte contiene el conjunto de información XML, que puede contener referencias a otras partes de contenido de elementos reales.</span><span class="sxs-lookup"><span data-stu-id="97902-315">One part contains the XML Infoset, which may contain references to other parts for actual element contents.</span></span> <span data-ttu-id="97902-316">Puesto que el conjunto de información XML es normalmente pequeño en comparación con el contenido secuenciado, tiene sentido almacenar en búfer el conjunto de información, escribirlo y, a continuación, escribir el contenido de manera secuenciada.</span><span class="sxs-lookup"><span data-stu-id="97902-316">The XML Infoset is normally small compared to the streamed contents, so it makes sense to buffer the Infoset, write it out, and then write the contents in a streamed way.</span></span> <span data-ttu-id="97902-317">Esto significa que cuando se escribe la etiqueta del elemento de cierre, no se debería haber escrito todavía la secuencia.</span><span class="sxs-lookup"><span data-stu-id="97902-317">This means that by the time the closing element tag is written, the stream should not have been written out yet.</span></span>  
  
 <span data-ttu-id="97902-318">Para este propósito, se utiliza la interfaz <xref:System.Xml.IStreamProvider> .</span><span class="sxs-lookup"><span data-stu-id="97902-318">For this purpose, the <xref:System.Xml.IStreamProvider> interface is used.</span></span> <span data-ttu-id="97902-319">La interfaz tiene un método <xref:System.Xml.IStreamProvider.GetStream> que devuelve la secuencia que se va a escribir.</span><span class="sxs-lookup"><span data-stu-id="97902-319">The interface has a <xref:System.Xml.IStreamProvider.GetStream> method that returns the stream to be written.</span></span> <span data-ttu-id="97902-320">La manera correcta de escribir un cuerpo de mensaje transmitido <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> es la siguiente:</span><span class="sxs-lookup"><span data-stu-id="97902-320">The correct way to write out a streamed message body in <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> is as follows:</span></span>  
  
1. <span data-ttu-id="97902-321">Escriba cualquier información necesaria que preceda a la secuencia (por ejemplo, la etiqueta de apertura XML)</span><span class="sxs-lookup"><span data-stu-id="97902-321">Write any necessary information preceding the stream (for example, the opening XML tag).</span></span>  
  
2. <span data-ttu-id="97902-322">Llame a la sobrecarga `WriteValue` en el <xref:System.Xml.XmlDictionaryWriter> que toma <xref:System.Xml.IStreamProvider>, con una implementación `IStreamProvider` que devuelve la secuencia que se va a escribir.</span><span class="sxs-lookup"><span data-stu-id="97902-322">Call the `WriteValue` overload on the <xref:System.Xml.XmlDictionaryWriter> that takes an <xref:System.Xml.IStreamProvider>, with an `IStreamProvider` implementation that returns the stream to be written.</span></span>  
  
3. <span data-ttu-id="97902-323">Escriba cualquier información que siga a la secuencia (por ejemplo, la etiqueta de cierre XML)</span><span class="sxs-lookup"><span data-stu-id="97902-323">Write any information following the stream (for example, the closing XML tag).</span></span>  
  
 <span data-ttu-id="97902-324">Con este enfoque, el sistema de escritura XML puede escoger cuándo llamar <xref:System.Xml.IStreamProvider.GetStream> y escribir los datos transmitidos por secuencias.</span><span class="sxs-lookup"><span data-stu-id="97902-324">With this approach, the XML writer has a choice of when to call <xref:System.Xml.IStreamProvider.GetStream> and write out the streamed data.</span></span> <span data-ttu-id="97902-325">Por ejemplo, los sistemas de escritura XML textuales y binarios lo llamarán inmediatamente y escribirán el contenido transmitido por secuencias entre las etiquetas de inicio y cierre.</span><span class="sxs-lookup"><span data-stu-id="97902-325">For example, the textual and binary XML writers will call it immediately and write out the streamed contents in-between the start and end tags.</span></span> <span data-ttu-id="97902-326">El sistema de escritura de MTOM puede decidir llamar <xref:System.Xml.IStreamProvider.GetStream> posteriormente, cuando esté listo para escribir la parte adecuada del mensaje.</span><span class="sxs-lookup"><span data-stu-id="97902-326">The MTOM writer may decide to call <xref:System.Xml.IStreamProvider.GetStream> later, when it is ready to write the appropriate part of the message.</span></span>  
  
## <a name="representing-data-in-the-service-framework"></a><span data-ttu-id="97902-327">Representación de datos en el marco de trabajo de servicio</span><span class="sxs-lookup"><span data-stu-id="97902-327">Representing Data in the Service Framework</span></span>  
 <span data-ttu-id="97902-328">Como se indica en la sección "arquitectura básica" de este tema, el marco de trabajo de servicio es la parte de WCF que, entre otras cosas, es responsable de la conversión entre un modelo de programación fácil de obtener para los datos de mensaje y `Message` las instancias reales.</span><span class="sxs-lookup"><span data-stu-id="97902-328">As stated in the "Basic Architecture" section of this topic, the service framework is the part of WCF that, among other things, is responsible for converting between a user-friendly programming model for message data and actual `Message` instances.</span></span> <span data-ttu-id="97902-329">Normalmente, un intercambio de mensajes se representa en el marco de trabajo de servicio como un .NET Framework método marcado con el <xref:System.ServiceModel.OperationContractAttribute> atributo.</span><span class="sxs-lookup"><span data-stu-id="97902-329">Normally, a message exchange is represented in the service framework as a .NET Framework method marked with the <xref:System.ServiceModel.OperationContractAttribute> attribute.</span></span> <span data-ttu-id="97902-330">El método puede tomar algunos parámetros y devolver un valor devuelto o parámetros out (o ambos).</span><span class="sxs-lookup"><span data-stu-id="97902-330">The method can take in some parameters and can return a return value or out parameters (or both).</span></span> <span data-ttu-id="97902-331">En el lado de servicio, los parámetros de entrada representan el mensaje entrante y el valor devuelto y los parámetros out representan el mensaje saliente.</span><span class="sxs-lookup"><span data-stu-id="97902-331">On the service side, the input parameters represent the incoming message, and the return value and out parameters represent the outgoing message.</span></span> <span data-ttu-id="97902-332">En el lado de cliente, se cumple lo contrario.</span><span class="sxs-lookup"><span data-stu-id="97902-332">On the client side, the reverse is true.</span></span> <span data-ttu-id="97902-333">El modelo de programación para la descripción de mensajes mediante el uso de parámetros y el valor devuelto se describe en detalle en [Specifying Data Transfer in Service Contracts](specifying-data-transfer-in-service-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="97902-333">The programming model for describing messages using parameters and the return value is described in detail in [Specifying Data Transfer in Service Contracts](specifying-data-transfer-in-service-contracts.md).</span></span> <span data-ttu-id="97902-334">Sin embargo, esta sección proporcionará una información general resumida.</span><span class="sxs-lookup"><span data-stu-id="97902-334">However, this section will provide a brief overview.</span></span>  
  
## <a name="programming-models"></a><span data-ttu-id="97902-335">Modelos de programación</span><span class="sxs-lookup"><span data-stu-id="97902-335">Programming Models</span></span>  
 <span data-ttu-id="97902-336">El marco de trabajo de servicio de WCF admite cinco modelos de programación diferentes para describir mensajes:</span><span class="sxs-lookup"><span data-stu-id="97902-336">The WCF service framework supports five different programming models for describing messages:</span></span>  
  
### <a name="1-the-empty-message"></a><span data-ttu-id="97902-337">1. El mensaje vacío</span><span class="sxs-lookup"><span data-stu-id="97902-337">1. The Empty Message</span></span>  
 <span data-ttu-id="97902-338">Éste es el caso más simple.</span><span class="sxs-lookup"><span data-stu-id="97902-338">This is the simplest case.</span></span> <span data-ttu-id="97902-339">Para describir un mensaje entrante vacío, no utilice ningún parámetro de entrada.</span><span class="sxs-lookup"><span data-stu-id="97902-339">To describe an empty incoming message, do not use any input parameters.</span></span>  
  
 [!code-csharp[C_DataArchitecture#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#3)]
 [!code-vb[C_DataArchitecture#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#3)]  
  
 <span data-ttu-id="97902-340">Para describir un mensaje saliente vacío, utilice un valor devuelto nulo y no utilice ningún parámetro out:</span><span class="sxs-lookup"><span data-stu-id="97902-340">To describe an empty outgoing message, use a void return value and do not use any out parameters:</span></span>  
  
 [!code-csharp[C_DataArchitecture#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#4)]
 [!code-vb[C_DataArchitecture#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#4)]  
  
 <span data-ttu-id="97902-341">Observe que esto es diferente de un contrato de operación unidireccional:</span><span class="sxs-lookup"><span data-stu-id="97902-341">Note that this is different from a one-way operation contract:</span></span>  
  
 [!code-csharp[C_DataArchitecture#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#5)]
 [!code-vb[C_DataArchitecture#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#5)]  
  
 <span data-ttu-id="97902-342">En el ejemplo `SetDesiredTemperature` , se describe un patrón de intercambio de mensajes bidireccional.</span><span class="sxs-lookup"><span data-stu-id="97902-342">In the `SetDesiredTemperature` example, a two-way message exchange pattern is described.</span></span> <span data-ttu-id="97902-343">Se devuelve un mensaje de la operación, pero está vacío.</span><span class="sxs-lookup"><span data-stu-id="97902-343">A message is returned from the operation, but it is empty.</span></span> <span data-ttu-id="97902-344">Es posible devolver un error de la operación.</span><span class="sxs-lookup"><span data-stu-id="97902-344">It is possible to return a fault from the operation.</span></span> <span data-ttu-id="97902-345">En el ejemplo "Definir bombilla", el patrón de intercambio de mensajes es unidireccional, por lo que no hay ningún mensaje saliente para describir.</span><span class="sxs-lookup"><span data-stu-id="97902-345">In the "Set Lightbulb" example, the message exchange pattern is one-way, so there is no outgoing message to describe.</span></span> <span data-ttu-id="97902-346">El servicio no puede devolver ningún estado al cliente en este caso.</span><span class="sxs-lookup"><span data-stu-id="97902-346">The service cannot communicate any status back to the client in this case.</span></span>  
  
### <a name="2-using-the-message-class-directly"></a><span data-ttu-id="97902-347">2. Uso de la clase Message directamente</span><span class="sxs-lookup"><span data-stu-id="97902-347">2. Using the Message Class Directly</span></span>  
 <span data-ttu-id="97902-348">Es posible utilizar directamente la clase <xref:System.ServiceModel.Channels.Message> (o una de sus subclases) en un contrato de operación.</span><span class="sxs-lookup"><span data-stu-id="97902-348">It is possible to use the <xref:System.ServiceModel.Channels.Message> class (or one of its subclasses) directly in an operation contract.</span></span> <span data-ttu-id="97902-349">En este caso, el marco de trabajo de servicio simplemente pasa el `Message` de la operación a la pila de canales y viceversa, sin procesamiento adicional.</span><span class="sxs-lookup"><span data-stu-id="97902-349">In this case, the service framework just passes the `Message` from the operation to the channel stack and vice versa, with no further processing.</span></span>  
  
 <span data-ttu-id="97902-350">Hay dos casos principales para utilizar directamente `Message` .</span><span class="sxs-lookup"><span data-stu-id="97902-350">There are two main use cases for using `Message` directly.</span></span> <span data-ttu-id="97902-351">Puede utilizar esto para escenarios avanzados, cuando ninguno de los otros modelos de programación le da suficiente flexibilidad para poder describir su mensaje.</span><span class="sxs-lookup"><span data-stu-id="97902-351">You can use this for advanced scenarios, when none of the other programming models gives you enough flexibility to describe your message.</span></span> <span data-ttu-id="97902-352">Por ejemplo, podría desear utilizar los archivos de un disco para describir un mensaje, con las propiedades de los archivos transformándose en encabezados del mensaje y el contenido de los archivos convirtiéndose en el cuerpo del mensaje.</span><span class="sxs-lookup"><span data-stu-id="97902-352">For example, you might want to use files on disk to describe a message, with the file’s properties becoming message headers and the file’s contents becoming the message body.</span></span> <span data-ttu-id="97902-353">Puede crear a continuación algo similar a lo siguiente.</span><span class="sxs-lookup"><span data-stu-id="97902-353">You can then create something similar to the following.</span></span>  
  
 [!code-csharp[C_DataArchitecture#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#6)]
 [!code-vb[C_DataArchitecture#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#6)]  
  
 <span data-ttu-id="97902-354">El segundo uso más extendido de un `Message` en un contrato de operación tiene lugar cuando un servicio no se preocupa del contenido concreto del mensaje y actúa sobre el mensaje como sobre una caja negra.</span><span class="sxs-lookup"><span data-stu-id="97902-354">The second common use for `Message` in an operation contract is when a service does not care about the particular message contents and acts on the message as on a black box.</span></span> <span data-ttu-id="97902-355">Por ejemplo, puede que tenga un servicio que reenvíe los mensajes a múltiples destinatarios.</span><span class="sxs-lookup"><span data-stu-id="97902-355">For example, you might have a service that forwards messages to multiple other recipients.</span></span> <span data-ttu-id="97902-356">El contrato se puede escribir del siguiente modo.</span><span class="sxs-lookup"><span data-stu-id="97902-356">The contract can be written as follows.</span></span>  
  
 [!code-csharp[C_DataArchitecture#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#7)]
 [!code-vb[C_DataArchitecture#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#7)]  
  
 <span data-ttu-id="97902-357">La línea Action = "\*" desactiva eficazmente el envío de mensajes y garantiza que todos los mensajes enviados al `IForwardingService` contrato hagan su camino a la `ForwardMessage` operación.</span><span class="sxs-lookup"><span data-stu-id="97902-357">The Action="\*" line effectively turns off message dispatching and ensures that all messages sent to the `IForwardingService` contract make their way to the `ForwardMessage` operation.</span></span> <span data-ttu-id="97902-358">(Normalmente, el distribuidor examinaría el encabezado "Action" del mensaje para determinar la operación para la que está previsto.</span><span class="sxs-lookup"><span data-stu-id="97902-358">(Normally, the dispatcher would examine the message’s "Action" header to determine which operation it is intended for.</span></span> <span data-ttu-id="97902-359">Action = " \* " significa "todos los valores posibles del encabezado de acción"). La combinación de Action = " \* " y el uso de Message como parámetro se conoce como "contrato universal", ya que es capaz de recibir todos los mensajes posibles.</span><span class="sxs-lookup"><span data-stu-id="97902-359">Action="\*" means "all possible values of the Action header".) The combination of Action="\*" and using Message as a parameter is known as the "universal contract" because it is able to receive all possible messages.</span></span> <span data-ttu-id="97902-360">Para poder enviar todos los mensajes posibles, use Message como valor devuelto y establézcalo `ReplyAction` en " \* ".</span><span class="sxs-lookup"><span data-stu-id="97902-360">To be able to send all possible messages, use Message as the return value and set `ReplyAction` to "\*".</span></span> <span data-ttu-id="97902-361">Esto evitará que el marco de trabajo de servicio agregue su propio encabezado Action, lo que permite controlar este encabezado mediante el uso del objeto `Message` devuelto.</span><span class="sxs-lookup"><span data-stu-id="97902-361">This will prevent the service framework from adding its own Action header, enabling you to control this header using the `Message` object you return.</span></span>  
  
### <a name="3-message-contracts"></a><span data-ttu-id="97902-362">3. Contratos de mensajes</span><span class="sxs-lookup"><span data-stu-id="97902-362">3. Message Contracts</span></span>  
 <span data-ttu-id="97902-363">WCF proporciona un modelo de programación declarativo para la descripción de mensajes, denominado *contratos de mensajes*.</span><span class="sxs-lookup"><span data-stu-id="97902-363">WCF provides a declarative programming model for describing messages, called *message contracts*.</span></span> <span data-ttu-id="97902-364">Este modelo se describe en detalle en [Using Message Contracts](using-message-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="97902-364">This model is described in detail in [Using Message Contracts](using-message-contracts.md).</span></span> <span data-ttu-id="97902-365">Esencialmente, el mensaje completo se representa mediante un tipo de .NET Framework único que utiliza atributos como <xref:System.ServiceModel.MessageBodyMemberAttribute> y <xref:System.ServiceModel.MessageHeaderAttribute> para describir qué partes de la clase de contrato de mensaje se deben asignar a qué parte del mensaje.</span><span class="sxs-lookup"><span data-stu-id="97902-365">Essentially, the entire message is represented by a single .NET Framework type that uses attributes like the <xref:System.ServiceModel.MessageBodyMemberAttribute> and <xref:System.ServiceModel.MessageHeaderAttribute> to describe which parts of the message contract class should map to which part of the message.</span></span>  
  
 <span data-ttu-id="97902-366">Los contratos de mensajes proporcionan mucho control sobre las instancias `Message` resultantes (aunque obviamente no tanto control como el resultante al utilizar directamente la clase `Message` ).</span><span class="sxs-lookup"><span data-stu-id="97902-366">Message contracts provide a lot of control over the resulting `Message` instances (although obviously not as much control as using the `Message` class directly).</span></span> <span data-ttu-id="97902-367">Por ejemplo, los cuerpos de mensajes se crean a menudo a partir de varias partes de información, cada una representada por su propio elemento XML.</span><span class="sxs-lookup"><span data-stu-id="97902-367">For example, message bodies are often composed of multiple pieces of information, each represented by its own XML element.</span></span> <span data-ttu-id="97902-368">Estos elementos pueden hallarse directamente en el cuerpo (modo*vacío* ) o pueden *ajustarse* en un elemento XML que los abarque.</span><span class="sxs-lookup"><span data-stu-id="97902-368">These elements can either occur directly in the body (*bare* mode) or can be *wrapped* in an encompassing XML element.</span></span> <span data-ttu-id="97902-369">Utilizar el modelo de programación de contrato de mensajes permite decidir entre desnudo y ajustado y controlar el nombre del nombre del contenedor y del espacio de nombres.</span><span class="sxs-lookup"><span data-stu-id="97902-369">Using the message contract programming model enables you to make the bare-versus-wrapped decision and control the name of the wrapper name and namespace.</span></span>  
  
 <span data-ttu-id="97902-370">El siguiente ejemplo de código de un contrato de mensajes muestra estas características.</span><span class="sxs-lookup"><span data-stu-id="97902-370">The following code example of a message contract demonstrates these features.</span></span>  
  
 [!code-csharp[C_DataArchitecture#9](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#9)]
 [!code-vb[C_DataArchitecture#9](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#9)]  
  
 <span data-ttu-id="97902-371">Los elementos marcados para serializar (con <xref:System.ServiceModel.MessageBodyMemberAttribute>, <xref:System.ServiceModel.MessageHeaderAttribute>u otros atributos relacionados) deben ser serializables para participar en un contrato de mensaje.</span><span class="sxs-lookup"><span data-stu-id="97902-371">Items marked to be serialized (with the <xref:System.ServiceModel.MessageBodyMemberAttribute>, <xref:System.ServiceModel.MessageHeaderAttribute>, or other related attributes) must be serializable to participate in a message contract.</span></span> <span data-ttu-id="97902-372">Para obtener más información, vea la sección "serialización" más adelante en este tema.</span><span class="sxs-lookup"><span data-stu-id="97902-372">For more information, see the "Serialization" section later in this topic.</span></span>  
  
### <a name="4-parameters"></a><span data-ttu-id="97902-373">4. Parámetros</span><span class="sxs-lookup"><span data-stu-id="97902-373">4. Parameters</span></span>  
 <span data-ttu-id="97902-374">A menudo, un desarrollador que desea describir una operación que actúa en varios pedazos de datos no necesita el grado de control que los contratos de mensajes proporcionan.</span><span class="sxs-lookup"><span data-stu-id="97902-374">Often, a developer who wants to describe an operation that acts on multiple pieces of data does not need the degree of control that message contracts provide.</span></span> <span data-ttu-id="97902-375">Por ejemplo, al crear los nuevos servicios, uno normalmente no desea tomar la decisión de desnudo frente a ajustado, sino decidirse por el nombre del elemento contenedor.</span><span class="sxs-lookup"><span data-stu-id="97902-375">For example, when creating new services, one does not usually want to make the bare-versus-wrapped decision and decide on the wrapper element name.</span></span> <span data-ttu-id="97902-376">La toma de estas decisiones a menudo requiere un amplio conocimiento de servicios Web y SOAP.</span><span class="sxs-lookup"><span data-stu-id="97902-376">Making these decisions often requires deep knowledge of Web services and SOAP.</span></span>  
  
 <span data-ttu-id="97902-377">El marco de trabajo de servicio de WCF puede elegir automáticamente la representación SOAP mejor y más interoperable para enviar o recibir varias partes relacionadas de la información, sin forzar a estas opciones en el usuario.</span><span class="sxs-lookup"><span data-stu-id="97902-377">The WCF service framework can automatically pick the best and most interoperable SOAP representation for sending or receiving multiple related pieces of information, without forcing these choices on the user.</span></span> <span data-ttu-id="97902-378">Para ello, basta con describir estos fragmentos de información como parámetros o valores devueltos de un contrato de operación.</span><span class="sxs-lookup"><span data-stu-id="97902-378">This is accomplished by simply describing these pieces of information as parameters or return values of an operation contract.</span></span> <span data-ttu-id="97902-379">Por ejemplo, considere el siguiente contrato de operación:</span><span class="sxs-lookup"><span data-stu-id="97902-379">For example, consider the following operation contract.</span></span>  
  
 [!code-csharp[C_DataArchitecture#11](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#11)]
 [!code-vb[C_DataArchitecture#11](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#11)]  
  
 <span data-ttu-id="97902-380">El marco de trabajo de servicio decide automáticamente colocar las tres piezas de información (`customerID`, `item`y `quantity`) en el cuerpo del mensaje y ajustarlas en un elemento contenedor denominado `SubmitOrderRequest`.</span><span class="sxs-lookup"><span data-stu-id="97902-380">The service framework automatically decides to put all three pieces of information (`customerID`, `item`, and `quantity`) into the message body and wrap them in a wrapper element named `SubmitOrderRequest`.</span></span>  
  
 <span data-ttu-id="97902-381">Describir la información que se va a enviar o recibir como una simple lista de parámetros de contratos de operaciones es el enfoque recomendado, a menos que tenga razones especiales para pasar al contrato de mensaje más complejo o a los modelos de programación basados en `Message`.</span><span class="sxs-lookup"><span data-stu-id="97902-381">Describing the information to be sent or received as a simple list of operation contract parameters is the recommended approach, unless special reasons exist to move to the more-complex message contract or `Message`-based programming models.</span></span>  
  
### <a name="5-stream"></a><span data-ttu-id="97902-382">5. Secuencia</span><span class="sxs-lookup"><span data-stu-id="97902-382">5. Stream</span></span>  
 <span data-ttu-id="97902-383">Utilizar `Stream` o una de sus subclases en un contrato de operación o como una sola parte del cuerpo del mensaje en un contrato de mensajes puede considerarse como  un modelo de programación independiente de los descritos anteriormente.</span><span class="sxs-lookup"><span data-stu-id="97902-383">Using `Stream` or one of its subclasses in an operation contract or as a sole message body part in a message contract can be considered a separate programming model from the ones described above.</span></span> <span data-ttu-id="97902-384">Utilizar `Stream` de esta manera es la única manera de garantizar que su contrato se podrá usar de manera secuenciada, sin tener que escribir su propia subclase `Message` compatible con transmisión por secuencias.</span><span class="sxs-lookup"><span data-stu-id="97902-384">Using `Stream` in this way is the only way to guarantee that your contract will be usable in a streamed fashion, short of writing your own streaming-compatible `Message` subclass.</span></span> <span data-ttu-id="97902-385">Para obtener más información, consulte [datos y streaming de gran tamaño](large-data-and-streaming.md).</span><span class="sxs-lookup"><span data-stu-id="97902-385">For more information, see [Large Data and Streaming](large-data-and-streaming.md).</span></span>  
  
 <span data-ttu-id="97902-386">Cuando `Stream` o una de sus subclases se utiliza de esta manera, no se invoca el serializador.</span><span class="sxs-lookup"><span data-stu-id="97902-386">When `Stream` or one of its subclasses is used in this way, the serializer is not invoked.</span></span> <span data-ttu-id="97902-387">Para los mensajes salientes, se crea una subclase `Message` de transmisión por secuencias y la secuencia se escribe tal y como se describe en la sección sobre la interfaz <xref:System.Xml.IStreamProvider> .</span><span class="sxs-lookup"><span data-stu-id="97902-387">For outgoing messages, a special streaming `Message` subclass is created and the stream is written out as described in the section on the <xref:System.Xml.IStreamProvider> interface.</span></span> <span data-ttu-id="97902-388">Para los mensajes entrantes, el marco de trabajo de servicio crea una subclase `Stream` sobre el mensaje entrante y la proporciona a la operación.</span><span class="sxs-lookup"><span data-stu-id="97902-388">For incoming messages, the service framework creates a `Stream` subclass over the incoming message and provides it to the operation.</span></span>  
  
## <a name="programming-model-restrictions"></a><span data-ttu-id="97902-389">Restricciones del modelo de programación</span><span class="sxs-lookup"><span data-stu-id="97902-389">Programming Model Restrictions</span></span>  
 <span data-ttu-id="97902-390">No se pueden combinar los modelos de programación descritos anteriormente de manera arbitraria.</span><span class="sxs-lookup"><span data-stu-id="97902-390">The programming models described above cannot be arbitrarily combined.</span></span> <span data-ttu-id="97902-391">Por ejemplo, si una operación acepta un tipo de contrato de mensajes, el contrato de mensajes debe ser su único parámetro de entrada.</span><span class="sxs-lookup"><span data-stu-id="97902-391">For example, if an operation accepts a message contract type, the message contract must be its only input parameter.</span></span> <span data-ttu-id="97902-392">Lo que es más, la operación debe devolver a continuación un mensaje vacío (tipo de valor devuelto de vacío) u otro contrato de mensajes.</span><span class="sxs-lookup"><span data-stu-id="97902-392">Furthermore, the operation must then either return an empty message (return type of void) or another message contract.</span></span> <span data-ttu-id="97902-393">Estas restricciones del modelo de programación se describen en los temas de cada modelo de programación concreto: [Using Message Contracts](using-message-contracts.md), [Using the Message Class](using-the-message-class.md)y [Large Data and Streaming](large-data-and-streaming.md).</span><span class="sxs-lookup"><span data-stu-id="97902-393">These programming model restrictions are described in the topics for each specific programming model: [Using Message Contracts](using-message-contracts.md), [Using the Message Class](using-the-message-class.md), and [Large Data and Streaming](large-data-and-streaming.md).</span></span>  
  
## <a name="message-formatters"></a><span data-ttu-id="97902-394">Formateadores de mensajes</span><span class="sxs-lookup"><span data-stu-id="97902-394">Message Formatters</span></span>  
 <span data-ttu-id="97902-395">Los modelos de programación descritos anteriormente se admiten agregando componentes llamados *formateadores de mensajes* en el marco de trabajo de servicio.</span><span class="sxs-lookup"><span data-stu-id="97902-395">The programming models described above are supported by plugging in components called *message formatters* into the service framework.</span></span> <span data-ttu-id="97902-396">Los formateadores de mensajes son tipos que implementan la <xref:System.ServiceModel.Dispatcher.IClientMessageFormatter> <xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter> interfaz o, o ambos, para su uso en clientes y clientes de WCF de servicio, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="97902-396">Message formatters are types that implement the <xref:System.ServiceModel.Dispatcher.IClientMessageFormatter> or <xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter> interface, or both, for use in clients and service WCF clients, respectively.</span></span>  
  
 <span data-ttu-id="97902-397">A los formateadores de mensajes se le agregan normalmente comportamientos.</span><span class="sxs-lookup"><span data-stu-id="97902-397">Message formatters are normally plugged in by behaviors.</span></span> <span data-ttu-id="97902-398">Por ejemplo, <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> agrega el formateador de mensajes de contratos de datos.</span><span class="sxs-lookup"><span data-stu-id="97902-398">For example, the <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> plugs in the data contract message formatter.</span></span> <span data-ttu-id="97902-399">Esto se hace en el lado de servicio estableciendo <xref:System.ServiceModel.Dispatcher.DispatchOperation.Formatter%2A> en el formateador correcto en el método <xref:System.ServiceModel.Description.IOperationBehavior.ApplyDispatchBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.DispatchOperation%29> o en el lado de cliente estableciendo <xref:System.ServiceModel.Dispatcher.ClientOperation.Formatter%2A> en el formateador correcto en el método <xref:System.ServiceModel.Description.IOperationBehavior.ApplyClientBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.ClientOperation%29> .</span><span class="sxs-lookup"><span data-stu-id="97902-399">This is done on the service side by setting <xref:System.ServiceModel.Dispatcher.DispatchOperation.Formatter%2A> to the correct formatter in the <xref:System.ServiceModel.Description.IOperationBehavior.ApplyDispatchBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.DispatchOperation%29> method, or on the client side by setting <xref:System.ServiceModel.Dispatcher.ClientOperation.Formatter%2A> to the correct formatter in the <xref:System.ServiceModel.Description.IOperationBehavior.ApplyClientBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.ClientOperation%29> method.</span></span>  
  
 <span data-ttu-id="97902-400">Las siguientes tablas enumeran los métodos que un formateador de mensajes puede implementar.</span><span class="sxs-lookup"><span data-stu-id="97902-400">The following tables lists the methods that a message formatter may implement.</span></span>  
  
|<span data-ttu-id="97902-401">Interfaz</span><span class="sxs-lookup"><span data-stu-id="97902-401">Interface</span></span>|<span data-ttu-id="97902-402">Método</span><span class="sxs-lookup"><span data-stu-id="97902-402">Method</span></span>|<span data-ttu-id="97902-403">Acción</span><span class="sxs-lookup"><span data-stu-id="97902-403">Action</span></span>|  
|---------------|------------|------------|  
|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter.DeserializeRequest%28System.ServiceModel.Channels.Message%2CSystem.Object%5B%5D%29>|<span data-ttu-id="97902-404">Convierte un `Message` entrante en parámetros de operación</span><span class="sxs-lookup"><span data-stu-id="97902-404">Converts an incoming `Message` to operation parameters</span></span>|  
|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter.SerializeReply%28System.ServiceModel.Channels.MessageVersion%2CSystem.Object%5B%5D%2CSystem.Object%29>|<span data-ttu-id="97902-405">Crea un `Message` saliente a partir del valor devuelto/parámetros out de la operación</span><span class="sxs-lookup"><span data-stu-id="97902-405">Creates an outgoing `Message` from operation return value/out parameters</span></span>|  
|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter.SerializeRequest%28System.ServiceModel.Channels.MessageVersion%2CSystem.Object%5B%5D%29>|<span data-ttu-id="97902-406">Crea un `Message` saliente a partir de los parámetros de operación</span><span class="sxs-lookup"><span data-stu-id="97902-406">Creates an outgoing `Message` from operation parameters</span></span>|  
|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter.DeserializeReply%28System.ServiceModel.Channels.Message%2CSystem.Object%5B%5D%29>|<span data-ttu-id="97902-407">Convierte un `Message` entrante en un valor devuelto/parámetros out</span><span class="sxs-lookup"><span data-stu-id="97902-407">Converts an incoming `Message` to a return value/out parameters</span></span>|  
  
## <a name="serialization"></a><span data-ttu-id="97902-408">Serialización</span><span class="sxs-lookup"><span data-stu-id="97902-408">Serialization</span></span>  
 <span data-ttu-id="97902-409">Siempre que use contratos de mensajes o parámetros para describir el contenido de los mensajes, debe utilizar la serialización para convertir entre .NET Framework tipos y la representación del conjunto de código XML.</span><span class="sxs-lookup"><span data-stu-id="97902-409">Whenever you use message contracts or parameters to describe message contents, you must use serialization to convert between .NET Framework types and XML Infoset representation.</span></span> <span data-ttu-id="97902-410">La serialización se utiliza en otros lugares en WCF, por ejemplo, <xref:System.ServiceModel.Channels.Message> tiene un <xref:System.ServiceModel.Channels.Message.GetBody%2A> método genérico que puede usar para leer el cuerpo completo del mensaje deserializado en un objeto.</span><span class="sxs-lookup"><span data-stu-id="97902-410">Serialization is used in other places in WCF, for example, <xref:System.ServiceModel.Channels.Message> has a Generic <xref:System.ServiceModel.Channels.Message.GetBody%2A> method that you can use to read the entire body of the message deserialized into an object.</span></span>  
  
 <span data-ttu-id="97902-411">WCF admite dos tecnologías de serialización "preparadas" para serializar y deserializar parámetros y partes de mensajes: <xref:System.Runtime.Serialization.DataContractSerializer> y `XmlSerializer` .</span><span class="sxs-lookup"><span data-stu-id="97902-411">WCF supports two serialization technologies "out of the box" for serializing and deserializing parameters and message parts: the <xref:System.Runtime.Serialization.DataContractSerializer> and the `XmlSerializer`.</span></span> <span data-ttu-id="97902-412">Además, puede escribir serializadores personalizados.</span><span class="sxs-lookup"><span data-stu-id="97902-412">Additionally, you can write custom serializers.</span></span> <span data-ttu-id="97902-413">Sin embargo, otras partes de WCF (como el `GetBody` método genérico o la serialización de errores de SOAP) pueden estar restringidas a usar solo las <xref:System.Runtime.Serialization.XmlObjectSerializer> subclases ( <xref:System.Runtime.Serialization.DataContractSerializer> y <xref:System.Runtime.Serialization.NetDataContractSerializer> , pero no <xref:System.Xml.Serialization.XmlSerializer> ) o incluso estar codificadas de forma rígida para usar solo <xref:System.Runtime.Serialization.DataContractSerializer> .</span><span class="sxs-lookup"><span data-stu-id="97902-413">However, other parts of WCF (such as the Generic `GetBody` method or SOAP fault serialization) may be restricted to use only the <xref:System.Runtime.Serialization.XmlObjectSerializer> subclasses (<xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer>, but not the <xref:System.Xml.Serialization.XmlSerializer>), or may even be hard-coded to use only the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span>  
  
 <span data-ttu-id="97902-414">`XmlSerializer`Es el motor de serialización utilizado en los servicios Web de ASP.net.</span><span class="sxs-lookup"><span data-stu-id="97902-414">The `XmlSerializer` is the serialization engine used in ASP.NET Web services.</span></span> <span data-ttu-id="97902-415">`DataContractSerializer` es el nuevo motor de serialización que entiende el nuevo modelo de programación de contrato de datos.</span><span class="sxs-lookup"><span data-stu-id="97902-415">The `DataContractSerializer` is the new serialization engine that understands the new data contract programming model.</span></span> <span data-ttu-id="97902-416">`DataContractSerializer` es la opción predeterminada, y la decisión de usar `XmlSerializer` se puede tomar según la operación mediante el atributo <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.DataContractFormatAttribute%2A> .</span><span class="sxs-lookup"><span data-stu-id="97902-416">`DataContractSerializer` is the default choice, and the choice to use the `XmlSerializer` can be made on a per-operation basis using the <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.DataContractFormatAttribute%2A> attribute.</span></span>  
  
 <span data-ttu-id="97902-417"><xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> y <xref:System.ServiceModel.Description.XmlSerializerOperationBehavior> son los comportamientos de operaciones responsables de agregar los formateadores de mensajes para  el `DataContractSerializer` y `XmlSerializer`, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="97902-417"><xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> and <xref:System.ServiceModel.Description.XmlSerializerOperationBehavior> are the operation behaviors responsible for plugging in the message formatters for the `DataContractSerializer` and the `XmlSerializer`, respectively.</span></span> <span data-ttu-id="97902-418">El comportamiento <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> puede realmente funcionar con cualquier serializador que derive de <xref:System.Runtime.Serialization.XmlObjectSerializer>, incluso <xref:System.Runtime.Serialization.NetDataContractSerializer> (descrito en detalle en Uso de serialización independiente).</span><span class="sxs-lookup"><span data-stu-id="97902-418">The <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> behavior can actually operate with any serializer that derives from <xref:System.Runtime.Serialization.XmlObjectSerializer>, including the <xref:System.Runtime.Serialization.NetDataContractSerializer> (described in detail in Using Stand-Alone Serialization).</span></span> <span data-ttu-id="97902-419">El comportamiento llama a una de las sobrecargas de método virtual `CreateSerializer` para obtener el serializador.</span><span class="sxs-lookup"><span data-stu-id="97902-419">The behavior calls one of the `CreateSerializer` virtual method overloads to obtain the serializer.</span></span> <span data-ttu-id="97902-420">Para agregar un serializador diferente, cree una nueva subclase <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> e invalide ambas sobrecargas `CreateSerializer` .</span><span class="sxs-lookup"><span data-stu-id="97902-420">To plug in a different serializer, create a new <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> subclass and override both `CreateSerializer` overloads.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="97902-421">Vea también</span><span class="sxs-lookup"><span data-stu-id="97902-421">See also</span></span>

- [<span data-ttu-id="97902-422">Especificación de transferencia de datos en contratos de servicio</span><span class="sxs-lookup"><span data-stu-id="97902-422">Specifying Data Transfer in Service Contracts</span></span>](specifying-data-transfer-in-service-contracts.md)
