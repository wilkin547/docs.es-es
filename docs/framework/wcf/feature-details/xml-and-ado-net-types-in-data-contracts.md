---
title: Clases de XML y ADO.NET en contratos de datos
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
ms.assetid: c2ce8461-3c15-4c41-8c81-1cb78f5b59a6
caps.latest.revision: "7"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.workload: dotnet
ms.openlocfilehash: c4641815687f2c510aa664a287a79f64dc86d769
ms.sourcegitcommit: 16186c34a957fdd52e5db7294f291f7530ac9d24
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 12/22/2017
---
# <a name="xml-and-adonet-types-in-data-contracts"></a><span data-ttu-id="dd337-102">Clases de XML y ADO.NET en contratos de datos</span><span class="sxs-lookup"><span data-stu-id="dd337-102">XML and ADO.NET Types in Data Contracts</span></span>
<span data-ttu-id="dd337-103">El modelo del contrato de datos [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)] admite ciertos tipos que representan directamente XML.</span><span class="sxs-lookup"><span data-stu-id="dd337-103">The [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)] data contract model supports certain types that represent XML directly.</span></span> <span data-ttu-id="dd337-104">Cuando estos tipos se serializan a XML, el serializador escribe el contenido de XML de estos tipos sin procesar la instrucción.</span><span class="sxs-lookup"><span data-stu-id="dd337-104">When these types are serialized to XML, the serializer writes out the XML contents of these types without any further processing.</span></span> <span data-ttu-id="dd337-105">Los tipos admitidos son <xref:System.Xml.XmlElement>, matrices de <xref:System.Xml.XmlNode> (pero no el propio tipo `XmlNode` ), así como los tipos que implementan <xref:System.Xml.Serialization.IXmlSerializable>.</span><span class="sxs-lookup"><span data-stu-id="dd337-105">Supported types are <xref:System.Xml.XmlElement>, arrays of <xref:System.Xml.XmlNode> (but not the `XmlNode` type itself), as well as types that implement <xref:System.Xml.Serialization.IXmlSerializable>.</span></span> <span data-ttu-id="dd337-106"><xref:System.Data.DataSet> y el tipo <xref:System.Data.DataTable>, así como los conjuntos de datos con tipo, se utilizan normalmente en programación de base de datos.</span><span class="sxs-lookup"><span data-stu-id="dd337-106">The <xref:System.Data.DataSet> and <xref:System.Data.DataTable> type, as well as typed datasets, are commonly used in database programming.</span></span> <span data-ttu-id="dd337-107">Estos tipos implementan la interfaz `IXmlSerializable` y son, por lo tanto, serializables en el modelo del contrato de datos.</span><span class="sxs-lookup"><span data-stu-id="dd337-107">These types implement the `IXmlSerializable` interface and are therefore serializable in the data contract model.</span></span> <span data-ttu-id="dd337-108">Al final de este tema, se describen algunas consideraciones especiales para estos tipos.</span><span class="sxs-lookup"><span data-stu-id="dd337-108">Some special considerations for these types are listed at the end of this topic.</span></span>  
  
## <a name="xml-types"></a><span data-ttu-id="dd337-109">Tipos XML</span><span class="sxs-lookup"><span data-stu-id="dd337-109">XML Types</span></span>  
  
### <a name="xml-element"></a><span data-ttu-id="dd337-110">Elemento Xml</span><span class="sxs-lookup"><span data-stu-id="dd337-110">Xml Element</span></span>  
 <span data-ttu-id="dd337-111">El tipo `XmlElement` se serializa utilizando sus contenidos de XML.</span><span class="sxs-lookup"><span data-stu-id="dd337-111">The `XmlElement` type is serialized using its XML contents.</span></span> <span data-ttu-id="dd337-112">Por ejemplo, utilizando el siguiente tipo.</span><span class="sxs-lookup"><span data-stu-id="dd337-112">For example, using the following type.</span></span>  
  
 [!code-csharp[DataContractAttribute#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/datacontractattribute/cs/overview.cs#4)]
 [!code-vb[DataContractAttribute#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/datacontractattribute/vb/overview.vb#4)]  
  
 <span data-ttu-id="dd337-113">Esto se serializará a XML del modo siguiente:</span><span class="sxs-lookup"><span data-stu-id="dd337-113">This is serialized to XML as follows:</span></span>  
  
```xml  
<MyDataContract xmlns="http://schemas.contoso.com">  
    <myDataMember>  
        <myElement xmlns="" myAttribute="myValue">  
            myContents  
        </myElement>  
    </myDataMember>  
</MyDataContract>  
```  
  
 <span data-ttu-id="dd337-114">Fíjese en que un elemento contenedor de miembro de datos `<myDataMember>` todavía está presente.</span><span class="sxs-lookup"><span data-stu-id="dd337-114">Notice that a wrapper data member element `<myDataMember>` is still present.</span></span> <span data-ttu-id="dd337-115">No hay ninguna manera de quitar este elemento en el modelo del contrato de datos.</span><span class="sxs-lookup"><span data-stu-id="dd337-115">There is no way of removing this element in the data contract model.</span></span> <span data-ttu-id="dd337-116">Los serializadores que administran este modelo ( <xref:System.Runtime.Serialization.DataContractSerializer> y <xref:System.Runtime.Serialization.NetDataContractSerializer>) pueden emitir atributos especiales en este elemento contenedor.</span><span class="sxs-lookup"><span data-stu-id="dd337-116">The serializers that handle this model (the <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer>) may emit special attributes into this wrapper element.</span></span> <span data-ttu-id="dd337-117">Estos atributos incluyen el atributo "nil" de la instancia del estándar Esquema XML (que permite que `XmlElement` sea `null`) y el atributo "type" (que permite que `XmlElement` se utilice polimórficamente)."</span><span class="sxs-lookup"><span data-stu-id="dd337-117">These attributes include the standard XML Schema Instance "nil" attribute (allowing the `XmlElement` to be `null`) and the "type" attribute (allowing `XmlElement` to be used polymorphically).</span></span> <span data-ttu-id="dd337-118">Asimismo, los atributos XML siguientes son específicos de [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]: "Id", "Ref", "Type" y "Assembly".</span><span class="sxs-lookup"><span data-stu-id="dd337-118">Also, the following XML attributes are specific to [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]: "Id", "Ref", "Type" and "Assembly".</span></span> <span data-ttu-id="dd337-119">Estos atributos se pueden emitir para permitir utilizar `XmlElement` con el modo de preservación de gráfico de objetos habilitado o con <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span><span class="sxs-lookup"><span data-stu-id="dd337-119">These attributes may be emitted to support using the `XmlElement` with the object graph preservation mode enabled, or with the <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span></span> <span data-ttu-id="dd337-120">([!INCLUDE[crabout](../../../../includes/crabout-md.md)] el modo de preservación de gráfico de objeto, vea [serialización y deserialización](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).)</span><span class="sxs-lookup"><span data-stu-id="dd337-120">([!INCLUDE[crabout](../../../../includes/crabout-md.md)] the object graph preservation mode, see [Serialization and Deserialization](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).)</span></span>  
  
 <span data-ttu-id="dd337-121">Las matrices o colecciones de `XmlElement` se permiten y administran como cualquier otra matriz o colección.</span><span class="sxs-lookup"><span data-stu-id="dd337-121">Arrays or collections of `XmlElement` are allowed and are handled as any other array or collection.</span></span> <span data-ttu-id="dd337-122">Es decir, existe un elemento contenedor para la colección completa y un elemento contenedor independiente (similar a `<myDataMember>` en el ejemplo anterior) para cada `XmlElement` de la matriz.</span><span class="sxs-lookup"><span data-stu-id="dd337-122">That is, there is a wrapper element for the entire collection, and a separate wrapper element (similar to `<myDataMember>` in the preceding example) for each `XmlElement` in the array.</span></span>  
  
 <span data-ttu-id="dd337-123">En la deserialización, el deserializador crea un `XmlElement` a partir del XML de entrada.</span><span class="sxs-lookup"><span data-stu-id="dd337-123">On deserialization, an `XmlElement` is created by the deserializer from the incoming XML.</span></span> <span data-ttu-id="dd337-124">El deserializador proporciona un <xref:System.Xml.XmlDocument> primario válido.</span><span class="sxs-lookup"><span data-stu-id="dd337-124">A valid parent <xref:System.Xml.XmlDocument> is provided by the deserializer.</span></span>  
  
 <span data-ttu-id="dd337-125">Asegúrese de que el fragmento XML que se deserializará a un `XmlElement` define todos los prefijos que utiliza y que no está basado en ninguna definición de prefijo de elementos antecesores.</span><span class="sxs-lookup"><span data-stu-id="dd337-125">Make sure that the XML fragment that is deserialized to an `XmlElement` defines all prefixes that it uses and does not rely on any prefix definitions from ancestor elements.</span></span> <span data-ttu-id="dd337-126">Esto solo resulta preocupante si se utiliza el `DataContractSerializer` para tener acceso a XML desde un origen diferente (no -`DataContractSerializer`).</span><span class="sxs-lookup"><span data-stu-id="dd337-126">This is a concern only when using the `DataContractSerializer` to access XML from a different (non-`DataContractSerializer`) source.</span></span>  
  
 <span data-ttu-id="dd337-127">Cuando se usa con la `DataContractSerializer`, `XmlElement` puede estar asignado polimórficamente, pero solo a un miembro de datos de tipo <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="dd337-127">When used with the `DataContractSerializer`, the `XmlElement` may be assigned polymorphically, but only to a data member of type <xref:System.Object>.</span></span> <span data-ttu-id="dd337-128">Aunque implementa <xref:System.Collections.IEnumerable>, un `XmlElement` no se puede utilizar como un tipo de colección y no se puede asignar a un miembro de datos <xref:System.Collections.IEnumerable>.</span><span class="sxs-lookup"><span data-stu-id="dd337-128">Even though it implements <xref:System.Collections.IEnumerable>, an `XmlElement` cannot be used as a collection type and cannot be assigned to an <xref:System.Collections.IEnumerable> data member.</span></span> <span data-ttu-id="dd337-129">Como con todas las asignaciones polimórficas, `DataContractSerializer` emite el nombre de contrato de datos en el XML resultante. En este caso, es "XmlElement" en el espacio de nombres "http://schemas.datacontract.org/2004/07/System.Xml."</span><span class="sxs-lookup"><span data-stu-id="dd337-129">As with all polymorphic assignments, the `DataContractSerializer` emits the data contract name in the resulting XML – in this case, it is "XmlElement" in the "http://schemas.datacontract.org/2004/07/System.Xml" namespace.</span></span>  
  
 <span data-ttu-id="dd337-130">Con `NetDataContractSerializer`, cualquier trabajo polimórfico válido de `XmlElement` (a `Object` o `IEnumerable`) se admite.</span><span class="sxs-lookup"><span data-stu-id="dd337-130">With the `NetDataContractSerializer`, any valid polymorphic assignment of `XmlElement` (to `Object` or `IEnumerable`) is supported.</span></span>  
  
 <span data-ttu-id="dd337-131">No intente utilizar cualquiera de los serializadores con tipos derivados de `XmlElement`, estén asignados polimórficamente o no.</span><span class="sxs-lookup"><span data-stu-id="dd337-131">Do not attempt to use either of the serializers with types derived from `XmlElement`, whether they are assigned polymorphically or not.</span></span>  
  
### <a name="array-of-xmlnode"></a><span data-ttu-id="dd337-132">Matriz de XMLNode</span><span class="sxs-lookup"><span data-stu-id="dd337-132">Array of XmlNode</span></span>  
 <span data-ttu-id="dd337-133">Utilizar matrices de <xref:System.Xml.XmlNode> es muy similar a utilizar `XmlElement`.</span><span class="sxs-lookup"><span data-stu-id="dd337-133">Using arrays of <xref:System.Xml.XmlNode> is very similar to using `XmlElement`.</span></span> <span data-ttu-id="dd337-134">Utilizar matrices de `XmlNode` le proporciona más flexibilidad que utilizar `XmlElement`.</span><span class="sxs-lookup"><span data-stu-id="dd337-134">Using arrays of `XmlNode` gives you more flexibility than using `XmlElement`.</span></span> <span data-ttu-id="dd337-135">Puede escribir varios elementos dentro del elemento de ajuste de miembro de datos.</span><span class="sxs-lookup"><span data-stu-id="dd337-135">You can write multiple elements inside the data member wrapping element.</span></span> <span data-ttu-id="dd337-136">También puede insertar contenido que no sean elementos dentro del elemento de ajuste de miembro de datos, como comentarios XML.</span><span class="sxs-lookup"><span data-stu-id="dd337-136">You can also inject content other than elements inside of the data member wrapping element, such as XML comments.</span></span> <span data-ttu-id="dd337-137">Por último, puede poner atributos en el elemento de miembro de datos de ajuste.</span><span class="sxs-lookup"><span data-stu-id="dd337-137">Finally, you can put attributes into the wrapping data member element.</span></span> <span data-ttu-id="dd337-138">Todos esto puede lograrse rellenando la matriz de `XmlNode` con clases derivadas específicas de `XmlNode`, como <xref:System.Xml.XmlAttribute>, `XmlElement` o <xref:System.Xml.XmlComment>.</span><span class="sxs-lookup"><span data-stu-id="dd337-138">All this can be achieved by populating the array of `XmlNode` with specific derived classes of `XmlNode` such as <xref:System.Xml.XmlAttribute>, `XmlElement` or <xref:System.Xml.XmlComment>.</span></span> <span data-ttu-id="dd337-139">Por ejemplo, utilizando el siguiente tipo.</span><span class="sxs-lookup"><span data-stu-id="dd337-139">For example, using the following type.</span></span>  
  
 [!code-csharp[DataContractAttribute#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/datacontractattribute/cs/overview.cs#5)]
 [!code-vb[DataContractAttribute#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/datacontractattribute/vb/overview.vb#5)]  
  
 <span data-ttu-id="dd337-140">Al serializar, el XML resultante es similar al siguiente código.</span><span class="sxs-lookup"><span data-stu-id="dd337-140">When serialized, the resulting XML is similar to the following code.</span></span>  
  
```xml  
<MyDataContract xmlns="http://schemas.contoso.com">  
  <myDataMember myAttribute="myValue">  
     <!--myComment-->  
     <myElement xmlns="" myAttribute="myValue">  
 myContents  
     </myElement>  
     <myElement xmlns="" myAttribute="myValue">  
       myContents  
     </myElement>  
  </myDataMember>  
</MyDataContract>  
```  
  
 <span data-ttu-id="dd337-141">Tenga en cuenta que `<myDataMember>` del elemento contenedor de miembro de datos contiene un atributo, un comentario y dos elementos.</span><span class="sxs-lookup"><span data-stu-id="dd337-141">Note that the data member wrapper element `<myDataMember>` contains an attribute, a comment, and two elements.</span></span> <span data-ttu-id="dd337-142">Éstas son las cuatro instancias `XmlNode` serializadas.</span><span class="sxs-lookup"><span data-stu-id="dd337-142">These are the four `XmlNode` instances that were serialized.</span></span>  
  
 <span data-ttu-id="dd337-143">No se puede serializar una matriz de `XmlNode` que produciría un XML no válido.</span><span class="sxs-lookup"><span data-stu-id="dd337-143">An array of `XmlNode` that results in invalid XML cannot be serialized.</span></span> <span data-ttu-id="dd337-144">Por ejemplo, una matriz de dos instancias `XmlNode` donde la primera es `XmlElement` y la segunda es <xref:System.Xml.XmlAttribute> no es válida, porque esta secuencia no corresponde a ninguna instancia XML válida (no hay ningún lugar para adjuntar el atributo).</span><span class="sxs-lookup"><span data-stu-id="dd337-144">For example, an array of two `XmlNode` instances where the first one is an `XmlElement` and the second one is an <xref:System.Xml.XmlAttribute> is invalid, because this sequence does not correspond to any valid XML instance (there is no place to attach the attribute to).</span></span>  
  
 <span data-ttu-id="dd337-145">En la deserialización de una matriz de `XmlNode`, los nodos se crean y rellenan con información del XML de entrada.</span><span class="sxs-lookup"><span data-stu-id="dd337-145">On deserialization of an array of `XmlNode`, nodes are created and populated with information from the incoming XML.</span></span> <span data-ttu-id="dd337-146">El deserializador proporciona un <xref:System.Xml.XmlDocument> primario válido.</span><span class="sxs-lookup"><span data-stu-id="dd337-146">A valid parent <xref:System.Xml.XmlDocument> is provided by the deserializer.</span></span> <span data-ttu-id="dd337-147">Se deserializan todos los nodos, incluso los atributos en el elemento contenedor de miembro de datos, excepto los atributos colocados allí por los serializadores [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] (como los atributos utilizados para indicar el trabajo polimórfico).</span><span class="sxs-lookup"><span data-stu-id="dd337-147">All nodes are deserialized, including any attributes on the wrapper data member element, but excluding the attributes placed there by the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] serializers (such as the attributes used to indicate polymorphic assignment).</span></span> <span data-ttu-id="dd337-148">La advertencia sobre cómo definir todos los prefijos de espacio de nombres en el fragmento XML se aplica a la deserialización de matrices de `XmlNode` simplemente como se hace al deserializar `XmlElement`.</span><span class="sxs-lookup"><span data-stu-id="dd337-148">The caveat about defining all namespace prefixes in the XML fragment applies to the deserialization of arrays of `XmlNode` just like it does to deserializing `XmlElement`.</span></span>  
  
 <span data-ttu-id="dd337-149">Al utilizar los serializadores con preservación del gráfico de objetos activada, la igualdad de los objeto solo se conserva en el nivel de matrices `XmlNode`, no instancias `XmlNode` individuales.</span><span class="sxs-lookup"><span data-stu-id="dd337-149">When using the serializers with object graph preservation turned on, object equality is only preserved on the level of `XmlNode` arrays, not individual `XmlNode` instances.</span></span>  
  
 <span data-ttu-id="dd337-150">No intente serializar una matriz de `XmlNode` en la que uno o varios nodos están establecidos en `null`.</span><span class="sxs-lookup"><span data-stu-id="dd337-150">Do not attempt to serialize an array of `XmlNode` where one or more of the nodes is set to `null`.</span></span> <span data-ttu-id="dd337-151">Se permite que todo el miembro de la matriz sea `null`, pero no los `XmlNode` individuales incluidos en la matriz.</span><span class="sxs-lookup"><span data-stu-id="dd337-151">It is permitted for the entire array member to be `null`, but not for any individual `XmlNode` contained in the array.</span></span> <span data-ttu-id="dd337-152">Si todo el miembro de la matriz es null, el elemento contenedor de miembro de datos incluirá un atributo especial que indica que es null.</span><span class="sxs-lookup"><span data-stu-id="dd337-152">If the entire array member is null, the wrapper data member element contains a special attribute that indicates that it is null.</span></span> <span data-ttu-id="dd337-153">En la deserialización, todo el miembro de la matriz también se convertirá en null.</span><span class="sxs-lookup"><span data-stu-id="dd337-153">On deserialization, the entire array member also becomes null.</span></span>  
  
 <span data-ttu-id="dd337-154">El serializador trata especialmente solo las matrices normales de `XmlNode`.</span><span class="sxs-lookup"><span data-stu-id="dd337-154">Only regular arrays of `XmlNode` are treated specially by the serializer.</span></span> <span data-ttu-id="dd337-155">Los miembros de datos declarados como otros tipos de colección que contienen `XmlNode`, o los miembros de datos declarados como matrices de tipos derivadas de `XmlNode`, no se tratan de manera especial.</span><span class="sxs-lookup"><span data-stu-id="dd337-155">Data members declared as other collection types that contain `XmlNode`, or data members declared as arrays of types derived from `XmlNode`, are not treated specially.</span></span> <span data-ttu-id="dd337-156">Por esta razón, normalmente, no son serializables a menos que también cumplan uno de los otros criterios de serialización.</span><span class="sxs-lookup"><span data-stu-id="dd337-156">Thus, they are normally not serializable unless they also meet one of the other criteria for serializing.</span></span>  
  
 <span data-ttu-id="dd337-157">Se permiten matrices o colecciones de matrices de `XmlNode`.</span><span class="sxs-lookup"><span data-stu-id="dd337-157">Arrays or collections of arrays of `XmlNode` are allowed.</span></span> <span data-ttu-id="dd337-158">Existe un elemento contenedor para toda la colección, y un elemento contenedor independiente (similar a `<myDataMember>` en el ejemplo anterior) para cada matriz de `XmlNode` en la matriz o colección externa.</span><span class="sxs-lookup"><span data-stu-id="dd337-158">There is a wrapper element for the entire collection, and a separate wrapper element (similar to `<myDataMember>` in the preceding example) for each array of `XmlNode` in the outer array or collection.</span></span>  
  
 <span data-ttu-id="dd337-159">Rellenar un miembro de datos de tipo <xref:System.Array> de `Object`, o `Array` de `IEnumerable`, con instancias `XmlNode` no produce el miembro de datos tratado como una `Array` de instancias `XmlNode`.</span><span class="sxs-lookup"><span data-stu-id="dd337-159">Populating a data member of type <xref:System.Array> of `Object` or `Array` of `IEnumerable` with `XmlNode` instances does not result in the data member being treated as an `Array` of `XmlNode` instances.</span></span> <span data-ttu-id="dd337-160">Cada miembro de matriz se serializa de manera independiente.</span><span class="sxs-lookup"><span data-stu-id="dd337-160">Each array member is serialized separately.</span></span>  
  
 <span data-ttu-id="dd337-161">Cuando se utiliza con el `DataContractSerializer`, las matrices de `XmlNode`pueden estar asignadas polimórficamente pero solo a un miembro de datos de tipo `Object`.</span><span class="sxs-lookup"><span data-stu-id="dd337-161">When used with the `DataContractSerializer`, arrays of `XmlNode` can be assigned polymorphically, but only to a data member of type `Object`.</span></span> <span data-ttu-id="dd337-162">Aunque implementa `IEnumerable`, una matriz de `XmlNode` no se puede utilizar como un tipo de colección y no se puede asignar a un miembro de datos `IEnumerable`.</span><span class="sxs-lookup"><span data-stu-id="dd337-162">Even though it implements `IEnumerable`, an array of `XmlNode` cannot be used as a collection type and be assigned to an `IEnumerable` data member.</span></span> <span data-ttu-id="dd337-163">Como con todas las asignaciones polimórficas, `DataContractSerializer` emite el nombre de contrato de datos en el XML resultante. En este caso, es "ArrayOfXmlNode" en el espacio de nombres "http://schemas.datacontract.org/2004/07/System.Xml".</span><span class="sxs-lookup"><span data-stu-id="dd337-163">As with all polymorphic assignments, the `DataContractSerializer` emits the data contract name in the resulting XML – in this case, it is "ArrayOfXmlNode" in the "http://schemas.datacontract.org/2004/07/System.Xml" namespace.</span></span> <span data-ttu-id="dd337-164">Cuando se usa con la `NetDataContractSerializer`, cualquier trabajo válido de un `XmlNode` se admite la matriz.</span><span class="sxs-lookup"><span data-stu-id="dd337-164">When used with the `NetDataContractSerializer`, any valid assignment of an `XmlNode` array is supported.</span></span>  
  
### <a name="schema-considerations"></a><span data-ttu-id="dd337-165">Consideraciones del esquema</span><span class="sxs-lookup"><span data-stu-id="dd337-165">Schema Considerations</span></span>  
 <span data-ttu-id="dd337-166">Para obtener más información sobre la asignación de esquema de los tipos de XML, vea [referencia de esquema de contrato de datos](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="dd337-166">For details about the schema mapping of XML types, see [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span></span> <span data-ttu-id="dd337-167">En esta sección se proporciona un resumen de los puntos importantes.</span><span class="sxs-lookup"><span data-stu-id="dd337-167">This section provides a summary of the important points.</span></span>  
  
 <span data-ttu-id="dd337-168">Un miembro de datos de tipo `XmlElement` está asignado a un elemento definido mediante el siguiente tipo anónimo.</span><span class="sxs-lookup"><span data-stu-id="dd337-168">A data member of type `XmlElement` is mapped to an element defined using the following anonymous type.</span></span>  
  
```xml  
<xsd:complexType>  
   <xsd:sequence>  
      <xsd:any minOccurs="0" processContents="lax" />  
   </xsd:sequence>  
</xsd:complexType>  
```  
  
 <span data-ttu-id="dd337-169">Un miembro de datos de tipo Matriz de `XmlNode` está asignado a un elemento definido mediante el siguiente tipo anónimo.</span><span class="sxs-lookup"><span data-stu-id="dd337-169">A data member of type Array of `XmlNode` is mapped to an element defined using the following anonymous type.</span></span>  
  
```xml  
<xsd:complexType mixed="true">  
   <xsd:sequence>  
      <xsd:any minOccurs="0" maxOccurs="unbounded" processContents="lax" />  
   </xsd:sequence>  
   <xsd:anyAttribute/>  
</xsd:complexType>  
```  
  
## <a name="types-implementing-the-ixmlserializable-interface"></a><span data-ttu-id="dd337-170">Tipos que implementan la interfaz IXmlSerializable </span><span class="sxs-lookup"><span data-stu-id="dd337-170">Types Implementing the IXmlSerializable Interface</span></span>  
 <span data-ttu-id="dd337-171">`IXmlSerializable`admite totalmente los tipos que implementan la interfaz `DataContractSerializer`.</span><span class="sxs-lookup"><span data-stu-id="dd337-171">Types that implement the `IXmlSerializable` interface are fully supported by the `DataContractSerializer`.</span></span> <span data-ttu-id="dd337-172">El atributo <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> siempre se debería aplicar a estos tipos para controlar su esquema.</span><span class="sxs-lookup"><span data-stu-id="dd337-172">The <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute should always be applied to these types to control their schema.</span></span>  
  
 <span data-ttu-id="dd337-173">Existen tres variedades de tipos que implementan `IXmlSerializable`: tipos que representan el contenido arbitrario, tipos que representan un elemento único, y los tipos <xref:System.Data.DataSet> heredados.</span><span class="sxs-lookup"><span data-stu-id="dd337-173">There are three varieties of types that implement `IXmlSerializable`: types that represent arbitrary content, types that represent a single element, and legacy <xref:System.Data.DataSet> types.</span></span>  
  
-   <span data-ttu-id="dd337-174">Los tipos de contenido utilizan un método de proveedor de esquema especificado por el atributo `XmlSchemaProviderAttribute`.</span><span class="sxs-lookup"><span data-stu-id="dd337-174">Content types use a schema provider method specified by the `XmlSchemaProviderAttribute` attribute.</span></span> <span data-ttu-id="dd337-175">El método no devuelve `null`y la propiedad <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> en el atributo se deja como su valor predeterminado de `false`.</span><span class="sxs-lookup"><span data-stu-id="dd337-175">The method does not return `null`, and the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the attribute is left at its default value of `false`.</span></span> <span data-ttu-id="dd337-176">Éste es el uso más común de los tipos `IXmlSerializable`.</span><span class="sxs-lookup"><span data-stu-id="dd337-176">This is the most common usage of `IXmlSerializable` types.</span></span>  
  
-   <span data-ttu-id="dd337-177">Se utilizan los tipos de elemento cuando un tipo `IXmlSerializable` debe controlar su propio nombre del elemento raíz.</span><span class="sxs-lookup"><span data-stu-id="dd337-177">Element types are used when an `IXmlSerializable` type must control its own root element name.</span></span> <span data-ttu-id="dd337-178">Para marcar un tipo como un tipo de elemento, establezca la propiedad <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> del atributo <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> en `true` o devuelva null a partir del método de proveedor de esquema.</span><span class="sxs-lookup"><span data-stu-id="dd337-178">To mark a type as an element type, either set the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute to `true` or return null from the schema provider method.</span></span> <span data-ttu-id="dd337-179">Tener un método de proveedor de esquema es opcional para los tipos de elemento. Puede especificar null en lugar del nombre del método en `XmlSchemaProviderAttribute`.</span><span class="sxs-lookup"><span data-stu-id="dd337-179">Having a schema provider method is optional for element types – you may specify null instead of the method name in the `XmlSchemaProviderAttribute`.</span></span> <span data-ttu-id="dd337-180">Sin embargo, si `IsAny` es `true` y se especifica un método de proveedor de esquema, el método debe devolver null.</span><span class="sxs-lookup"><span data-stu-id="dd337-180">However, if `IsAny` is `true` and a schema provider method is specified, the method must return null.</span></span>  
  
-   <span data-ttu-id="dd337-181">Los tipos <xref:System.Data.DataSet> heredados son `IXmlSerializable` escribe que no se marca con el atributo `XmlSchemaProviderAttribute`.</span><span class="sxs-lookup"><span data-stu-id="dd337-181">Legacy <xref:System.Data.DataSet> types are `IXmlSerializable` types that are not marked with the `XmlSchemaProviderAttribute` attribute.</span></span> <span data-ttu-id="dd337-182">En su lugar, confían en el método <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A> para la generación del esquema.</span><span class="sxs-lookup"><span data-stu-id="dd337-182">Instead, they rely on the <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A> method for schema generation.</span></span> <span data-ttu-id="dd337-183">Este patrón se utiliza para el tipo `DataSet` y su conjunto de datos con tipo deriva una clase en versiones anteriores de .NET Framework, pero ahora es obsoleto y sólo se admite por razones heredadas.</span><span class="sxs-lookup"><span data-stu-id="dd337-183">This pattern is used for the `DataSet` type and its typed dataset derives a class in earlier versions of the .NET Framework, but is now obsolete and is supported only for legacy reasons.</span></span> <span data-ttu-id="dd337-184">No confíe en este patrón y aplique siempre `XmlSchemaProviderAttribute` a sus tipos `IXmlSerializable`.</span><span class="sxs-lookup"><span data-stu-id="dd337-184">Do not rely on this pattern and always apply the `XmlSchemaProviderAttribute` to your `IXmlSerializable` types.</span></span>  
  
### <a name="ixmlserializable-content-types"></a><span data-ttu-id="dd337-185">Tipos de contenido de IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="dd337-185">IXmlSerializable Content Types</span></span>  
 <span data-ttu-id="dd337-186">Al serializar un miembro de datos de un tipo que implementa `IXmlSerializable`, y es un tipo de contenido como el que se ha definido previamente, el serializador escribe el elemento contenedor para el miembro de datos y pasará el control al método <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A>.</span><span class="sxs-lookup"><span data-stu-id="dd337-186">When serializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the serializer writes the wrapper element for the data member and pass control to the <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> method.</span></span> <span data-ttu-id="dd337-187">La implementación <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> puede escribir cualquier XML, incluso agregar los atributos al elemento contenedor.</span><span class="sxs-lookup"><span data-stu-id="dd337-187">The <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> implementation can write any XML, including adding attributes to the wrapper element.</span></span> <span data-ttu-id="dd337-188">Una vez realizado `WriteXml`, el serializador cierra el elemento.</span><span class="sxs-lookup"><span data-stu-id="dd337-188">After `WriteXml` is done, the serializer closes the element.</span></span>  
  
 <span data-ttu-id="dd337-189">Al deserializar un miembro de datos de un tipo que implementa `IXmlSerializable`, y es un tipo de contenido como el que se ha definido previamente, el deserializador sitúa el lector de XML en el elemento contenedor para el miembro de datos y pasa el control al método <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A>.</span><span class="sxs-lookup"><span data-stu-id="dd337-189">When deserializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the deserializer positions the XML reader on the wrapper element for the data member and pass control to the <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A> method.</span></span> <span data-ttu-id="dd337-190">El método debe leer todo el elemento, también las etiquetas de cierre e inicio.</span><span class="sxs-lookup"><span data-stu-id="dd337-190">The method must read the entire element, including the start and end tags.</span></span> <span data-ttu-id="dd337-191">Asegúrese de que su código `ReadXml` controla el caso donde el elemento está vacío.</span><span class="sxs-lookup"><span data-stu-id="dd337-191">Make sure your `ReadXml` code handles the case where the element is empty.</span></span> <span data-ttu-id="dd337-192">Además, su implementación `ReadXml` no debería confiar en el elemento contenedor denominado de una manera determinada.</span><span class="sxs-lookup"><span data-stu-id="dd337-192">Additionally, your `ReadXml` implementation should not rely on the wrapper element being named a particular way.</span></span> <span data-ttu-id="dd337-193">El serializador elige el nombre y este puede variar.</span><span class="sxs-lookup"><span data-stu-id="dd337-193">The name is chosen by the serializer can vary.</span></span>  
  
 <span data-ttu-id="dd337-194">Se permite asignar polimórficamente tipos de contenido `IXmlSerializable`, por ejemplo, a los miembros de datos de tipo <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="dd337-194">It is permitted to assign `IXmlSerializable` content types polymorphically, for example, to data members of type <xref:System.Object>.</span></span> <span data-ttu-id="dd337-195">También se permite que las instancias de tipo sean nulo.</span><span class="sxs-lookup"><span data-stu-id="dd337-195">It is also permitted for the type instances to be null.</span></span> <span data-ttu-id="dd337-196">Finalmente, es posible utilizar los tipos `IXmlSerializable` con preservación de gráfico de objetos habilitado y con <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span><span class="sxs-lookup"><span data-stu-id="dd337-196">Finally, it is possible to use `IXmlSerializable` types with object graph preservation enabled and with the <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span></span> <span data-ttu-id="dd337-197">Todas estas características exigen al serializador [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] que adjunte ciertos atributos en el elemento contenedor ("nil "y "type" en el espacio de nombres de instancia del Esquema XML e "Id", "Ref", "Type" y "Assembly" en un espacio de nombres específico de [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]).</span><span class="sxs-lookup"><span data-stu-id="dd337-197">All these features require the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] serializer to attach certain attributes into the wrapper element ("nil" and "type" in the XML Schema Instance namespace and "Id", "Ref", "Type" and "Assembly" in a [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]-specific namespace).</span></span>  
  
#### <a name="attributes-to-ignore-when-implementing-readxml"></a><span data-ttu-id="dd337-198">Atributos que hay que omitir al Implementar ReadXml</span><span class="sxs-lookup"><span data-stu-id="dd337-198">Attributes to Ignore when Implementing ReadXml</span></span>  
 <span data-ttu-id="dd337-199">Antes de pasar el control al código `ReadXml`, el deserializador examina el elemento XML, detecta estos atributos XML especiales y actúa sobre ellos.</span><span class="sxs-lookup"><span data-stu-id="dd337-199">Before passing control to your `ReadXml` code, the deserializer examines the XML element, detects these special XML attributes, and acts on them.</span></span> <span data-ttu-id="dd337-200">Por ejemplo, si "nil" es `true`, se deserializa un valor null y no se llama a `ReadXml`.</span><span class="sxs-lookup"><span data-stu-id="dd337-200">For example, if "nil" is `true`, a null value is deserialized and `ReadXml` is not called.</span></span> <span data-ttu-id="dd337-201">Si se detecta polimorfismo, el contenido del elemento se deserializa como si fuera un tipo diferente.</span><span class="sxs-lookup"><span data-stu-id="dd337-201">If polymorphism is detected, the contents of the element are deserialized as if it was a different type.</span></span> <span data-ttu-id="dd337-202">Se llama a la implementación del tipo asignado polimórficamente `ReadXml`.</span><span class="sxs-lookup"><span data-stu-id="dd337-202">The polymorphically assigned type’s implementation of `ReadXml` is called.</span></span> <span data-ttu-id="dd337-203">En cualquier caso, una implementación de `ReadXml` debería omitir estos atributos especiales ya que están controlados por el deserializador.</span><span class="sxs-lookup"><span data-stu-id="dd337-203">In any case, a `ReadXml` implementation should ignore these special attributes because they are handled by the deserializer.</span></span>  
  
### <a name="schema-considerations-for-ixmlserializable-content-types"></a><span data-ttu-id="dd337-204">Consideraciones del esquema para los tipos de contenido de IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="dd337-204">Schema Considerations for IXmlSerializable Content Types</span></span>  
 <span data-ttu-id="dd337-205">Al exportar el esquema un tipo de contenido `IXmlSerializable`, se llama al método del proveedor de esquema.</span><span class="sxs-lookup"><span data-stu-id="dd337-205">When exporting schema an `IXmlSerializable` content type, the schema provider method is called.</span></span> <span data-ttu-id="dd337-206"><xref:System.Xml.Schema.XmlSchemaSet> se pasa al método de proveedor de esquema.</span><span class="sxs-lookup"><span data-stu-id="dd337-206">An <xref:System.Xml.Schema.XmlSchemaSet> is passed to the schema provider method.</span></span> <span data-ttu-id="dd337-207">El método puede agregar cualquier esquema válido al conjunto de esquemas.</span><span class="sxs-lookup"><span data-stu-id="dd337-207">The method can add any valid schema to the schema set.</span></span> <span data-ttu-id="dd337-208">El conjunto de esquemas contiene el esquema conocido en el momento de la exportación del esquema.</span><span class="sxs-lookup"><span data-stu-id="dd337-208">The schema set contains the schema that is already known at the time when schema export occurs.</span></span> <span data-ttu-id="dd337-209">Cuando el método de proveedor de esquemas debe agregar un elemento al conjunto de esquemas, debe determinar si en el esquema ya existe un <xref:System.Xml.Schema.XmlSchema> con el espacio de nombres adecuado.</span><span class="sxs-lookup"><span data-stu-id="dd337-209">When the schema provider method must add an item to the schema set, it must determine if an <xref:System.Xml.Schema.XmlSchema> with the appropriate namespace already exists in the set.</span></span> <span data-ttu-id="dd337-210">Si ya existe, el método de proveedor de esquema debe agregar el nuevo elemento al `XmlSchema` existente.</span><span class="sxs-lookup"><span data-stu-id="dd337-210">If it does, the schema provider method must add the new item to the existing `XmlSchema`.</span></span> <span data-ttu-id="dd337-211">De lo contrario, debe crear una nueva instancia `XmlSchema`.</span><span class="sxs-lookup"><span data-stu-id="dd337-211">Otherwise, it must create a new `XmlSchema` instance.</span></span> <span data-ttu-id="dd337-212">Esto es importante si se utilizan las matrices de los tipos `IXmlSerializable`.</span><span class="sxs-lookup"><span data-stu-id="dd337-212">This is important if arrays of `IXmlSerializable` types are being used.</span></span> <span data-ttu-id="dd337-213">Por ejemplo, si tiene un tipo `IXmlSerializable` que se exporta como tipo "A" en el espacio de nombres "B", es posible que cuando al llamar al método de proveedor de esquema, el conjunto de esquemas ya contenga el esquema para que "B" incluya el tipo "ArrayOfA."</span><span class="sxs-lookup"><span data-stu-id="dd337-213">For example, if you have an `IXmlSerializable` type that gets exported as type "A" in namespace "B", it is possible that by the time the schema provider method is called the schema set already contains the schema for "B" to hold the "ArrayOfA" type.</span></span>  
  
 <span data-ttu-id="dd337-214">Además de agregar los tipos a <xref:System.Xml.Schema.XmlSchemaSet>, el método de proveedor de esquema para los tipos de contenido debe devolver un valor no nulo.</span><span class="sxs-lookup"><span data-stu-id="dd337-214">In addition to adding types to the <xref:System.Xml.Schema.XmlSchemaSet>, the schema provider method for content types must return a non-null value.</span></span> <span data-ttu-id="dd337-215">Puede devolver un <xref:System.Xml.XmlQualifiedName> que especifique el nombre del tipo de esquema que se utilizará para el tipo `IXmlSerializable` concreto.</span><span class="sxs-lookup"><span data-stu-id="dd337-215">It can return an <xref:System.Xml.XmlQualifiedName> that specifies the name of the schema type to use for the given `IXmlSerializable` type.</span></span> <span data-ttu-id="dd337-216">Este nombre completo también actúa como el nombre de contrato de datos y el espacio de nombres del tipo.</span><span class="sxs-lookup"><span data-stu-id="dd337-216">This qualified name also serves as the data contract name and namespace for the type.</span></span> <span data-ttu-id="dd337-217">Se permite devolver un tipo que no existe en el esquema establecido inmediatamente cuando vuelve el método del proveedor de esquema.</span><span class="sxs-lookup"><span data-stu-id="dd337-217">It is permitted to return a type that does not exist in the schema set immediately when the schema provider method returns.</span></span> <span data-ttu-id="dd337-218">No obstante, se espera que en el momento de exportar todos los tipos relacionados (se llama al método <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A> para todos los tipos relevantes en el <xref:System.Runtime.Serialization.XsdDataContractExporter>, y se tiene acceso a la propiedad <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A>), el tipo existirá en el conjunto de esquemas.</span><span class="sxs-lookup"><span data-stu-id="dd337-218">However, it is expected that by the time all related types are exported (the <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A> method is called for all relevant types on the <xref:System.Runtime.Serialization.XsdDataContractExporter> and the <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A> property is accessed), the type exists in the schema set.</span></span> <span data-ttu-id="dd337-219">Teniendo acceso a la propiedad `Schemas` antes de que se hayan realizado todas las llamadas `Export` pertinentes puede producir <xref:System.Xml.Schema.XmlSchemaException>.</span><span class="sxs-lookup"><span data-stu-id="dd337-219">Accessing the `Schemas` property before all relevant `Export` calls have been made can result in an <xref:System.Xml.Schema.XmlSchemaException>.</span></span> [!INCLUDE[crabout](../../../../includes/crabout-md.md)]<span data-ttu-id="dd337-220">el proceso de exportación, consulte [Exportar esquemas de las clases](../../../../docs/framework/wcf/feature-details/exporting-schemas-from-classes.md).</span><span class="sxs-lookup"><span data-stu-id="dd337-220"> the export process, see [Exporting Schemas from Classes](../../../../docs/framework/wcf/feature-details/exporting-schemas-from-classes.md).</span></span>  
  
 <span data-ttu-id="dd337-221">El método de proveedor de esquema también puede devolver el <xref:System.Xml.Schema.XmlSchemaType> que se va a utilizar.</span><span class="sxs-lookup"><span data-stu-id="dd337-221">The schema provider method can also return the <xref:System.Xml.Schema.XmlSchemaType> to use.</span></span> <span data-ttu-id="dd337-222">El tipo puede o no ser anónimo.</span><span class="sxs-lookup"><span data-stu-id="dd337-222">The type may or may not be anonymous.</span></span> <span data-ttu-id="dd337-223">Si es anónimo, el esquema para el tipo `IXmlSerializable` se exporta como tipo anónimo cada vez que el tipo `IXmlSerializable` se utiliza como un miembro de datos.</span><span class="sxs-lookup"><span data-stu-id="dd337-223">If it is anonymous, the schema for the `IXmlSerializable` type is exported as an anonymous type every time the `IXmlSerializable` type is used as a data member.</span></span> <span data-ttu-id="dd337-224">El tipo `IXmlSerializable` aún tiene un nombre de contrato de datos y un espacio de nombres.</span><span class="sxs-lookup"><span data-stu-id="dd337-224">The `IXmlSerializable` type still has a data contract name and namespace.</span></span> <span data-ttu-id="dd337-225">(Esto se determina como se describe en [nombres de contrato de datos](../../../../docs/framework/wcf/feature-details/data-contract-names.md) salvo que la <xref:System.Runtime.Serialization.DataContractAttribute> atributo no se puede usar para personalizar el nombre.) Si no es anónimo, debe ser uno de los tipos en `XmlSchemaSet`.</span><span class="sxs-lookup"><span data-stu-id="dd337-225">(This is determined as described in [Data Contract Names](../../../../docs/framework/wcf/feature-details/data-contract-names.md) except that the <xref:System.Runtime.Serialization.DataContractAttribute> attribute cannot be used to customize the name.) If it is not anonymous, it must be one of the types in the `XmlSchemaSet`.</span></span> <span data-ttu-id="dd337-226">Este caso es equivalente a la devolución del `XmlQualifiedName` del tipo.</span><span class="sxs-lookup"><span data-stu-id="dd337-226">This case is equivalent to returning the `XmlQualifiedName` of the type.</span></span>  
  
 <span data-ttu-id="dd337-227">Además, se exporta una declaración de elemento global para el tipo.</span><span class="sxs-lookup"><span data-stu-id="dd337-227">Additionally, a global element declaration is exported for the type.</span></span> <span data-ttu-id="dd337-228">Si el tipo no tiene el atributo <xref:System.Xml.Serialization.XmlRootAttribute> aplicado, el elemento tiene el mismo nombre y espacio de nombres que el contrato de datos, y su propiedad "nillable" será verdadera.</span><span class="sxs-lookup"><span data-stu-id="dd337-228">If the type does not have the <xref:System.Xml.Serialization.XmlRootAttribute> attribute applied to it, the element has the same name and namespace as the data contract, and its "nillable" property is true.</span></span> <span data-ttu-id="dd337-229">La única excepción es el espacio de nombres de esquema ("http://www.w3.org/2001/XMLSchema"). Si el contrato de datos del tipo está en este espacio de nombres, el elemento global correspondiente está en el espacio de nombres en blanco porque no está permitido agregar nuevos elementos al espacio de nombres del esquema.</span><span class="sxs-lookup"><span data-stu-id="dd337-229">The only exception to this is the schema namespace ("http://www.w3.org/2001/XMLSchema") – if the type’s data contract is in this namespace, the corresponding global element is in the blank namespace because it is forbidden to add new elements to the schema namespace.</span></span> <span data-ttu-id="dd337-230">Si el tipo tiene el atributo `XmlRootAttribute` aplicado, la declaración del elemento global se exporta mediante las siguientes propiedades: <xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>, <xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> y <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A>.</span><span class="sxs-lookup"><span data-stu-id="dd337-230">If the type has the `XmlRootAttribute` attribute applied to it, the global element declaration is exported using the following: <xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>, <xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> and <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A> properties.</span></span> <span data-ttu-id="dd337-231">Los valores predeterminados con `XmlRootAttribute` aplicados son el nombre de contrato de datos, un espacio de nombres en blanco y "nillable" verdadero.</span><span class="sxs-lookup"><span data-stu-id="dd337-231">The defaults with `XmlRootAttribute` applied are the data contract name, a blank namespace and "nillable" being true.</span></span>  
  
 <span data-ttu-id="dd337-232">Las mismas reglas de la declaración de elemento globales se aplican a los tipos de conjunto de datos heredados.</span><span class="sxs-lookup"><span data-stu-id="dd337-232">The same global element declaration rules apply to legacy dataset types.</span></span> <span data-ttu-id="dd337-233">Tenga en cuenta que `XmlRootAttribute` no puede invalidar declaraciones de elemento globales agregadas a través de código personalizado, o agregadas a `XmlSchemaSet` mediante el método de proveedor de esquema o a través de `GetSchema` para los tipos de conjunto de datos heredados.</span><span class="sxs-lookup"><span data-stu-id="dd337-233">Note that the `XmlRootAttribute` cannot override global element declarations added through custom code, either added to the `XmlSchemaSet` using the schema provider method or through `GetSchema` for legacy dataset types.</span></span>  
  
### <a name="ixmlserializable-element-types"></a><span data-ttu-id="dd337-234">Tipos de elemento de IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="dd337-234">IXmlSerializable Element Types</span></span>  
 <span data-ttu-id="dd337-235">Los tipos de elemento `IXmlSerializable` hacen que la propiedad `IsAny` se establezca en `true` o hacen que su método de proveedor de esquema se vuelva `null`.</span><span class="sxs-lookup"><span data-stu-id="dd337-235">`IXmlSerializable` element types have either the `IsAny` property set to `true` or have their schema provider method return `null`.</span></span>  
  
 <span data-ttu-id="dd337-236">Serializar y deserializar un tipo de elemento es muy similar a serializar y deserializar un tipo de contenido.</span><span class="sxs-lookup"><span data-stu-id="dd337-236">Serializing and deserializing an element type is very similar to serializing and deserializing a content type.</span></span> <span data-ttu-id="dd337-237">Sin embargo, hay algunas diferencias importantes:</span><span class="sxs-lookup"><span data-stu-id="dd337-237">However, there are some important differences:</span></span>  
  
-   <span data-ttu-id="dd337-238">Se espera que la implementación `WriteXml` escriba exactamente un elemento (qué podría contener, por supuesto, varios elementos secundarios).</span><span class="sxs-lookup"><span data-stu-id="dd337-238">The `WriteXml` implementation is expected to write exactly one element (which could of course contain multiple child elements).</span></span> <span data-ttu-id="dd337-239">No debería estar escribiendo los atributos fuera de este elemento único, varios elementos del mismo nivel o contenido mixto.</span><span class="sxs-lookup"><span data-stu-id="dd337-239">It should not be writing attributes outside of this single element, multiple sibling elements or mixed content.</span></span> <span data-ttu-id="dd337-240">El elemento puede estar vacío.</span><span class="sxs-lookup"><span data-stu-id="dd337-240">The element may be empty.</span></span>  
  
-   <span data-ttu-id="dd337-241">La implementación `ReadXml` no debería leer el elemento contenedor.</span><span class="sxs-lookup"><span data-stu-id="dd337-241">The `ReadXml` implementation should not read the wrapper element.</span></span> <span data-ttu-id="dd337-242">Se espera que lea el un elemento que `WriteXml` genera.</span><span class="sxs-lookup"><span data-stu-id="dd337-242">It is expected to read the one element that `WriteXml` produces.</span></span>  
  
-   <span data-ttu-id="dd337-243">Al serializar de manera regular un tipo de elemento (por ejemplo, como un miembro de datos en un contrato de datos), el serializador producirá un elemento contenedor antes de llamar a `WriteXml`, como en los tipos de contenido.</span><span class="sxs-lookup"><span data-stu-id="dd337-243">When serializing an element type regularly (for example, as a data member in a data contract), the serializer outputs a wrapper element before calling `WriteXml`, as with content types.</span></span> <span data-ttu-id="dd337-244">No obstante, al serializar un tipo de elemento en el nivel superior, normalmente, el serializador no produce un elemento contenedor alrededor del elemento que `WriteXml` escribe, salvo que se especifiquen explícitamente un nombre de raíz y un espacio de nombres al construir el serializador en el `DataContractSerializer`, o los constructores `NetDataContractSerializer`.</span><span class="sxs-lookup"><span data-stu-id="dd337-244">However, when serializing an element type at the top level, the serializer does not normally output a wrapper element at all around the element that `WriteXml` writes, unless a root name and namespace were explicitly specified when constructing the serializer in the `DataContractSerializer` or `NetDataContractSerializer` constructors.</span></span> [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]<span data-ttu-id="dd337-245">[Serialización y deserialización](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).</span><span class="sxs-lookup"><span data-stu-id="dd337-245"> [Serialization and Deserialization](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).</span></span>  
  
-   <span data-ttu-id="dd337-246">Cuando se serializa un tipo de elemento en el nivel superior sin especificar el nombre de raíz y el espacio de nombres en el momento de la construcción, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> y <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> no hace prácticamente nada, y <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> llama a `WriteXml`.</span><span class="sxs-lookup"><span data-stu-id="dd337-246">When serializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> essentially does nothing and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> calls `WriteXml`.</span></span> <span data-ttu-id="dd337-247">En este modo, el objeto que se serializa no puede ser nulo y no se puede asignar polimórficamente.</span><span class="sxs-lookup"><span data-stu-id="dd337-247">In this mode, the object being serialized cannot be null and cannot be polymorphically assigned.</span></span> <span data-ttu-id="dd337-248">Además, la preservación del gráfico de objetos puede se puede habilitar y no se puede utilizar `NetDataContractSerializer`.</span><span class="sxs-lookup"><span data-stu-id="dd337-248">Also, object graph preservation cannot enabled and the `NetDataContractSerializer` cannot be used.</span></span>  
  
-   <span data-ttu-id="dd337-249">Al deserializar un tipo de elemento en el nivel superior sin especificar el nombre y el espacio de nombres raíz en el momento de la construcción, <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> devuelve `true` si encuentra el inicio de cualquier elemento.</span><span class="sxs-lookup"><span data-stu-id="dd337-249">When deserializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> returns `true` if it can find the start of any element.</span></span> <span data-ttu-id="dd337-250"><xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> con el parámetro `verifyObjectName` establecido en `true` se comporta igual que `IsStartObject` antes realmente de leer el objeto realmente.</span><span class="sxs-lookup"><span data-stu-id="dd337-250"><xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> with the `verifyObjectName` parameter set to `true` behaves in the same way as `IsStartObject` before actually reading the object.</span></span> <span data-ttu-id="dd337-251">`ReadObject` después pasa el control al método `ReadXml`.</span><span class="sxs-lookup"><span data-stu-id="dd337-251">`ReadObject` then passes control to `ReadXml` method.</span></span>  
  
 <span data-ttu-id="dd337-252">El esquema exportado para los tipos de elemento es igual que para el tipo `XmlElement` tal y como se ha descrito en una sección anterior, excepto que el método de proveedor de esquema puede agregar un esquema adicional a <xref:System.Xml.Schema.XmlSchemaSet> como con los tipos de contenido.</span><span class="sxs-lookup"><span data-stu-id="dd337-252">The schema exported for element types is the same as for the `XmlElement` type as described in an earlier section, except that the schema provider method can add any additional schema to the <xref:System.Xml.Schema.XmlSchemaSet> as with content types.</span></span> <span data-ttu-id="dd337-253">No se permite utilizar el atributo `XmlRootAttribute` con tipos de elemento y las declaraciones de elemento globales nunca se emiten para estos tipos.</span><span class="sxs-lookup"><span data-stu-id="dd337-253">Using the `XmlRootAttribute` attribute with element types is not allowed, and global element declarations are never emitted for these types.</span></span>  
  
### <a name="differences-from-the-xmlserializer"></a><span data-ttu-id="dd337-254">Diferencias respecto a XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="dd337-254">Differences from the XmlSerializer</span></span>  
 <span data-ttu-id="dd337-255">`IXmlSerializable` entiende también la interfaz `XmlSchemaProviderAttribute` y `XmlRootAttribute` y los atributos <xref:System.Xml.Serialization.XmlSerializer>.</span><span class="sxs-lookup"><span data-stu-id="dd337-255">The `IXmlSerializable` interface and the `XmlSchemaProviderAttribute` and `XmlRootAttribute` attributes are also understood by the <xref:System.Xml.Serialization.XmlSerializer> .</span></span> <span data-ttu-id="dd337-256">Sin embargo, hay algunas diferencias en cómo se tratan estos en el modelo del contrato de datos.</span><span class="sxs-lookup"><span data-stu-id="dd337-256">However, there are some differences in how these are treated in the data contract model.</span></span> <span data-ttu-id="dd337-257">A continuación se resumen las principales diferencias:</span><span class="sxs-lookup"><span data-stu-id="dd337-257">The important differences are summarized in the following:</span></span>  
  
-   <span data-ttu-id="dd337-258">El método de proveedor de esquema debe ser público para ser utilizable en `XmlSerializer`, pero no tiene que ser público para ser utilizable en el modelo del contrato de datos.</span><span class="sxs-lookup"><span data-stu-id="dd337-258">The schema provider method must be public to be usable in the `XmlSerializer`, but does not have to be public to be usable in the data contract model.</span></span>  
  
-   <span data-ttu-id="dd337-259">Se llama al método de proveedor de esquema cuando `IsAny` es verdadero en el modelo del contrato de datos pero no con `XmlSerializer`.</span><span class="sxs-lookup"><span data-stu-id="dd337-259">The schema provider method is called when `IsAny` is true in the data contract model but not with the `XmlSerializer`.</span></span>  
  
-   <span data-ttu-id="dd337-260">Cuando el atributo `XmlRootAttribute` no está presente para contenido o tipos de conjunto de datos heredados, `XmlSerializer` exporta una declaración de elemento global en el espacio de nombres en blanco.</span><span class="sxs-lookup"><span data-stu-id="dd337-260">When the `XmlRootAttribute` attribute is not present for content or legacy dataset types, the `XmlSerializer` exports a global element declaration in the blank namespace.</span></span> <span data-ttu-id="dd337-261">En el modelo del contrato de datos, el espacio de nombres utilizado es normalmente el espacio de nombres de contrato de datos, tal y como se ha descrito anteriormente.</span><span class="sxs-lookup"><span data-stu-id="dd337-261">In the data contract model, the namespace used is normally the data contract namespace as described earlier.</span></span>  
  
 <span data-ttu-id="dd337-262">Tenga en cuenta estas diferencias cuando cree tipos que se utilizan con ambas tecnologías de serialización.</span><span class="sxs-lookup"><span data-stu-id="dd337-262">Be aware of these differences when creating types that are used with both serialization technologies.</span></span>  
  
### <a name="importing-ixmlserializable-schema"></a><span data-ttu-id="dd337-263">Importar el esquema de IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="dd337-263">Importing IXmlSerializable Schema</span></span>  
 <span data-ttu-id="dd337-264">Al importar un esquema generado a partir de los tipos `IXmlSerializable`, existen pocas posibilidades:</span><span class="sxs-lookup"><span data-stu-id="dd337-264">When importing a schema generated from `IXmlSerializable` types, there are a few possibilities:</span></span>  
  
-   <span data-ttu-id="dd337-265">El esquema generado puede ser un esquema de contrato de datos válidos, tal y como se describe en [referencia de esquema de contrato de datos](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="dd337-265">The generated schema may be a valid data contract schema as described in [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span></span> <span data-ttu-id="dd337-266">En este caso, el esquema puede importarse como de costumbre y se generarán los tipos de contrato de datos normales.</span><span class="sxs-lookup"><span data-stu-id="dd337-266">In this case, schema can be imported as usual and regular data contract types are generated.</span></span>  
  
-   <span data-ttu-id="dd337-267">El esquema generado no puede ser un esquema de contrato de datos válido.</span><span class="sxs-lookup"><span data-stu-id="dd337-267">The generated schema may not be a valid data contract schema.</span></span> <span data-ttu-id="dd337-268">Por ejemplo, su método de proveedor de esquemas puede generar un esquema que incluye atributos XML que no se admiten en el modelo de contrato de datos.</span><span class="sxs-lookup"><span data-stu-id="dd337-268">For example, your schema provider method may generate schema that involves XML attributes which are not supported in the data contract model.</span></span> <span data-ttu-id="dd337-269">En este caso, puede importar el esquema como tipos `IXmlSerializable`.</span><span class="sxs-lookup"><span data-stu-id="dd337-269">In this case, you can import the schema as `IXmlSerializable` types.</span></span> <span data-ttu-id="dd337-270">Este modo de importación no está activada de forma predeterminada, pero puede fácilmente habilitarse: por ejemplo, con el `/importXmlTypes` conmutador de línea de comandos para la [la herramienta de utilidad de metadatos de ServiceModel (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md).</span><span class="sxs-lookup"><span data-stu-id="dd337-270">This import mode is not on by default but can easily be enabled – for example, with the `/importXmlTypes` command-line switch to the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md).</span></span> <span data-ttu-id="dd337-271">Esto se describe en detalle en la [esquema de importación para generar clases de](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md).</span><span class="sxs-lookup"><span data-stu-id="dd337-271">This is described in detail in the [Importing Schema to Generate Classes](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md).</span></span> <span data-ttu-id="dd337-272">Tenga en cuenta que debe trabajar directamente con XML para sus instancias de tipo.</span><span class="sxs-lookup"><span data-stu-id="dd337-272">Note that you must work directly with the XML for your type instances.</span></span> <span data-ttu-id="dd337-273">También puede considerar la utilización de una tecnología de serialización diferente que admita una gama más amplia de esquemas. Vea el tema acerca de la utilización del `XmlSerializer`.</span><span class="sxs-lookup"><span data-stu-id="dd337-273">You may also consider using a different serialization technology that supports a wider range of schema – see the topic on using the `XmlSerializer`.</span></span>  
  
-   <span data-ttu-id="dd337-274">Puede desear volver a usar sus tipos `IXmlSerializable` existentes en el proxy en lugar de generar nuevos.</span><span class="sxs-lookup"><span data-stu-id="dd337-274">You may want to reuse your existing `IXmlSerializable` types in the proxy instead of generating new ones.</span></span> <span data-ttu-id="dd337-275">En este caso, la característica de tipos a la cual s se hace referencia descrita en el tema Esquema de Importación para generar Tipos se puede utilizar para indicar el tipo que se reutilizará.</span><span class="sxs-lookup"><span data-stu-id="dd337-275">In this case, the referenced types feature described in the Importing Schema to Generate Types topic can be used to indicate the type to reuse.</span></span> <span data-ttu-id="dd337-276">Esto equivale a utilizar el `/reference` cambie en svcutil.exe, que especifica el ensamblado que contiene los tipos que se va a volver a usar.</span><span class="sxs-lookup"><span data-stu-id="dd337-276">This corresponds to using the `/reference` switch on svcutil.exe, which specifies the assembly that contains the types to reuse.</span></span>  
  
## <a name="representing-arbitrary-xml-in-data-contracts"></a><span data-ttu-id="dd337-277">Representar XML arbitrario en contratos de datos</span><span class="sxs-lookup"><span data-stu-id="dd337-277">Representing Arbitrary XML in Data Contracts</span></span>  
 <span data-ttu-id="dd337-278">`XmlElement`, Matriz de `XmlNode` y los tipos `IXmlSerializable` le permite insertar XML arbitrario en el modelo del contrato de datos.</span><span class="sxs-lookup"><span data-stu-id="dd337-278">The `XmlElement`, Array of `XmlNode` and `IXmlSerializable` types allow you to inject arbitrary XML into the data contract model.</span></span> <span data-ttu-id="dd337-279">`DataContractSerializer` y `NetDataContractSerializer` pasan este contenido XML al sistema de escritura XML en uso, sin interferir en el proceso.</span><span class="sxs-lookup"><span data-stu-id="dd337-279">The `DataContractSerializer` and `NetDataContractSerializer` pass this XML content on to the XML writer in use, without interfering in the process.</span></span> <span data-ttu-id="dd337-280">Sin embargo, los sistemas de escritura XML pueden exigir ciertas restricciones en el XML que escriben.</span><span class="sxs-lookup"><span data-stu-id="dd337-280">However, the XML writers may enforce certain restrictions on the XML that they write.</span></span> <span data-ttu-id="dd337-281">Específicamente, aquí se describen algunos ejemplos importantes:</span><span class="sxs-lookup"><span data-stu-id="dd337-281">Specifically, here are some important examples:</span></span>  
  
-   <span data-ttu-id="dd337-282">Los sistemas de escritura XML normalmente no permiten una declaración de documento XML (por ejemplo, \<? xml versión ='1.0 '? >) en el medio de escritura de otro documento.</span><span class="sxs-lookup"><span data-stu-id="dd337-282">The XML writers do not typically allow an XML document declaration (for example, \<?xml version=’1.0’ ?>) in the middle of writing another document.</span></span> <span data-ttu-id="dd337-283">No puede tomar un documento XML completo y serializarlo como un `Array` de un miembro de datos de `XmlNode`.</span><span class="sxs-lookup"><span data-stu-id="dd337-283">You cannot take a full XML document and serialize it as an `Array` of `XmlNode` data member.</span></span> <span data-ttu-id="dd337-284">Para hacerlo, tiene que quitar la declaración del documento o utilizar su propio esquema de codificación para representarlo.</span><span class="sxs-lookup"><span data-stu-id="dd337-284">To do this, you have to either strip out the document declaration or use your own encoding scheme to represent it.</span></span>  
  
-   <span data-ttu-id="dd337-285">¿Todos los sistemas de escritura XML proporcionados con [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] rechazar las instrucciones de procesamiento de XML (\<?</span><span class="sxs-lookup"><span data-stu-id="dd337-285">All of the XML writers supplied with [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] reject XML processing instructions (\<?</span></span> <span data-ttu-id="dd337-286">…</span><span class="sxs-lookup"><span data-stu-id="dd337-286">…</span></span> <span data-ttu-id="dd337-287">? >) y las definiciones de tipo de documento (\<!</span><span class="sxs-lookup"><span data-stu-id="dd337-287">?>) and document type definitions (\<!</span></span> <span data-ttu-id="dd337-288">…</span><span class="sxs-lookup"><span data-stu-id="dd337-288">…</span></span> <span data-ttu-id="dd337-289">>), ya que no se admiten en los mensajes SOAP.</span><span class="sxs-lookup"><span data-stu-id="dd337-289">>), because they are not allowed in SOAP messages.</span></span> <span data-ttu-id="dd337-290">En este caso, también puede utilizar su propio mecanismo de codificación para evitar esta restricción.</span><span class="sxs-lookup"><span data-stu-id="dd337-290">Again, you can use your own encoding mechanism to get around this restriction.</span></span> <span data-ttu-id="dd337-291">Si debe incluirlos en el XML resultante, puede escribir un codificador personalizado que utilice sistemas de escritura XML que los admitan.</span><span class="sxs-lookup"><span data-stu-id="dd337-291">If you must include these in your resultant XML, you can write a custom encoder that uses XML writers that support them.</span></span>  
  
-   <span data-ttu-id="dd337-292">Al implementar `WriteXml`, evite llamar al método <xref:System.Xml.XmlWriter.WriteRaw%2A> en el sistema de escritura XML.</span><span class="sxs-lookup"><span data-stu-id="dd337-292">When implementing `WriteXml`, avoid calling <xref:System.Xml.XmlWriter.WriteRaw%2A> method on the XML writer.</span></span> [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]<span data-ttu-id="dd337-293"> usa diversas codificaciones XML (incluida binario); es muy difícil o no se puede usar `WriteRaw` para que el resultado se pueda usar en cualquier codificación.</span><span class="sxs-lookup"><span data-stu-id="dd337-293"> uses a variety of XML encodings (including binary), it is very difficult or impossible to use `WriteRaw` such that the result is usable in any encoding.</span></span>  
  
-   <span data-ttu-id="dd337-294">Al implementar `WriteXml`, evite utilizar <xref:System.Xml.XmlWriter.WriteEntityRef%2A> y los métodos <xref:System.Xml.XmlWriter.WriteNmToken%2A> que no son compatibles en los sistemas de escritura de XML proporcionados con [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)].</span><span class="sxs-lookup"><span data-stu-id="dd337-294">When implementing `WriteXml`, avoid using the <xref:System.Xml.XmlWriter.WriteEntityRef%2A> and <xref:System.Xml.XmlWriter.WriteNmToken%2A> methods that are unsupported on the XML writers supplied with [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)].</span></span>  
  
## <a name="using-dataset-typed-dataset-and-datatable"></a><span data-ttu-id="dd337-295">Utilizar DataSet, DataSet con tipo y DataTable</span><span class="sxs-lookup"><span data-stu-id="dd337-295">Using DataSet, Typed DataSet and DataTable</span></span>  
 <span data-ttu-id="dd337-296">El uso de estos tipos está totalmente admitido en el modelo del contrato de datos.</span><span class="sxs-lookup"><span data-stu-id="dd337-296">Using these types is fully supported in the data contract model.</span></span> <span data-ttu-id="dd337-297">Al utilizar estos tipos, considere los puntos siguientes:</span><span class="sxs-lookup"><span data-stu-id="dd337-297">When using these types, consider the following points:</span></span>  
  
-   <span data-ttu-id="dd337-298">El esquema para estos tipos (sobre todo <xref:System.Data.DataSet> y sus clases derivadas con tipo) puede no interoperar con algunas plataformas no-[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)], o podría dar lugar a una infrautilización si se utiliza con estas plataformas.</span><span class="sxs-lookup"><span data-stu-id="dd337-298">The schema for these types (especially <xref:System.Data.DataSet> and its typed derived classes) may not be interoperable with some non-[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] platforms, or may result in poor usability when used with these platforms.</span></span> <span data-ttu-id="dd337-299">Además, utilizar el tipo `DataSet` puede tener implicaciones de rendimiento.</span><span class="sxs-lookup"><span data-stu-id="dd337-299">Additionally, using the `DataSet` type may have performance implications.</span></span> <span data-ttu-id="dd337-300">Finalmente, puede hacer más difícil su control sobre las versiones de su aplicación en el futuro.</span><span class="sxs-lookup"><span data-stu-id="dd337-300">Finally, it may make it more difficult for you to version your application in the future.</span></span> <span data-ttu-id="dd337-301">Considere utilizar explícitamente los tipos de contrato de datos definidos en lugar de los tipos `DataSet` en sus contratos.</span><span class="sxs-lookup"><span data-stu-id="dd337-301">Consider using explicitly defined data contract types instead of `DataSet` types in your contracts.</span></span>  
  
-   <span data-ttu-id="dd337-302">Al importar `DataSet` o esquema `DataTable`, es importante hacer referencia a estos tipos.</span><span class="sxs-lookup"><span data-stu-id="dd337-302">When importing `DataSet` or `DataTable` schema, it is important to reference these types.</span></span> <span data-ttu-id="dd337-303">Con la herramienta de línea de comandos Svcutil.exe, esto puede realizarse si se pasa el nombre del ensamblado System.Data.dll a la `/reference` cambiar.</span><span class="sxs-lookup"><span data-stu-id="dd337-303">With the Svcutil.exe command-line tool, this can be accomplished by passing the System.Data.dll assembly name to the `/reference` switch.</span></span> <span data-ttu-id="dd337-304">Si importa el esquema del conjunto de datos con tipo, debe hacer referencia al tipo del conjunto de datos con tipo.</span><span class="sxs-lookup"><span data-stu-id="dd337-304">If importing typed dataset schema, you must reference the typed dataset’s type.</span></span> <span data-ttu-id="dd337-305">Con Svcutil.exe, pase la ubicación del ensamblado del conjunto de datos con tipo para el `/reference` cambiar.</span><span class="sxs-lookup"><span data-stu-id="dd337-305">With Svcutil.exe, pass the location of the typed dataset’s assembly to the `/reference` switch.</span></span> [!INCLUDE[crabout](../../../../includes/crabout-md.md)]<span data-ttu-id="dd337-306">hacer referencia a tipos, vea la [esquema de importación para generar clases de](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md).</span><span class="sxs-lookup"><span data-stu-id="dd337-306"> referencing types, see the [Importing Schema to Generate Classes](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md).</span></span>  
  
 <span data-ttu-id="dd337-307">La compatibilidad de los conjuntos de datos con tipo del modelo de contrato de datos es limitada.</span><span class="sxs-lookup"><span data-stu-id="dd337-307">Support for typed DataSets in the data contract model is limited.</span></span> <span data-ttu-id="dd337-308">Los conjuntos de datos con tipos pueden serializarse y deserializarse, y pueden exportar su esquema.</span><span class="sxs-lookup"><span data-stu-id="dd337-308">Typed DataSets can be serialized and deserialized and can export their schema.</span></span> <span data-ttu-id="dd337-309">No obstante, la importación del esquema de contrato de datos no puede generar nuevos tipos de conjunto de datos con tipo desde el esquema, ya que solo puede reutilizar los existentes.</span><span class="sxs-lookup"><span data-stu-id="dd337-309">However, the Data Contract schema import is unable to generate new typed DataSet types from the schema, as it can only reuse existing ones.</span></span> <span data-ttu-id="dd337-310">Puede señalar a un conjunto de datos con tipo existente mediante el modificador `/r` en Svcutil.exe.</span><span class="sxs-lookup"><span data-stu-id="dd337-310">You can point to an existing typed DataSet by using the `/r` switch on Svcutil.exe.</span></span> <span data-ttu-id="dd337-311">Si intenta usar una Svcutil.exe sin el modificador `/r` en un servicio que usa un conjunto de datos con tipo, se selecciona automáticamente un serializador alternativo (XmlSerializer).</span><span class="sxs-lookup"><span data-stu-id="dd337-311">If you attempt to use a Svcutil.exe without the `/r` switch on a service that uses a typed dataset, an alternative serializer (XmlSerializer) is automatically selected.</span></span> <span data-ttu-id="dd337-312">Si necesita usar DataContractSerializer y generar conjuntos de datos a partir del esquema, puede usar el procedimiento siguiente: genere los tipos DataSet con tipo (mediante la herramienta Xsd.exe con el modificador `/d` en el servicio), compile los tipos y, a continuación, señale a ellos mediante el uso del modificador `/r` en Svcutil.exe.</span><span class="sxs-lookup"><span data-stu-id="dd337-312">If you must use the DataContractSerializer and must generate DataSets from schema, you can use the following procedure: generate the typed DataSet types (by using the Xsd.exe tool with the `/d` switch on the service), compile the types, and then point to them using the `/r` switch on Svcutil.exe.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="dd337-313">Vea también</span><span class="sxs-lookup"><span data-stu-id="dd337-313">See Also</span></span>  
 <xref:System.Runtime.Serialization.DataContractSerializer>  
 <xref:System.Xml.Serialization.IXmlSerializable>  
 [<span data-ttu-id="dd337-314">Utilización de contratos de datos</span><span class="sxs-lookup"><span data-stu-id="dd337-314">Using Data Contracts</span></span>](../../../../docs/framework/wcf/feature-details/using-data-contracts.md)  
 [<span data-ttu-id="dd337-315">Tipos admitidos por el serializador de contratos de datos</span><span class="sxs-lookup"><span data-stu-id="dd337-315">Types Supported by the Data Contract Serializer</span></span>](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md)
