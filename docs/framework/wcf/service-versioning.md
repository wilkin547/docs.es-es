---
title: Control de versiones del servicio
ms.date: 03/30/2017
ms.assetid: 37575ead-d820-4a67-8059-da11a2ab48e2
ms.openlocfilehash: ea5e80e33d1b29e01e6d1867c50bb3bb973b01c3
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 03/12/2020
ms.locfileid: "79183121"
---
# <a name="service-versioning"></a><span data-ttu-id="e8165-102">Control de versiones del servicio</span><span class="sxs-lookup"><span data-stu-id="e8165-102">Service Versioning</span></span>
<span data-ttu-id="e8165-103">Después de la implementación inicial y de haber transcurrido potencialmente varias horas durante su duración, los servicios (y los puntos de conexión que exponen) pueden necesitar ser cambiados debido a diversas razones, como cambios en las necesidades comerciales, requisitos de tecnología de la información o para resolver otros problemas.</span><span class="sxs-lookup"><span data-stu-id="e8165-103">After initial deployment, and potentially several times during their lifetime, services (and the endpoints they expose) may need to be changed for a variety of reasons, such as changing business needs, information technology requirements, or to address other issues.</span></span> <span data-ttu-id="e8165-104">Cada cambio produce una nueva versión del servicio.</span><span class="sxs-lookup"><span data-stu-id="e8165-104">Each change introduces a new version of the service.</span></span> <span data-ttu-id="e8165-105">En este tema se explica cómo considerar el control de versiones en Windows Communication Foundation (WCF).</span><span class="sxs-lookup"><span data-stu-id="e8165-105">This topic explains how to consider versioning in Windows Communication Foundation (WCF).</span></span>  
  
## <a name="four-categories-of-service-changes"></a><span data-ttu-id="e8165-106">Cuatro categorías de cambios del servicio</span><span class="sxs-lookup"><span data-stu-id="e8165-106">Four Categories of Service Changes</span></span>  
 <span data-ttu-id="e8165-107">Los cambios en los servicios que se pueden requerir pueden clasificarse en cuatro categorías:</span><span class="sxs-lookup"><span data-stu-id="e8165-107">The changes to services that may be required can be classified into four categories:</span></span>  
  
- <span data-ttu-id="e8165-108">Cambios del contrato: por ejemplo, se podría agregar una operación o se podría agregar o cambiar un elemento de datos en un mensaje.</span><span class="sxs-lookup"><span data-stu-id="e8165-108">Contract changes: For example, an operation might be added, or a data element in a message might be added or changed.</span></span>  
  
- <span data-ttu-id="e8165-109">Cambios de la dirección: por ejemplo, se mueve un servicio a una ubicación diferente donde los puntos de conexión tienen nuevas direcciones.</span><span class="sxs-lookup"><span data-stu-id="e8165-109">Address changes: For example, a service moves to a different location where endpoints have new addresses.</span></span>  
  
- <span data-ttu-id="e8165-110">Cambios del enlace: por ejemplo, un mecanismo de seguridad cambia o lo hace su configuración.</span><span class="sxs-lookup"><span data-stu-id="e8165-110">Binding changes: For example, a security mechanism changes or its settings change.</span></span>  
  
- <span data-ttu-id="e8165-111">Cambios de implementación: por ejemplo, cuando cambia una implementación de método interno.</span><span class="sxs-lookup"><span data-stu-id="e8165-111">Implementation changes: For example, when an internal method implementation changes.</span></span>  
  
 <span data-ttu-id="e8165-112">Algunos de estos cambios se denominan "con interrupción" y otros son denominados "sin interrupción".</span><span class="sxs-lookup"><span data-stu-id="e8165-112">Some of these changes are called "breaking" and others are "nonbreaking."</span></span> <span data-ttu-id="e8165-113">Un cambio no se *rompe* si todos los mensajes que se habrían procesado correctamente en la versión anterior se procesan correctamente en la nueva versión.</span><span class="sxs-lookup"><span data-stu-id="e8165-113">A change is *nonbreaking* if all messages that would have been processed successfully in the previous version are processed successfully in the new version.</span></span> <span data-ttu-id="e8165-114">Cualquier cambio que no cumpla ese criterio es un cambio *importante.*</span><span class="sxs-lookup"><span data-stu-id="e8165-114">Any change that does not meet that criterion is a *breaking* change.</span></span>  
  
## <a name="service-orientation-and-versioning"></a><span data-ttu-id="e8165-115">Orientación del servicio y control de las versiones</span><span class="sxs-lookup"><span data-stu-id="e8165-115">Service Orientation and Versioning</span></span>  
 <span data-ttu-id="e8165-116">Uno de los principios de orientación del servicio es que los servicios y los clientes son autónomos (o independientes).</span><span class="sxs-lookup"><span data-stu-id="e8165-116">One of the tenets of service orientation is that services and clients are autonomous (or independent).</span></span> <span data-ttu-id="e8165-117">Entre otras cosas, esto implica que los programadores del servicio no pueden suponer que controlan o que incluso lo saben todo sobre los clientes del servicio.</span><span class="sxs-lookup"><span data-stu-id="e8165-117">Among other things, this implies that service developers cannot assume that they control or even know about all service clients.</span></span> <span data-ttu-id="e8165-118">Esto elimina la opción de recompilar y volver a implementar todos los clientes cuando un servicio cambia de versión.</span><span class="sxs-lookup"><span data-stu-id="e8165-118">This eliminates the option of rebuilding and redeploying all clients when a service changes versions.</span></span> <span data-ttu-id="e8165-119">En este tema se supone que el servicio se adhiere a este principio de orientación y, por consiguiente, su modificación o el "control de versiones" tiene lugar con independencia de los clientes.</span><span class="sxs-lookup"><span data-stu-id="e8165-119">This topic assumes the service adheres to this tenet and therefore must be changed or "versioned" independent of its clients.</span></span>  
  
 <span data-ttu-id="e8165-120">En los casos en los que no se prevé un cambio con interrupción y no puede evitarse, una aplicación puede decidir si omitir este principio y requerir que los clientes se recompilen y se implementen de nuevo con una nueva versión del servicio.</span><span class="sxs-lookup"><span data-stu-id="e8165-120">In cases where a breaking change is unexpected and cannot be avoided, an application may choose to ignore this tenet and require that clients be rebuilt and redeployed with a new version of the service.</span></span>  
  
## <a name="contract-versioning"></a><span data-ttu-id="e8165-121">Versiones de contratos</span><span class="sxs-lookup"><span data-stu-id="e8165-121">Contract Versioning</span></span>  
 <span data-ttu-id="e8165-122">Los contratos utilizados por un cliente no tienen por qué ser iguales que el contrato utilizado por el servicio; solo deben ser compatibles.</span><span class="sxs-lookup"><span data-stu-id="e8165-122">Contracts used by a client do not need to be the same as the contract used by the service; they need only to be compatible.</span></span>  
  
 <span data-ttu-id="e8165-123">Para los contratos de servicios, la compatibilidad significa que se pueden agregar nuevas operaciones expuestas por el servicio pero que no se pueden quitar o cambiar semánticamente las operaciones existentes en el contrato.</span><span class="sxs-lookup"><span data-stu-id="e8165-123">For service contracts, compatibility means new operations exposed by the service can be added but existing operations cannot be removed or changed semantically.</span></span>  
  
 <span data-ttu-id="e8165-124">Para los contratos de datos, la compatibilidad significa que se pueden agregar las nuevas definiciones de tipo de esquema pero las definiciones existentes de tipo de esquema no se pueden cambiar con interrupción.</span><span class="sxs-lookup"><span data-stu-id="e8165-124">For data contracts, compatibility means new schema type definitions can be added but existing schema type definitions cannot be changed in breaking ways.</span></span> <span data-ttu-id="e8165-125">Los cambios con interrupción podrían incluir quitar los miembros de datos o cambiar de manera incompatible su tipo de datos.</span><span class="sxs-lookup"><span data-stu-id="e8165-125">Breaking changes might include removing data members or changing their data type incompatibly.</span></span> <span data-ttu-id="e8165-126">Esta característica da alguna libertad al servicio para cambiar la versión de sus contratos sin interrumpir a los clientes.</span><span class="sxs-lookup"><span data-stu-id="e8165-126">This feature allows the service some latitude in changing the version of its contracts without breaking clients.</span></span> <span data-ttu-id="e8165-127">Las dos secciones siguientes explican los cambios de no interrupción y de interrupción que se pueden realizar en los contratos de servicio y datos de WCF.</span><span class="sxs-lookup"><span data-stu-id="e8165-127">The next two sections explain nonbreaking and breaking changes that can be made to WCF data and service contracts.</span></span>  
  
## <a name="data-contract-versioning"></a><span data-ttu-id="e8165-128">Versiones de contratos de datos</span><span class="sxs-lookup"><span data-stu-id="e8165-128">Data Contract Versioning</span></span>  
 <span data-ttu-id="e8165-129">Esta sección trata de datos que controlan las versiones al utilizar las clases <xref:System.Runtime.Serialization.DataContractSerializer> y <xref:System.Runtime.Serialization.DataContractAttribute>.</span><span class="sxs-lookup"><span data-stu-id="e8165-129">This section deals with data versioning when using the <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.DataContractAttribute> classes.</span></span>  
  
### <a name="strict-versioning"></a><span data-ttu-id="e8165-130">Control estricto de las versiones</span><span class="sxs-lookup"><span data-stu-id="e8165-130">Strict Versioning</span></span>  
 <span data-ttu-id="e8165-131">En muchos escenarios el cambio de versiones es un problema, el programador del servicio no tiene el control sobre los clientes y, por consiguiente, no puede suponer cómo reaccionarían a los cambios en el mensaje XML o esquema.</span><span class="sxs-lookup"><span data-stu-id="e8165-131">In many scenarios when changing versions is an issue, the service developer does not have control over the clients and therefore cannot make assumptions about how they would react to changes in the message XML or schema.</span></span> <span data-ttu-id="e8165-132">En estos casos, debe garantizar que los nuevos mensajes se validarán ante el esquema anterior, por dos razones:</span><span class="sxs-lookup"><span data-stu-id="e8165-132">In these cases, you must guarantee that the new messages will validate against the old schema, for two reasons:</span></span>  
  
- <span data-ttu-id="e8165-133">Los clientes anteriores se desarrollaron suponiendo que el esquema no cambiaría.</span><span class="sxs-lookup"><span data-stu-id="e8165-133">The old clients were developed with the assumption that the schema will not change.</span></span> <span data-ttu-id="e8165-134">No pueden procesar mensajes para los que nunca estuvieron diseñados.</span><span class="sxs-lookup"><span data-stu-id="e8165-134">They may fail to process messages that they were never designed for.</span></span>  
  
- <span data-ttu-id="e8165-135">Los clientes anteriores pueden realizar la validación del esquema real en el esquema anterior antes de intentar, incluso, procesar los mensajes.</span><span class="sxs-lookup"><span data-stu-id="e8165-135">The old clients may perform actual schema validation against the old schema before even attempting to process the messages.</span></span>  
  
 <span data-ttu-id="e8165-136">El enfoque recomendado en tales escenarios es tratar los existentes contratos de datos como inmutables y crear nuevos contratos con nombres completos y únicos en XML.</span><span class="sxs-lookup"><span data-stu-id="e8165-136">The recommended approach in such scenarios is to treat existing data contracts as immutable and create new ones with unique XML qualified names.</span></span> <span data-ttu-id="e8165-137">El programador del servicio agregaría a continuación los nuevos métodos a un contrato de servicios existente o crearía un nuevo contrato de servicios con métodos que utilizan el nuevo contrato de datos.</span><span class="sxs-lookup"><span data-stu-id="e8165-137">The service developer would then either add new methods to an existing service contract or create a new service contract with methods that use the new data contract.</span></span>  
  
 <span data-ttu-id="e8165-138">A menudo se dará el caso de que un programador del servicio necesite escribir alguna lógica empresarial que se debería ejecutar dentro de todas las versiones de un contrato de datos más el código empresarial específico para cada versión del contrato de datos.</span><span class="sxs-lookup"><span data-stu-id="e8165-138">It will often be the case that a service developer needs to write some business logic that should run within all versions of a data contract plus version-specific business code for each version of the data contract.</span></span> <span data-ttu-id="e8165-139">El apéndice que se encuentra al final de este tema explica cómo se pueden utilizar las interfaces para satisfacer esta necesidad.</span><span class="sxs-lookup"><span data-stu-id="e8165-139">The appendix at the end of this topic explains how interfaces can be used to satisfy this need.</span></span>  
  
### <a name="lax-versioning"></a><span data-ttu-id="e8165-140">Control de versiones lax</span><span class="sxs-lookup"><span data-stu-id="e8165-140">Lax Versioning</span></span>  
 <span data-ttu-id="e8165-141">En muchos otros escenarios, el programador del servicio puede suponer que al agregar un nuevo miembro opcional al contrato de datos no se interrumpirán los clientes existentes.</span><span class="sxs-lookup"><span data-stu-id="e8165-141">In many other scenarios, the service developer can make the assumption that adding a new, optional member to the data contract will not break existing clients.</span></span> <span data-ttu-id="e8165-142">Esto exige al programador del servicio que investigue si los clientes existentes no realizan una validación del esquema y que si omiten a los miembros de datos desconocidos.</span><span class="sxs-lookup"><span data-stu-id="e8165-142">This requires the service developer to investigate whether existing clients are not performing schema validation and that they ignore unknown data members.</span></span> <span data-ttu-id="e8165-143">En estos escenarios, es posible aprovecharse de las características del contrato de datos para agregar los nuevos miembros sin interrupción.</span><span class="sxs-lookup"><span data-stu-id="e8165-143">In these scenarios, it is possible to take advantage of data contract features for adding new members in a nonbreaking way.</span></span> <span data-ttu-id="e8165-144">El programador del servicio puede hacer esta suposición con confianza si las características del contrato de datos para controlar las versiones ya se utilizaron para la primera versión del servicio.</span><span class="sxs-lookup"><span data-stu-id="e8165-144">The service developer can make this assumption with confidence if the data contract features for versioning were already used for the first version of the service.</span></span>  
  
 <span data-ttu-id="e8165-145">WCF, ASP.NET Web Services y muchas otras pilas de servicios web admiten el control de versiones *laxo:* es decir, no producen excepciones para los nuevos miembros de datos desconocidos en los datos recibidos.</span><span class="sxs-lookup"><span data-stu-id="e8165-145">WCF, ASP.NET Web Services, and many other Web service stacks support *lax versioning*: that is, they do not throw exceptions for new unknown data members in received data.</span></span>  
  
 <span data-ttu-id="e8165-146">Es fácil creer erróneamente que al agregar un nuevo miembro no se interrumpirán los clientes existentes.</span><span class="sxs-lookup"><span data-stu-id="e8165-146">It is easy to mistakenly believe that adding a new member will not break existing clients.</span></span> <span data-ttu-id="e8165-147">Si no está seguro de que todos los clientes puedan controlar el control lax de versiones, la recomendación es utilizar las instrucciones del control estricto de las versiones y tratar los contratos de datos como inmutables.</span><span class="sxs-lookup"><span data-stu-id="e8165-147">If you are unsure that all clients can handle lax versioning, the recommendation is to use the strict versioning guidelines and treat data contracts as immutable.</span></span>  
  
 <span data-ttu-id="e8165-148">Para obtener instrucciones detalladas para el control de versiones de datos tanto laxos como estrictos, consulte [Prácticas recomendadas: control](best-practices-data-contract-versioning.md)de versiones de contratos de datos .</span><span class="sxs-lookup"><span data-stu-id="e8165-148">For detailed guidelines for both lax and strict versioning of data contracts, see [Best Practices: Data Contract Versioning](best-practices-data-contract-versioning.md).</span></span>  
  
### <a name="distinguishing-between-data-contract-and-net-types"></a><span data-ttu-id="e8165-149">Distinguir entre los tipos de contrato de datos y .NET</span><span class="sxs-lookup"><span data-stu-id="e8165-149">Distinguishing Between Data Contract and .NET Types</span></span>  
 <span data-ttu-id="e8165-150">Una clase o estructura .NET se puede proyectar como un contrato de datos aplicando el atributo <xref:System.Runtime.Serialization.DataContractAttribute> a la clase.</span><span class="sxs-lookup"><span data-stu-id="e8165-150">A .NET class or structure can be projected as a data contract by applying the <xref:System.Runtime.Serialization.DataContractAttribute> attribute to the class.</span></span> <span data-ttu-id="e8165-151">El tipo .NET y sus proyecciones del contrato de datos son dos cuestiones distintas.</span><span class="sxs-lookup"><span data-stu-id="e8165-151">The .NET type and its data contract projections are two distinct matters.</span></span> <span data-ttu-id="e8165-152">Es posible tener varios tipos .NET con la misma proyección del contrato de datos.</span><span class="sxs-lookup"><span data-stu-id="e8165-152">It is possible to have multiple .NET types with the same data contract projection.</span></span> <span data-ttu-id="e8165-153">Esta distinción es especialmente útil para permitirle cambiar el tipo .NET mientras mantiene el contrato de datos proyectado, manteniendo así eso la compatibilidad con clientes existentes en el sentido estricto de la palabra.</span><span class="sxs-lookup"><span data-stu-id="e8165-153">This distinction is especially useful in allowing you to change the .NET type while maintaining the projected data contract, thereby maintaining compatibility with existing clients even in the strict sense of the word.</span></span> <span data-ttu-id="e8165-154">Hay dos cosas que siempre debería hacer para mantener esta distinción entre tipo .NET y contrato de datos:</span><span class="sxs-lookup"><span data-stu-id="e8165-154">There are two things you should always do to maintain this distinction between .NET type and data contract:</span></span>  
  
- <span data-ttu-id="e8165-155">Especifique <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A> y <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A>.</span><span class="sxs-lookup"><span data-stu-id="e8165-155">Specify a <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A> and <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A>.</span></span> <span data-ttu-id="e8165-156">Siempre debería especificar el nombre y espacio de nombres de su contrato de datos para evitar que el nombre y espacio de nombres de su tipo .NET se expongan en el contrato.</span><span class="sxs-lookup"><span data-stu-id="e8165-156">You should always specify the name and namespace of your data contract to prevent your .NET type’s name and namespace from being exposed in the contract.</span></span> <span data-ttu-id="e8165-157">Así, si más tarde decide cambiar el espacio de nombres o nombre de tipo de .NET, el contrato de datos se mantiene invariable.</span><span class="sxs-lookup"><span data-stu-id="e8165-157">This way, if you decide later to change the .NET namespace or type name, your data contract remains the same.</span></span>  
  
- <span data-ttu-id="e8165-158">Especifique <xref:System.Runtime.Serialization.DataMemberAttribute.Name%2A>.</span><span class="sxs-lookup"><span data-stu-id="e8165-158">Specify <xref:System.Runtime.Serialization.DataMemberAttribute.Name%2A>.</span></span> <span data-ttu-id="e8165-159">Siempre debería especificar el nombre de sus miembros de datos para evitar que su nombre de miembro de .NET se exponga en el contrato.</span><span class="sxs-lookup"><span data-stu-id="e8165-159">You should always specify the name of your data members to prevent your .NET member name from being exposed in the contract.</span></span> <span data-ttu-id="e8165-160">Esta manera, si más tarde decide cambiar el nombre de .NET del miembro, su contrato de datos seguirá siendo el mismo.</span><span class="sxs-lookup"><span data-stu-id="e8165-160">This way, if you decide later to change the .NET name of the member, your data contract remains the same.</span></span>  
  
### <a name="changing-or-removing-members"></a><span data-ttu-id="e8165-161">Cambiar o quitar los miembros</span><span class="sxs-lookup"><span data-stu-id="e8165-161">Changing or Removing Members</span></span>  
 <span data-ttu-id="e8165-162">Cambiar el nombre o el tipo de datos de un miembro, o quitar los miembros de datos se considera un cambio con interrupción, aun cuando se permite un control poco estricto de las versiones.</span><span class="sxs-lookup"><span data-stu-id="e8165-162">Changing the name or data type of a member, or removing data members is a breaking change even if lax versioning is allowed.</span></span> <span data-ttu-id="e8165-163">Si es necesario, cree un nuevo contrato de datos.</span><span class="sxs-lookup"><span data-stu-id="e8165-163">If this is necessary, create a new data contract.</span></span>  
  
 <span data-ttu-id="e8165-164">Si la compatibilidad del servicio es de importancia elevada, podría considerar omitir los miembros de datos no usados en su código y dejarlos en su lugar.</span><span class="sxs-lookup"><span data-stu-id="e8165-164">If service compatibility is of high importance, you might consider ignoring unused data members in your code and leave them in place.</span></span> <span data-ttu-id="e8165-165">Si se divide un miembro de datos en varios miembros, se podría optar por dejar el miembro existente como una propiedad que pueda realizar la división necesaria y volver a agregar los clientes de nivel inferior (clientes que no se han actualizado a la última versión).</span><span class="sxs-lookup"><span data-stu-id="e8165-165">If you are splitting up a data member into multiple members, you might consider leaving the existing member in place as a property that can perform the required splitting and re-aggregation for down-level clients (clients that are not upgraded to the latest version).</span></span>  
  
 <span data-ttu-id="e8165-166">De igual forma, los cambios realizados al nombre del contrato de datos o al espacio de nombres son cambios con interrupción.</span><span class="sxs-lookup"><span data-stu-id="e8165-166">Similarly, changes to the data contract’s name or namespace are breaking changes.</span></span>  
  
### <a name="round-trips-of-unknown-data"></a><span data-ttu-id="e8165-167">Ida y vuelta de datos desconocidos</span><span class="sxs-lookup"><span data-stu-id="e8165-167">Round-Trips of Unknown Data</span></span>  
 <span data-ttu-id="e8165-168">En algunos escenarios, hay una necesidad de realizar una "ida y vuelta" de datos desconocidos que proceden de los miembros agregados en una nueva versión.</span><span class="sxs-lookup"><span data-stu-id="e8165-168">In some scenarios, there is a need to "round-trip" unknown data that comes from members added in a new version.</span></span> <span data-ttu-id="e8165-169">Por ejemplo, un servicio de "versionNew" envía los datos con algunos miembros agregados recientemente a un cliente de "versionOld".</span><span class="sxs-lookup"><span data-stu-id="e8165-169">For example, a "versionNew" service sends data with some newly added members to a "versionOld" client.</span></span> <span data-ttu-id="e8165-170">El cliente omite los miembros recientemente agregados al procesar el mensaje, pero reenvía esos mismos datos, incluso los miembros agregados recientemente, de vuelta al servicio de versionNew.</span><span class="sxs-lookup"><span data-stu-id="e8165-170">The client ignores the newly added members when processing the message, but it resends that same data, including the newly added members, back to the versionNew service.</span></span> <span data-ttu-id="e8165-171">El escenario típico para esto son las actualizaciones de datos donde los datos se recuperan del servicio, se cambian y se devuelven.</span><span class="sxs-lookup"><span data-stu-id="e8165-171">The typical scenario for this is data updates where data is retrieved from the service, changed, and returned.</span></span>  
  
 <span data-ttu-id="e8165-172">Para habilitar el round-tripping para un tipo determinado, el tipo debe implementar la interfaz <xref:System.Runtime.Serialization.IExtensibleDataObject>.</span><span class="sxs-lookup"><span data-stu-id="e8165-172">To enable round-tripping for a particular type, the type must implement the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface.</span></span> <span data-ttu-id="e8165-173">La interfaz contiene una propiedad, <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A> que devuelve el tipo <xref:System.Runtime.Serialization.ExtensionDataObject>.</span><span class="sxs-lookup"><span data-stu-id="e8165-173">The interface contains one property, <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A> that returns the <xref:System.Runtime.Serialization.ExtensionDataObject> type.</span></span> <span data-ttu-id="e8165-174">La propiedad se utiliza para almacenar cualquier dato de las versiones futuras del contrato de datos que es desconocido para la versión actual.</span><span class="sxs-lookup"><span data-stu-id="e8165-174">The property is used to store any data from future versions of the data contract that is unknown to the current version.</span></span> <span data-ttu-id="e8165-175">Estos datos son opacos para el cliente, pero cuando se serializa la instancia, el contenido de la propiedad <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A> se escribe con el resto de los datos de los miembros del contrato de datos.</span><span class="sxs-lookup"><span data-stu-id="e8165-175">This data is opaque to the client, but when the instance is serialized, the content of the <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A> property is written with the rest of the data contract members' data.</span></span>  
  
 <span data-ttu-id="e8165-176">Se recomienda que todos sus tipos implementen esta interfaz para alojar los nuevos y desconocidos miembros futuros.</span><span class="sxs-lookup"><span data-stu-id="e8165-176">It is recommended that all your types implement this interface to accommodate new and unknown future members.</span></span>  
  
### <a name="data-contract-libraries"></a><span data-ttu-id="e8165-177">Bibliotecas de contratos de datos</span><span class="sxs-lookup"><span data-stu-id="e8165-177">Data Contract Libraries</span></span>  
 <span data-ttu-id="e8165-178">Puede haber bibliotecas de contratos de datos donde un contrato se publica en un repositorio central y el servicio e implementadores de tipo implementan y exponen los contratos de datos de ese repositorio.</span><span class="sxs-lookup"><span data-stu-id="e8165-178">There may be libraries of data contracts where a contract is published to a central repository, and service and type implementers implement and expose data contracts from that repository.</span></span> <span data-ttu-id="e8165-179">En ese caso, al publicar un contrato de datos en el repositorio, no tiene ningún control sobre quién crea tipos que lo implementan.</span><span class="sxs-lookup"><span data-stu-id="e8165-179">In that case, when you publish a data contract to the repository, you have no control over who creates types that implement it.</span></span> <span data-ttu-id="e8165-180">Por lo tanto, no puede modificar el contrato una vez publicado, por lo que se representa inmutable de manera efectiva.</span><span class="sxs-lookup"><span data-stu-id="e8165-180">Thus, you cannot modify the contract once it is published, rendering it effectively immutable.</span></span>  
  
### <a name="when-using-the-xmlserializer"></a><span data-ttu-id="e8165-181">Al utilizar XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="e8165-181">When Using the XmlSerializer</span></span>  
 <span data-ttu-id="e8165-182">Se aplican los mismos principios de control de versiones al utilizar la clase <xref:System.Xml.Serialization.XmlSerializer>.</span><span class="sxs-lookup"><span data-stu-id="e8165-182">The same versioning principles apply when using the <xref:System.Xml.Serialization.XmlSerializer> class.</span></span> <span data-ttu-id="e8165-183">Cuando se requiere la versión estricta se requiere, trata los contratos de datos como inmutables y crea los nuevos contratos de datos con nombres únicos y completos para las nuevas versiones.</span><span class="sxs-lookup"><span data-stu-id="e8165-183">When strict versioning is required, treat data contracts as immutable and create new data contracts with unique, qualified names for the new versions.</span></span> <span data-ttu-id="e8165-184">Al estar seguro de que se puede utilizar el control lax para las versiones, puede agregar los nuevos miembros serializables en las nuevas versiones pero no puede cambiar o quitar los miembros existentes.</span><span class="sxs-lookup"><span data-stu-id="e8165-184">When you are sure that lax versioning can be used, you can add new serializable members in new versions but not change or remove existing members.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="e8165-185"><xref:System.Xml.Serialization.XmlSerializer> utiliza <xref:System.Xml.Serialization.XmlAnyElementAttribute> y los atributos <xref:System.Xml.Serialization.XmlAnyAttributeAttribute> para admitir viajes de ida y vuelta de los datos desconocidos.</span><span class="sxs-lookup"><span data-stu-id="e8165-185">The <xref:System.Xml.Serialization.XmlSerializer> uses the <xref:System.Xml.Serialization.XmlAnyElementAttribute> and <xref:System.Xml.Serialization.XmlAnyAttributeAttribute> attributes to support round-tripping of unknown data.</span></span>  
  
## <a name="message-contract-versioning"></a><span data-ttu-id="e8165-186">Versiones de contratos de mensaje</span><span class="sxs-lookup"><span data-stu-id="e8165-186">Message Contract Versioning</span></span>  
 <span data-ttu-id="e8165-187">Las instrucciones para las versiones de contrato de mensaje son muy similares al control de las versiones de los contratos de datos.</span><span class="sxs-lookup"><span data-stu-id="e8165-187">The guidelines for message contract versioning are very similar to versioning data contracts.</span></span> <span data-ttu-id="e8165-188">Si se requiere el control estricto de las versiones, no debería cambiar el cuerpo de su mensaje pero, en su lugar, debería crear un nuevo contrato de mensaje con un nombre único y completo.</span><span class="sxs-lookup"><span data-stu-id="e8165-188">If strict versioning is required, you should not change your message body but instead create a new message contract with a unique qualified name.</span></span> <span data-ttu-id="e8165-189">Si sabe que puede utilizar el control lax de las versiones, puede agregar nuevas piezas del cuerpo del mensaje pero no puede cambiar o quitar las existentes.</span><span class="sxs-lookup"><span data-stu-id="e8165-189">If you know that you can use lax versioning, you can add new message body parts but not change or remove existing ones.</span></span> <span data-ttu-id="e8165-190">Esta orientación se aplica tanto a los contratos de mensaje sencillos como a los ajustados.</span><span class="sxs-lookup"><span data-stu-id="e8165-190">This guidance applies both to bare and wrapped message contracts.</span></span>  
  
 <span data-ttu-id="e8165-191">Se pueden agregar los encabezados del mensaje siempre, aun cuando el control estricto de versiones esté en uso.</span><span class="sxs-lookup"><span data-stu-id="e8165-191">Message headers can always be added, even if strict versioning is in use.</span></span> <span data-ttu-id="e8165-192">La marca MustUnderstand puede afectar a las versiones.</span><span class="sxs-lookup"><span data-stu-id="e8165-192">The MustUnderstand flag may affect versioning.</span></span> <span data-ttu-id="e8165-193">En general, el modelo de control de versiones para encabezados en WCF es como se describe en la especificación SOAP.</span><span class="sxs-lookup"><span data-stu-id="e8165-193">In general, the versioning model for headers in WCF is as described in the SOAP specification.</span></span>  
  
## <a name="service-contract-versioning"></a><span data-ttu-id="e8165-194">Control de las versiones del contrato de servicios</span><span class="sxs-lookup"><span data-stu-id="e8165-194">Service Contract Versioning</span></span>  
 <span data-ttu-id="e8165-195">De manera parecida al control de las versiones del contrato de datos, el contrato de servicios que también controla las versiones implica agregar, cambiar y quitar operaciones.</span><span class="sxs-lookup"><span data-stu-id="e8165-195">Similar to data contract versioning, service contract versioning also involves adding, changing, and removing operations.</span></span>  
  
### <a name="specifying-name-namespace-and-action"></a><span data-ttu-id="e8165-196">Especificar nombre, espacio de nombres y acción</span><span class="sxs-lookup"><span data-stu-id="e8165-196">Specifying Name, Namespace, and Action</span></span>  
 <span data-ttu-id="e8165-197">De forma predeterminada, el nombre de un contrato de servicios es el nombre de la interfaz.</span><span class="sxs-lookup"><span data-stu-id="e8165-197">By default, the name of a service contract is the name of the interface.</span></span> <span data-ttu-id="e8165-198">Su espacio dehttp://tempuri.orgnombres predeterminado es " ", y la acción de cada operación es "http://tempuri.org/contractname/methodname".</span><span class="sxs-lookup"><span data-stu-id="e8165-198">Its default namespace is "http://tempuri.org", and each operation’s action is "http://tempuri.org/contractname/methodname".</span></span> <span data-ttu-id="e8165-199">Se recomienda especificar explícitamente un nombre y un espacio de nombres para elhttp://tempuri.orgcontrato de servicio y una acción para cada operación para evitar el uso de " " y evitar que los nombres de interfaz y método se expongan en el contrato del servicio.</span><span class="sxs-lookup"><span data-stu-id="e8165-199">It is recommended that you explicitly specify a name and namespace for the service contract, and an action for each operation to avoid using "http://tempuri.org" and to prevent interface and method names from being exposed in the service’s contract.</span></span>  
  
### <a name="adding-parameters-and-operations"></a><span data-ttu-id="e8165-200">Agregar parámetros y operaciones</span><span class="sxs-lookup"><span data-stu-id="e8165-200">Adding Parameters and Operations</span></span>  
 <span data-ttu-id="e8165-201">Agregar operaciones del servicio expuestas por el servicio es un cambio sin interrupción porque los clientes existentes no necesitan ocuparse de esas nuevas operaciones.</span><span class="sxs-lookup"><span data-stu-id="e8165-201">Adding service operations exposed by the service is a nonbreaking change because existing clients need not be concerned about those new operations.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="e8165-202">Agregar las operaciones a un contrato de devolución de llamada dúplex es un cambio con interrupción.</span><span class="sxs-lookup"><span data-stu-id="e8165-202">Adding operations to a duplex callback contract is a breaking change.</span></span>  
  
### <a name="changing-operation-parameter-or-return-types"></a><span data-ttu-id="e8165-203">Cambiar el parámetro de operación o los tipos de valor devuelto</span><span class="sxs-lookup"><span data-stu-id="e8165-203">Changing Operation Parameter or Return Types</span></span>  
 <span data-ttu-id="e8165-204">Cambiar el parámetro o los tipos de valor devuelto generalmente comportan un cambio con interrupción a menos que el nuevo tipo implemente el mismo contrato de datos implementado por el tipo anterior.</span><span class="sxs-lookup"><span data-stu-id="e8165-204">Changing parameter or return types generally is a breaking change unless the new type implements the same data contract implemented by the old type.</span></span> <span data-ttu-id="e8165-205">Para realizar este cambio, agregue una nueva operación al contrato de servicios o defina un nuevo contrato de servicios.</span><span class="sxs-lookup"><span data-stu-id="e8165-205">To make such a change, add a new operation to the service contract or define a new service contract.</span></span>  
  
### <a name="removing-operations"></a><span data-ttu-id="e8165-206">Quitar operaciones</span><span class="sxs-lookup"><span data-stu-id="e8165-206">Removing Operations</span></span>  
 <span data-ttu-id="e8165-207">Quitar las operaciones también es un cambio con interrupción.</span><span class="sxs-lookup"><span data-stu-id="e8165-207">Removing operations is also a breaking change.</span></span> <span data-ttu-id="e8165-208">Para realizar este cambio, defina un nuevo contrato de servicios y expóngalo en un nuevo extremo.</span><span class="sxs-lookup"><span data-stu-id="e8165-208">To make such a change, define a new service contract and expose it on a new endpoint.</span></span>  
  
### <a name="fault-contracts"></a><span data-ttu-id="e8165-209">Contrato de error</span><span class="sxs-lookup"><span data-stu-id="e8165-209">Fault Contracts</span></span>  
 <span data-ttu-id="e8165-210">El atributo <xref:System.ServiceModel.FaultContractAttribute> permite que a un programador del contrato de servicios especifique la información sobre los errores que pueden devolver las operaciones del contrato.</span><span class="sxs-lookup"><span data-stu-id="e8165-210">The <xref:System.ServiceModel.FaultContractAttribute> attribute enables a service contract developer to specify information about faults that can be returned from the contract's operations.</span></span>  
  
 <span data-ttu-id="e8165-211">La lista de errores descrita en el contrato de un servicio no se considera exhaustiva.</span><span class="sxs-lookup"><span data-stu-id="e8165-211">The list of faults described in a service's contract is not considered exhaustive.</span></span> <span data-ttu-id="e8165-212">En cualquier momento, una operación puede devolver errores que no se describen en su contrato.</span><span class="sxs-lookup"><span data-stu-id="e8165-212">At any time, an operation may return faults that are not described in its contract.</span></span> <span data-ttu-id="e8165-213">Cambiar, por consiguiente, el conjunto de errores descrito en el contrato no se considerado como con interrupción.</span><span class="sxs-lookup"><span data-stu-id="e8165-213">Therefore changing the set of faults described in the contract is not considered breaking.</span></span> <span data-ttu-id="e8165-214">Por ejemplo, agregar un nuevo error al contrato utilizando <xref:System.ServiceModel.FaultContractAttribute> o quitando un error existente del contrato.</span><span class="sxs-lookup"><span data-stu-id="e8165-214">For example, adding a new fault to the contract using the <xref:System.ServiceModel.FaultContractAttribute> or removing an existing fault from the contract.</span></span>  
  
### <a name="service-contract-libraries"></a><span data-ttu-id="e8165-215">Bibliotecas de contratos de servicios</span><span class="sxs-lookup"><span data-stu-id="e8165-215">Service Contract Libraries</span></span>  
 <span data-ttu-id="e8165-216">Las organizaciones pueden tener bibliotecas de contratos donde un contrato se publica en un repositorio central y los implementadores de servicio y repositorio implementan los contratos desde ese repositorio.</span><span class="sxs-lookup"><span data-stu-id="e8165-216">Organizations may have libraries of contracts where a contract is published to a central repository and service implementers implement contracts from that repository.</span></span> <span data-ttu-id="e8165-217">En este caso, al publicar un contrato de servicios en el repositorio, no tiene ningún control sobre quién crea servicios que lo implementan.</span><span class="sxs-lookup"><span data-stu-id="e8165-217">In this case, when you publish a service contract to the repository you have no control over who creates services that implement it.</span></span> <span data-ttu-id="e8165-218">Por tanto, no puede modificar el contrato de servicio una vez publicado, por lo que se presenta inmutable de manera efectiva.</span><span class="sxs-lookup"><span data-stu-id="e8165-218">Therefore, you cannot modify the service contract once published, rendering it effectively immutable.</span></span> <span data-ttu-id="e8165-219">WCF admite la herencia de contratos, que se puede usar para crear un nuevo contrato que extiende los contratos existentes.</span><span class="sxs-lookup"><span data-stu-id="e8165-219">WCF supports contract inheritance, which can be used to create a new contract that extends existing contracts.</span></span> <span data-ttu-id="e8165-220">Para utilizar esta característica, defina una nueva interfaz del contrato de servicios que se hereda de la interfaz del contrato de servicios anterior y, a continuación, agregue los métodos a la nueva interfaz.</span><span class="sxs-lookup"><span data-stu-id="e8165-220">To use this feature, define a new service contract interface that inherits from the old service contract interface, then add methods to the new interface.</span></span> <span data-ttu-id="e8165-221">Cambia, a continuación, el servicio que implementa el contrato anterior para implementar el nuevo contrato y cambiar la definición de extremo de "versionOld" para utilizar el nuevo contrato.</span><span class="sxs-lookup"><span data-stu-id="e8165-221">You then change the service that implements the old contract to implement the new contract and change the "versionOld" endpoint definition to use the new contract.</span></span> <span data-ttu-id="e8165-222">Para los clientes de "versionOld", el punto de conexión continuará apareciendo como si se expusiera el contrato de "versionOld"; para los clientes de "versionNew", el punto de conexión aparecerá para exponer el contrato de "versionNew."</span><span class="sxs-lookup"><span data-stu-id="e8165-222">To "versionOld" clients, the endpoint will continue to appear as exposing the "versionOld" contract; to "versionNew" clients, the endpoint will appear to expose the "versionNew" contract.</span></span>  
  
## <a name="address-and-binding-versioning"></a><span data-ttu-id="e8165-223">Dirección y enlace de las versiones</span><span class="sxs-lookup"><span data-stu-id="e8165-223">Address and Binding Versioning</span></span>  
 <span data-ttu-id="e8165-224">Los cambios de la dirección del extremo y enlace son cambios con interrupción a menos que los clientes sean capaces de detectar dinámicamente la nueva dirección del extremo o enlace.</span><span class="sxs-lookup"><span data-stu-id="e8165-224">Changes to endpoint address and binding are breaking changes unless clients are capable of dynamically discovering the new endpoint address or binding.</span></span> <span data-ttu-id="e8165-225">Un mecanismo para implementar esta función consiste en utilizar un registro de la Descripción e integración de la detección universal (UDDI) y el patrón de invocación UDDI donde un cliente intenta comunicar con un punto de conexión y, en cuando se produce un error, consulta los metadatos del punto de conexión actual en un registro de UDDI conocido.</span><span class="sxs-lookup"><span data-stu-id="e8165-225">One mechanism for implementing this capability is by using a Universal Discovery Description and Integration (UDDI) registry and the UDDI Invocation Pattern where a client attempts to communicate with an endpoint and, upon failure, queries a well-known UDDI registry for the current endpoint metadata.</span></span> <span data-ttu-id="e8165-226">El cliente utiliza a continuación la dirección y el enlace desde estos metadatos para comunicarse con el extremo.</span><span class="sxs-lookup"><span data-stu-id="e8165-226">The client then uses the address and binding from this metadata to communicate with the endpoint.</span></span> <span data-ttu-id="e8165-227">Si esta comunicación se realiza con éxito, el cliente almacena en caché la dirección e información de enlace para su uso en el futuro.</span><span class="sxs-lookup"><span data-stu-id="e8165-227">If this communication succeeds, the client caches the address and binding information for future use.</span></span>  
  
## <a name="routing-service-and-versioning"></a><span data-ttu-id="e8165-228">Servicio de enrutamiento y control de versiones</span><span class="sxs-lookup"><span data-stu-id="e8165-228">Routing Service and Versioning</span></span>  
 <span data-ttu-id="e8165-229">Si los cambios realizados en un servicio son cambios importantes y es necesario crear dos o más versiones diferentes de un servicio que se ejecuta simultáneamente, puede utilizar el servicio de enrutamiento de WCF para enrutar los mensajes a la instancia del servicio adecuada.</span><span class="sxs-lookup"><span data-stu-id="e8165-229">If the changes made to a service are breaking changes and you need to have two or more different versions of a service running simultaneously you can use the WCF Routing Service to route messages to the appropriate service instance.</span></span> <span data-ttu-id="e8165-230">El Servicio de enrutamiento de WCF usa enrutamiento basado en el contenido; es decir, usa información contenida en el mensaje para determinar dónde enrutarlo.</span><span class="sxs-lookup"><span data-stu-id="e8165-230">The WCF Routing Service uses content-based routing, in other words, it uses information within the message to determine where to route the message.</span></span> <span data-ttu-id="e8165-231">Para obtener más información sobre el servicio de enrutamiento WCF, vea [Servicio de enrutamiento](./feature-details/routing-service.md).</span><span class="sxs-lookup"><span data-stu-id="e8165-231">For more information about the WCF Routing Service see [Routing Service](./feature-details/routing-service.md).</span></span> <span data-ttu-id="e8165-232">Para obtener un ejemplo de cómo usar el servicio de enrutamiento WCF para el control de versiones de servicio, vea [Cómo: control de versiones](./feature-details/how-to-service-versioning.md)de servicio .</span><span class="sxs-lookup"><span data-stu-id="e8165-232">For an example of how to use the WCF Routing Service for service versioning see [How To: Service Versioning](./feature-details/how-to-service-versioning.md).</span></span>  
  
## <a name="appendix"></a><span data-ttu-id="e8165-233">Apéndice</span><span class="sxs-lookup"><span data-stu-id="e8165-233">Appendix</span></span>  
 <span data-ttu-id="e8165-234">La recomendación general para el control de versiones de los contratos de datos es que cuando se necesite un control estricto de las versiones los contratos de datos se traten como inmutables y crear otros nuevos cuando se requieran cambios.</span><span class="sxs-lookup"><span data-stu-id="e8165-234">The general data contract versioning guidance when strict versioning is needed is to treat data contracts as immutable and create new ones when changes are required.</span></span> <span data-ttu-id="e8165-235">Se necesita crear una nueva clase para cada nuevo contrato de datos, por lo que necesita que un mecanismo evite tener que tomar código existente, que se escribió referido a la clase del contrato de datos antiguo y volverlo a escribir, referido a la nueva clase del contrato de datos.</span><span class="sxs-lookup"><span data-stu-id="e8165-235">A new class needs to be created for each new data contract, so a mechanism is needed to avoid having to take existing code that was written in terms of the old data contract class and rewrite it in terms of the new data contract class.</span></span>  
  
 <span data-ttu-id="e8165-236">Dicho mecanismo se utiliza en interfaces para definir los miembros de cada contrato de datos y escribir el código de implementación interno, referido a las interfaces en lugar de referirse a las clases del contrato de datos que implementan las interfaces.</span><span class="sxs-lookup"><span data-stu-id="e8165-236">One such mechanism is to use interfaces to define the members of each data contract and write internal implementation code in terms of the interfaces rather than the data contract classes that implement the interfaces.</span></span> <span data-ttu-id="e8165-237">El código siguiente para la versión 1 de un servicio muestra una interfaz `IPurchaseOrderV1` y `PurchaseOrderV1`:</span><span class="sxs-lookup"><span data-stu-id="e8165-237">The following code for version 1 of a service shows an `IPurchaseOrderV1` interface and a `PurchaseOrderV1`:</span></span>  
  
```csharp  
public interface IPurchaseOrderV1  
{  
    string OrderId { get; set; }  
    string CustomerId { get; set; }  
}  
  
[DataContract(  
Name = "PurchaseOrder",  
Namespace = "http://examples.microsoft.com/WCF/2005/10/PurchaseOrder")]  
public class PurchaseOrderV1 : IPurchaseOrderV1  
{  
    [DataMember(...)]  
    public string OrderId {...}  
    [DataMember(...)]  
    public string CustomerId {...}  
}  
```  
  
 <span data-ttu-id="e8165-238">Aunque las operaciones del contrato de servicios se escriban referidas a `PurchaseOrderV1`, la lógica empresarial real se referiría a `IPurchaseOrderV1`.</span><span class="sxs-lookup"><span data-stu-id="e8165-238">While the service contract’s operations would be written in terms of `PurchaseOrderV1`, the actual business logic would be in terms of `IPurchaseOrderV1`.</span></span> <span data-ttu-id="e8165-239">En la versión 2 habría, como se muestra a continuación, una nueva interfaz `IPurchaseOrderV2` y una nueva clase `PurchaseOrderV2` en el código siguiente:</span><span class="sxs-lookup"><span data-stu-id="e8165-239">Then, in version 2, there would be a new `IPurchaseOrderV2` interface and a new `PurchaseOrderV2` class as shown in the following code:</span></span>  
  
```csharp
public interface IPurchaseOrderV2  
{  
    DateTime OrderDate { get; set; }  
}

[DataContract(
Name = "PurchaseOrder",  
Namespace = "http://examples.microsoft.com/WCF/2006/02/PurchaseOrder")]  
public class PurchaseOrderV2 : IPurchaseOrderV1, IPurchaseOrderV2  
{  
    [DataMember(...)]  
    public string OrderId {...}  
    [DataMember(...)]  
    public string CustomerId {...}  
    [DataMember(...)]  
    public DateTime OrderDate { ... }  
}  
```  
  
 <span data-ttu-id="e8165-240">El contrato de servicios se actualizaría para incluir las nuevas operaciones que se escriben referidas a `PurchaseOrderV2`.</span><span class="sxs-lookup"><span data-stu-id="e8165-240">The service contract would be updated to include new operations that are written in terms of `PurchaseOrderV2`.</span></span> <span data-ttu-id="e8165-241">La lógica empresarial existente, escrita referida a `IPurchaseOrderV1` seguiría funcionando para `PurchaseOrderV2` y la nueva lógica empresarial que necesita la propiedad `OrderDate` se escribiría referida a `IPurchaseOrderV2`.</span><span class="sxs-lookup"><span data-stu-id="e8165-241">Existing business logic written in terms of `IPurchaseOrderV1` would continue to work for `PurchaseOrderV2` and new business logic that needs the `OrderDate` property would be written in terms of `IPurchaseOrderV2`.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="e8165-242">Consulte también</span><span class="sxs-lookup"><span data-stu-id="e8165-242">See also</span></span>

- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Runtime.Serialization.DataContractAttribute>
- <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A>
- <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A>
- <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A>
- <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A>
- <xref:System.Runtime.Serialization.IExtensibleDataObject>
- <xref:System.Runtime.Serialization.ExtensionDataObject>
- <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A>
- <xref:System.Xml.Serialization.XmlSerializer>
- [<span data-ttu-id="e8165-243">Data Contract Equivalence</span><span class="sxs-lookup"><span data-stu-id="e8165-243">Data Contract Equivalence</span></span>](./feature-details/data-contract-equivalence.md)
- [<span data-ttu-id="e8165-244">Devoluciones de llamadas en la serialización tolerante a versiones</span><span class="sxs-lookup"><span data-stu-id="e8165-244">Version-Tolerant Serialization Callbacks</span></span>](./feature-details/version-tolerant-serialization-callbacks.md)
