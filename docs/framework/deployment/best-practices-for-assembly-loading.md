---
title: Procedimientos recomendados para cargar ensamblados
description: Explore los procedimientos recomendados para cargar ensamblados en .NET. Evite problemas de identidad de tipos que pueden conducir a conversiones no válidas, métodos que faltan y otras excepciones.
ms.date: 03/30/2017
helpviewer_keywords:
- assemblies,binding
- LoadFrom method
- default load context
- TypeLoadException class,causes
- assembly loading errors
- load contexts
- assemblies,loading
- LoadWithPartialName method
- load-from context
ms.assetid: 68d1c539-6a47-4614-ab59-4b071c9d4b4c
ms.openlocfilehash: 03d2cacea4d2c0e7452240df30350d93ce79282d
ms.sourcegitcommit: 1e8382d0ce8b5515864f8fbb178b9fd692a7503f
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 09/10/2020
ms.locfileid: "89656150"
---
# <a name="best-practices-for-assembly-loading"></a><span data-ttu-id="870a1-104">Procedimientos recomendados para cargar ensamblados</span><span class="sxs-lookup"><span data-stu-id="870a1-104">Best Practices for Assembly Loading</span></span>
<span data-ttu-id="870a1-105">En este artículo se abordan formas de evitar problemas de identidad de tipos que pueden causar errores como <xref:System.InvalidCastException> o <xref:System.MissingMethodException>, entre otros.</span><span class="sxs-lookup"><span data-stu-id="870a1-105">This article discusses ways to avoid problems of type identity that can lead to <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, and other errors.</span></span> <span data-ttu-id="870a1-106">En él se ofrecen las siguientes recomendaciones:</span><span class="sxs-lookup"><span data-stu-id="870a1-106">The article discusses the following recommendations:</span></span>  
  
- [<span data-ttu-id="870a1-107">Comprenda las ventajas y las desventajas de los contextos de carga</span><span class="sxs-lookup"><span data-stu-id="870a1-107">Understand the advantages and disadvantages of load contexts</span></span>](#load_contexts)  
  
- [<span data-ttu-id="870a1-108">Evite los enlaces en nombres de ensamblado parciales</span><span class="sxs-lookup"><span data-stu-id="870a1-108">Avoid binding on partial assembly names</span></span>](#avoid_partial_names)  
  
- [<span data-ttu-id="870a1-109">Evite la carga de un ensamblado en varios contextos</span><span class="sxs-lookup"><span data-stu-id="870a1-109">Avoid loading an assembly into multiple contexts</span></span>](#avoid_loading_into_multiple_contexts)  
  
- [<span data-ttu-id="870a1-110">Evite la carga de varias versiones de un ensamblado en el mismo contexto</span><span class="sxs-lookup"><span data-stu-id="870a1-110">Avoid loading multiple versions of an assembly into the same context</span></span>](#avoid_loading_multiple_versions)  
  
- [<span data-ttu-id="870a1-111">Considere la posibilidad de cambiar al contexto de carga predeterminado</span><span class="sxs-lookup"><span data-stu-id="870a1-111">Consider switching to the default load context</span></span>](#switch_to_default)  
  
 <span data-ttu-id="870a1-112">La primera recomendación, [comprenda las ventajas y las desventajas de los contextos de carga](#load_contexts), proporciona información general para las demás recomendaciones, ya que todas dependen del conocimiento de los contextos de carga.</span><span class="sxs-lookup"><span data-stu-id="870a1-112">The first recommendation, [understand the advantages and disadvantages of load contexts](#load_contexts), provides background information for the other recommendations, because they all depend on a knowledge of load contexts.</span></span>  
  
<a name="load_contexts"></a>
## <a name="understand-the-advantages-and-disadvantages-of-load-contexts"></a><span data-ttu-id="870a1-113">Comprenda las ventajas y las desventajas de los contextos de carga</span><span class="sxs-lookup"><span data-stu-id="870a1-113">Understand the Advantages and Disadvantages of Load Contexts</span></span>  
 <span data-ttu-id="870a1-114">En un dominio de aplicación, los ensamblados se pueden cargar en uno de entre tres contextos o sin contexto:</span><span class="sxs-lookup"><span data-stu-id="870a1-114">Within an application domain, assemblies can be loaded into one of three contexts, or they can be loaded without context:</span></span>  
  
- <span data-ttu-id="870a1-115">El contexto de carga predeterminado contiene ensamblados que se encuentran al sondear la caché global de ensamblados, el almacén de ensamblado de host si el runtime está hospedado (por ejemplo, en SQL Server) y el <xref:System.AppDomainSetup.ApplicationBase%2A> y <xref:System.AppDomainSetup.PrivateBinPath%2A> del dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="870a1-115">The default load context contains assemblies found by probing the global assembly cache, the host assembly store if the runtime is hosted (for example, in SQL Server), and the <xref:System.AppDomainSetup.ApplicationBase%2A> and <xref:System.AppDomainSetup.PrivateBinPath%2A> of the application domain.</span></span> <span data-ttu-id="870a1-116">La mayoría de las sobrecargas del método <xref:System.Reflection.Assembly.Load%2A> carga ensamblados en este contexto.</span><span class="sxs-lookup"><span data-stu-id="870a1-116">Most overloads of the <xref:System.Reflection.Assembly.Load%2A> method load assemblies into this context.</span></span>  
  
- <span data-ttu-id="870a1-117">El contexto de origen de carga contiene ensamblados que se cargan desde ubicaciones en las que no busca el cargador.</span><span class="sxs-lookup"><span data-stu-id="870a1-117">The load-from context contains assemblies that are loaded from locations that are not searched by the loader.</span></span> <span data-ttu-id="870a1-118">Por ejemplo, los complementos podrían instalarse en un directorio que no esté bajo la ruta de acceso de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="870a1-118">For example, add-ins might be installed in a directory that is not under the application path.</span></span> <span data-ttu-id="870a1-119"><xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>, <xref:System.AppDomain.CreateInstanceFrom%2A?displayProperty=nameWithType> y <xref:System.AppDomain.ExecuteAssembly%2A?displayProperty=nameWithType> son ejemplos de métodos que cargan por ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="870a1-119"><xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>, <xref:System.AppDomain.CreateInstanceFrom%2A?displayProperty=nameWithType>, and <xref:System.AppDomain.ExecuteAssembly%2A?displayProperty=nameWithType> are examples of methods that load by path.</span></span>  
  
- <span data-ttu-id="870a1-120">El contexto de solo reflexión contiene ensamblados cargados con los métodos <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> y <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="870a1-120">The reflection-only context contains assemblies loaded with the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> and <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> methods.</span></span> <span data-ttu-id="870a1-121">No se puede ejecutar código en este contexto, por lo que no se trata aquí.</span><span class="sxs-lookup"><span data-stu-id="870a1-121">Code in this context cannot be executed, so it is not discussed here.</span></span> <span data-ttu-id="870a1-122">Para obtener más información, vea [Cómo: Cargar ensamblados en el contexto de solo reflexión](../reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md).</span><span class="sxs-lookup"><span data-stu-id="870a1-122">For more information, see [How to: Load Assemblies into the Reflection-Only Context](../reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md).</span></span>  
  
- <span data-ttu-id="870a1-123">Si ha generado un ensamblado dinámico transitorio mediante la reflexión de la emisión, el ensamblado no está en ningún contexto.</span><span class="sxs-lookup"><span data-stu-id="870a1-123">If you generated a transient dynamic assembly by using reflection emit, the assembly is not in any context.</span></span> <span data-ttu-id="870a1-124">Además, la mayoría de los ensamblados que se carga mediante el método <xref:System.Reflection.Assembly.LoadFile%2A> lo hace sin contexto, mientras que los ensamblados que se cargan desde matrices de bytes lo hacen sin contexto a menos que su identidad (una vez aplicada la directiva) establezca que están en la caché global de ensamblados.</span><span class="sxs-lookup"><span data-stu-id="870a1-124">In addition, most assemblies that are loaded by using the <xref:System.Reflection.Assembly.LoadFile%2A> method are loaded without context, and assemblies that are loaded from byte arrays are loaded without context unless their identity (after policy is applied) establishes that they are in the global assembly cache.</span></span>  
  
 <span data-ttu-id="870a1-125">Los contextos de ejecución tienen ventajas y desventajas, como se explica en las secciones siguientes.</span><span class="sxs-lookup"><span data-stu-id="870a1-125">The execution contexts have advantages and disadvantages, as discussed in the following sections.</span></span>  
  
### <a name="default-load-context"></a><span data-ttu-id="870a1-126">Contexto de carga predeterminado</span><span class="sxs-lookup"><span data-stu-id="870a1-126">Default Load Context</span></span>  
 <span data-ttu-id="870a1-127">Cuando los ensamblados se cargan en el contexto de carga predeterminado, sus dependencias se cargan automáticamente.</span><span class="sxs-lookup"><span data-stu-id="870a1-127">When assemblies are loaded into the default load context, their dependencies are loaded automatically.</span></span> <span data-ttu-id="870a1-128">Las dependencias que se cargan en el contexto de carga predeterminado se encuentran automáticamente para los ensamblados en el contexto de carga predeterminado o en el contexto de origen de carga.</span><span class="sxs-lookup"><span data-stu-id="870a1-128">Dependencies that are loaded into the default load context are found automatically for assemblies in the default load context or the load-from context.</span></span> <span data-ttu-id="870a1-129">La carga por identidad del ensamblado aumenta la estabilidad de las aplicaciones al garantizar que no se usen versiones desconocidas de ensamblados (vea la sección [Evite los enlaces en nombres de ensamblado parciales](#avoid_partial_names)).</span><span class="sxs-lookup"><span data-stu-id="870a1-129">Loading by assembly identity increases the stability of applications by ensuring that unknown versions of assemblies are not used (see the [Avoid Binding on Partial Assembly Names](#avoid_partial_names) section).</span></span>  
  
 <span data-ttu-id="870a1-130">El empleo del contexto de carga predeterminado tiene las siguientes desventajas:</span><span class="sxs-lookup"><span data-stu-id="870a1-130">Using the default load context has the following disadvantages:</span></span>  
  
- <span data-ttu-id="870a1-131">Las dependencias que se cargan en otros contextos no están disponibles.</span><span class="sxs-lookup"><span data-stu-id="870a1-131">Dependencies that are loaded into other contexts are not available.</span></span>  
  
- <span data-ttu-id="870a1-132">No es posible cargar ensamblados desde ubicaciones situadas fuera de la ruta de acceso de sondeo en el contexto de carga predeterminado.</span><span class="sxs-lookup"><span data-stu-id="870a1-132">You cannot load assemblies from locations outside the probing path into the default load context.</span></span>  
  
### <a name="load-from-context"></a><span data-ttu-id="870a1-133">Contexto de origen de carga</span><span class="sxs-lookup"><span data-stu-id="870a1-133">Load-From Context</span></span>  
 <span data-ttu-id="870a1-134">El contexto de origen de carga permite cargar un ensamblado desde una ruta de acceso que no está en la ruta de acceso de la aplicación y que, por tanto, no está incluida en el sondeo.</span><span class="sxs-lookup"><span data-stu-id="870a1-134">The load-from context lets you load an assembly from a path that is not under the application path, and therefore is not included in probing.</span></span> <span data-ttu-id="870a1-135">Permite encontrar y cargar dependencias desde esa ruta de acceso porque el contexto mantiene la información de la ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="870a1-135">It enables dependencies to be located and loaded from that path, because the path information is maintained by the context.</span></span> <span data-ttu-id="870a1-136">Además, los ensamblados de este contexto pueden usar dependencias que se cargan en el contexto de carga predeterminado.</span><span class="sxs-lookup"><span data-stu-id="870a1-136">In addition, assemblies in this context can use dependencies that are loaded into the default load context.</span></span>  
  
 <span data-ttu-id="870a1-137">La carga de ensamblados mediante el método <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>, o alguno de los demás métodos que cargan por ruta de acceso, tiene las siguientes desventajas:</span><span class="sxs-lookup"><span data-stu-id="870a1-137">Loading assemblies by using the <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> method, or one of the other methods that load by path, has the following disadvantages:</span></span>  
  
- <span data-ttu-id="870a1-138">Si hay un ensamblado con la misma identidad ya cargado en el contexto de origen de carga, <xref:System.Reflection.Assembly.LoadFrom%2A> devuelve el ensamblado cargado aunque se haya especificado otra ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="870a1-138">If an assembly with the same identity is already loaded in the load-from context, <xref:System.Reflection.Assembly.LoadFrom%2A> returns the loaded assembly even if a different path was specified.</span></span>  
  
- <span data-ttu-id="870a1-139">Si se carga un ensamblado con <xref:System.Reflection.Assembly.LoadFrom%2A> y después un ensamblado del contexto de carga predeterminado intenta cargar el mismo ensamblado por nombre para mostrar, se produce un error en el intento de carga.</span><span class="sxs-lookup"><span data-stu-id="870a1-139">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and later an assembly in the default load context tries to load the same assembly by display name, the load attempt fails.</span></span> <span data-ttu-id="870a1-140">Esto puede ocurrir cuando se deserializa un ensamblado.</span><span class="sxs-lookup"><span data-stu-id="870a1-140">This can occur when an assembly is deserialized.</span></span>  
  
- <span data-ttu-id="870a1-141">Si un ensamblado se carga con <xref:System.Reflection.Assembly.LoadFrom%2A> y la ruta de acceso de sondeo incluye un ensamblado con la misma identidad pero en otra ubicación, puede producirse una <xref:System.InvalidCastException>, <xref:System.MissingMethodException> u otro comportamiento inesperado.</span><span class="sxs-lookup"><span data-stu-id="870a1-141">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and the probing path includes an assembly with the same identity but in a different location, an <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, or other unexpected behavior can occur.</span></span>  
  
- <span data-ttu-id="870a1-142"><xref:System.Reflection.Assembly.LoadFrom%2A> exige <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> y <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, o <xref:System.Net.WebPermission>, en la ruta de acceso especificada.</span><span class="sxs-lookup"><span data-stu-id="870a1-142"><xref:System.Reflection.Assembly.LoadFrom%2A> demands <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, or <xref:System.Net.WebPermission>, on the specified path.</span></span>  
  
- <span data-ttu-id="870a1-143">Si existe una imagen nativa del ensamblado, no se usa.</span><span class="sxs-lookup"><span data-stu-id="870a1-143">If a native image exists for the assembly, it is not used.</span></span>  
  
- <span data-ttu-id="870a1-144">No se puede cargar el ensamblado con dominio neutro.</span><span class="sxs-lookup"><span data-stu-id="870a1-144">The assembly cannot be loaded as domain-neutral.</span></span>  
  
- <span data-ttu-id="870a1-145">En las versiones 1.0 y 1.1 de .NET Framework no se aplica la directiva.</span><span class="sxs-lookup"><span data-stu-id="870a1-145">In the .NET Framework versions 1.0 and 1.1, policy is not applied.</span></span>  
  
### <a name="no-context"></a><span data-ttu-id="870a1-146">Sin contexto</span><span class="sxs-lookup"><span data-stu-id="870a1-146">No Context</span></span>  
 <span data-ttu-id="870a1-147">La carga sin contexto es la única opción para los ensamblados transitorios generados con la emisión de la reflexión.</span><span class="sxs-lookup"><span data-stu-id="870a1-147">Loading without context is the only option for transient assemblies that are generated with reflection emit.</span></span> <span data-ttu-id="870a1-148">La carga sin contexto es la única manera de cargar varios ensamblados con la misma identidad en un dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="870a1-148">Loading without context is the only way to load multiple assemblies that have the same identity into one application domain.</span></span> <span data-ttu-id="870a1-149">Se evita el costo del sondeo.</span><span class="sxs-lookup"><span data-stu-id="870a1-149">The cost of probing is avoided.</span></span>  
  
 <span data-ttu-id="870a1-150">Los ensamblados que se cargan desde matrices de bytes lo hacen sin contexto a menos que la identidad del ensamblado, que se establece al aplicar la directiva, coincide con la identidad de un ensamblado de la caché global de ensamblados; en ese caso, el ensamblado se carga desde la caché global de ensamblados.</span><span class="sxs-lookup"><span data-stu-id="870a1-150">Assemblies that are loaded from byte arrays are loaded without context unless the identity of the assembly, which is established when policy is applied, matches the identity of an assembly in the global assembly cache; in that case, the assembly is loaded from the global assembly cache.</span></span>  
  
 <span data-ttu-id="870a1-151">La carga de ensamblados sin contexto presenta las siguientes desventajas:</span><span class="sxs-lookup"><span data-stu-id="870a1-151">Loading assemblies without context has the following disadvantages:</span></span>  
  
- <span data-ttu-id="870a1-152">No es posible enlazar otros ensamblados a ensamblados cargados sin contexto, a menos que controle el evento <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="870a1-152">Other assemblies cannot bind to assemblies that are loaded without context, unless you handle the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event.</span></span>  
  
- <span data-ttu-id="870a1-153">Las dependencias no se cargan automáticamente.</span><span class="sxs-lookup"><span data-stu-id="870a1-153">Dependencies are not loaded automatically.</span></span> <span data-ttu-id="870a1-154">Puede cargarlas previamente sin contexto, cargarlas previamente en el contexto de carga predeterminado o cargarlas mediante el control del evento <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="870a1-154">You can preload them without context, preload them into the default load context, or load them by handling the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event.</span></span>  
  
- <span data-ttu-id="870a1-155">La carga de varios ensamblados con la misma identidad sin contexto puede provocar problemas de identidad de tipos similares a los que produce la carga de ensamblados con la misma identidad en varios contextos.</span><span class="sxs-lookup"><span data-stu-id="870a1-155">Loading multiple assemblies with the same identity without context can cause type identity problems similar to those caused by loading assemblies with the same identity into multiple contexts.</span></span> <span data-ttu-id="870a1-156">Vea [Evite la carga de un ensamblado en varios contextos](#avoid_loading_into_multiple_contexts).</span><span class="sxs-lookup"><span data-stu-id="870a1-156">See [Avoid Loading an Assembly into Multiple Contexts](#avoid_loading_into_multiple_contexts).</span></span>  
  
- <span data-ttu-id="870a1-157">Si existe una imagen nativa del ensamblado, no se usa.</span><span class="sxs-lookup"><span data-stu-id="870a1-157">If a native image exists for the assembly, it is not used.</span></span>  
  
- <span data-ttu-id="870a1-158">No se puede cargar el ensamblado con dominio neutro.</span><span class="sxs-lookup"><span data-stu-id="870a1-158">The assembly cannot be loaded as domain-neutral.</span></span>  
  
- <span data-ttu-id="870a1-159">En las versiones 1.0 y 1.1 de .NET Framework no se aplica la directiva.</span><span class="sxs-lookup"><span data-stu-id="870a1-159">In the .NET Framework versions 1.0 and 1.1, policy is not applied.</span></span>  
  
<a name="avoid_partial_names"></a>
## <a name="avoid-binding-on-partial-assembly-names"></a><span data-ttu-id="870a1-160">Evite los enlaces en nombres de ensamblado parciales</span><span class="sxs-lookup"><span data-stu-id="870a1-160">Avoid Binding on Partial Assembly Names</span></span>  
 <span data-ttu-id="870a1-161">Los enlaces de nombre parcial se producen cuando se especifica solo parte del nombre para mostrar del ensamblado (<xref:System.Reflection.Assembly.FullName%2A>) al cargar un ensamblado.</span><span class="sxs-lookup"><span data-stu-id="870a1-161">Partial name binding occurs when you specify only part of the assembly display name (<xref:System.Reflection.Assembly.FullName%2A>) when you load an assembly.</span></span> <span data-ttu-id="870a1-162">Por ejemplo, puede llamar al método <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> con solo el nombre simple del ensamblado, omitiendo la versión, la referencia cultural y el token de clave pública.</span><span class="sxs-lookup"><span data-stu-id="870a1-162">For example, you might call the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method with only the simple name of the assembly, omitting the version, culture, and public key token.</span></span> <span data-ttu-id="870a1-163">O bien puede llamar al método <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType>, que primero llama al método <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> y, si así no logra encontrar el ensamblado, busca en la caché global de ensamblados y carga la última versión disponible del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="870a1-163">Or you might call the <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType> method, which first calls the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method and, if that fails to locate the assembly, searches the global assembly cache and loads the latest available version of the assembly.</span></span>  
  
 <span data-ttu-id="870a1-164">Los enlaces de nombre parcial pueden producir muchos problemas, incluidos los siguientes:</span><span class="sxs-lookup"><span data-stu-id="870a1-164">Partial name binding can cause many problems, including the following:</span></span>  
  
- <span data-ttu-id="870a1-165">El método <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType> puede cargar otro ensamblado con el mismo nombre simple.</span><span class="sxs-lookup"><span data-stu-id="870a1-165">The <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType> method might load a different assembly with the same simple name.</span></span> <span data-ttu-id="870a1-166">Por ejemplo, dos aplicaciones podrían instalar dos ensamblados completamente diferentes con el nombre simple `GraphicsLibrary` en la caché global de ensamblados.</span><span class="sxs-lookup"><span data-stu-id="870a1-166">For example, two applications might install two completely different assemblies that both have the simple name `GraphicsLibrary` into the global assembly cache.</span></span>  
  
- <span data-ttu-id="870a1-167">El ensamblado cargado realmente podría no ser compatible con versiones anteriores.</span><span class="sxs-lookup"><span data-stu-id="870a1-167">The assembly that is actually loaded might not be backward-compatible.</span></span> <span data-ttu-id="870a1-168">Por ejemplo, si no se especifica la versión, se podría cargar una versión muy posterior a aquella en que se escribiera originalmente el programa.</span><span class="sxs-lookup"><span data-stu-id="870a1-168">For example, not specifying the version might result in the loading of a much later version than the version your program was originally written to use.</span></span> <span data-ttu-id="870a1-169">Los cambios en la versión más reciente podrían provocar errores en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="870a1-169">Changes in the later version might cause errors in your application.</span></span>  
  
- <span data-ttu-id="870a1-170">El ensamblado cargado realmente podría no ser compatible con versiones posteriores.</span><span class="sxs-lookup"><span data-stu-id="870a1-170">The assembly that is actually loaded might not be forward-compatible.</span></span> <span data-ttu-id="870a1-171">Por ejemplo, podría haber compilado y probado la aplicación con la versión más reciente de un ensamblado, pero el enlace parcial podría cargar una versión muy anterior que no tuviera características que usa la aplicación.</span><span class="sxs-lookup"><span data-stu-id="870a1-171">For example, you might have built and tested your application with the latest version of an assembly, but partial binding might load a much earlier version that lacks features your application uses.</span></span>  
  
- <span data-ttu-id="870a1-172">Al instalar nuevas aplicaciones se podrían interrumpir aplicaciones existentes.</span><span class="sxs-lookup"><span data-stu-id="870a1-172">Installing new applications can break existing applications.</span></span> <span data-ttu-id="870a1-173">Una aplicación que usa el método <xref:System.Reflection.Assembly.LoadWithPartialName%2A> puede interrumpirse al instalar una versión no compatible más reciente de un ensamblado compartido.</span><span class="sxs-lookup"><span data-stu-id="870a1-173">An application that uses the <xref:System.Reflection.Assembly.LoadWithPartialName%2A> method can be broken by installing a newer, incompatible version of a shared assembly.</span></span>  
  
- <span data-ttu-id="870a1-174">Se puede producir una carga de dependencias inesperada.</span><span class="sxs-lookup"><span data-stu-id="870a1-174">Unexpected dependency loading can occur.</span></span> <span data-ttu-id="870a1-175">Si carga dos ensamblados que comparten una dependencia, el cargarlos con enlace parcial podría dar lugar a que uno usara un componente con el que no se hubiera compilado ni probado.</span><span class="sxs-lookup"><span data-stu-id="870a1-175">It you load two assemblies that share a dependency, loading them with partial binding might result in one assembly using a component that it was not built or tested with.</span></span>  
  
 <span data-ttu-id="870a1-176">Debido a los problemas que puede ocasionar, el método <xref:System.Reflection.Assembly.LoadWithPartialName%2A> se ha marcado como obsoleto.</span><span class="sxs-lookup"><span data-stu-id="870a1-176">Because of the problems it can cause, the <xref:System.Reflection.Assembly.LoadWithPartialName%2A> method has been marked obsolete.</span></span> <span data-ttu-id="870a1-177">Se recomienda usar el método <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> en su lugar y especificar nombres para mostrar de ensamblado completos.</span><span class="sxs-lookup"><span data-stu-id="870a1-177">We recommend that you use the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method instead, and specify full assembly display names.</span></span> <span data-ttu-id="870a1-178">Vea [Comprenda las ventajas y las desventajas de los contextos de carga](#load_contexts) y [Considere la posibilidad de cambiar al contexto de carga predeterminado](#switch_to_default).</span><span class="sxs-lookup"><span data-stu-id="870a1-178">See [Understand the Advantages and Disadvantages of Load Contexts](#load_contexts) and [Consider Switching to the Default Load Context](#switch_to_default).</span></span>  
  
 <span data-ttu-id="870a1-179">Si quiere usar el método <xref:System.Reflection.Assembly.LoadWithPartialName%2A> porque facilita la carga de ensamblados, tenga en cuenta que un error de la aplicación con un mensaje de error que identifique el ensamblado que falta es probable que proporcione una mejor experiencia de usuario que el empleo automático de una versión desconocida del ensamblado, que podría dar lugar a un comportamiento impredecible y a vulnerabilidades de seguridad.</span><span class="sxs-lookup"><span data-stu-id="870a1-179">If you want to use the <xref:System.Reflection.Assembly.LoadWithPartialName%2A> method because it makes assembly loading easy, consider that having your application fail with an error message that identifies the missing assembly is likely to provide a better user experience than automatically using an unknown version of the assembly, which might cause unpredictable behavior and security holes.</span></span>  
  
<a name="avoid_loading_into_multiple_contexts"></a>
## <a name="avoid-loading-an-assembly-into-multiple-contexts"></a><span data-ttu-id="870a1-180">Evite la carga de un ensamblado en varios contextos</span><span class="sxs-lookup"><span data-stu-id="870a1-180">Avoid Loading an Assembly into Multiple Contexts</span></span>  
 <span data-ttu-id="870a1-181">La carga de un ensamblado en varios contextos puede ocasionar problemas de identidad de tipos.</span><span class="sxs-lookup"><span data-stu-id="870a1-181">Loading an assembly into multiple contexts can cause type identity problems.</span></span> <span data-ttu-id="870a1-182">Si se carga el mismo tipo desde el mismo ensamblado en dos contextos diferentes, es como si se hubieran cargado dos tipos diferentes con el mismo nombre.</span><span class="sxs-lookup"><span data-stu-id="870a1-182">If the same type is loaded from the same assembly into two different contexts, it is as if two different types with the same name had been loaded.</span></span> <span data-ttu-id="870a1-183">Si intenta convertir un tipo en el otro, se produce una <xref:System.InvalidCastException> con el confuso mensaje de que no se puede convertir el tipo `MyType` en el tipo `MyType`.</span><span class="sxs-lookup"><span data-stu-id="870a1-183">An <xref:System.InvalidCastException> is thrown if you try to cast one type to the other, with the confusing message that type `MyType` cannot be cast to type `MyType`.</span></span>  
  
 <span data-ttu-id="870a1-184">Por ejemplo, imagine que se declara la interfaz `ICommunicate` en un ensamblado denominado `Utility` al que hace referencia el programa y, además, otros ensamblados que carga el programa.</span><span class="sxs-lookup"><span data-stu-id="870a1-184">For example, suppose that the `ICommunicate` interface is declared in an assembly named `Utility`, which is referenced by your program and also by other assemblies that your program loads.</span></span> <span data-ttu-id="870a1-185">Estos otros ensamblados contienen tipos que implementan la interfaz `ICommunicate`, lo que permite al programa usarlos.</span><span class="sxs-lookup"><span data-stu-id="870a1-185">These other assemblies contain types that implement the `ICommunicate` interface, allowing your program to use them.</span></span>  
  
 <span data-ttu-id="870a1-186">Ahora imagine qué ocurre al ejecutar el programa.</span><span class="sxs-lookup"><span data-stu-id="870a1-186">Now consider what happens when your program is run.</span></span> <span data-ttu-id="870a1-187">Los ensamblados a los que hace referencia el programa se cargan en el contexto de carga predeterminado.</span><span class="sxs-lookup"><span data-stu-id="870a1-187">Assemblies that are referenced by your program are loaded into the default load context.</span></span> <span data-ttu-id="870a1-188">Si carga un ensamblado de destino por su identidad, con el método <xref:System.Reflection.Assembly.Load%2A>, estará en el contexto de carga predeterminado, igual que sus dependencias.</span><span class="sxs-lookup"><span data-stu-id="870a1-188">If you load a target assembly by its identity, using the <xref:System.Reflection.Assembly.Load%2A> method, it will be in the default load context, and so will its dependencies.</span></span> <span data-ttu-id="870a1-189">Tanto el programa como el ensamblado de destino usarán el mismo ensamblado `Utility`.</span><span class="sxs-lookup"><span data-stu-id="870a1-189">Both your program and the target assembly will use the same `Utility` assembly.</span></span>  
  
 <span data-ttu-id="870a1-190">Pero imagine que carga el ensamblado de destino por su ruta de acceso, con el método <xref:System.Reflection.Assembly.LoadFile%2A>.</span><span class="sxs-lookup"><span data-stu-id="870a1-190">However, suppose you load the target assembly by its file path, using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="870a1-191">El ensamblado se carga sin ningún contexto, así que sus dependencias no se cargan automáticamente.</span><span class="sxs-lookup"><span data-stu-id="870a1-191">The assembly is loaded without any context, so its dependencies are not automatically loaded.</span></span> <span data-ttu-id="870a1-192">Podría tener un controlador para que el evento <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> proporcionara la dependencia y este podría cargar el ensamblado `Utility` sin contexto con el método <xref:System.Reflection.Assembly.LoadFile%2A>.</span><span class="sxs-lookup"><span data-stu-id="870a1-192">You might have a handler for the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event to supply the dependency, and it might load the `Utility` assembly with no context by using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="870a1-193">Al crear una instancia de un tipo incluido en el ensamblado de destino e intentar asignarla a una variable de tipo `ICommunicate`, se produce una <xref:System.InvalidCastException> porque el runtime considera que las interfaces `ICommunicate` de las dos copias del ensamblado `Utility` son tipos distintos.</span><span class="sxs-lookup"><span data-stu-id="870a1-193">Now when you create an instance of a type that is contained in the target assembly and try to assign it to a variable of type `ICommunicate`, an <xref:System.InvalidCastException> is thrown because the runtime considers the `ICommunicate` interfaces in the two copies of the `Utility` assembly to be different types.</span></span>  
  
 <span data-ttu-id="870a1-194">Hay muchos otros escenarios en los que se puede cargar un ensamblado en varios contextos.</span><span class="sxs-lookup"><span data-stu-id="870a1-194">There are many other scenarios in which an assembly can be loaded into multiple contexts.</span></span> <span data-ttu-id="870a1-195">El mejor enfoque es evitar los conflictos mediante la reubicación del ensamblado de destino en la ruta de acceso de la aplicación y el empleo del método <xref:System.Reflection.Assembly.Load%2A> con el nombre para mostrar completo.</span><span class="sxs-lookup"><span data-stu-id="870a1-195">The best approach is to avoid conflicts by relocating the target assembly in your application path and using the <xref:System.Reflection.Assembly.Load%2A> method with the full display name.</span></span> <span data-ttu-id="870a1-196">Luego se carga el ensamblado en el contexto de carga predeterminado y ambos ensamblados usan el mismo ensamblado `Utility`.</span><span class="sxs-lookup"><span data-stu-id="870a1-196">The assembly is then loaded into the default load context, and both assemblies use the same `Utility` assembly.</span></span>  
  
 <span data-ttu-id="870a1-197">Si el ensamblado de destino debe permanecer fuera de la ruta de acceso de la aplicación, puede usar el método <xref:System.Reflection.Assembly.LoadFrom%2A> para cargarlo en el contexto de origen de carga.</span><span class="sxs-lookup"><span data-stu-id="870a1-197">If the target assembly must remain outside your application path, you can use the <xref:System.Reflection.Assembly.LoadFrom%2A> method to load it into the load-from context.</span></span> <span data-ttu-id="870a1-198">Si el ensamblado de destino se ha compilado con una referencia al ensamblado `Utility` de la aplicación, usará el ensamblado `Utility` que la aplicación haya cargado en el contexto de carga predeterminado.</span><span class="sxs-lookup"><span data-stu-id="870a1-198">If the target assembly was compiled with a reference to your application's `Utility` assembly, it will use the `Utility` assembly that your application has loaded into the default load context.</span></span> <span data-ttu-id="870a1-199">Tenga en cuenta que pueden producirse problemas si el ensamblado de destino tiene una dependencia en una copia del ensamblado `Utility` ubicado fuera de la ruta de acceso de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="870a1-199">Note that problems can occur if the target assembly has a dependency on a copy of the `Utility` assembly located outside your application path.</span></span> <span data-ttu-id="870a1-200">Si se carga ese ensamblado en el contexto de origen de carga antes de que la aplicación cargue el ensamblado `Utility`, se produce un error en la carga de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="870a1-200">If that assembly is loaded into the load-from context before your application loads the `Utility` assembly, your application's load will fail.</span></span>  
  
 <span data-ttu-id="870a1-201">En la sección [Considere la posibilidad de cambiar al contexto de carga predeterminado](#switch_to_default) se explican alternativas al uso de cargas de ruta de acceso de archivo como <xref:System.Reflection.Assembly.LoadFile%2A> y <xref:System.Reflection.Assembly.LoadFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="870a1-201">The [Consider Switching to the Default Load Context](#switch_to_default) section discusses alternatives to using file path loads such as <xref:System.Reflection.Assembly.LoadFile%2A> and <xref:System.Reflection.Assembly.LoadFrom%2A>.</span></span>  
  
<a name="avoid_loading_multiple_versions"></a>
## <a name="avoid-loading-multiple-versions-of-an-assembly-into-the-same-context"></a><span data-ttu-id="870a1-202">Evite la carga de varias versiones de un ensamblado en el mismo contexto</span><span class="sxs-lookup"><span data-stu-id="870a1-202">Avoid Loading Multiple Versions of an Assembly into the Same Context</span></span>  
 <span data-ttu-id="870a1-203">La carga de varias versiones de un ensamblado en un contexto de carga puede producir problemas de identidad de tipos.</span><span class="sxs-lookup"><span data-stu-id="870a1-203">Loading multiple versions of an assembly into one load context can cause type identity problems.</span></span> <span data-ttu-id="870a1-204">Si se carga el mismo tipo desde dos versiones del mismo ensamblado, es como si se hubieran cargado dos tipos diferentes con el mismo nombre.</span><span class="sxs-lookup"><span data-stu-id="870a1-204">If the same type is loaded from two versions of the same assembly, it is as if two different types with the same name had been loaded.</span></span> <span data-ttu-id="870a1-205">Si intenta convertir un tipo en el otro, se produce una <xref:System.InvalidCastException> con el confuso mensaje de que no se puede convertir el tipo `MyType` en el tipo `MyType`.</span><span class="sxs-lookup"><span data-stu-id="870a1-205">An <xref:System.InvalidCastException> is thrown if you try to cast one type to the other, with the confusing message that type `MyType` cannot be cast to type `MyType`.</span></span>  
  
 <span data-ttu-id="870a1-206">Por ejemplo, el programa podría cargar una versión del ensamblado `Utility` directamente y luego podría cargar otro ensamblado que cargara una versión diferente del ensamblado `Utility`.</span><span class="sxs-lookup"><span data-stu-id="870a1-206">For example, your program might load one version of the `Utility` assembly directly, and later it might load another assembly that loads a different version of the `Utility` assembly.</span></span> <span data-ttu-id="870a1-207">O bien un error de codificación podría hacer que dos rutas de acceso de código diferentes de la aplicación cargaran versiones distintas de un ensamblado.</span><span class="sxs-lookup"><span data-stu-id="870a1-207">Or a coding error might cause two different code paths in your application to load different versions of an assembly.</span></span>  
  
 <span data-ttu-id="870a1-208">En el contexto de carga predeterminado, este problema puede producirse cuando se usa el método <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> y se especifican nombres para mostrar de ensamblado completos que incluyen números de versión diferentes.</span><span class="sxs-lookup"><span data-stu-id="870a1-208">In the default load context, this problem can occur when you use the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method and specify complete assembly display names that include different version numbers.</span></span> <span data-ttu-id="870a1-209">En el caso de los ensamblados que se cargan sin contexto, el problema puede deberse al uso del método <xref:System.Reflection.Assembly.LoadFile%2A?displayProperty=nameWithType> para cargar el mismo ensamblado desde rutas de acceso diferentes.</span><span class="sxs-lookup"><span data-stu-id="870a1-209">For assemblies that are loaded without context, the problem can be caused by using the <xref:System.Reflection.Assembly.LoadFile%2A?displayProperty=nameWithType> method to load the same assembly from different paths.</span></span> <span data-ttu-id="870a1-210">El runtime considera que dos ensamblados que se cargan desde rutas de acceso diferentes son ensamblados distintos, aunque sus identidades sean iguales.</span><span class="sxs-lookup"><span data-stu-id="870a1-210">The runtime considers two assemblies that are loaded from different paths to be different assemblies, even if their identities are the same.</span></span>  
  
 <span data-ttu-id="870a1-211">Además de los problemas de identidad de tipos, varias versiones de un ensamblado pueden producir una <xref:System.MissingMethodException> si un tipo cargado desde una versión del ensamblado se pasa a código que espera ese tipo desde otra versión.</span><span class="sxs-lookup"><span data-stu-id="870a1-211">In addition to type identity problems, multiple versions of an assembly can cause a <xref:System.MissingMethodException> if a type that is loaded from one version of the assembly is passed to code that expects that type from a different version.</span></span> <span data-ttu-id="870a1-212">Por ejemplo, el código podría esperar un método que se ha agregado a la versión más reciente.</span><span class="sxs-lookup"><span data-stu-id="870a1-212">For example, the code might expect a method that was added to the later version.</span></span>  
  
 <span data-ttu-id="870a1-213">Si el comportamiento del tipo ha cambiado entre versiones, se pueden producir errores más sutiles.</span><span class="sxs-lookup"><span data-stu-id="870a1-213">More subtle errors can occur if the behavior of the type changed between versions.</span></span> <span data-ttu-id="870a1-214">Por ejemplo, un método podría producir una excepción imprevista o devolver un valor inesperado.</span><span class="sxs-lookup"><span data-stu-id="870a1-214">For example, a method might throw an unexpected exception or return an unexpected value.</span></span>  
  
 <span data-ttu-id="870a1-215">Revise el código atentamente para garantizar que solo se cargue una versión de un ensamblado.</span><span class="sxs-lookup"><span data-stu-id="870a1-215">Carefully review your code to ensure that only one version of an assembly is loaded.</span></span> <span data-ttu-id="870a1-216">Puede usar el método <xref:System.AppDomain.GetAssemblies%2A?displayProperty=nameWithType> para determinar qué ensamblados se cargan en un momento dado.</span><span class="sxs-lookup"><span data-stu-id="870a1-216">You can use the <xref:System.AppDomain.GetAssemblies%2A?displayProperty=nameWithType> method to determine which assemblies are loaded at any given time.</span></span>  
  
<a name="switch_to_default"></a>
## <a name="consider-switching-to-the-default-load-context"></a><span data-ttu-id="870a1-217">Considere la posibilidad de cambiar al contexto de carga predeterminado</span><span class="sxs-lookup"><span data-stu-id="870a1-217">Consider Switching to the Default Load Context</span></span>  
 <span data-ttu-id="870a1-218">Examine los patrones de carga e implementación de ensamblados de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="870a1-218">Examine your application's assembly loading and deployment patterns.</span></span> <span data-ttu-id="870a1-219">¿Puede eliminar ensamblados cargados desde matrices de bytes?</span><span class="sxs-lookup"><span data-stu-id="870a1-219">Can you eliminate assemblies that are loaded from byte arrays?</span></span> <span data-ttu-id="870a1-220">¿Puede mover ensamblados a la ruta de acceso de sondeo?</span><span class="sxs-lookup"><span data-stu-id="870a1-220">Can you move assemblies into the probing path?</span></span> <span data-ttu-id="870a1-221">Si los ensamblados se encuentran en la caché global de ensamblados o en la ruta de acceso de sondeo del dominio de la aplicación (es decir, su <xref:System.AppDomainSetup.ApplicationBase%2A> y <xref:System.AppDomainSetup.PrivateBinPath%2A>), puede cargar el ensamblado por su identidad.</span><span class="sxs-lookup"><span data-stu-id="870a1-221">If assemblies are located in the global assembly cache or in the application domain's probing path (that is, its <xref:System.AppDomainSetup.ApplicationBase%2A> and <xref:System.AppDomainSetup.PrivateBinPath%2A>), you can load the assembly by its identity.</span></span>  
  
 <span data-ttu-id="870a1-222">Si no es posible colocar todos los ensamblados en la ruta de acceso de sondeo, considere alternativas como usar el modelo de complementos de .NET Framework, colocar los ensamblados en la caché global de ensamblados o crear dominios de aplicación.</span><span class="sxs-lookup"><span data-stu-id="870a1-222">If it is not possible to put all your assemblies in the probing path, consider alternatives such as using the .NET Framework add-in model, placing assemblies into the global assembly cache, or creating application domains.</span></span>  
  
### <a name="consider-using-the-net-framework-add-in-model"></a><span data-ttu-id="870a1-223">Considere la posibilidad de usar el modelo de complementos de .NET Framework</span><span class="sxs-lookup"><span data-stu-id="870a1-223">Consider Using the .NET Framework Add-In Model</span></span>  
 <span data-ttu-id="870a1-224">Si está usando el contexto de origen de carga para implementar complementos, que normalmente no están instalados en la base de la aplicación, use el modelo de complementos de .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="870a1-224">If you are using the load-from context to implement add-ins, which typically are not installed in the application base, use the .NET Framework add-in model.</span></span> <span data-ttu-id="870a1-225">Este modelo proporciona aislamiento en el nivel del proceso o el dominio de la aplicación sin exigirle que administre los dominios de aplicación usted mismo.</span><span class="sxs-lookup"><span data-stu-id="870a1-225">This model provides isolation at the application domain or process level, without requiring you to manage application domains yourself.</span></span> <span data-ttu-id="870a1-226">Para más información sobre el modelo de complementos, vea [Complementos y extensibilidad](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100)).</span><span class="sxs-lookup"><span data-stu-id="870a1-226">For information about the add-in model, see [Add-ins and Extensibility](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100)).</span></span>  
  
### <a name="consider-using-the-global-assembly-cache"></a><span data-ttu-id="870a1-227">Considere la posibilidad de usar la caché global de ensamblados</span><span class="sxs-lookup"><span data-stu-id="870a1-227">Consider Using the Global Assembly Cache</span></span>  
 <span data-ttu-id="870a1-228">Coloque los ensamblados en la caché global de ensamblados para beneficiarse de una ruta de acceso de ensamblado compartida que esté fuera de la base de la aplicación, sin perder las ventajas del contexto de carga predeterminado ni asumir las desventajas de los otros contextos.</span><span class="sxs-lookup"><span data-stu-id="870a1-228">Place assemblies in the global assembly cache to get the benefit of a shared assembly path that is outside the application base, without losing the advantages of the default load context or taking on the disadvantages of the other contexts.</span></span>  
  
### <a name="consider-using-application-domains"></a><span data-ttu-id="870a1-229">Considere la posibilidad de usar dominios de aplicación</span><span class="sxs-lookup"><span data-stu-id="870a1-229">Consider Using Application Domains</span></span>  
 <span data-ttu-id="870a1-230">Si determina que algunos de los ensamblados no se pueden implementar en la ruta de acceso de sondeo de la aplicación, considere la posibilidad de crear un nuevo dominio de aplicación para esos ensamblados.</span><span class="sxs-lookup"><span data-stu-id="870a1-230">If you determine that some of your assemblies cannot be deployed in the application's probing path, consider creating a new application domain for those assemblies.</span></span> <span data-ttu-id="870a1-231">Use un <xref:System.AppDomainSetup> para crear el nuevo dominio de aplicación y la propiedad <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType> para especificar la ruta de acceso que contiene los ensamblados que quiere cargar.</span><span class="sxs-lookup"><span data-stu-id="870a1-231">Use an <xref:System.AppDomainSetup> to create the new application domain, and use the <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType> property to specify the path that contains the assemblies you want to load.</span></span> <span data-ttu-id="870a1-232">Si tiene varios directorios para sondear, puede establecer <xref:System.AppDomainSetup.ApplicationBase%2A> en un directorio raíz y usar la propiedad <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType> para identificar los subdirectorios de sondeo.</span><span class="sxs-lookup"><span data-stu-id="870a1-232">If you have multiple directories to probe, you can set the <xref:System.AppDomainSetup.ApplicationBase%2A> to a root directory and use the <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType> property to identify the subdirectories to probe.</span></span> <span data-ttu-id="870a1-233">Como alternativa, puede crear varios dominios de aplicación y establecer la <xref:System.AppDomainSetup.ApplicationBase%2A> de cada dominio de aplicación en la ruta de acceso adecuada para sus ensamblados.</span><span class="sxs-lookup"><span data-stu-id="870a1-233">Alternatively, you can create multiple application domains and set the <xref:System.AppDomainSetup.ApplicationBase%2A> of each application domain to the appropriate path for its assemblies.</span></span>  
  
 <span data-ttu-id="870a1-234">Tenga en cuenta que puede usar el método <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> para cargar estos ensamblados.</span><span class="sxs-lookup"><span data-stu-id="870a1-234">Note that you can use the <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> method to load these assemblies.</span></span> <span data-ttu-id="870a1-235">Dado que ahora se encuentran en la ruta de acceso de sondeo, se cargarán en el contexto de carga predeterminado en lugar de hacerlo en el contexto de origen de carga.</span><span class="sxs-lookup"><span data-stu-id="870a1-235">Because they are now in the probing path, they will be loaded into the default load context instead of the load-from context.</span></span> <span data-ttu-id="870a1-236">Pero se recomienda cambiar al método <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> y proporcionar nombres para mostrar de ensamblado completos para asegurarse de que siempre se usen versiones correctas.</span><span class="sxs-lookup"><span data-stu-id="870a1-236">However, we recommend that you switch to the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method and supply full assembly display names to ensure that correct versions are always used.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="870a1-237">Vea también</span><span class="sxs-lookup"><span data-stu-id="870a1-237">See also</span></span>

- <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>
- <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>
- <xref:System.Reflection.Assembly.LoadFile%2A?displayProperty=nameWithType>
- <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>
