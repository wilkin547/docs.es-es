---
title: Metadatos de las propiedades de dependencia
ms.date: 03/30/2017
helpviewer_keywords:
- APIs [WPF], metadata
- dependency properties [WPF], metadata
- metadata [WPF], for dependency properties
- overriding metadata [WPF]
ms.assetid: d01ed009-b722-41bf-b82f-fe1a8cdc50dd
ms.openlocfilehash: fc50f50d499f64d7838c2148e39c423d491a7dbe
ms.sourcegitcommit: 6b308cf6d627d78ee36dbbae8972a310ac7fd6c8
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 01/23/2019
ms.locfileid: "54507286"
---
# <a name="dependency-property-metadata"></a>Metadatos de las propiedades de dependencia
El sistema de propiedades de [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] incluye un sistema de informe de metadatos que va más allá de lo que puede notificarse sobre una propiedad mediante la reflexión o las características generales de [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)]. Los metadatos de una propiedad de dependencia también los puede asignar de manera exclusiva la clase que define una propiedad de dependencia, se pueden cambiar cuando la propiedad de dependencia se agrega a una clase diferente y los pueden invalidar específicamente todas las clases derivadas que heredan la propiedad de dependencia de la clase base de definición.  
  
 
  
<a name="prerequisites"></a>   
## <a name="prerequisites"></a>Requisitos previos  
 En este tema, se supone que entiende las propiedades de dependencia desde la perspectiva de un consumidor de propiedades de dependencia existentes en las clases [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] y que ha leído [Información general sobre las propiedades de dependencia](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md). Para seguir los ejemplos de este tema, también debe comprender el lenguaje [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] y saber cómo escribir aplicaciones de [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].  
  
<a name="dp_metadata_contents"></a>   
## <a name="how-dependency-property-metadata-is-used"></a>Uso de los metadatos de las propiedades de dependencia  
 Los metadatos de las propiedades de dependencia existen como un objeto que se puede consultar para examinar las características de una propiedad de dependencia. El sistema de propiedades también accede con frecuencia a estos metadatos mientras procesa cualquier propiedad de dependencia determinada. El objeto de metadatos de una propiedad de dependencia puede contener los siguientes tipos de información:  
  
-   Valor predeterminado de la propiedad de dependencia, si no se puede determinar ningún otro valor para la propiedad de dependencia por valor local, estilo, herencia, etc. Para ver un análisis detallado de cómo participan los valores predeterminados en la precedencia que usa el sistema de propiedades al asignar valores de propiedades de dependencia, consulte [Prioridad de los valores de propiedades de dependencia](../../../../docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
-   Referencias a las implementaciones de devoluciones de llamada que afectan a los comportamientos de coerción o notificación de cambios por tipo de propietario. Tenga en cuenta que estas devoluciones de llamada se definen a menudo con un nivel de acceso no público, de modo que obtener las referencias reales de los metadatos no suele ser posible a menos que estén dentro de su ámbito de acceso permitido. Para obtener más información sobre las devoluciones de llamada de propiedades de dependencia, consulte [Devoluciones de llamada y validación de las propiedades de dependencia](../../../../docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
-   Si la propiedad de dependencia en cuestión se considera una propiedad del nivel de marco de WPF, los metadatos podrían contener características de propiedades de dependencia del nivel de marco de WPF, que comunican los datos y el estado de los servicios, tales como la lógica de herencia de propiedades y el motor de diseño del nivel de marco de WPF. Para obtener más información sobre este aspecto de los metadatos de propiedades de dependencia, consulte [Metadatos de las propiedades de marco de trabajo](../../../../docs/framework/wpf/advanced/framework-property-metadata.md).  
  
<a name="APIs"></a>   
## <a name="metadata-apis"></a>API de metadatos  
 El tipo que notifica la mayor parte de la información de metadatos utilizada por el sistema de propiedades es el <xref:System.Windows.PropertyMetadata> clase. Las instancias de metadatos se especifican de manera opcional cuando las propiedades de dependencia se registran con el sistema de propiedades y pueden especificarse de nuevo para tipos adicionales que se agreguen a sí mismos como propietarios o invaliden los metadatos que heredan de la definición de propiedad de dependencia de clase base. (En los casos donde un registro de la propiedad no especifica metadatos, el valor predeterminado es <xref:System.Windows.PropertyMetadata> se crea con los valores predeterminados para esa clase.) Los metadatos registrados se devuelven como <xref:System.Windows.PropertyMetadata> al llamar a las diversas <xref:System.Windows.DependencyProperty.GetMetadata%2A> sobrecargas que obtienen metadatos de una propiedad de dependencia en un <xref:System.Windows.DependencyObject> instancia.  
  
 La <xref:System.Windows.PropertyMetadata> clase se deriva, a continuación, para proporcionar metadatos más específicos para divisiones arquitectónicas tales como las clases de nivel de marco WPF. <xref:System.Windows.UIPropertyMetadata> informes de animación, se agrega y <xref:System.Windows.FrameworkPropertyMetadata> proporciona las propiedades de nivel de marco WPF mencionadas en la sección anterior. Cuando se registran las propiedades de dependencia, pueden registrarse con estos <xref:System.Windows.PropertyMetadata> las clases derivadas. Cuando se examinan los metadatos, la base <xref:System.Windows.PropertyMetadata> tipo potencialmente se puede convertir en las clases derivadas para que puedan examinar las propiedades más específicas.  
  
> [!NOTE]
>  Las características de la propiedad que se pueden especificar en <xref:System.Windows.FrameworkPropertyMetadata> se conocen a veces en esta documentación como "marcadores". Al crear nuevas instancias de metadatos para su uso en la dependencia de los registros de la propiedad o invalidaciones de metadatos, especifique estos valores mediante la enumeración basada en marcas <xref:System.Windows.FrameworkPropertyMetadataOptions> y, a continuación, se suministra valores concatenados, posiblemente, de la enumeración a la <xref:System.Windows.FrameworkPropertyMetadata> constructor. Sin embargo, una vez construidos, estas características de opción se exponen dentro de un <xref:System.Windows.FrameworkPropertyMetadata> como una serie de propiedades booleanas en lugar del valor de enumeración de construcción. Las propiedades booleanas permiten comprobar cada condicional, en lugar de exigir que aplique una máscara a un valor de enumeración basada en marcas para obtener la información que le interesa. El constructor usa concatenadas <xref:System.Windows.FrameworkPropertyMetadataOptions> con el fin de mantener la longitud de la firma del constructor razonable, mientras que los metadatos construidos reales exponen las propiedades discretas para simplificar las consultas de los metadatos más intuitivo.  
  
<a name="override_or_subclass"></a>   
## <a name="when-to-override-metadata-when-to-derive-a-class"></a>Cuándo invalidar metadatos y cuándo derivar una clase  
 El sistema de propiedades de [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] tiene funcionalidades establecidas para modificar algunas características de las propiedades de dependencia sin necesidad de volver a implementarlas completamente. Esto se logra construyendo una instancia diferente de los metadatos de la propiedad de dependencia tal como existe en un tipo determinado. Tenga en cuenta que la mayoría de las propiedades de dependencia existentes no son propiedades virtuales, de modo que, en el sentido estricto, su "reimplementación" en clases heredadas solo se puede lograr mediante el sombreado del miembro existente.  
  
 Si el escenario que intenta habilitar para una propiedad de dependencia en un tipo no se puede lograr con la modificación de las características de las propiedades de dependencia existentes, podría ser necesario crear una clase derivada y, después, declarar una propiedad de dependencia personalizada en su clase derivada. Una propiedad de dependencia personalizada se comporta igual que las propiedades de dependencia que definen las [!INCLUDE[TLA#tla_api#plural](../../../../includes/tlasharptla-apisharpplural-md.md)] de [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]. Para obtener más información acerca de las propiedades de dependencia personalizadas, consulte [Propiedades de dependencia personalizadas](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md).  
  
 Una característica importante de una propiedad de dependencia que no se puede invalidar es su tipo de valor. Si hereda una propiedad de dependencia que tiene el comportamiento aproximado que necesita, pero necesita que tenga un tipo diferente, tendrá que implementar una propiedad de dependencia personalizada y, posiblemente, vincular las propiedades mediante la conversión de tipos u otra implementación en la clase personalizada. Además, no se puede reemplazar una existente <xref:System.Windows.ValidateValueCallback>, porque esta devolución de llamada existe en el propio campo de registro y no dentro de sus metadatos.  
  
<a name="scenarios"></a>   
## <a name="scenarios-for-changing-existing-metadata"></a>Escenarios para modificar los metadatos existentes  
 Si está trabajando con los metadatos de una propiedad de dependencia existente, un escenario común para cambiar dichos metadatos es cambiar el valor predeterminado. Cambiar o agregar devoluciones de llamada del sistema de propiedades es un escenario más avanzado. Es posible que quiera hacerlo si su implementación de una clase derivada tiene diferentes interrelaciones entre las propiedades de dependencia. Uno de los condicionales de tener un modelo de programación que admita tanto el uso declarativo como de código es que las propiedades deben poder establecerse en cualquier orden. Por lo tanto, las propiedades dependientes deben establecerse Just-in-Time sin contexto y no pueden depender de saber un orden de configuración como podría darse en un constructor. Para obtener más información sobre este aspecto del sistema de propiedades, consulte [Devoluciones de llamada y validación de las propiedades de dependencia](../../../../docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md). Tenga en cuenta que las devoluciones de llamada de validación no forman parte de los metadatos, sino del identificador de la propiedad de dependencia. Por lo tanto, las devoluciones de llamada de validación no se pueden cambiar mediante la invalidación de los metadatos.  
  
 Es posible que en algunos casos también quiera modificar las opciones de metadatos de la propiedad del nivel de marco de WPF en las propiedades de dependencia existente. Estas opciones comunican determinados condicionales conocidos acerca de las propiedades del nivel de marco de WPF a otros procesos del nivel de marco de WPF, como el sistema de diseño.  Configuración de las opciones se realiza por lo general solo al registrar una nueva propiedad de dependencia, pero también es posible cambiar los metadatos de propiedad de nivel de marco WPF como parte de un <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> o <xref:System.Windows.DependencyProperty.AddOwner%2A> llamar. Para obtener los valores específicos que se van a usar y otros datos, consulte [Metadatos de las propiedades de marco de trabajo](../../../../docs/framework/wpf/advanced/framework-property-metadata.md). Para obtener más información relativa a cómo deben establecerse estas opciones para una propiedad de dependencia recién registrada, consulte [Propiedades de dependencia personalizadas](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md).  
  
<a name="dp_override_metadata"></a>   
### <a name="overriding-metadata"></a>Invalidar metadatos  
 El propósito de invalidar metadatos es principalmente que tenga la oportunidad de cambiar los distintos comportamientos derivados de metadatos que se aplican a la propiedad de dependencia tal como existe en el tipo. Las razones para ello se explican con más detalle en la sección [Metadatos](#dp_metadata_contents). Para obtener más información, incluidos algunos ejemplos de código, consulte [Invalidar metadatos en una propiedad de dependencia](../../../../docs/framework/wpf/advanced/how-to-override-metadata-for-a-dependency-property.md).  
  
 Se pueden proporcionar los metadatos de propiedad para una propiedad de dependencia durante la llamada de registro (<xref:System.Windows.DependencyProperty.Register%2A>). Sin embargo, en muchos casos, es posible que quiera proporcionar metadatos específicos del tipo para la clase cuando esta herede esa propiedad de dependencia. Puede hacerlo mediante una llamada a la <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> método.  Para obtener un ejemplo de la [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)], <xref:System.Windows.FrameworkElement> es el tipo que se registra en primer lugar el <xref:System.Windows.UIElement.Focusable%2A> propiedad de dependencia. Pero la <xref:System.Windows.Controls.Control> clase invalida los metadatos de la propiedad de dependencia proporcionar su propio valor predeterminado inicial, cambiarlo de `false` a `true`y en caso contrario, vuelve a utilizar el original <xref:System.Windows.UIElement.Focusable%2A> implementación.  
  
 Si invalida los metadatos, las distintas características de los metadatos se combinan o se reemplazan.  
  
-   <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> se combina. Si agrega un nuevo <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>, esa devolución de llamada se almacena en los metadatos. Si no especifica un <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> en la invalidación, el valor de <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> se promueve como referencia del antecesor más próximo que se haya especificado en los metadatos.  
  
-   El comportamiento del sistema de propiedad real para <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> es que las implementaciones de todos los propietarios de metadatos de la jerarquía se conservan y se agregan a una tabla, con el orden de ejecución en el sistema de propiedades radica en que las devoluciones de llamada de la clase más derivada se invocan en primer lugar.  
  
-   <xref:System.Windows.PropertyMetadata.DefaultValue%2A> se ha reemplazado. Si no especifica un <xref:System.Windows.PropertyMetadata.DefaultValue%2A> en la invalidación, el valor de <xref:System.Windows.PropertyMetadata.DefaultValue%2A> proviene del antecesor más cercano que se haya especificado en los metadatos.  
  
-   <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> se reemplazan las implementaciones. Si agrega un nuevo <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>, esa devolución de llamada se almacena en los metadatos. Si no especifica un <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> en la invalidación, el valor de <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> se promueve como referencia del antecesor más próximo que se haya especificado en los metadatos.  
  
-   El comportamiento del sistema de propiedades es que sólo el <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> se invoca en los metadatos inmediatos. No hay referencias a otras <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> se conservan las implementaciones en la jerarquía.  
  
 Este comportamiento se implementa mediante <xref:System.Windows.PropertyMetadata.Merge%2A>y se puede invalidar en clases de metadatos derivadas.  
  
#### <a name="overriding-attached-property-metadata"></a>Invalidar los metadatos de las propiedades adjuntas  
 En [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], las propiedades adjuntas se implementan como propiedades de dependencia. Esto significa que también tienen metadatos de propiedad, que las clases individuales pueden invalidar. Las consideraciones de ámbito para una propiedad adjunta en [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] son generalmente que cualquier <xref:System.Windows.DependencyObject> puede tener una propiedad adjunta establecida en ellos. Por lo tanto, cualquier <xref:System.Windows.DependencyObject> clase derivada puede invalidar los metadatos de cualquier propiedad adjunta, tal como se puede establecer en una instancia de la clase. Puede invalidar valores predeterminados, devoluciones de llamada o propiedades de informes de características del nivel de marco de WPF. Si se establece la propiedad adjunta en una instancia de la clase, se aplicarán las características de invalidación de metadatos de propiedad. Por ejemplo, puede invalidar el valor predeterminado, de modo que el valor de invalidación se notifique como el valor de la propiedad adjunta en las instancias de la clase, siempre que la propiedad no esté establecida de otro modo.  
  
> [!NOTE]
>  El <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> propiedad no es relevante para las propiedades adjuntas.  
  
<a name="dp_add_owner"></a>   
### <a name="adding-a-class-as-an-owner-of-an-existing-dependency-property"></a>Agregar una clase como propietaria de una propiedad de dependencia existente  
 Una clase se puede agregar como propietario de una propiedad de dependencia que ya se ha registrado, mediante el uso de la <xref:System.Windows.DependencyProperty.AddOwner%2A> método. Esto permite que la clase use una propiedad de dependencia que se registró originalmente para un tipo diferente. La clase que se agrega no suele ser una clase derivada del tipo que registró inicialmente esa propiedad de dependencia como propietaria. De hecho, esto permite que la clase y sus clases derivadas "hereden" una implementación de propiedad de dependencia sin que la clase propietaria original y la clase que se agrega estén en la misma jerarquía de clases real. Además, la clase que se agrega (y también todas las clases derivadas) pueden proporcionar metadatos específicos del tipo para la propiedad de dependencia original.  
  
 Además de agregarse a sí misma como propietaria a través de los métodos de utilidad del sistema de propiedades, la clase que se agrega debe declarar miembros públicos adicionales en sí misma para convertir la propiedad de dependencia en un participante completo en el sistema de propiedades, con exposición para el código y la marcación. Una clase que agrega una propiedad de dependencia existente tiene las mismas responsabilidades en cuanto a exponer el modelo de objetos para esa propiedad de dependencia que una clase que define una nueva propiedad de dependencia personalizada. El primer miembro de este tipo que se va a exponer es un campo de identificador de propiedad de dependencia. Este campo debe ser un `public static readonly` campo de tipo <xref:System.Windows.DependencyProperty>, que se asigna al valor devuelto de la <xref:System.Windows.DependencyProperty.AddOwner%2A> llamar. El segundo miembro que se va a definir es la propiedad del "contenedor" de [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)]. El contenedor hace que sea mucho más cómodo manipular la propiedad de dependencia en el código (evitar las llamadas a <xref:System.Windows.DependencyObject.SetValue%2A> cada vez y puede realizar esa llamada solo una vez en el propio contenedor). El contenedor se implementa de forma idéntica a cómo se implementaría si se estuviera registrando una propiedad de dependencia personalizada. Para obtener más información acerca de cómo implementar una propiedad de dependencia, consulte [Propiedades de dependencia personalizadas](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md) y [Agregar un tipo de propietario para una propiedad de dependencia](../../../../docs/framework/wpf/advanced/how-to-add-an-owner-type-for-a-dependency-property.md).  
  
#### <a name="addowner-and-attached-properties"></a>AddOwner y propiedades adjuntas  
 Puede llamar a <xref:System.Windows.DependencyProperty.AddOwner%2A> para una propiedad de dependencia que se define como una propiedad adjunta mediante la clase propietaria. Generalmente, el motivo para hacerlo es exponer la propiedad adjunta anteriormente como una propiedad de dependencia no adjunta. A continuación, se expone el <xref:System.Windows.DependencyProperty.AddOwner%2A> devolver valor como un `public static readonly` campo para su uso como el identificador de propiedad de dependencia y definirá las propiedades de "contenedor" adecuadas para que la propiedad aparece en la tabla de miembros y admite una propiedad no adjunta uso de la clase.  
  
## <a name="see-also"></a>Vea también
- <xref:System.Windows.PropertyMetadata>
- <xref:System.Windows.DependencyObject>
- <xref:System.Windows.DependencyProperty>
- <xref:System.Windows.DependencyProperty.GetMetadata%2A>
- [Información general sobre las propiedades de dependencia](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md)
- [Metadatos de las propiedades de marco de trabajo](../../../../docs/framework/wpf/advanced/framework-property-metadata.md)
