---
title: Clases XAML y personalizadas para WPF
ms.custom: ''
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: ''
ms.suite: ''
ms.technology:
- dotnet-wpf
ms.tgt_pltfrm: ''
ms.topic: article
helpviewer_keywords:
- custom classes in XAML [WPF]
- XAML [WPF], custom classes
- classes [WPF], custom classes in XAML
ms.assetid: e7313137-581e-4a64-8453-d44e15a6164a
caps.latest.revision: 22
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.workload:
- dotnet
ms.openlocfilehash: a7aa7ffe38f1fbd7de71dbc95ae12b8faca6e356
ms.sourcegitcommit: 86adcc06e35390f13c1e372c36d2e044f1fc31ef
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 04/26/2018
---
# <a name="xaml-and-custom-classes-for-wpf"></a><span data-ttu-id="3b30b-102">Clases XAML y personalizadas para WPF</span><span class="sxs-lookup"><span data-stu-id="3b30b-102">XAML and Custom Classes for WPF</span></span>
<span data-ttu-id="3b30b-103">XAML implementado en marcos de [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] admite la capacidad de definir una clase o estructura personalizada en cualquier lenguaje de [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)], y después, tiene acceso a esa clase mediante marcado XAML.</span><span class="sxs-lookup"><span data-stu-id="3b30b-103">XAML as implemented in [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] frameworks supports the ability to define a custom class or structure in any [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] language, and then access that class using XAML markup.</span></span> <span data-ttu-id="3b30b-104">Puede usar una mezcla de tipos definidos por [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] y sus tipos personalizados dentro del mismo archivo de marcado, normalmente asignando los tipos personalizados a un prefijo de espacio de nombres de XAML.</span><span class="sxs-lookup"><span data-stu-id="3b30b-104">You can use a mixture of [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]-defined types and your custom types within the same markup file, typically by mapping the custom types to a XAML namespace prefix.</span></span> <span data-ttu-id="3b30b-105">En este tema se describen los requisitos que debe satisfacer una clase personalizada para que se pueda usar como elemento XAML.</span><span class="sxs-lookup"><span data-stu-id="3b30b-105">This topic discusses the requirements that a custom class must satisfy to be usable as a XAML element.</span></span>  
  
 
  
<a name="Custom_Classes_in_Applications_vs__in_Assemblies"></a>   
## <a name="custom-classes-in-applications-or-assemblies"></a><span data-ttu-id="3b30b-106">Clases personalizadas en aplicaciones o ensamblados</span><span class="sxs-lookup"><span data-stu-id="3b30b-106">Custom Classes in Applications or Assemblies</span></span>  
 <span data-ttu-id="3b30b-107">Las clases personalizadas que se usan en XAML pueden definirse de dos maneras distintas: dentro del código subyacente o de otro código que genera la aplicación primaria de [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], o como una clase en un ensamblado independiente, como una aplicación ejecutable o DLL usado como una biblioteca de clases.</span><span class="sxs-lookup"><span data-stu-id="3b30b-107">Custom classes that are used in XAML can be defined in two distinct ways: within the code-behind or other code that produces the primary [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] application, or as a class in a separate assembly, such as an executable or DLL used as a class library.</span></span> <span data-ttu-id="3b30b-108">Cada uno de estos enfoques tiene ventajas y desventajas determinadas.</span><span class="sxs-lookup"><span data-stu-id="3b30b-108">Each of these approaches has particular advantages and disadvantages.</span></span>  
  
-   <span data-ttu-id="3b30b-109">La ventaja de crear una biblioteca de clases es que cualquiera de esas clases personalizadas puede compartirse entre muchas posibles aplicaciones diferentes.</span><span class="sxs-lookup"><span data-stu-id="3b30b-109">The advantage of creating a class library is that any such custom classes can be shared across many different possible applications.</span></span> <span data-ttu-id="3b30b-110">Una biblioteca independiente también facilita que las versiones de las aplicaciones sean más fáciles de controlar, y simplifica la creación de una clase donde el uso previsto de la clase es como un elemento raíz en una página XAML.</span><span class="sxs-lookup"><span data-stu-id="3b30b-110">A separate library also makes versioning issues of applications easier to control, and simplifies creating a class where the intended class usage is as a root element on a XAML page.</span></span>  
  
-   <span data-ttu-id="3b30b-111">La ventaja de definir las clases personalizadas en la aplicación consiste en que esta técnica es relativamente ligera, y minimiza los problemas de implementación y pruebas que se encuentran al especificar ensamblados independientes además del ejecutable principal de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="3b30b-111">The advantage of defining the custom classes in the application is that this technique is relatively lightweight and minimizes the deployment and testing issues encountered when you introduce separate assemblies beyond the main application executable.</span></span>  
  
-   <span data-ttu-id="3b30b-112">Si se define en el mismo ensamblado o en uno diferente, las clases personalizadas deben asignarse entre el espacio de nombres CLR y el espacio de nombres XML para usarlo en XAML como elementos.</span><span class="sxs-lookup"><span data-stu-id="3b30b-112">Whether defined in the same or different assembly, custom classes need to be mapped between CLR  namespace and XML  namespace in order to be used in XAML as elements.</span></span> <span data-ttu-id="3b30b-113">Vea [Espacios de nombres y asignación de espacios de nombres XAML para WPF](../../../../docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="3b30b-113">See [XAML Namespaces and Namespace Mapping for WPF XAML](../../../../docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span></span>  
  
<a name="Requirements_for_a_Custom_Class_as_a_XAML_Element"></a>   
## <a name="requirements-for-a-custom-class-as-a-xaml-element"></a><span data-ttu-id="3b30b-114">Requisitos para una clase personalizada como elemento XAML</span><span class="sxs-lookup"><span data-stu-id="3b30b-114">Requirements for a Custom Class as a XAML Element</span></span>  
 <span data-ttu-id="3b30b-115">Para permitir la creación de instancias como elementos de objeto, la clase debe cumplir los requisitos siguientes:</span><span class="sxs-lookup"><span data-stu-id="3b30b-115">In order to be able to be instantiated as an object element, your class must meet the following requirements:</span></span>  
  
-   <span data-ttu-id="3b30b-116">La clase personalizada debe ser pública y admitir un constructor público predeterminado (sin parámetros).</span><span class="sxs-lookup"><span data-stu-id="3b30b-116">Your custom class must be public and support a default (parameterless) public constructor.</span></span> <span data-ttu-id="3b30b-117">(Vea en la siguiente sección las notas relativas a las estructuras).</span><span class="sxs-lookup"><span data-stu-id="3b30b-117">(See following section for notes regarding structures.)</span></span>  
  
-   <span data-ttu-id="3b30b-118">Su clase personalizada no debe ser una clase anidada.</span><span class="sxs-lookup"><span data-stu-id="3b30b-118">Your custom class must not be a nested class.</span></span> <span data-ttu-id="3b30b-119">Las clases anidadas y el "punto" en su sintaxis de uso de CLR general interfieren con otras características de [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] o XAML como las propiedades adjuntas.</span><span class="sxs-lookup"><span data-stu-id="3b30b-119">Nested classes and the "dot" in their general CLR usage syntax interfere with other [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] and/or XAML features such as attached properties.</span></span>  
  
 <span data-ttu-id="3b30b-120">Además de permitir la sintaxis de elemento de objeto, su definición del objeto también debe habilitar la sintaxis de elemento de propiedad para cualquier otra propiedad pública que admita el objeto como el tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="3b30b-120">In addition to enabling object element syntax, your object definition also enables property element syntax for any other public properties that take that object as the value type.</span></span> <span data-ttu-id="3b30b-121">Esto se debe a que ahora es posible crear instancias de un objeto como un elemento de objeto y a que puede rellenar el valor de elemento de propiedad de dicha propiedad.</span><span class="sxs-lookup"><span data-stu-id="3b30b-121">This is because the object can now be instantiated as an object element and can fill the property element value of such a property.</span></span>  
  
### <a name="structures"></a><span data-ttu-id="3b30b-122">Estructuras</span><span class="sxs-lookup"><span data-stu-id="3b30b-122">Structures</span></span>  
 <span data-ttu-id="3b30b-123">Las estructuras que se definen como tipos personalizados siempre pueden construirse en XAML en [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]. Esto es porque los compiladores de [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] crean implícitamente un constructor predeterminado para una estructura que inicializa todos los valores de propiedad a sus valores predeterminados.</span><span class="sxs-lookup"><span data-stu-id="3b30b-123">Structures that you define as custom types are always able to be constructed in XAML  in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] .This is because the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] compilers implicitly create a default constructor for a structure that initializes all property values to their defaults.</span></span> <span data-ttu-id="3b30b-124">En algunos casos, no es deseable para una estructura el comportamiento predeterminado de construcción o el uso de elementos de objeto.</span><span class="sxs-lookup"><span data-stu-id="3b30b-124">In some cases, the default construction behavior and/or object element usage for a structure is not desirable.</span></span> <span data-ttu-id="3b30b-125">Esto se puede deber a que la estructura está pensada para rellenar valores y funcionar, desde el punto de vista conceptual, como una unión, cuyos valores contenidos pueden tener interpretaciones mutuamente excluyentes, por lo que ninguna de sus propiedades se podría establecer.</span><span class="sxs-lookup"><span data-stu-id="3b30b-125">This might be because the structure is intended to fill values and function conceptually as a union, where the values contained might have mutually exclusive interpretations and thus none of its properties are settable.</span></span> <span data-ttu-id="3b30b-126">A [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] ejemplo de este tipo de estructura es <xref:System.Windows.GridLength>.</span><span class="sxs-lookup"><span data-stu-id="3b30b-126">A [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] example of such a structure is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="3b30b-127">Generalmente, tales estructuras deberían implementar un convertidor de tipos para que los valores se puedan expresar en forma de atributo y usar las convenciones de cadena que crean las diferentes interpretaciones o modos de los valores de la estructura.</span><span class="sxs-lookup"><span data-stu-id="3b30b-127">Generally, such structures should implement a type converter such that the values can be expressed in attribute form, using string conventions that create the different interpretations or modes of the structure's values.</span></span> <span data-ttu-id="3b30b-128">La estructura también debería exponer un comportamiento similar por la construcción del código a través de un constructor no predeterminado.</span><span class="sxs-lookup"><span data-stu-id="3b30b-128">The structure should also expose similar behavior for code construction through a non-default constructor.</span></span>  
  
<a name="Requirements_for_Properties_of_a_Custom_Class_as_XAML"></a>   
## <a name="requirements-for-properties-of-a-custom-class-as-xaml-attributes"></a><span data-ttu-id="3b30b-129">Requisitos para las propiedades de una clase personalizada como atributos XAML</span><span class="sxs-lookup"><span data-stu-id="3b30b-129">Requirements for Properties of a Custom Class as XAML Attributes</span></span>  
 <span data-ttu-id="3b30b-130">Las propiedades deben hacer referencia a un tipo por valor (como un tipo primitivo) o usar una clase para tipos que tenga un constructor predeterminado o un convertidor de tipos dedicado al que pueda obtener acceso un procesador XAML.</span><span class="sxs-lookup"><span data-stu-id="3b30b-130">Properties must reference a by-value type (such as a primitive), or use a class for type that has either a default constructor or a dedicated type converter that a XAML processor can access.</span></span> <span data-ttu-id="3b30b-131">En la implementación de CLR XAML, los procesadores XAML buscan estos convertidores a través de la compatibilidad nativa para las primitivas del lenguaje, o a través de la aplicación de <xref:System.ComponentModel.TypeConverterAttribute> a un tipo o miembro en las definiciones de tipos de respaldo</span><span class="sxs-lookup"><span data-stu-id="3b30b-131">In the CLR XAML implementation, XAML processors either find such converters through native support for language primitives, or through application of <xref:System.ComponentModel.TypeConverterAttribute> to a type or member in backing type definitions</span></span>  
  
 <span data-ttu-id="3b30b-132">De manera alternativa, la propiedad puede hacer referencia a un tipo de clase abstracta o a una interfaz.</span><span class="sxs-lookup"><span data-stu-id="3b30b-132">Alternatively, the property may reference an abstract class type, or an interface.</span></span> <span data-ttu-id="3b30b-133">Para las clases abstractas o las interfaces, la expectativa del análisis de XAML es que el valor de propiedad debe rellenarse con instancias de clase prácticas que implementen la interfaz, o con instancias de tipos derivadas de la clase abstracta.</span><span class="sxs-lookup"><span data-stu-id="3b30b-133">For abstract classes or interfaces, the expectation for XAML parsing is that the property value must be filled with practical class instances that implement the interface, or instances of types that derive from the abstract class.</span></span>  
  
 <span data-ttu-id="3b30b-134">Las propiedades se pueden declarar en una clase abstracta, pero solo se pueden establecer en las clases prácticas derivadas de la clase abstracta.</span><span class="sxs-lookup"><span data-stu-id="3b30b-134">Properties can be declared on an abstract class, but can only be set on practical classes that derive from the abstract class.</span></span> <span data-ttu-id="3b30b-135">Esto se debe a que crear el elemento de objeto para la clase requiere un constructor predeterminado público en la clase.</span><span class="sxs-lookup"><span data-stu-id="3b30b-135">This is because creating the object element for the class at all requires a public default constructor on the class.</span></span>  
  
### <a name="typeconverter-enabled-attribute-syntax"></a><span data-ttu-id="3b30b-136">Sintaxis de atributo con convertidor de tipos</span><span class="sxs-lookup"><span data-stu-id="3b30b-136">TypeConverter Enabled Attribute Syntax</span></span>  
 <span data-ttu-id="3b30b-137">Si proporciona un convertidor de tipos dedicado, con atributos, en el nivel de clase, la conversión de tipos aplicada habilita la sintaxis de atributo para cualquier propiedad que necesita crear instancias de ese tipo.</span><span class="sxs-lookup"><span data-stu-id="3b30b-137">If you provide a dedicated, attributed type converter at the class level, the applied type conversion enables attribute syntax for any property that needs to instantiate that type.</span></span> <span data-ttu-id="3b30b-138">Un convertidor de tipos no permite el uso de elemento de objeto del tipo; solamente la presencia de un constructor predeterminado para ese tipo habilita el uso de elemento de objeto.</span><span class="sxs-lookup"><span data-stu-id="3b30b-138">A type converter does not enable object element usage of the type; only the presence of a default constructor for that type enables object element usage.</span></span> <span data-ttu-id="3b30b-139">Por consiguiente, las propiedades habilitadas con convertidor de tipos, en general, no se usan en sintaxis de propiedad, a menos que el propio tipo admita también la sintaxis de elemento de objeto.</span><span class="sxs-lookup"><span data-stu-id="3b30b-139">Therefore, properties that are type-converter enabled are generally speaking not usable in property syntax, unless the type itself also supports object element syntax.</span></span> <span data-ttu-id="3b30b-140">La excepción consiste en que se puede especificar una sintaxis de elemento de propiedad, pero el elemento de propiedad debe contener una cadena.</span><span class="sxs-lookup"><span data-stu-id="3b30b-140">The exception to this is that you can specify a property element syntax, but have the property element contain a string.</span></span> <span data-ttu-id="3b30b-141">Realmente, ese uso es esencialmente el equivalente a un uso de sintaxis de atributo, y dicho uso no es común a menos que se necesite un control más sólido del espacio en blanco en el valor del atributo.</span><span class="sxs-lookup"><span data-stu-id="3b30b-141">That usage is really essentially equivalent to an attribute syntax usage, and such a usage is not common unless there is a need for more robust whitespace handling of the attribute value.</span></span> <span data-ttu-id="3b30b-142">Por ejemplo, lo siguiente es un uso de elemento de propiedad que toma una cadena y el uso de atributo equivalente:</span><span class="sxs-lookup"><span data-stu-id="3b30b-142">For example, the following is a property element usage that takes a string, and the attribute usage equivalent:</span></span>  
  
 [!code-xaml[XamlOvwSupport#GoofyTCPE](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofytcpe)]  
  
 [!code-xaml[XamlOvwSupport#GoofyTCPE2](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofytcpe2)]  
  
 <span data-ttu-id="3b30b-143">Ejemplos de propiedades donde se permite la sintaxis de atributo pero la sintaxis de elemento de propiedad que contiene un elemento de objeto no está permitida a través de XAML son varias propiedades que toman el <xref:System.Windows.Input.Cursor> tipo.</span><span class="sxs-lookup"><span data-stu-id="3b30b-143">Examples of properties where attribute syntax is allowed but property element syntax that contains an object element is disallowed through XAML are various properties that take the <xref:System.Windows.Input.Cursor> type.</span></span> <span data-ttu-id="3b30b-144">El <xref:System.Windows.Input.Cursor> clase tiene un convertidor de tipos dedicado <xref:System.Windows.Input.CursorConverter>, pero no expone un constructor predeterminado, por lo que la <xref:System.Windows.FrameworkElement.Cursor%2A> propiedad solo se puede establecer mediante la sintaxis de atributo, aunque los datos reales <xref:System.Windows.Input.Cursor> es un tipo de referencia.</span><span class="sxs-lookup"><span data-stu-id="3b30b-144">The <xref:System.Windows.Input.Cursor> class has a dedicated type converter <xref:System.Windows.Input.CursorConverter>, but does not expose a default constructor, so the <xref:System.Windows.FrameworkElement.Cursor%2A> property can only be set through attribute syntax even though the actual <xref:System.Windows.Input.Cursor> type is a reference type.</span></span>  
  
### <a name="per-property-type-converters"></a><span data-ttu-id="3b30b-145">Convertidores de tipo por propiedad</span><span class="sxs-lookup"><span data-stu-id="3b30b-145">Per-Property Type Converters</span></span>  
 <span data-ttu-id="3b30b-146">De manera alternativa, la propia propiedad puede declarar un convertidor de tipos en el nivel de propiedad.</span><span class="sxs-lookup"><span data-stu-id="3b30b-146">Alternatively, the property itself may declare a type converter at the property level.</span></span> <span data-ttu-id="3b30b-147">Esto permite un "lenguaje mini" que crea instancias de objetos del tipo de la propiedad alineados, mediante el procesamiento entrante valores de cadena del atributo como entrada para un <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> operación en función del tipo adecuado.</span><span class="sxs-lookup"><span data-stu-id="3b30b-147">This enables a "mini language" that instantiates objects of the type of the property inline, by processing incoming string values of the attribute as input for a <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> operation based on the appropriate type.</span></span> <span data-ttu-id="3b30b-148">Normalmente esto se realiza para proporcionar un descriptor de acceso adecuado, y no como único medio para habilitar el establecimiento de una propiedad en XAML.</span><span class="sxs-lookup"><span data-stu-id="3b30b-148">Typically this is done to provide a convenience accessor, and not as the sole means to enable setting a property in XAML.</span></span> <span data-ttu-id="3b30b-149">En cambio, también es posible usar convertidores de tipos para atributos cuando quiera usar tipos [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] existentes que no proporcionen un constructor predeterminado ni un convertidor de tipos con atributos.</span><span class="sxs-lookup"><span data-stu-id="3b30b-149">However, it is also possible to use type converters for attributes where you want to use existing [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] types that do not supply either a default constructor or an attributed type converter.</span></span> <span data-ttu-id="3b30b-150">Ejemplos de la [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] API son ciertas propiedades que aceptan el <xref:System.Globalization.CultureInfo> tipo.</span><span class="sxs-lookup"><span data-stu-id="3b30b-150">Examples from the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] API are certain properties that take the <xref:System.Globalization.CultureInfo> type.</span></span> <span data-ttu-id="3b30b-151">En este caso, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] usa la versión existente de Microsoft .NET Framework <xref:System.Globalization.CultureInfo> tipo mejor administrar escenarios de migración y compatibilidad que se usaron en versiones anteriores de marcos de trabajo, pero la <xref:System.Globalization.CultureInfo> tipo no admitía la necesaria los constructores o conversión de tipos de nivel de tipo que se pueda usar como un valor de propiedad XAML directamente.</span><span class="sxs-lookup"><span data-stu-id="3b30b-151">In this case, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] used the existing Microsoft .NET Framework <xref:System.Globalization.CultureInfo> type to better address compatibility and migration scenarios that were used in earlier versions of frameworks, but the <xref:System.Globalization.CultureInfo> type did not support the necessary constructors or type-level type conversion to be usable as a XAML property value directly.</span></span>  
  
 <span data-ttu-id="3b30b-152">Siempre que exponga una propiedad que se pueda usar en XAML, en particular si es un creador de controles, deberá considerar la posibilidad de respaldar esa propiedad con una propiedad de dependencia.</span><span class="sxs-lookup"><span data-stu-id="3b30b-152">Whenever you expose a property that has a XAML usage, particularly if you are a control author, you should strongly consider backing that property with a dependency property.</span></span> <span data-ttu-id="3b30b-153">Esto es especialmente cierto si usas existente [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] implementación del procesador XAML, porque se puede mejorar el rendimiento mediante el uso de <xref:System.Windows.DependencyProperty> copia.</span><span class="sxs-lookup"><span data-stu-id="3b30b-153">This is particularly true if you use the existing [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] implementation of the XAML processor, because you can improve performance by using <xref:System.Windows.DependencyProperty> backing.</span></span> <span data-ttu-id="3b30b-154">Una propiedad de dependencia expondrá para la propiedad las características del sistema de propiedades que los usuarios esperan de una propiedad accesible a través de XAML.</span><span class="sxs-lookup"><span data-stu-id="3b30b-154">A dependency property will expose property system features for your property that users will come to expect for a XAML accessible property.</span></span> <span data-ttu-id="3b30b-155">Esto incluye características tales como la animación, el enlace de datos y la compatibilidad con estilos.</span><span class="sxs-lookup"><span data-stu-id="3b30b-155">This includes features such as animation, data binding, and style support.</span></span> <span data-ttu-id="3b30b-156">Para obtener más información, vea [Propiedades de dependencia personalizadas](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md) y [Carga de XAML y propiedades de dependencia](../../../../docs/framework/wpf/advanced/xaml-loading-and-dependency-properties.md).</span><span class="sxs-lookup"><span data-stu-id="3b30b-156">For more information, see [Custom Dependency Properties](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md) and [XAML Loading and Dependency Properties](../../../../docs/framework/wpf/advanced/xaml-loading-and-dependency-properties.md).</span></span>  
  
### <a name="writing-and-attributing-a-type-converter"></a><span data-ttu-id="3b30b-157">Escribir y asignar atributos a un convertidor de tipos</span><span class="sxs-lookup"><span data-stu-id="3b30b-157">Writing and Attributing a Type Converter</span></span>  
 <span data-ttu-id="3b30b-158">En ocasiones, deberá escribir un personalizado <xref:System.ComponentModel.TypeConverter> clase derivada para proporcionar la conversión de tipo para el tipo de propiedad.</span><span class="sxs-lookup"><span data-stu-id="3b30b-158">You occasionally will need to write a custom <xref:System.ComponentModel.TypeConverter> derived class to provide type conversion for your property type.</span></span> <span data-ttu-id="3b30b-159">Para obtener instrucciones sobre cómo derivar y crear un convertidor de tipos que puede admitir usos XAML y cómo aplicar el <xref:System.ComponentModel.TypeConverterAttribute>, consulte [clases TypeConverter y XAML](../../../../docs/framework/wpf/advanced/typeconverters-and-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="3b30b-159">For instructions on how to derive from and create a type converter that can support XAML usages, and how to apply the <xref:System.ComponentModel.TypeConverterAttribute>, see [TypeConverters and XAML](../../../../docs/framework/wpf/advanced/typeconverters-and-xaml.md).</span></span>  
  
<a name="Requirements_for_Events_of_a_Custom_Class_as_XAML"></a>   
## <a name="requirements-for-xaml-event-handler-attribute-syntax-on-events-of-a-custom-class"></a><span data-ttu-id="3b30b-160">Requisitos para la sintaxis de atributo del controlador de eventos XAML en los eventos de una clase personalizada</span><span class="sxs-lookup"><span data-stu-id="3b30b-160">Requirements for XAML Event Handler Attribute Syntax on Events of a Custom Class</span></span>  
 <span data-ttu-id="3b30b-161">Para que se pueda usar como un evento [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)], el evento se debe exponer como un evento público en una clase que admita un constructor predeterminado o en una clase abstracta donde se pueda tener acceso al evento en clases derivadas.</span><span class="sxs-lookup"><span data-stu-id="3b30b-161">To be usable as a [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] event, the event must be exposed as a public event on a class that supports a default constructor, or on an abstract class where the event can be accessed on derived classes.</span></span> <span data-ttu-id="3b30b-162">Para poder usarlo de forma cómoda como un evento enrutado, su [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] eventos deberían implementar explícita `add` y `remove` métodos, que agregar y quitan controladores para la [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] firma de evento y reenviar los controladores para la <xref:System.Windows.UIElement.AddHandler%2A>y <xref:System.Windows.UIElement.RemoveHandler%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="3b30b-162">In order to be used conveniently as a routed event, your [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] event should implement explicit `add` and `remove` methods, which add and remove handlers for the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] event signature and forward those handlers to the <xref:System.Windows.UIElement.AddHandler%2A> and <xref:System.Windows.UIElement.RemoveHandler%2A> methods.</span></span> <span data-ttu-id="3b30b-163">Estos métodos agregan o quitan controladores del almacén del controlador de eventos enrutados en la instancia a la que está asociado el evento.</span><span class="sxs-lookup"><span data-stu-id="3b30b-163">These methods add or remove the handlers to the routed event handler store on the instance that the event is attached to.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3b30b-164">Es posible registrar controladores directamente para los eventos enrutados mediante <xref:System.Windows.UIElement.AddHandler%2A>así como definir deliberadamente, no sea un [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] eventos que expone el evento enrutado.</span><span class="sxs-lookup"><span data-stu-id="3b30b-164">It is possible to register handlers directly for routed events using <xref:System.Windows.UIElement.AddHandler%2A>, and to deliberately not define a [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] event that exposes the routed event.</span></span> <span data-ttu-id="3b30b-165">Esto no suele ser recomendable porque el evento no habilitará la sintaxis de atributo de XAML para asociar controladores, y la clase resultante ofrecerá una vista menos transparente XAML de las capacidades de ese tipo.</span><span class="sxs-lookup"><span data-stu-id="3b30b-165">This is not generally recommended because the event will not enable XAML attribute syntax for attaching handlers, and your resulting class will offer a less transparent XAML view of that type's capabilities.</span></span>  
  
<a name="Collection_Properties"></a>   
## <a name="writing-collection-properties"></a><span data-ttu-id="3b30b-166">Escribir propiedades de colección</span><span class="sxs-lookup"><span data-stu-id="3b30b-166">Writing Collection Properties</span></span>  
 <span data-ttu-id="3b30b-167">Las propiedades cuyo tipo es una colección tienen una sintaxis XAML que le permite especificar los objetos que se agregan a la colección.</span><span class="sxs-lookup"><span data-stu-id="3b30b-167">Properties that take a collection type have a XAML syntax that enables you to specify objects that are added to the collection.</span></span> <span data-ttu-id="3b30b-168">Esta sintaxis tiene dos características notables.</span><span class="sxs-lookup"><span data-stu-id="3b30b-168">This syntax has two notable features.</span></span>  
  
-   <span data-ttu-id="3b30b-169">El objeto que es el objeto de colección no necesita especificarse en la sintaxis de elemento de objeto.</span><span class="sxs-lookup"><span data-stu-id="3b30b-169">The object that is the collection object does not need to be specified in object element syntax.</span></span> <span data-ttu-id="3b30b-170">La presencia de ese tipo de colección es implícita cuando se especifica una propiedad en XAML que toma un tipo de colección.</span><span class="sxs-lookup"><span data-stu-id="3b30b-170">The presence of that collection type is implicit whenever you specify a property in XAML that takes a collection type.</span></span>  
  
-   <span data-ttu-id="3b30b-171">Los elementos secundarios de la propiedad de colección del marcado se procesan para convertirse en miembros de la colección.</span><span class="sxs-lookup"><span data-stu-id="3b30b-171">Child elements of the collection property in markup are processed to become members of the collection.</span></span> <span data-ttu-id="3b30b-172">Normalmente, el acceso del código a los miembros de una colección se realiza a través de métodos de lista y diccionario, tales como `Add`, o mediante un indexador.</span><span class="sxs-lookup"><span data-stu-id="3b30b-172">Ordinarily, the code access to the members of a collection is performed through list/dictionary methods such as `Add`, or through an indexer.</span></span> <span data-ttu-id="3b30b-173">Pero la sintaxis de XAML no admite los métodos o indexadores (excepción: XAML 2009 puede admitir métodos, pero con XAML 2009 limita los usos posibles de WPF; vea [Características del lenguaje XAML 2009](../../../../docs/framework/xaml-services/xaml-2009-language-features.md)).</span><span class="sxs-lookup"><span data-stu-id="3b30b-173">But XAML syntax does not support methods or indexers (exception: XAML 2009 can support methods, but using XAML 2009 restricts the possible WPF usages; see [XAML 2009 Language Features](../../../../docs/framework/xaml-services/xaml-2009-language-features.md)).</span></span> <span data-ttu-id="3b30b-174">Las colecciones son obviamente un requisito muy común para compilar un árbol de elementos y necesita alguna manera de rellenarlas en XAML declarativo.</span><span class="sxs-lookup"><span data-stu-id="3b30b-174">Collections are obviously a very common requirement for building a tree of elements, and you need some way to populate these collections in declarative XAML.</span></span> <span data-ttu-id="3b30b-175">Por consiguiente, los elementos secundarios de una propiedad de colección se procesan agregándolos a la colección que es el valor de tipo de la propiedad de colección.</span><span class="sxs-lookup"><span data-stu-id="3b30b-175">Therefore, child elements of a collection property are processed by adding them to the collection that is the collection property type value.</span></span>  
  
 <span data-ttu-id="3b30b-176">La implementación de los servicios XAML de.NET Framework y el procesador XAML de WPF usan así la siguiente definición de lo que constituye una propiedad de colección.</span><span class="sxs-lookup"><span data-stu-id="3b30b-176">The .NET Framework XAML Services implementation and thus the WPF XAML processor uses the following definition for what constitutes a collection property.</span></span> <span data-ttu-id="3b30b-177">El tipo de propiedad de la propiedad debe implementar una de las opciones siguientes:</span><span class="sxs-lookup"><span data-stu-id="3b30b-177">The property type of the property must implement one of the following:</span></span>  
  
-   <span data-ttu-id="3b30b-178">Implementa <xref:System.Collections.IList>.</span><span class="sxs-lookup"><span data-stu-id="3b30b-178">Implements <xref:System.Collections.IList>.</span></span>  
  
-   <span data-ttu-id="3b30b-179">Implementa <xref:System.Collections.IDictionary> o el equivalente genérico (<xref:System.Collections.Generic.IDictionary%602>).</span><span class="sxs-lookup"><span data-stu-id="3b30b-179">Implements <xref:System.Collections.IDictionary> or the generic equivalent (<xref:System.Collections.Generic.IDictionary%602>).</span></span>  
  
-   <span data-ttu-id="3b30b-180">Se deriva de <xref:System.Array> (para obtener más información acerca de las matrices en XAML, vea [extensión de marcado x: Array](../../../../docs/framework/xaml-services/x-array-markup-extension.md).)</span><span class="sxs-lookup"><span data-stu-id="3b30b-180">Derives from <xref:System.Array> (for more information about arrays in XAML, see [x:Array Markup Extension](../../../../docs/framework/xaml-services/x-array-markup-extension.md).)</span></span>  
  
-   <span data-ttu-id="3b30b-181">Implementa <xref:System.Windows.Markup.IAddChild> (una interfaz definida por [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]).</span><span class="sxs-lookup"><span data-stu-id="3b30b-181">Implements <xref:System.Windows.Markup.IAddChild> (an interface defined by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]).</span></span>  
  
 <span data-ttu-id="3b30b-182">Cada uno de estos tipos de CLR tiene un método de `Add`, usado por el procesador XAML para agregar elementos a la colección subyacente al crear el gráfico de objetos.</span><span class="sxs-lookup"><span data-stu-id="3b30b-182">Each of these types in CLR has an `Add` method, which is used by the XAML processor to add items to the underlying collection when creating the object graph.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3b30b-183">La interfaz genérica `List` y `Dictionary` interfaces (<xref:System.Collections.Generic.IList%601> y <xref:System.Collections.Generic.IDictionary%602>) no se admiten para la detección de la colección por la [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] procesador XAML.</span><span class="sxs-lookup"><span data-stu-id="3b30b-183">The generic `List` and `Dictionary` interfaces (<xref:System.Collections.Generic.IList%601> and <xref:System.Collections.Generic.IDictionary%602>) are not supported for collection detection by the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML processor.</span></span> <span data-ttu-id="3b30b-184">Sin embargo, puede usar el <xref:System.Collections.Generic.List%601> de clase como una clase base, porque implementa <xref:System.Collections.IList> directamente, o <xref:System.Collections.Generic.Dictionary%602> como una clase base, porque implementa <xref:System.Collections.IDictionary> directamente.</span><span class="sxs-lookup"><span data-stu-id="3b30b-184">However, you can use the <xref:System.Collections.Generic.List%601> class as a base class, because it implements <xref:System.Collections.IList> directly, or <xref:System.Collections.Generic.Dictionary%602> as a base class, because it implements <xref:System.Collections.IDictionary> directly.</span></span>  
  
 <span data-ttu-id="3b30b-185">Al declarar una propiedad que toma una colección, tenga cuidado con el modo en el que se inicializa ese valor de propiedad en las nuevas instancias del tipo.</span><span class="sxs-lookup"><span data-stu-id="3b30b-185">When you declare a property that takes a collection, be cautious about how that property value is initialized in new instances of the type.</span></span> <span data-ttu-id="3b30b-186">Si no está implementando la propiedad como una propiedad de dependencia, es aconsejable hacer que la propiedad use un campo de respaldo que llame al constructor del tipo de colección.</span><span class="sxs-lookup"><span data-stu-id="3b30b-186">If you are not implementing the property as a dependency property, then having the property use a backing field that calls the collection type constructor is adequate.</span></span> <span data-ttu-id="3b30b-187">Si la propiedad es una propiedad de dependencia, quizá necesite inicializar la propiedad de colección como parte del constructor de tipo predeterminado.</span><span class="sxs-lookup"><span data-stu-id="3b30b-187">If your property is a dependency property, then you may need to initialize the collection property as part of the default type constructor.</span></span> <span data-ttu-id="3b30b-188">Esto se debe a que una propiedad de dependencia toma su valor predeterminado de los metadatos y, normalmente, no es conveniente que el valor inicial de una propiedad de colección sea una colección estática compartida.</span><span class="sxs-lookup"><span data-stu-id="3b30b-188">This is because a dependency property takes its default value from metadata, and you typically do not want the initial value of a collection property to be a static, shared collection.</span></span> <span data-ttu-id="3b30b-189">Debería haber una instancia de colección por cada instancia del tipo contenedor.</span><span class="sxs-lookup"><span data-stu-id="3b30b-189">There should be a collection instance per each containing type instance.</span></span> <span data-ttu-id="3b30b-190">Para obtener más información, vea [Propiedades de dependencia personalizadas](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md).</span><span class="sxs-lookup"><span data-stu-id="3b30b-190">For more information, see [Custom Dependency Properties](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md).</span></span>  
  
 <span data-ttu-id="3b30b-191">Puede implementar un tipo de colección personalizado para la propiedad de colección.</span><span class="sxs-lookup"><span data-stu-id="3b30b-191">You can implement a custom collection type for your collection property.</span></span> <span data-ttu-id="3b30b-192">Debido al tratamiento de propiedad de colección implícito, no es necesario que el tipo de colección personalizado proporcione un constructor predeterminado para que se use implícitamente en XAML.</span><span class="sxs-lookup"><span data-stu-id="3b30b-192">Because of implicit collection property treatment, the custom collection type does not need to provide a default constructor in order to be used in XAML implicitly.</span></span> <span data-ttu-id="3b30b-193">En cambio, puede proporcionar de manera opcional un constructor predeterminado para el tipo de colección.</span><span class="sxs-lookup"><span data-stu-id="3b30b-193">However, you can optionally provide a default constructor for the collection type.</span></span> <span data-ttu-id="3b30b-194">Esta puede ser una práctica útil.</span><span class="sxs-lookup"><span data-stu-id="3b30b-194">This can be a worthwhile practice.</span></span> <span data-ttu-id="3b30b-195">A menos que proporcione un constructor predeterminado, no puede declarar explícitamente la colección como un elemento de objeto.</span><span class="sxs-lookup"><span data-stu-id="3b30b-195">Unless you do provide a default constructor, you cannot explicitly declare the collection as an object element.</span></span> <span data-ttu-id="3b30b-196">Es posible que algunos autores de marcado prefieran considerar la colección explícita como una cuestión de estilo de marcado.</span><span class="sxs-lookup"><span data-stu-id="3b30b-196">Some markup authors might prefer to see the explicit collection as a matter of markup style.</span></span> <span data-ttu-id="3b30b-197">Además, un constructor predeterminado puede simplificar los requisitos de inicialización al crear nuevos objetos que usen el tipo de colección como un valor de propiedad.</span><span class="sxs-lookup"><span data-stu-id="3b30b-197">Also, a default constructor can simplify the initialization requirements when you create new objects that use your collection type as a property value.</span></span>  
  
<a name="XAMLCONtent"></a>   
## <a name="declaring-xaml-content-properties"></a><span data-ttu-id="3b30b-198">Declarar propiedades de contenido XAML</span><span class="sxs-lookup"><span data-stu-id="3b30b-198">Declaring XAML Content Properties</span></span>  
 <span data-ttu-id="3b30b-199">El lenguaje XAML define el concepto de una propiedad de contenido de [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)].</span><span class="sxs-lookup"><span data-stu-id="3b30b-199">The XAML language defines the concept of a [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] content property.</span></span> <span data-ttu-id="3b30b-200">Cada clase que se puede usar en la sintaxis de objeto puede tener exactamente una propiedad de contenido XAML.</span><span class="sxs-lookup"><span data-stu-id="3b30b-200">Each class that is usable in object syntax can have exactly one XAML content property.</span></span> <span data-ttu-id="3b30b-201">Para declarar una propiedad como la propiedad de contenido XAML para la clase, aplique el <xref:System.Windows.Markup.ContentPropertyAttribute> como parte de la definición de clase.</span><span class="sxs-lookup"><span data-stu-id="3b30b-201">To declare a property to be the XAML content property for your class, apply the <xref:System.Windows.Markup.ContentPropertyAttribute> as part of the class definition.</span></span> <span data-ttu-id="3b30b-202">Especifique el nombre de la propiedad de contenido XAML como el <xref:System.Windows.Markup.ContentPropertyAttribute.Name%2A> en el atributo.</span><span class="sxs-lookup"><span data-stu-id="3b30b-202">Specify the name of the intended XAML content property as the <xref:System.Windows.Markup.ContentPropertyAttribute.Name%2A> in the attribute.</span></span> <span data-ttu-id="3b30b-203">La propiedad se especifica como una cadena por su nombre, no como una construcción de reflexión como <xref:System.Reflection.PropertyInfo>.</span><span class="sxs-lookup"><span data-stu-id="3b30b-203">The property is specified as a string by name, not as a reflection construct such as <xref:System.Reflection.PropertyInfo>.</span></span>  
  
 <span data-ttu-id="3b30b-204">Puede especificar una propiedad de colección para que sea la propiedad de contenido XAML.</span><span class="sxs-lookup"><span data-stu-id="3b30b-204">You can specify a collection property to be the XAML content property.</span></span> <span data-ttu-id="3b30b-205">El resultado es un uso para esa propiedad mediante la cual el elemento de objeto puede tener uno o más elementos secundarios, sin elementos de objeto de colección intermedios ni etiquetas de elemento de propiedad.</span><span class="sxs-lookup"><span data-stu-id="3b30b-205">This results in a usage for that property whereby the object element can have one or more child elements, without any intervening collection object elements or property element tags.</span></span> <span data-ttu-id="3b30b-206">Estos elementos se tratan entonces como el valor de la propiedad de contenido XAML y se agregan a la instancia de respaldo de la colección.</span><span class="sxs-lookup"><span data-stu-id="3b30b-206">These elements are then treated as the value for the XAML content property and added to the backing collection instance.</span></span>  
  
 <span data-ttu-id="3b30b-207">Algunas propiedades existentes de contenido de XAML usan el tipo de propiedad de `Object`.</span><span class="sxs-lookup"><span data-stu-id="3b30b-207">Some existing XAML content properties use the property type of `Object`.</span></span> <span data-ttu-id="3b30b-208">Esto permite un contenido de valores de propiedad que puede llevar a cabo primitivo como XAML un <xref:System.String> , así como un valor de objeto de referencia único.</span><span class="sxs-lookup"><span data-stu-id="3b30b-208">This enables a XAML content property that can take primitive values such as a <xref:System.String> as well as taking a single reference object value.</span></span> <span data-ttu-id="3b30b-209">Si sigue este modelo, el tipo será responsable de la determinación de tipo, así como del control de los tipos posibles.</span><span class="sxs-lookup"><span data-stu-id="3b30b-209">If you follow this model, your type is responsible for type determination as well as the handling of possible types.</span></span> <span data-ttu-id="3b30b-210">La razón típica para un <xref:System.Object> contenido tipo consiste en admitir tanto un medio simple para agregar contenido de objetos como una cadena (que recibe un tratamiento de presentación predeterminado) o un medio avanzado de agregar contenido que especifique una presentación no predeterminada del objeto o datos adicionales.</span><span class="sxs-lookup"><span data-stu-id="3b30b-210">The typical reason for an <xref:System.Object> content type is to support both a simple means of adding object content as a string (which receives a default presentation treatment), or an advanced means of adding object content that specifies a non-default presentation or additional data.</span></span>  
  
<a name="Serializing"></a>   
## <a name="serializing-xaml"></a><span data-ttu-id="3b30b-211">Serializar XAML</span><span class="sxs-lookup"><span data-stu-id="3b30b-211">Serializing XAML</span></span>  
 <span data-ttu-id="3b30b-212">En determinados escenarios, como si es un creador de controles, quizá también quiera asegurarse de que cualquier representación de objeto de la que se pueda crear una instancia en XAML también pueda serializarse de nuevo al marcado equivalente de XAML.</span><span class="sxs-lookup"><span data-stu-id="3b30b-212">For certain scenarios, such as if you are a control author, you may also want to assure that any object representation that can be instantiated in XAML can also be serialized back to equivalent XAML markup.</span></span> <span data-ttu-id="3b30b-213">Los requisitos de serialización no se describen en este tema.</span><span class="sxs-lookup"><span data-stu-id="3b30b-213">Serialization requirements are not described in this topic.</span></span> <span data-ttu-id="3b30b-214">Vea [Información general sobre la creación de controles](../../../../docs/framework/wpf/controls/control-authoring-overview.md) y [Árbol de elementos y serialización](../../../../docs/framework/wpf/advanced/element-tree-and-serialization.md).</span><span class="sxs-lookup"><span data-stu-id="3b30b-214">See [Control Authoring Overview](../../../../docs/framework/wpf/controls/control-authoring-overview.md) and [Element Tree and Serialization](../../../../docs/framework/wpf/advanced/element-tree-and-serialization.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="3b30b-215">Vea también</span><span class="sxs-lookup"><span data-stu-id="3b30b-215">See Also</span></span>  
 [<span data-ttu-id="3b30b-216">Información general sobre XAML (WPF)</span><span class="sxs-lookup"><span data-stu-id="3b30b-216">XAML Overview (WPF)</span></span>](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md)  
 [<span data-ttu-id="3b30b-217">Propiedades de dependencia personalizadas</span><span class="sxs-lookup"><span data-stu-id="3b30b-217">Custom Dependency Properties</span></span>](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md)  
 [<span data-ttu-id="3b30b-218">Información general sobre la creación de controles</span><span class="sxs-lookup"><span data-stu-id="3b30b-218">Control Authoring Overview</span></span>](../../../../docs/framework/wpf/controls/control-authoring-overview.md)  
 [<span data-ttu-id="3b30b-219">Información general sobre elementos base</span><span class="sxs-lookup"><span data-stu-id="3b30b-219">Base Elements Overview</span></span>](../../../../docs/framework/wpf/advanced/base-elements-overview.md)  
 [<span data-ttu-id="3b30b-220">Carga de XAML y propiedades de dependencia</span><span class="sxs-lookup"><span data-stu-id="3b30b-220">XAML Loading and Dependency Properties</span></span>](../../../../docs/framework/wpf/advanced/xaml-loading-and-dependency-properties.md)
