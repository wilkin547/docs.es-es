---
title: "Árboles en WPF"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-wpf
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- logical tree [WPF]
- element tree [WPF]
- visual tree [WPF]
ms.assetid: e83f25e5-d66b-4fc7-92d2-50130c9a6649
caps.latest.revision: "20"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.workload: dotnet
ms.openlocfilehash: 73c34f8edfa735e361bf294f08cefd285be3e898
ms.sourcegitcommit: 16186c34a957fdd52e5db7294f291f7530ac9d24
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 12/22/2017
---
# <a name="trees-in-wpf"></a>Árboles en WPF
En muchas tecnologías, los elementos y componentes se organizan en una estructura de árbol en la que los desarrolladores manipulan directamente los nodos de objeto en el árbol para modificar la representación o el comportamiento de una aplicación. [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] también usa varias metáforas de la estructura de árbol para definir las relaciones entre los elementos de programa. En su mayor parte, los desarrolladores de WPF pueden crear una aplicación en código o definir partes de la aplicación en código XAML mientras piensan conceptualmente en la metáfora de árbol de objetos, pero estarán llamando a una API concreta o usando un marcado concreto para llamarla, en lugar de usar una API de manipulación de árbol de objetos general como se usaría en DOM XML. WPF expone dos clases auxiliares que proporcionan una vista de metáfora de árbol, <xref:System.Windows.LogicalTreeHelper> y <xref:System.Windows.Media.VisualTreeHelper>. Los términos árbol visual y árbol lógico también se usan en la documentación de WPF porque estos mismos árboles son útiles para entender el comportamiento de ciertas características clave de WPF. Define lo que representan el árbol visual y el árbol lógico de este tema, se describe cómo se relacionan estos árboles con un concepto de árbol de objetos general y presenta <xref:System.Windows.LogicalTreeHelper> y <xref:System.Windows.Media.VisualTreeHelper>s.  
  

  
<a name="element_tree"></a>   
## <a name="trees-in-wpf"></a>Árboles en WPF  
 La estructura de árbol más completa de [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] es el árbol de objetos. Si se define una página de aplicación en [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] y después se carga el [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], se crea una estructura de árbol basada en las relaciones de anidamiento de los elementos del marcado. Si se define una aplicación o una parte de la aplicación en código, se crea la estructura de árbol en función de cómo se asignen los valores de propiedad de las propiedades que implementan el modelo de contenido para un objeto determinado. En [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], hay dos maneras de conceptualizar el árbol de objetos completo y de notificarlo a su API pública: como el árbol lógico y como el árbol visual. Las distinciones entre árbol lógico y árbol visual no son siempre importantes, pero en ocasiones pueden dar lugar a problemas con algunos subsistemas de [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] y afectar a las decisiones que se toman en el marcado o el código.  
  
 Aunque no siempre se manipula directamente el árbol lógico o el árbol visual, entender los conceptos relativos a cómo interactúan ayuda a entender WPF como tecnología. Pensar en WPF como en un tipo de metáfora de árbol también es crucial para entender cómo funcionan la herencia de propiedades y el enrutamiento de eventos en [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].  
  
> [!NOTE]
>  Dado que el árbol de objetos es más un concepto que una API real, otra manera de pensar en el concepto es como un gráfico de objetos. En la práctica, hay relaciones entre los objetos en tiempo de ejecución en las que la metáfora del árbol no servirá. Pero la metáfora del árbol es lo bastante relevante para que la mayor parte de la documentación de WPF use el término árbol de objetos al hacer referencia a este concepto general, en especial con la interfaz de usuario definida en XAML.  
  
<a name="logical_tree"></a>   
## <a name="the-logical-tree"></a>El árbol lógico  
 En [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], el contenido se agrega a los elementos de la interfaz de usuario estableciendo propiedades de los objetos que respaldan esos elementos. Por ejemplo, se agregan elementos a un <xref:System.Windows.Controls.ListBox> control mediante la manipulación de su <xref:System.Windows.Controls.ItemsControl.Items%2A> propiedad. Al hacerlo, está colocando elementos en el <xref:System.Windows.Controls.ItemCollection> que es el <xref:System.Windows.Controls.ItemsControl.Items%2A> valor de propiedad. De forma similar, para agregar objetos a un <xref:System.Windows.Controls.DockPanel>, manipular su <xref:System.Windows.Controls.Panel.Children%2A> valor de propiedad. En este caso, va a agregar objetos a la <xref:System.Windows.Controls.UIElementCollection>. Para obtener un ejemplo de código, vea [Add an Element Dynamically](http://msdn.microsoft.com/en-us/d00f258a-7973-4de7-bc54-a3fc1f638419) (Agregar dinámicamente un elemento).  
  
 En [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)], al colocar los elementos de lista en un <xref:System.Windows.Controls.ListBox> o controles u otros elementos de interfaz de usuario en un <xref:System.Windows.Controls.DockPanel>, utiliza también el <xref:System.Windows.Controls.ItemsControl.Items%2A> y <xref:System.Windows.Controls.Panel.Children%2A> propiedades, explícita o implícitamente, como en el ejemplo siguiente.  
  
 [!code-xaml[TreeOvwsSupport#AllCode](../../../../samples/snippets/csharp/VS_Snippets_Wpf/TreeOvwsSupport/CS/page1.xaml#allcode)]  
  
 Si se procesara este código XAML como XML bajo un modelo de objetos de documento y se incluyeran como implícitas las etiquetas marcadas como comentario (lo que sería válido), el árbol DOM XML resultante incluiría elementos para `<ListBox.Items>` y los demás elementos implícitos. Pero XAML no se procesa de esta forma al leer el marcado y escribir en los objetos; el gráfico de objetos resultante no incluye literalmente `ListBox.Items`. Sin embargo tiene un <xref:System.Windows.Controls.ListBox> propiedad denominada `Items` que contiene un <xref:System.Windows.Controls.ItemCollection>y que <xref:System.Windows.Controls.ItemCollection> se inicializa pero vacío cuando el <xref:System.Windows.Controls.ListBox> XAML se procesa. A continuación, cada elemento de objeto secundario que exista como contenido de la <xref:System.Windows.Controls.ListBox> se agrega a la <xref:System.Windows.Controls.ItemCollection> analizador llamadas a `ItemCollection.Add`. Este ejemplo de procesamiento de XAML en un árbol de objetos es hasta ahora aparentemente un ejemplo en el que el árbol de objetos creado es básicamente el árbol lógico.  
  
 Pero el árbol lógico no es el gráfico de objetos completo que existe en tiempo de ejecución para la interfaz de usuario de la aplicación, incluso con los elementos de sintaxis implícitos de XAML factorizados. La razón principal para esto son los elementos visuales y las plantillas. Por ejemplo, considere la <xref:System.Windows.Controls.Button>. Los informes del árbol lógico del <xref:System.Windows.Controls.Button> objeto y también su cadena `Content`. Pero este botón es más complejo en el árbol de objetos en tiempo de ejecución. En concreto, el botón sólo aparece en pantalla de la manera que se debe a que un determinado <xref:System.Windows.Controls.Button> se aplicó la plantilla de control. Los objetos visuales que proceden de una plantilla aplicada (como definido por la plantilla <xref:System.Windows.Controls.Border> de gris oscuro alrededor del botón visual) no se notifican en el árbol lógico, incluso si está mirando el árbol lógico durante el tiempo de ejecución (como la administración de un evento de entrada desde el interfaz de usuario visible y, a continuación, leer el árbol lógico). Para buscar los elementos visuales de la plantilla, sería necesario examinar el árbol visual en su lugar.  
  
 Para más información sobre cómo se asigna la sintaxis de [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] al gráfico de objetos creado, y la sintaxis implícita en XAML, vea [Detalles de la sintaxis XAML](../../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md) o [Información general sobre XAML (WPF)](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md).  
  
<a name="tree_property_inheritance_event_routing"></a>   
### <a name="the-purpose-of-the-logical-tree"></a>Finalidad del árbol lógico  
 El árbol lógico existe para que los modelos de contenido puedan iterar fácilmente sus posibles objetos secundarios y para que los modelos de contenido puedan ser extensibles. Además, el árbol lógico proporciona un marco para algunas notificaciones, como, por ejemplo cuándo se cargan todos los objetos en él. Básicamente, el árbol lógico es una aproximación de un gráfico de objetos en tiempo de ejecución en el nivel de marco, que excluye los elementos visuales, pero es adecuado para muchas operaciones de consulta en la composición de su propia aplicación en tiempo de ejecución.  
  
 Además, se resuelven las referencias de recursos estáticos y dinámicos mirando hacia arriba a través del árbol lógico de <xref:System.Windows.FrameworkElement.Resources%2A> colecciones en el objeto solicitante inicial y, a continuación, continuar el árbol lógico y proteger cada uno de ellos <xref:System.Windows.FrameworkElement> (o <xref:System.Windows.FrameworkContentElement>) por otra cosa `Resources` valor que contiene un <xref:System.Windows.ResourceDictionary>, posiblemente que contiene esa clave. El árbol lógico se usa para la búsqueda de recursos cuando también está presente el árbol visual. Para más información sobre los diccionarios de recursos y la búsqueda, vea [Recursos XAML](../../../../docs/framework/wpf/advanced/xaml-resources.md).  
  
<a name="composition"></a>   
### <a name="composition-of-the-logical-tree"></a>Composición del árbol lógico  
 El árbol lógico se define en el marco WPF, lo que significa que el elemento base de WPF que es muy importante para las operaciones del árbol lógico sea <xref:System.Windows.FrameworkElement> o <xref:System.Windows.FrameworkContentElement>. Sin embargo, como se puede ver si realmente utiliza la <xref:System.Windows.LogicalTreeHelper> API, el árbol lógico contiene a veces nodos que no son <xref:System.Windows.FrameworkElement> o <xref:System.Windows.FrameworkContentElement>. Por ejemplo, el árbol lógico notifica el <xref:System.Windows.Controls.TextBlock.Text%2A> valor de un <xref:System.Windows.Controls.TextBlock>, que es una cadena.  
  
<a name="override_logical_tree"></a>   
### <a name="overriding-the-logical-tree"></a>Invalidar el árbol lógico  
 Los autores de controles avanzados pueden invalidar el árbol lógico si invalidan varias [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] que definen la forma en que un objeto general o un modelo de contenido agrega o quita objetos en dicho árbol. Para obtener un ejemplo de cómo invalidar el árbol lógico, vea [Invalidar el árbol lógico](../../../../docs/framework/wpf/advanced/how-to-override-the-logical-tree.md).  
  
<a name="pvi"></a>   
### <a name="property-value-inheritance"></a>Herencia de valores de propiedad  
 La herencia de valores de propiedad funciona a través de un árbol híbrido. Los metadatos reales que contiene el <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> propiedad que habilita la herencia de propiedades es el nivel de marco de WPF <xref:System.Windows.FrameworkPropertyMetadata> clase. Por lo tanto, el elemento primario que contiene el valor original y el objeto secundario que hereda ese valor deben ser <xref:System.Windows.FrameworkElement> o <xref:System.Windows.FrameworkContentElement>, y ambos deben formar parte de un árbol lógico. Pero para las propiedades de WPF existentes que admiten la herencia de propiedades, la herencia del valor de propiedad puede perpetuarse a través de un objeto intermedio que no está en el árbol lógico. Esto es especialmente pertinente para hacer que los elementos de plantilla usen cualquier valor de propiedad heredado establecido en la instancia basada en una plantilla o en los niveles aun más altos de composición de página y, por tanto, superiores en el árbol lógico. Para que la herencia del valor de propiedad funcione de forma coherente a través de un límite de este tipo, la propiedad que hereda se debe registrar como una propiedad adjunta y se debe seguir este patrón si se piensa definir una propiedad de dependencia personalizada con un comportamiento de herencia de propiedades. El árbol exacto que se usa para la herencia de propiedades no se puede prever completamente mediante un método de utilidad de clase auxiliar, ni siquiera en tiempo de ejecución. Para más información, vea [Herencia de valores de propiedad](../../../../docs/framework/wpf/advanced/property-value-inheritance.md).  
  
<a name="two_trees"></a>   
## <a name="the-visual-tree"></a>El árbol visual  
 Además del concepto de árbol lógico, en [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] también existe el concepto de árbol visual. El árbol visual describe la estructura de objetos visuales, tal como está representado por la <xref:System.Windows.Media.Visual> clase base. Cuando se escribe una plantilla para un control, se define o se vuelve a definir el árbol visual aplicable a ese control. El árbol visual también tiene interés para los desarrolladores que quieren un control más específico sobre el dibujo por motivos de optimización y rendimiento. Una exposición del árbol visual como parte de la programación convencional de aplicaciones de [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] consiste en que las rutas de evento de un evento enrutado recorren en su mayoría el árbol visual, no el árbol lógico. Esta sutileza de comportamiento de los eventos enrutados puede no resultar patente de forma inmediata salvo para los autores de controles. El enrutamiento de eventos a través del árbol visual permite que los controles que implementan la composición en el nivel visual controlen eventos o creen establecedores de eventos.  
  
<a name="trees_content"></a>   
## <a name="trees-content-elements-and-content-hosts"></a>Árboles, elementos de contenido y hosts de contenido  
 Elementos de contenido (clases que derivan de <xref:System.Windows.ContentElement>) no forman parte del árbol visual; no heredan de <xref:System.Windows.Media.Visual> y no tiene una representación visual. Para que aparezca en una interfaz de usuario, un <xref:System.Windows.ContentElement> se debe hospedar en un host de contenido que es un <xref:System.Windows.Media.Visual> y un participante del árbol lógico. Normalmente este tipo de objeto es un <xref:System.Windows.FrameworkElement>. Puede considerarse el host del contenido como una especie de "explorador" para el contenido que decide cómo mostrar ese contenido dentro de la zona de la pantalla que controla. Cuando se hospeda el contenido, puede participar en algunos procesos del árbol que suelen asociarse al árbol visual. Por lo general, el <xref:System.Windows.FrameworkElement> clase host incluye el código de implementación que los hospedado agrega <xref:System.Windows.ContentElement> a la ruta del evento a través de los subnodos del árbol lógico contenido, aunque el contenido hospedado no es parte del árbol visual es true. Esto es necesario para que un <xref:System.Windows.ContentElement> puede originar un evento enrutado que se enruta a cualquier elemento que no es él.  
  
<a name="tree_traversal"></a>   
## <a name="tree-traversal"></a>Exploración transversal del árbol  
 El <xref:System.Windows.LogicalTreeHelper> clase proporciona el <xref:System.Windows.LogicalTreeHelper.GetChildren%2A>, <xref:System.Windows.LogicalTreeHelper.GetParent%2A>, y <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> métodos para el cruce seguro del árbol lógico. En la mayoría de los casos, no debería tener que recorrer el árbol lógico de los controles existentes, porque casi siempre exponen sus elementos secundarios lógicos como una propiedad de colección dedicada que admite el acceso a colecciones como `Add`, un indexador, etc. Recorrido del árbol es principalmente un escenario que usa los autores de control que decidan no derivan de patrones de control previsto como <xref:System.Windows.Controls.ItemsControl> o <xref:System.Windows.Controls.Panel> donde ya se han definido las propiedades de la colección y que desean proporcionar su propia colección compatibilidad con la propiedad.  
  
 El árbol visual también admite una clase auxiliar para el cruce seguro del árbol visual, <xref:System.Windows.Media.VisualTreeHelper>. El árbol visual no se expone como cómodamente a través de propiedades específicas del control, por lo que la <xref:System.Windows.Media.VisualTreeHelper> clase es la manera recomendada para recorrer el árbol visual si es necesario para su escenario de programación. Para más información, consulte [Información general sobre la representación de gráficos en WPF](../../../../docs/framework/wpf/graphics-multimedia/wpf-graphics-rendering-overview.md).  
  
> [!NOTE]
>  A veces es necesario examinar el árbol visual de una plantilla aplicada. Se recomienda tener cuidado al usar esta técnica. Incluso si se atraviesa un árbol visual para un control que definen la plantilla, los consumidores de su control siempre pueden cambiar la plantilla estableciendo la <xref:System.Windows.Controls.Control.Template%2A> propiedad instancias y incluso el usuario final puede influir en la plantilla aplicada cambiando el tema del sistema.  
  
<a name="routes"></a>   
## <a name="routes-for-routed-events-as-a-tree"></a>Rutas para los eventos enrutados como un "árbol"  
 Como se ha mencionado antes, la ruta de cualquier evento enrutado determinado recorre una sola ruta de acceso predeterminada de un árbol, que es un híbrido de las representaciones del árbol visual y del árbol lógico. La ruta de evento puede recorrer el árbol hacia arriba o hacia abajo en función de si es un evento enrutado de tunelización o de propagación. El concepto de ruta de evento no tiene ninguna clase auxiliar que lo respalde directamente y que se pueda usar para "recorrer" la ruta de evento con independencia de que se genere un evento que se enrute realmente. Hay una clase que representa la ruta, <xref:System.Windows.EventRoute>, pero los métodos de esa clase suelen ser sólo para uso interno.  
  
<a name="resourcesandtrees"></a>   
## <a name="resource-dictionaries-and-trees"></a>Diccionarios de recursos y árboles  
 La búsqueda de diccionarios de recursos para todos los `Resources` definidos en una página recorre básicamente el árbol lógico. Los objetos que no están en el árbol lógico pueden hacer referencia a recursos con clave, pero la secuencia de búsqueda de recursos se inicia en el punto donde ese objeto está conectado al árbol lógico. En WPF, solo los nodos de árbol lógico pueden tener un `Resources` propiedad que contiene un <xref:System.Windows.ResourceDictionary>, por lo tanto, no hay ninguna ventaja en recorrer el árbol visual de buscar recursos con clave de un <xref:System.Windows.ResourceDictionary>.  
  
 Pero la búsqueda de recursos también se puede extender más allá del árbol lógico inmediato. Para el marcado de la aplicación, la búsqueda de recursos puede continuar con los diccionarios de recursos de nivel de aplicación y, después, con los valores de compatibilidad y sistema de tema a los que se hace referencia como propiedades estáticas o claves. Los propios temas también pueden hacer referencia a valores del sistema situados fuera del árbol lógico del tema si las referencias de recurso son dinámicas. Para más información sobre los diccionarios de recursos y la lógica de búsqueda, vea [Recursos XAML](../../../../docs/framework/wpf/advanced/xaml-resources.md).  
  
## <a name="see-also"></a>Vea también  
 [Información general sobre acciones del usuario](../../../../docs/framework/wpf/advanced/input-overview.md)  
 [Información general sobre la representación de gráficos en WPF](../../../../docs/framework/wpf/graphics-multimedia/wpf-graphics-rendering-overview.md)  
 [Información general sobre eventos enrutados](../../../../docs/framework/wpf/advanced/routed-events-overview.md)  
 [Inicialización de elementos de objeto no incluidos en un árbol de objetos](../../../../docs/framework/wpf/advanced/initialization-for-object-elements-not-in-an-object-tree.md)  
 [Arquitectura de WPF](../../../../docs/framework/wpf/advanced/wpf-architecture.md)
