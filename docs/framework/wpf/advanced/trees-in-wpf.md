---
title: Árboles
ms.date: 03/30/2017
helpviewer_keywords:
- logical tree [WPF]
- element tree [WPF]
- visual tree [WPF]
ms.assetid: e83f25e5-d66b-4fc7-92d2-50130c9a6649
ms.openlocfilehash: 696772da1ebee405493f2ff0e1481daf93d08ec7
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 03/12/2020
ms.locfileid: "79187017"
---
# <a name="trees-in-wpf"></a>Árboles en WPF
En muchas tecnologías, los elementos y componentes se organizan en una estructura de árbol en la que los desarrolladores manipulan directamente los nodos de objeto en el árbol para modificar la representación o el comportamiento de una aplicación. [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] también usa varias metáforas de la estructura de árbol para definir las relaciones entre los elementos de programa. En su mayor parte, los desarrolladores de WPF pueden crear una aplicación en código o definir partes de la aplicación en código XAML mientras piensan conceptualmente en la metáfora de árbol de objetos, pero estarán llamando a una API concreta o usando un marcado concreto para llamarla, en lugar de usar una API de manipulación de árbol de objetos general como se usaría en DOM XML. WPFWPF expone dos clases auxiliares <xref:System.Windows.LogicalTreeHelper> que <xref:System.Windows.Media.VisualTreeHelper>proporcionan una vista de metáfora de árbol y . Los términos árbol visual y árbol lógico también se usan en la documentación de WPF porque estos mismos árboles son útiles para entender el comportamiento de ciertas características clave de WPF. En este tema se define lo que representan el árbol visual y el árbol <xref:System.Windows.LogicalTreeHelper> lógico, se describe cómo se relacionan estos árboles con un concepto general de árbol de objetos e introducen y <xref:System.Windows.Media.VisualTreeHelper>s.  

<a name="element_tree"></a>
## <a name="trees-in-wpf"></a>Árboles en WPF  
 La estructura de árbol más completa de [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] es el árbol de objetos. Si se define una página de aplicación en [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] y después se carga el [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], se crea una estructura de árbol basada en las relaciones de anidamiento de los elementos del marcado. Si se define una aplicación o una parte de la aplicación en código, se crea la estructura de árbol en función de cómo se asignen los valores de propiedad de las propiedades que implementan el modelo de contenido para un objeto determinado. En [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], hay dos maneras de conceptualizar el árbol de objetos completo y de notificarlo a su API pública: como el árbol lógico y como el árbol visual. Las distinciones entre árbol lógico y árbol visual no son siempre importantes, pero en ocasiones pueden dar lugar a problemas con algunos subsistemas de [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] y afectar a las decisiones que se toman en el marcado o el código.  
  
 Aunque no siempre se manipula directamente el árbol lógico o el árbol visual, entender los conceptos relativos a cómo interactúan ayuda a entender WPF como tecnología. Pensar en WPF como en un tipo de metáfora de árbol también es crucial para entender cómo funcionan la herencia de propiedades y el enrutamiento de eventos en [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].  
  
> [!NOTE]
> Dado que el árbol de objetos es más un concepto que una API real, otra manera de pensar en el concepto es como un gráfico de objetos. En la práctica, hay relaciones entre los objetos en tiempo de ejecución en las que la metáfora del árbol no servirá. Pero la metáfora del árbol es lo bastante relevante para que la mayor parte de la documentación de WPF use el término árbol de objetos al hacer referencia a este concepto general, en especial con la interfaz de usuario definida en XAML.  
  
<a name="logical_tree"></a>
## <a name="the-logical-tree"></a>El árbol lógico  
 En [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], el contenido se agrega a los elementos de la interfaz de usuario estableciendo propiedades de los objetos que respaldan esos elementos. Por ejemplo, se agregan <xref:System.Windows.Controls.ListBox> elementos a <xref:System.Windows.Controls.ItemsControl.Items%2A> un control manipulando su propiedad. Al hacer esto, está colocando elementos en el <xref:System.Windows.Controls.ItemCollection> que es el <xref:System.Windows.Controls.ItemsControl.Items%2A> valor de propiedad. De forma similar, <xref:System.Windows.Controls.DockPanel>para agregar <xref:System.Windows.Controls.Panel.Children%2A> objetos a un , se manipula su valor de propiedad. Aquí, está agregando <xref:System.Windows.Controls.UIElementCollection>objetos al archivo . Para obtener un ejemplo de código, vea [Cómo: Agregar un elemento dinámicamente](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ms752374(v=vs.100)).  
  
 En [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)], cuando se colocan <xref:System.Windows.Controls.ListBox> elementos de lista <xref:System.Windows.Controls.DockPanel>en un o <xref:System.Windows.Controls.ItemsControl.Items%2A> <xref:System.Windows.Controls.Panel.Children%2A> controles u otros elementos de interfaz de usuario en un , también se usan las propiedades y, ya sea explícita o implícitamente, como en el ejemplo siguiente.  
  
 [!code-xaml[TreeOvwsSupport#AllCode](~/samples/snippets/csharp/VS_Snippets_Wpf/TreeOvwsSupport/CS/page1.xaml#allcode)]  
  
 Si se procesara este código XAML como XML bajo un modelo de objetos de documento y se incluyeran como implícitas las etiquetas marcadas como comentario (lo que sería válido), el árbol DOM XML resultante incluiría elementos para `<ListBox.Items>` y los demás elementos implícitos. Pero XAML no se procesa de esta forma al leer el marcado y escribir en los objetos; el gráfico de objetos resultante no incluye literalmente `ListBox.Items`. Sin embargo, <xref:System.Windows.Controls.ListBox> tiene `Items` una <xref:System.Windows.Controls.ItemCollection>propiedad denominada <xref:System.Windows.Controls.ItemCollection> que contiene un <xref:System.Windows.Controls.ListBox> , y que se inicializa pero vacía cuando se procesa el XAML. A continuación, cada elemento de objeto <xref:System.Windows.Controls.ListBox> secundario que <xref:System.Windows.Controls.ItemCollection> existe como contenido `ItemCollection.Add`para el se agrega a la por llamadas de analizador a . Este ejemplo de procesamiento de XAML en un árbol de objetos es hasta ahora aparentemente un ejemplo en el que el árbol de objetos creado es básicamente el árbol lógico.  
  
 Sin embargo, el árbol lógico no es el gráfico de objetos completo que existe para la interfaz de usuario de la aplicación en tiempo de ejecución, incluso con los elementos de sintaxis implícita XAML factorizados. La razón principal de esto son los objetos visuales y las plantillas. Por ejemplo, <xref:System.Windows.Controls.Button>considere el archivo . El árbol lógico <xref:System.Windows.Controls.Button> notifica el `Content`objeto y también su cadena. Pero este botón es más complejo en el árbol de objetos en tiempo de ejecución. En particular, el botón sólo aparece en <xref:System.Windows.Controls.Button> la pantalla de la forma en que lo hace porque se aplicó una plantilla de control específica. Los objetos visuales que proceden de una <xref:System.Windows.Controls.Border> plantilla aplicada (como la plantilla definida de gris oscuro alrededor del botón visual) no se notifican en el árbol lógico, incluso si está mirando el árbol lógico durante el tiempo de ejecución (por ejemplo, controlar un evento de entrada de la interfaz de usuario visible y, a continuación, leer el árbol lógico). Para buscar los elementos visuales de la plantilla, sería necesario examinar el árbol visual en su lugar.  
  
 Para más información sobre cómo se asigna la sintaxis de [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] al gráfico de objetos creado, y la sintaxis implícita en XAML, vea [Detalles de la sintaxis XAML](xaml-syntax-in-detail.md) o [Información general sobre XAML (WPF)](xaml-overview-wpf.md).  
  
<a name="tree_property_inheritance_event_routing"></a>
### <a name="the-purpose-of-the-logical-tree"></a>Finalidad del árbol lógico  
 El árbol lógico existe para que los modelos de contenido puedan iterar fácilmente sus posibles objetos secundarios y para que los modelos de contenido puedan ser extensibles. Además, el árbol lógico proporciona un marco para algunas notificaciones, como, por ejemplo cuándo se cargan todos los objetos en él. Básicamente, el árbol lógico es una aproximación de un gráfico de objetos en tiempo de ejecución en el nivel de marco, que excluye los elementos visuales, pero es adecuado para muchas operaciones de consulta en la composición de su propia aplicación en tiempo de ejecución.  
  
 Además, las referencias de recursos estáticos y dinámicos <xref:System.Windows.FrameworkElement.Resources%2A> se resuelven mirando hacia arriba a través del <xref:System.Windows.FrameworkElement> árbol <xref:System.Windows.FrameworkContentElement>lógico `Resources` para las <xref:System.Windows.ResourceDictionary>colecciones en el objeto solicitante inicial y, a continuación, continuando hacia arriba en el árbol lógico y comprobando cada uno (o ) para otro valor que contiene un , posiblemente que contenga esa clave. El árbol lógico se usa para la búsqueda de recursos cuando también está presente el árbol visual. Para más información sobre los diccionarios de recursos y la búsqueda, vea [Recursos XAML](../../../desktop-wpf/fundamentals/xaml-resources-define.md).  
  
<a name="composition"></a>
### <a name="composition-of-the-logical-tree"></a>Composición del árbol lógico  
 El árbol lógico se define en el wpfWPF nivel de marco, lo que significa <xref:System.Windows.FrameworkElement> <xref:System.Windows.FrameworkContentElement>que el wpfWPF elemento base que es más relevante para las operaciones de árbol lógico es o . Sin embargo, como puede ver <xref:System.Windows.LogicalTreeHelper> si realmente utiliza la API, <xref:System.Windows.FrameworkElement> el <xref:System.Windows.FrameworkContentElement>árbol lógico a veces contiene nodos que no son ninguno o . Por ejemplo, el árbol <xref:System.Windows.Controls.TextBlock.Text%2A> lógico <xref:System.Windows.Controls.TextBlock>notifica el valor de un , que es una cadena.  
  
<a name="override_logical_tree"></a>
### <a name="overriding-the-logical-tree"></a>Invalidar el árbol lógico  
 Los autores de controles avanzados pueden invalidar el árbol lógico reemplazando varias API que definen cómo un objeto general o modelo de contenido agrega o quita objetos dentro del árbol lógico. Para obtener un ejemplo de cómo invalidar el árbol lógico, vea [Invalidar el árbol lógico](how-to-override-the-logical-tree.md).  
  
<a name="pvi"></a>
### <a name="property-value-inheritance"></a>Herencia de valores de propiedad  
 La herencia de valores de propiedad funciona a través de un árbol híbrido. Los metadatos reales <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> que contienen la propiedad que <xref:System.Windows.FrameworkPropertyMetadata> habilita la herencia de propiedades es la clase de nivel de marco WPF. Por lo tanto, tanto el elemento primario que contiene el valor <xref:System.Windows.FrameworkElement> original <xref:System.Windows.FrameworkContentElement>como el objeto secundario que hereda ese valor deben ser o , y ambos deben formar parte de algún árbol lógico. Pero para las propiedades de WPF existentes que admiten la herencia de propiedades, la herencia del valor de propiedad puede perpetuarse a través de un objeto intermedio que no está en el árbol lógico. Esto es especialmente pertinente para hacer que los elementos de plantilla usen cualquier valor de propiedad heredado establecido en la instancia basada en una plantilla o en los niveles aun más altos de composición de página y, por tanto, superiores en el árbol lógico. Para que la herencia del valor de propiedad funcione de forma coherente a través de un límite de este tipo, la propiedad que hereda se debe registrar como una propiedad adjunta y se debe seguir este patrón si se piensa definir una propiedad de dependencia personalizada con un comportamiento de herencia de propiedades. El árbol exacto que se usa para la herencia de propiedades no se puede prever completamente mediante un método de utilidad de clase del asistente, ni siquiera en tiempo de ejecución. Para más información, vea [Herencia de valores de propiedad](property-value-inheritance.md).  
  
<a name="two_trees"></a>
## <a name="the-visual-tree"></a>El árbol visual  
 Además del concepto de árbol lógico, en [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] también existe el concepto de árbol visual. El árbol visual describe la estructura de objetos <xref:System.Windows.Media.Visual> visuales, representada por la clase base. Cuando se escribe una plantilla para un control, se define o se vuelve a definir el árbol visual aplicable a ese control. El árbol visual también tiene interés para los desarrolladores que quieren un control más específico sobre el dibujo por motivos de optimización y rendimiento. Una exposición del árbol visual como parte de la programación convencional de aplicaciones de [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] consiste en que las rutas de evento de un evento enrutado recorren en su mayoría el árbol visual, no el árbol lógico. Esta sutileza de comportamiento de los eventos enrutados puede no resultar patente de forma inmediata salvo para los autores de controles. El enrutamiento de eventos a través del árbol visual permite que los controles que implementan la composición en el nivel visual controlen eventos o creen establecedores de eventos.  
  
<a name="trees_content"></a>
## <a name="trees-content-elements-and-content-hosts"></a>Árboles, elementos de contenido y hosts de contenido  
 Los elementos de <xref:System.Windows.ContentElement>contenido (clases que derivan de ) no forman parte del árbol visual; no heredan <xref:System.Windows.Media.Visual> de y no tienen una representación visual. Para aparecer en una interfaz <xref:System.Windows.ContentElement> de usuario en absoluto, un <xref:System.Windows.Media.Visual> debe hospedarse en un host de contenido que es a y un participante de árbol lógico. Por lo general, <xref:System.Windows.FrameworkElement>un objeto de este tipo es un archivo . Puede considerarse el host del contenido como una especie de "explorador" para el contenido que decide cómo mostrar ese contenido dentro de la zona de la pantalla que controla. Cuando se hospeda el contenido, puede participar en algunos procesos del árbol que suelen asociarse al árbol visual. Por lo <xref:System.Windows.FrameworkElement> general, la clase host incluye <xref:System.Windows.ContentElement> código de implementación que agrega cualquier hospedado a la ruta de eventos a través de subnodos del árbol lógico de contenido, aunque el contenido hospedado no forma parte del árbol visual verdadero. Esto es necesario <xref:System.Windows.ContentElement> para que a pueda originar un evento enrutado que enruta a cualquier elemento que no sea él mismo.  
  
<a name="tree_traversal"></a>
## <a name="tree-traversal"></a>Exploración transversal del árbol  
 La <xref:System.Windows.LogicalTreeHelper> clase <xref:System.Windows.LogicalTreeHelper.GetChildren%2A>proporciona <xref:System.Windows.LogicalTreeHelper.GetParent%2A>el <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> , , y los métodos para el recorrido lógico del árbol. En la mayoría de los casos, no debería tener que recorrer el árbol lógico de los controles existentes, porque casi siempre exponen sus elementos secundarios lógicos como una propiedad de colección dedicada que admite el acceso a colecciones como `Add`, un indexador, etc. El recorrido del árbol es principalmente un escenario que usan los autores de <xref:System.Windows.Controls.ItemsControl> <xref:System.Windows.Controls.Panel> controles que deciden no derivar de patrones de control previstos, como o donde las propiedades de colección ya están definidas, y que tienen la intención de proporcionar su propia compatibilidad con propiedades de colección.  
  
 El árbol visual también admite una clase auxiliar <xref:System.Windows.Media.VisualTreeHelper>para el recorrido del árbol visual, . El árbol visual no se expone tan convenientemente <xref:System.Windows.Media.VisualTreeHelper> a través de propiedades específicas del control, por lo que la clase es la forma recomendada de recorrer el árbol visual si es necesario para el escenario de programación. Para más información, consulte [Información general sobre la representación de gráficos en WPF](../graphics-multimedia/wpf-graphics-rendering-overview.md).  
  
> [!NOTE]
> A veces es necesario examinar el árbol visual de una plantilla aplicada. Se recomienda tener cuidado al usar esta técnica. Incluso si está recorriendo un árbol visual para un control donde se define la plantilla, <xref:System.Windows.Controls.Control.Template%2A> los consumidores del control siempre pueden cambiar la plantilla estableciendo la propiedad en las instancias, e incluso el usuario final puede influir en la plantilla aplicada cambiando el tema del sistema.  
  
<a name="routes"></a>
## <a name="routes-for-routed-events-as-a-tree"></a>Rutas para los eventos enrutados como un "árbol"  
 Como se ha mencionado antes, la ruta de cualquier evento enrutado determinado recorre una sola ruta de acceso predeterminada de un árbol, que es un híbrido de las representaciones del árbol visual y del árbol lógico. La ruta de evento puede recorrer el árbol hacia arriba o hacia abajo en función de si es un evento enrutado de tunelización o de propagación. El concepto de ruta de evento no tiene ninguna clase del asistente que lo respalde directamente y que se pueda usar para "recorrer" la ruta de evento con independencia de que se genere un evento que se enrute realmente. Hay una clase que representa <xref:System.Windows.EventRoute>la ruta, pero los métodos de esa clase son generalmente solo para uso interno.  
  
<a name="resourcesandtrees"></a>
## <a name="resource-dictionaries-and-trees"></a>Diccionarios de recursos y árboles  
 La búsqueda de diccionarios de recursos para todos los `Resources` definidos en una página recorre básicamente el árbol lógico. Los objetos que no están en el árbol lógico pueden hacer referencia a recursos con clave, pero la secuencia de búsqueda de recursos se inicia en el punto donde ese objeto está conectado al árbol lógico. En WPFWPF, solo los `Resources` nodos de <xref:System.Windows.ResourceDictionary>árbol lógico pueden tener una propiedad que contenga un archivo <xref:System.Windows.ResourceDictionary>, por lo tanto, no hay ninguna ventaja en recorrer el árbol visual en busca de recursos con clave de un archivo .  
  
 Pero la búsqueda de recursos también se puede extender más allá del árbol lógico inmediato. Para el marcado de la aplicación, la búsqueda de recursos puede continuar con los diccionarios de recursos de nivel de aplicación y, después, con los valores de compatibilidad y sistema de tema a los que se hace referencia como propiedades estáticas o claves. Los propios temas también pueden hacer referencia a valores del sistema situados fuera del árbol lógico del tema si las referencias de recurso son dinámicas. Para más información sobre los diccionarios de recursos y la lógica de búsqueda, vea [Recursos XAML](../../../desktop-wpf/fundamentals/xaml-resources-define.md).  
  
## <a name="see-also"></a>Consulte también

- [Información general sobre acciones del usuario](input-overview.md)
- [Información general sobre la representación de gráficos en WPF](../graphics-multimedia/wpf-graphics-rendering-overview.md)
- [Información general sobre eventos enrutados](routed-events-overview.md)
- [Inicialización de elementos de objeto no incluidos en un árbol de objetos](initialization-for-object-elements-not-in-an-object-tree.md)
- [Arquitectura de WPF](wpf-architecture.md)
