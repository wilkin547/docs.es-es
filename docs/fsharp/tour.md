---
title: Paseo por F#
description: Examine algunas de las características claves del lenguaje en esta visita con ejemplos de código de programación F#.
ms.date: 02/09/2020
ms.openlocfilehash: ac2eef40e2dbc494e41a9760f0a70edb0f7ce399
ms.sourcegitcommit: 011314e0c8eb4cf4a11d92078f58176c8c3efd2d
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 02/11/2020
ms.locfileid: "77124577"
---
# <a name="tour-of-f"></a><span data-ttu-id="30e02-103">Paseo por F\#</span><span class="sxs-lookup"><span data-stu-id="30e02-103">Tour of F\#</span></span>

<span data-ttu-id="30e02-104">Es la mejor manera para obtener información sobre F# leer y escribir código de F#.</span><span class="sxs-lookup"><span data-stu-id="30e02-104">The best way to learn about F# is to read and write F# code.</span></span> <span data-ttu-id="30e02-105">En este artículo actuará como un paseo por algunas de las características clave del lenguaje F# y proporcionarle algunos fragmentos de código que se pueden ejecutar en el equipo.</span><span class="sxs-lookup"><span data-stu-id="30e02-105">This article will act as a tour through some of the key features of the F# language and give you some code snippets that you can execute on your machine.</span></span> <span data-ttu-id="30e02-106">Para obtener información sobre cómo configurar un entorno de desarrollo, consulte [Introducción](get-started/index.md).</span><span class="sxs-lookup"><span data-stu-id="30e02-106">To learn about setting up a development environment, check out [Getting Started](get-started/index.md).</span></span>

<span data-ttu-id="30e02-107">Hay dos conceptos principales en F#: tipos y funciones.</span><span class="sxs-lookup"><span data-stu-id="30e02-107">There are two primary concepts in F#: functions and types.</span></span>  <span data-ttu-id="30e02-108">En este paseo se resaltan las características del lenguaje que se encuentran en estos dos conceptos.</span><span class="sxs-lookup"><span data-stu-id="30e02-108">This tour will emphasize features of the language which fall into these two concepts.</span></span>

## <a name="executing-the-code-online"></a><span data-ttu-id="30e02-109">Ejecutar el código en línea</span><span class="sxs-lookup"><span data-stu-id="30e02-109">Executing the code online</span></span>

<span data-ttu-id="30e02-110">Si no tiene F# instalado en el equipo, puede ejecutar todos los ejemplos en el explorador con [try F# on webassembly](https://tryfsharp.fsbolero.io/).</span><span class="sxs-lookup"><span data-stu-id="30e02-110">If you don't have F# installed on your machine, you can execute all of the samples in your browser with [Try F# on WebAssembly](https://tryfsharp.fsbolero.io/).</span></span> <span data-ttu-id="30e02-111">Fable es un dialecto de F# que se ejecuta directamente en el explorador.</span><span class="sxs-lookup"><span data-stu-id="30e02-111">Fable is a dialect of F# that executes directly in your browser.</span></span> <span data-ttu-id="30e02-112">Para ver los ejemplos siguientes en REPL, consulte los **ejemplos > Aprenda > Tour F#**  en la barra de menús de la izquierda del fable repl.</span><span class="sxs-lookup"><span data-stu-id="30e02-112">To view the samples that follow in the REPL, check out **Samples > Learn > Tour of F#** in the left-hand menu bar of the Fable REPL.</span></span>

## <a name="functions-and-modules"></a><span data-ttu-id="30e02-113">Funciones y módulos</span><span class="sxs-lookup"><span data-stu-id="30e02-113">Functions and Modules</span></span>

<span data-ttu-id="30e02-114">Las partes más fundamentales de cualquier F# programa son ***funciones*** organizadas en ***módulos***.</span><span class="sxs-lookup"><span data-stu-id="30e02-114">The most fundamental pieces of any F# program are ***functions*** organized into ***modules***.</span></span>  <span data-ttu-id="30e02-115">[Las funciones](./language-reference/functions/index.md) realizan trabajos en entradas para generar salidas y se organizan en [módulos](./language-reference/modules.md), que son la manera principal de F#agrupar elementos.</span><span class="sxs-lookup"><span data-stu-id="30e02-115">[Functions](./language-reference/functions/index.md) perform work on inputs to produce outputs, and they are organized under [Modules](./language-reference/modules.md), which are the primary way you group things in F#.</span></span>  <span data-ttu-id="30e02-116">Se definen mediante el [enlace de`let`](./language-reference/functions/let-bindings.md), que asigna un nombre a la función y definen sus argumentos.</span><span class="sxs-lookup"><span data-stu-id="30e02-116">They are defined using the [`let` binding](./language-reference/functions/let-bindings.md), which give the function a name and define its arguments.</span></span>

[!code-fsharp[BasicFunctions](~/samples/snippets/fsharp/tour.fs#L101-L133)]

<span data-ttu-id="30e02-117">`let` enlaces también son cómo enlazar un valor a un nombre, de forma similar a una variable en otros lenguajes.</span><span class="sxs-lookup"><span data-stu-id="30e02-117">`let` bindings are also how you bind a value to a name, similar to a variable in other languages.</span></span>  <span data-ttu-id="30e02-118">de forma predeterminada, los enlaces de `let` son ***inmutables*** , lo que significa que una vez que un valor o una función se enlaza a un nombre, no se puede cambiar en contexto.</span><span class="sxs-lookup"><span data-stu-id="30e02-118">`let` bindings are ***immutable*** by default, which means that once a value or function is bound to a name, it cannot be changed in-place.</span></span>  <span data-ttu-id="30e02-119">Esto contrasta con las variables de otros lenguajes, que son ***mutables***, lo que significa que sus valores se pueden cambiar en cualquier momento en el tiempo.</span><span class="sxs-lookup"><span data-stu-id="30e02-119">This is in contrast to variables in other languages, which are ***mutable***, meaning their values can be changed at any point in time.</span></span>  <span data-ttu-id="30e02-120">Si necesita un enlace mutable, puede usar `let mutable ...` sintaxis.</span><span class="sxs-lookup"><span data-stu-id="30e02-120">If you require a mutable binding, you can use `let mutable ...` syntax.</span></span>

[!code-fsharp[Immutability](~/samples/snippets/fsharp/tour.fs#L75-L94)]

## <a name="numbers-booleans-and-strings"></a><span data-ttu-id="30e02-121">Números, valores booleanos y cadenas</span><span class="sxs-lookup"><span data-stu-id="30e02-121">Numbers, Booleans, and Strings</span></span>

<span data-ttu-id="30e02-122">Como lenguaje .NET, F# admite los mismos [tipos primitivos](language-reference/basic-types.md) subyacentes que existen en .net.</span><span class="sxs-lookup"><span data-stu-id="30e02-122">As a .NET language, F# supports the same underlying [primitive types](language-reference/basic-types.md) that exist in .NET.</span></span>

<span data-ttu-id="30e02-123">Le mostramos cómo varios tipos numéricos se representan en F#:</span><span class="sxs-lookup"><span data-stu-id="30e02-123">Here is how various numeric types are represented in F#:</span></span>

[!code-fsharp[Numbers](~/samples/snippets/fsharp/tour.fs#L49-L68)]

<span data-ttu-id="30e02-124">Estos son los valores booleanos y la lógica condicional básica tiene el siguiente aspecto:</span><span class="sxs-lookup"><span data-stu-id="30e02-124">Here's what Boolean values and performing basic conditional logic looks like:</span></span>

[!code-fsharp[Bools](~/samples/snippets/fsharp/tour.fs#L142-L152)]

<span data-ttu-id="30e02-125">Y este es el aspecto básico de la manipulación de [cadenas](./language-reference/strings.md) :</span><span class="sxs-lookup"><span data-stu-id="30e02-125">And here's what basic [string](./language-reference/strings.md) manipulation looks like:</span></span>

[!code-fsharp[Strings](~/samples/snippets/fsharp/tour.fs#L158-L180)]

## <a name="tuples"></a><span data-ttu-id="30e02-126">Tuplas</span><span class="sxs-lookup"><span data-stu-id="30e02-126">Tuples</span></span>

<span data-ttu-id="30e02-127">Las [tuplas](./language-reference/tuples.md) son un gran trato F#en.</span><span class="sxs-lookup"><span data-stu-id="30e02-127">[Tuples](./language-reference/tuples.md) are a big deal in F#.</span></span>  <span data-ttu-id="30e02-128">Son una agrupación de valores sin nombre, pero ordenados, que se pueden tratar como propios valores.</span><span class="sxs-lookup"><span data-stu-id="30e02-128">They are a grouping of unnamed, but ordered values, that can be treated as values themselves.</span></span>  <span data-ttu-id="30e02-129">Considérelos como valores que se agregan a partir de otros valores.</span><span class="sxs-lookup"><span data-stu-id="30e02-129">Think of them as values which are aggregated from other values.</span></span>  <span data-ttu-id="30e02-130">Tienen muchos usos, como la devolución cómoda de varios valores de una función o la agrupación de valores para una conveniencia ad hoc.</span><span class="sxs-lookup"><span data-stu-id="30e02-130">They have many uses, such as conveniently returning multiple values from a function, or grouping values for some ad-hoc convenience.</span></span>

[!code-fsharp[Tuples](~/samples/snippets/fsharp/tour.fs#L186-L203)]

<span data-ttu-id="30e02-131">También puede crear tuplas `struct`.</span><span class="sxs-lookup"><span data-stu-id="30e02-131">You can also create `struct` tuples.</span></span>  <span data-ttu-id="30e02-132">También interoperan totalmente con las tuplas de C# 7/Visual Basic 15, que también se `struct` tuplas:</span><span class="sxs-lookup"><span data-stu-id="30e02-132">These also interoperate fully with C#7/Visual Basic 15 tuples, which are also `struct` tuples:</span></span>

[!code-fsharp[Tuples](~/samples/snippets/fsharp/tour.fs#L205-L218)]

<span data-ttu-id="30e02-133">Es importante tener en cuenta que, dado que `struct` tuplas son tipos de valor, no se pueden convertir implícitamente en tuplas de referencia, o viceversa.</span><span class="sxs-lookup"><span data-stu-id="30e02-133">It's important to note that because `struct` tuples are value types, they cannot be implicitly converted to reference tuples, or vice versa.</span></span>  <span data-ttu-id="30e02-134">Debe convertir explícitamente entre una tupla de referencia y struct.</span><span class="sxs-lookup"><span data-stu-id="30e02-134">You must explicitly convert between a reference and struct tuple.</span></span>

## <a name="pipelines-and-composition"></a><span data-ttu-id="30e02-135">Canalizaciones y composición</span><span class="sxs-lookup"><span data-stu-id="30e02-135">Pipelines and Composition</span></span>

<span data-ttu-id="30e02-136">Los operadores de canalización como `|>` se usan en gran medida al F#procesar los datos en.</span><span class="sxs-lookup"><span data-stu-id="30e02-136">Pipe operators such as `|>` are used extensively when processing data in F#.</span></span> <span data-ttu-id="30e02-137">Estos operadores son funciones que permiten establecer "canalizaciones" de funciones de una manera flexible.</span><span class="sxs-lookup"><span data-stu-id="30e02-137">These operators are functions that allow you to establish "pipelines" of functions in a flexible manner.</span></span> <span data-ttu-id="30e02-138">En el ejemplo siguiente se describe cómo puede aprovechar estos operadores para crear una canalización funcional sencilla:</span><span class="sxs-lookup"><span data-stu-id="30e02-138">The following example walks through how you can take advantage of these operators to build a simple functional pipeline:</span></span>

[!code-fsharp[Pipelines](~/samples/snippets/fsharp/tour.fs#L227-L282)]

<span data-ttu-id="30e02-139">En el ejemplo anterior se utilizaban muchas características F#de, incluidas las funciones de procesamiento de lista, las funciones de primera clase y la [aplicación parcial](./language-reference/functions/index.md#partial-application-of-arguments).</span><span class="sxs-lookup"><span data-stu-id="30e02-139">The previous sample made use of many features of F#, including list processing functions, first-class functions, and [partial application](./language-reference/functions/index.md#partial-application-of-arguments).</span></span> <span data-ttu-id="30e02-140">Aunque una comprensión profunda de cada uno de estos conceptos puede ser un poco más avanzada, debe estar claro cómo se pueden usar las funciones para procesar datos al crear canalizaciones.</span><span class="sxs-lookup"><span data-stu-id="30e02-140">Although a deep understanding of each of those concepts can become somewhat advanced, it should be clear how easily functions can be used to process data when building pipelines.</span></span>

## <a name="lists-arrays-and-sequences"></a><span data-ttu-id="30e02-141">Listas, matrices y secuencias</span><span class="sxs-lookup"><span data-stu-id="30e02-141">Lists, Arrays, and Sequences</span></span>

<span data-ttu-id="30e02-142">Las listas, matrices y las secuencias son tres tipos de colección principal en la biblioteca básica de F#.</span><span class="sxs-lookup"><span data-stu-id="30e02-142">Lists, Arrays, and Sequences are three primary collection types in the F# core library.</span></span>

<span data-ttu-id="30e02-143">[Las listas](./language-reference/lists.md) son colecciones ordenadas e inmutables de elementos del mismo tipo.</span><span class="sxs-lookup"><span data-stu-id="30e02-143">[Lists](./language-reference/lists.md) are ordered, immutable collections of elements of the same type.</span></span>  <span data-ttu-id="30e02-144">Se trata de listas vinculadas individualmente, lo que significa que están pensadas para la enumeración, pero es una opción deficiente para el acceso aleatorio y la concatenación si son grandes.</span><span class="sxs-lookup"><span data-stu-id="30e02-144">They are singly-linked lists, which means they are meant for enumeration, but a poor choice for random access and concatenation if they're large.</span></span>  <span data-ttu-id="30e02-145">Esto contrasta con las listas de otros lenguajes populares, que normalmente no usan una lista vinculada individualmente para representar listas.</span><span class="sxs-lookup"><span data-stu-id="30e02-145">This in contrast to Lists in other popular languages, which typically do not use a singly-linked list to represent Lists.</span></span>

[!code-fsharp[Lists](~/samples/snippets/fsharp/tour.fs#L309-L359)]

<span data-ttu-id="30e02-146">Las [matrices](./language-reference/arrays.md) son colecciones *mutables* de tamaño fijo de elementos del mismo tipo.</span><span class="sxs-lookup"><span data-stu-id="30e02-146">[Arrays](./language-reference/arrays.md) are fixed-size, *mutable* collections of elements of the same type.</span></span>  <span data-ttu-id="30e02-147">Se admiten el acceso aleatorio rápido de elementos y son más rápidas que F# listas porque son simplemente contiguos bloques de memoria.</span><span class="sxs-lookup"><span data-stu-id="30e02-147">They support fast random access of elements, and are faster than F# lists because they are just contiguous blocks of memory.</span></span>

[!code-fsharp[Arrays](~/samples/snippets/fsharp/tour.fs#L368-L407)]

<span data-ttu-id="30e02-148">Las [secuencias](./language-reference/sequences.md) son una serie lógica de elementos, todo del mismo tipo.</span><span class="sxs-lookup"><span data-stu-id="30e02-148">[Sequences](./language-reference/sequences.md) are a logical series of elements, all of the same type.</span></span>  <span data-ttu-id="30e02-149">Se trata de un tipo más general que las listas y matrices, capaz de ser su "vista" en cualquier serie lógica de elementos.</span><span class="sxs-lookup"><span data-stu-id="30e02-149">These are a more general type than Lists and Arrays, capable of being your "view" into any logical series of elements.</span></span>  <span data-ttu-id="30e02-150">También destacan porque pueden ser ***Lazy***, lo que significa que los elementos solo se pueden calcular cuando son necesarios.</span><span class="sxs-lookup"><span data-stu-id="30e02-150">They also stand out because they can be ***lazy***, which means that elements can be computed only when they are needed.</span></span>

[!code-fsharp[Sequences](~/samples/snippets/fsharp/tour.fs#L418-L452)]

## <a name="recursive-functions"></a><span data-ttu-id="30e02-151">Funciones recursivas</span><span class="sxs-lookup"><span data-stu-id="30e02-151">Recursive Functions</span></span>

<span data-ttu-id="30e02-152">El procesamiento de colecciones o secuencias de elementos se realiza normalmente con F# [recursividad](./language-reference/functions/index.md#recursive-functions) en.</span><span class="sxs-lookup"><span data-stu-id="30e02-152">Processing collections or sequences of elements is typically done with [recursion](./language-reference/functions/index.md#recursive-functions) in F#.</span></span>  <span data-ttu-id="30e02-153">Aunque F# tiene compatibilidad con bucles y la programación imperativa, recursividad es preferible porque es más fácil de garantizar la corrección.</span><span class="sxs-lookup"><span data-stu-id="30e02-153">Although F# has support for loops and imperative programming, recursion is preferred because it is easier to guarantee correctness.</span></span>

> [!NOTE]
> <span data-ttu-id="30e02-154">En el ejemplo siguiente se usa la coincidencia de patrones a través de la expresión `match`.</span><span class="sxs-lookup"><span data-stu-id="30e02-154">The following example makes use of the pattern matching via the `match` expression.</span></span>  <span data-ttu-id="30e02-155">Esta construcción fundamental se trata más adelante en este artículo.</span><span class="sxs-lookup"><span data-stu-id="30e02-155">This fundamental construct is covered later in this article.</span></span>

[!code-fsharp[RecursiveFunctions](~/samples/snippets/fsharp/tour.fs#L461-L500)]

<span data-ttu-id="30e02-156">F# también tiene compatibilidad total para la optimización de llamar al final, que es una forma de optimizar las llamadas recursivas para que sean tan rápidos como una construcción de bucle.</span><span class="sxs-lookup"><span data-stu-id="30e02-156">F# also has full support for Tail Call Optimization, which is a way to optimize recursive calls so that they are just as fast as a loop construct.</span></span>

## <a name="record-and-discriminated-union-types"></a><span data-ttu-id="30e02-157">Tipos de unión de registro y discriminado</span><span class="sxs-lookup"><span data-stu-id="30e02-157">Record and Discriminated Union Types</span></span>

<span data-ttu-id="30e02-158">Registro y tipos de unión son dos tipos de datos fundamentales utilizados en el código de F# y suelen ser la mejor manera de representar los datos en un programa de F#.</span><span class="sxs-lookup"><span data-stu-id="30e02-158">Record and Union types are two fundamental data types used in F# code, and are generally the best way to represent data in an F# program.</span></span>  <span data-ttu-id="30e02-159">Aunque esto hace que sean similares a las clases de otros lenguajes, una de sus principales diferencias es que tienen una semántica de igualdad estructural.</span><span class="sxs-lookup"><span data-stu-id="30e02-159">Although this makes them similar to classes in other languages, one of their primary differences is that they have structural equality semantics.</span></span>  <span data-ttu-id="30e02-160">Esto significa que se comparan de forma "nativa" y la igualdad es sencilla. Compruebe si uno es igual que el otro.</span><span class="sxs-lookup"><span data-stu-id="30e02-160">This means that they are "natively" comparable and equality is straightforward - just check if one is equal to the other.</span></span>

<span data-ttu-id="30e02-161">[Los registros](./language-reference/records.md) son un agregado de valores con nombre, con miembros opcionales (como métodos).</span><span class="sxs-lookup"><span data-stu-id="30e02-161">[Records](./language-reference/records.md) are an aggregate of named values, with optional members (such as methods).</span></span>  <span data-ttu-id="30e02-162">Si está familiarizado con C# o Java, estos deberían ser similares a poco o POJO, solo con igualdad estructural y menos ceremonia.</span><span class="sxs-lookup"><span data-stu-id="30e02-162">If you're familiar with C# or Java, then these should feel similar to POCOs or POJOs - just with structural equality and less ceremony.</span></span>

[!code-fsharp[Records](~/samples/snippets/fsharp/tour.fs#L507-L559)]

<span data-ttu-id="30e02-163">También puede representar registros como Structs.</span><span class="sxs-lookup"><span data-stu-id="30e02-163">You can also represent Records as structs.</span></span> <span data-ttu-id="30e02-164">Esto se hace con el atributo `[<Struct>]`:</span><span class="sxs-lookup"><span data-stu-id="30e02-164">This is done with the `[<Struct>]` attribute:</span></span>

[!code-fsharp[Records](~/samples/snippets/fsharp/tour.fs#L561-L568)]

<span data-ttu-id="30e02-165">Las [uniones discriminadas (DUs)](./language-reference/discriminated-unions.md) son valores que pueden ser una serie de formularios o casos con nombre.</span><span class="sxs-lookup"><span data-stu-id="30e02-165">[Discriminated Unions (DUs)](./language-reference/discriminated-unions.md) are values which could be a number of named forms or cases.</span></span>  <span data-ttu-id="30e02-166">Los datos almacenados en el tipo pueden tener uno de varios valores distintos.</span><span class="sxs-lookup"><span data-stu-id="30e02-166">Data stored in the type can be one of several distinct values.</span></span>

[!code-fsharp[Unions](~/samples/snippets/fsharp/tour.fs#L575-L631)]

<span data-ttu-id="30e02-167">También puede usar DUs como *uniones discriminadas de un solo caso*para ayudar con el modelado de dominios a través de tipos primitivos.</span><span class="sxs-lookup"><span data-stu-id="30e02-167">You can also use DUs as *Single-Case Discriminated Unions*, to help with domain modeling over primitive types.</span></span>  <span data-ttu-id="30e02-168">A menudo, las veces, las cadenas y otros tipos primitivos se utilizan para representar algo y, por tanto, se les da un significado determinado.</span><span class="sxs-lookup"><span data-stu-id="30e02-168">Often times, strings and other primitive types are used to represent something, and are thus given a particular meaning.</span></span>  <span data-ttu-id="30e02-169">Sin embargo, el uso de la representación primitiva de los datos puede dar lugar a la asignación errónea de un valor incorrecto.</span><span class="sxs-lookup"><span data-stu-id="30e02-169">However, using only the primitive representation of the data can result in mistakenly assigning an incorrect value!</span></span>  <span data-ttu-id="30e02-170">Representar cada tipo de información como una Unión de un solo caso distinto puede exigir una corrección en este escenario.</span><span class="sxs-lookup"><span data-stu-id="30e02-170">Representing each type of information as a distinct single-case union can enforce correctness in this scenario.</span></span>

[!code-fsharp[Unions](~/samples/snippets/fsharp/tour.fs#L633-L654)]

<span data-ttu-id="30e02-171">Como se muestra en el ejemplo anterior, para obtener el valor subyacente en una Unión discriminada de un solo caso, debe desencapsularlo explícitamente.</span><span class="sxs-lookup"><span data-stu-id="30e02-171">As the above sample demonstrates, to get the underlying value in a single-case Discriminated Union, you must explicitly unwrap it.</span></span>

<span data-ttu-id="30e02-172">Además, DUs también admite definiciones recursivas, lo que le permite representar fácilmente árboles y datos recursivos de forma inherente.</span><span class="sxs-lookup"><span data-stu-id="30e02-172">Additionally, DUs also support recursive definitions, allowing you to easily represent trees and inherently recursive data.</span></span>  <span data-ttu-id="30e02-173">Por ejemplo, aquí se muestra cómo puede representar un árbol de búsqueda binaria con funciones `exists` y `insert`.</span><span class="sxs-lookup"><span data-stu-id="30e02-173">For example, here's how you can represent a Binary Search Tree with `exists` and `insert` functions.</span></span>

[!code-fsharp[Unions](~/samples/snippets/fsharp/tour.fs#L656-L683)]

<span data-ttu-id="30e02-174">Dado que DUs le permite representar la estructura recursiva del árbol en el tipo de datos, el funcionamiento de esta estructura recursiva es sencillo y garantiza la corrección.</span><span class="sxs-lookup"><span data-stu-id="30e02-174">Because DUs allow you to represent the recursive structure of the tree in the data type, operating on this recursive structure is straightforward and guarantees correctness.</span></span>  <span data-ttu-id="30e02-175">También se admite en la coincidencia de patrones, como se muestra a continuación.</span><span class="sxs-lookup"><span data-stu-id="30e02-175">It is also supported in pattern matching, as shown below.</span></span>

<span data-ttu-id="30e02-176">Además, puede representar DUs como `struct`s con el atributo `[<Struct>]`:</span><span class="sxs-lookup"><span data-stu-id="30e02-176">Additionally, you can represent DUs as `struct`s with the `[<Struct>]` attribute:</span></span>

[!code-fsharp[Unions](~/samples/snippets/fsharp/tour.fs#L685-L696)]

<span data-ttu-id="30e02-177">Sin embargo, hay dos aspectos clave que hay que tener en cuenta al hacerlo:</span><span class="sxs-lookup"><span data-stu-id="30e02-177">However, there are two key things to keep in mind when doing so:</span></span>

1. <span data-ttu-id="30e02-178">No se puede definir un struct DU de forma recursiva.</span><span class="sxs-lookup"><span data-stu-id="30e02-178">A struct DU cannot be recursively-defined.</span></span>
2. <span data-ttu-id="30e02-179">Una estructura DU debe tener nombres únicos para cada uno de sus casos.</span><span class="sxs-lookup"><span data-stu-id="30e02-179">A struct DU must have unique names for each of its cases.</span></span>

<span data-ttu-id="30e02-180">Si no se sigue el anterior, se producirá un error de compilación.</span><span class="sxs-lookup"><span data-stu-id="30e02-180">Failure to follow the above will result in a compilation error.</span></span>

## <a name="pattern-matching"></a><span data-ttu-id="30e02-181">Coincidencia de modelos</span><span class="sxs-lookup"><span data-stu-id="30e02-181">Pattern Matching</span></span>

<span data-ttu-id="30e02-182">La [coincidencia](./language-reference/pattern-matching.md) de patrones F# es la característica de lenguaje que permite el funcionamiento F# en tipos.</span><span class="sxs-lookup"><span data-stu-id="30e02-182">[Pattern Matching](./language-reference/pattern-matching.md) is the F# language feature which enables correctness for operating on F# types.</span></span>  <span data-ttu-id="30e02-183">En los ejemplos anteriores, probablemente detectó bastante `match x with ...` sintaxis.</span><span class="sxs-lookup"><span data-stu-id="30e02-183">In the above samples, you probably noticed quite a bit of `match x with ...` syntax.</span></span>  <span data-ttu-id="30e02-184">Esta construcción permite al compilador, que puede comprender la "forma" de los tipos de datos, para obligarle a tener en cuenta todos los casos posibles al usar un tipo de datos a través de lo que se conoce como coincidencia de patrones exhaustiva.</span><span class="sxs-lookup"><span data-stu-id="30e02-184">This construct allows the compiler, which can understand the "shape" of data types, to force you to account for all possible cases when using a data type through what is known as Exhaustive Pattern Matching.</span></span>  <span data-ttu-id="30e02-185">Esto es increíblemente eficaz para corregir y se puede usar de forma inteligente para "levantar" lo que normalmente sería un problema de tiempo de ejecución en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="30e02-185">This is incredibly powerful for correctness, and can be cleverly used to "lift" what would normally be a runtime concern into compile-time.</span></span>

[!code-fsharp[PatternMatching](~/samples/snippets/fsharp/tour.fs#L705-L742)]

<span data-ttu-id="30e02-186">Algo que puede haber observado es el uso del patrón de `_`.</span><span class="sxs-lookup"><span data-stu-id="30e02-186">Something you may have noticed is the use of the `_` pattern.</span></span>  <span data-ttu-id="30e02-187">Esto se conoce como el [patrón de carácter comodín](./language-reference/pattern-matching.md#wildcard-pattern), que es una forma de decir "no me importa qué es algo".</span><span class="sxs-lookup"><span data-stu-id="30e02-187">This is known as the [Wildcard Pattern](./language-reference/pattern-matching.md#wildcard-pattern), which is a way of saying "I don't care what something is".</span></span>  <span data-ttu-id="30e02-188">Aunque es práctico, puede omitir accidentalmente la coincidencia de patrones exhaustivas y dejar de beneficiarse de las impuestas en tiempo de compilación si no tiene cuidado al usar `_`.</span><span class="sxs-lookup"><span data-stu-id="30e02-188">Although convenient, you can accidentally bypass Exhaustive Pattern Matching and no longer benefit from compile-time enforcements if you aren't careful in using `_`.</span></span>  <span data-ttu-id="30e02-189">Se recomienda usar cuando no le interesan ciertas partes de un tipo descompuesto al buscar coincidencias de patrones o la cláusula final cuando ha enumerado todos los casos significativos en una expresión de coincidencia de patrones.</span><span class="sxs-lookup"><span data-stu-id="30e02-189">It is best used when you don't care about certain pieces of a decomposed type when pattern matching, or the final clause when you have enumerated all meaningful cases in a pattern matching expression.</span></span>

<span data-ttu-id="30e02-190">En el ejemplo siguiente, se utiliza el caso `_` cuando se produce un error en una operación de análisis.</span><span class="sxs-lookup"><span data-stu-id="30e02-190">In the following example, the `_` case is used when a parse operation fails.</span></span>

[!code-fsharp[PatternMatching](~/samples/snippets/fsharp/tour.fs#L744-L762)]

<span data-ttu-id="30e02-191">Los [modelos activos](./language-reference/active-patterns.md) son otra construcción eficaz que se usa con la coincidencia de patrones.</span><span class="sxs-lookup"><span data-stu-id="30e02-191">[Active Patterns](./language-reference/active-patterns.md) are another powerful construct to use with pattern matching.</span></span>  <span data-ttu-id="30e02-192">Permiten particionar los datos de entrada en formularios personalizados, descomponerlos en el sitio de llamada de coincidencia de patrones.</span><span class="sxs-lookup"><span data-stu-id="30e02-192">They allow you to partition input data into custom forms, decomposing them at the pattern match call site.</span></span>  <span data-ttu-id="30e02-193">También se pueden parametrizar, lo que permite a definir la partición como una función.</span><span class="sxs-lookup"><span data-stu-id="30e02-193">They can also be parameterized, thus allowing to define the partition as a function.</span></span>  <span data-ttu-id="30e02-194">Expandir el ejemplo anterior para admitir patrones activos tiene un aspecto similar al siguiente:</span><span class="sxs-lookup"><span data-stu-id="30e02-194">Expanding the previous example to support Active Patterns looks something like this:</span></span>

[!code-fsharp[ActivePatterns](~/samples/snippets/fsharp/tour.fs#L764-L786)]

## <a name="optional-types"></a><span data-ttu-id="30e02-195">Tipos opcionales</span><span class="sxs-lookup"><span data-stu-id="30e02-195">Optional Types</span></span>

<span data-ttu-id="30e02-196">Un caso especial de tipos de unión discriminada es el tipo de opción, que es tan útil que forma parte de la biblioteca básica de F#.</span><span class="sxs-lookup"><span data-stu-id="30e02-196">One special case of Discriminated Union types is the Option Type, which is so useful that it's a part of the F# core library.</span></span>

<span data-ttu-id="30e02-197">[El tipo de opción](./language-reference/options.md) es un tipo que representa uno de los dos casos: un valor o nada en absoluto.</span><span class="sxs-lookup"><span data-stu-id="30e02-197">[The Option Type](./language-reference/options.md) is a type which represents one of two cases: a value, or nothing at all.</span></span>  <span data-ttu-id="30e02-198">Se usa en cualquier escenario en el que un valor pueda o no ser el resultado de una operación determinada.</span><span class="sxs-lookup"><span data-stu-id="30e02-198">It is used in any scenario where a value may or may not result from a particular operation.</span></span>  <span data-ttu-id="30e02-199">Esto le obliga a tener en cuenta los dos casos, convirtiéndolo en un problema de tiempo de compilación en lugar de un problema en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="30e02-199">This then forces you to account for both cases, making it a compile-time concern rather than a runtime concern.</span></span>  <span data-ttu-id="30e02-200">A menudo se usan en las API donde `null` se usa para representar "Nothing" en su lugar, lo que elimina la necesidad de preocuparse por `NullReferenceException` en muchas circunstancias.</span><span class="sxs-lookup"><span data-stu-id="30e02-200">These are often used in APIs where `null` is used to represent "nothing" instead, thus eliminating the need to worry about `NullReferenceException` in many circumstances.</span></span>

[!code-fsharp[Options](~/samples/snippets/fsharp/tour.fs#L789-L814)]

## <a name="units-of-measure"></a><span data-ttu-id="30e02-201">Unidades de medida</span><span class="sxs-lookup"><span data-stu-id="30e02-201">Units of Measure</span></span>

<span data-ttu-id="30e02-202">Una característica exclusiva de sistema de tipos de F# es la capacidad para proporcionar contexto para literales numéricos a través de las unidades de medida.</span><span class="sxs-lookup"><span data-stu-id="30e02-202">One unique feature of F#'s type system is the ability to provide context for numeric literals through Units of Measure.</span></span>

<span data-ttu-id="30e02-203">Las [unidades de medida](./language-reference/units-of-measure.md) permiten asociar un tipo numérico a una unidad, como los medidores, y hacer que las funciones realicen trabajos en unidades en lugar de literales numéricos.</span><span class="sxs-lookup"><span data-stu-id="30e02-203">[Units of Measure](./language-reference/units-of-measure.md) allow you to associate a numeric type to a unit, such as Meters, and have functions perform work on units rather than numeric literals.</span></span>  <span data-ttu-id="30e02-204">Esto permite al compilador comprobar que los tipos de literales numéricos pasados tienen sentido en un contexto determinado, con lo que se eliminan los errores en tiempo de ejecución asociados a ese tipo de trabajo.</span><span class="sxs-lookup"><span data-stu-id="30e02-204">This enables the compiler to verify that the types of numeric literals passed in make sense under a certain context, thus eliminating runtime errors associated with that kind of work.</span></span>

[!code-fsharp[UnitsOfMeasure](~/samples/snippets/fsharp/tour.fs#L817-L842)]

<span data-ttu-id="30e02-205">La biblioteca básica de F# define muchos tipos de unidad del SI y conversiones de unidades.</span><span class="sxs-lookup"><span data-stu-id="30e02-205">The F# Core library defines many SI unit types and unit conversions.</span></span>  <span data-ttu-id="30e02-206">Para obtener más información, consulte el [espacio de nombres Microsoft.FSharp.Data.UnitSystems.Si](https://msdn.microsoft.com/visualfsharpdocs/conceptual/microsoft.fsharp.data.unitsystems.si-namespace-%5bfsharp%5d).</span><span class="sxs-lookup"><span data-stu-id="30e02-206">To learn more, check out the [Microsoft.FSharp.Data.UnitSystems.SI Namespace](https://msdn.microsoft.com/visualfsharpdocs/conceptual/microsoft.fsharp.data.unitsystems.si-namespace-%5bfsharp%5d).</span></span>

## <a name="classes-and-interfaces"></a><span data-ttu-id="30e02-207">Clases e interfaces</span><span class="sxs-lookup"><span data-stu-id="30e02-207">Classes and Interfaces</span></span>

<span data-ttu-id="30e02-208">F#también es totalmente compatible con las clases, [interfaces](./language-reference/interfaces.md), [clases abstractas](./language-reference/abstract-classes.md), [herencia](./language-reference/inheritance.md), etc. de .net.</span><span class="sxs-lookup"><span data-stu-id="30e02-208">F# also has full support for .NET classes, [Interfaces](./language-reference/interfaces.md), [Abstract Classes](./language-reference/abstract-classes.md), [Inheritance](./language-reference/inheritance.md), and so on.</span></span>

<span data-ttu-id="30e02-209">[Las clases](./language-reference/classes.md) son tipos que representan objetos .net, que pueden tener propiedades, métodos y eventos como [miembros](./language-reference/members/index.md).</span><span class="sxs-lookup"><span data-stu-id="30e02-209">[Classes](./language-reference/classes.md) are types that represent .NET objects, which can have properties, methods, and events as its [Members](./language-reference/members/index.md).</span></span>

[!code-fsharp[Classes](~/samples/snippets/fsharp/tour.fs#L845-L880)]

<span data-ttu-id="30e02-210">La definición de clases genéricas también es muy sencilla.</span><span class="sxs-lookup"><span data-stu-id="30e02-210">Defining generic classes is also very straightforward.</span></span>

[!code-fsharp[Classes](~/samples/snippets/fsharp/tour.fs#L883-L908)]

<span data-ttu-id="30e02-211">Para implementar una interfaz, puede usar `interface ... with` sintaxis o una expresión de [objeto](./language-reference/object-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="30e02-211">To implement an Interface, you can use either `interface ... with` syntax or an [Object Expression](./language-reference/object-expressions.md).</span></span>

[!code-fsharp[Classes](~/samples/snippets/fsharp/tour.fs#L911-L934)]

## <a name="which-types-to-use"></a><span data-ttu-id="30e02-212">Qué tipos se van a usar</span><span class="sxs-lookup"><span data-stu-id="30e02-212">Which Types to Use</span></span>

<span data-ttu-id="30e02-213">La presencia de clases, registros, uniones discriminadas y tuplas conduce a una pregunta importante: ¿Qué debería usar?</span><span class="sxs-lookup"><span data-stu-id="30e02-213">The presence of Classes, Records, Discriminated Unions, and Tuples leads to an important question: which should you use?</span></span>  <span data-ttu-id="30e02-214">Como la mayoría de los casos, la respuesta depende de sus circunstancias.</span><span class="sxs-lookup"><span data-stu-id="30e02-214">Like most everything in life, the answer depends on your circumstances.</span></span>

<span data-ttu-id="30e02-215">Las tuplas son excelentes para devolver varios valores de una función y usar un agregado ad hoc de valores como un valor en sí.</span><span class="sxs-lookup"><span data-stu-id="30e02-215">Tuples are great for returning multiple values from a function, and using an ad-hoc aggregate of values as a value itself.</span></span>

<span data-ttu-id="30e02-216">Los registros son un "paso activo" de las tuplas, que tienen etiquetas con nombre y admiten miembros opcionales.</span><span class="sxs-lookup"><span data-stu-id="30e02-216">Records are a "step up" from Tuples, having named labels and support for optional members.</span></span>  <span data-ttu-id="30e02-217">Son excelentes para una representación de datos en tránsito con un bajo nivel de ceremonia a través del programa.</span><span class="sxs-lookup"><span data-stu-id="30e02-217">They are great for a low-ceremony representation of data in-transit through your program.</span></span>  <span data-ttu-id="30e02-218">Dado que tienen igualdad estructural, son fáciles de usar con la comparación.</span><span class="sxs-lookup"><span data-stu-id="30e02-218">Because they have structural equality, they are easy to use with comparison.</span></span>

<span data-ttu-id="30e02-219">Las uniones discriminadas tienen muchos usos, pero la ventaja principal es poder usarlas junto con la coincidencia de patrones para tener en cuenta todas las posibles "formas" que pueden tener los datos.</span><span class="sxs-lookup"><span data-stu-id="30e02-219">Discriminated Unions have many uses, but the core benefit is to be able to utilize them in conjunction with Pattern Matching to account for all possible "shapes" that a data can have.</span></span>  

<span data-ttu-id="30e02-220">Las clases son excelentes para una gran cantidad de razones, como cuando es necesario representar información y también asociar esa información a la funcionalidad.</span><span class="sxs-lookup"><span data-stu-id="30e02-220">Classes are great for a huge number of reasons, such as when you need to represent information and also tie that information to functionality.</span></span>  <span data-ttu-id="30e02-221">Como regla general, cuando tiene funcionalidad que está vinculada conceptualmente a algunos datos, el uso de clases y los principios de la programación orientada a objetos es una gran ventaja.</span><span class="sxs-lookup"><span data-stu-id="30e02-221">As a rule of thumb, when you have functionality which is conceptually tied to some data, using Classes and the principles of Object-Oriented Programming is a big benefit.</span></span>  <span data-ttu-id="30e02-222">Las clases son también el tipo de datos preferido al interoperar con C# y Visual Basic, ya que estos lenguajes usan clases para casi todo.</span><span class="sxs-lookup"><span data-stu-id="30e02-222">Classes are also the preferred data type when interoperating with C# and Visual Basic, as these languages use classes for nearly everything.</span></span>

## <a name="next-steps"></a><span data-ttu-id="30e02-223">Pasos siguientes</span><span class="sxs-lookup"><span data-stu-id="30e02-223">Next Steps</span></span>

<span data-ttu-id="30e02-224">Ahora que ha visto algunas de las principales características del lenguaje, debería estar listo para escribir sus primeros programas de F#!</span><span class="sxs-lookup"><span data-stu-id="30e02-224">Now that you've seen some of the primary features of the language, you should be ready to write your first F# programs!</span></span>  <span data-ttu-id="30e02-225">Consulte [Introducción](get-started/index.md) para obtener información sobre cómo configurar el entorno de desarrollo y escribir código.</span><span class="sxs-lookup"><span data-stu-id="30e02-225">Check out [Getting Started](get-started/index.md) to learn how to set up your development environment and write some code.</span></span>

<span data-ttu-id="30e02-226">Los siguientes pasos para obtener más información pueden ser el que desee, pero se recomienda la [Introducción a la F# programación funcional en](./introduction-to-functional-programming/index.md) para familiarizarse con los conceptos básicos de la programación funcional.</span><span class="sxs-lookup"><span data-stu-id="30e02-226">The next steps for learning more can be whatever you like, but we recommend [Introduction to Functional Programming in F#](./introduction-to-functional-programming/index.md) to get comfortable with core Functional Programming concepts.</span></span>  <span data-ttu-id="30e02-227">Estos serán esenciales en la creación de programas sólidos en F#.</span><span class="sxs-lookup"><span data-stu-id="30e02-227">These will be essential in building robust programs in F#.</span></span>

<span data-ttu-id="30e02-228">Además, consulte la [ F# referencia del lenguaje](./language-reference/index.md) para ver una colección completa de contenido conceptual sobre. F#</span><span class="sxs-lookup"><span data-stu-id="30e02-228">Also, check out the [F# Language Reference](./language-reference/index.md) to see a comprehensive collection of conceptual content on F#.</span></span>
