---
title: Expresiones de código delimitadas (F#)
description: 'Obtenga información sobre F # expresiones de código delimitadas, una característica del lenguaje que le permite generar y trabajar con expresiones de código de F # mediante programación.'
ms.date: 05/16/2016
ms.openlocfilehash: 27e9cf1d99e2b5955cc6359653fc87bdbe824cc7
ms.sourcegitcommit: fb78d8abbdb87144a3872cf154930157090dd933
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 09/27/2018
ms.locfileid: "47397207"
---
# <a name="code-quotations"></a><span data-ttu-id="992b8-103">Expresiones de código delimitadas</span><span class="sxs-lookup"><span data-stu-id="992b8-103">Code Quotations</span></span>

> [!NOTE]
<span data-ttu-id="992b8-104">El vínculo de la referencia de API le llevará a MSDN.</span><span class="sxs-lookup"><span data-stu-id="992b8-104">The API reference link will take you to MSDN.</span></span>  <span data-ttu-id="992b8-105">La referencia de API de docs.microsoft.com no está completa.</span><span class="sxs-lookup"><span data-stu-id="992b8-105">The docs.microsoft.com API reference is not complete.</span></span>

<span data-ttu-id="992b8-106">Este tema se describe *de código delimitadas*, una característica del lenguaje que le permite generar y trabajar con expresiones de código de F # mediante programación.</span><span class="sxs-lookup"><span data-stu-id="992b8-106">This topic describes *code quotations*, a language feature that enables you to generate and work with F# code expressions programmatically.</span></span> <span data-ttu-id="992b8-107">Esta característica le permite generar un árbol de sintaxis abstracta que representa el código de F #.</span><span class="sxs-lookup"><span data-stu-id="992b8-107">This feature lets you generate an abstract syntax tree that represents F# code.</span></span> <span data-ttu-id="992b8-108">Puede recorrer el árbol de sintaxis abstracta y procesan según las necesidades de su aplicación.</span><span class="sxs-lookup"><span data-stu-id="992b8-108">The abstract syntax tree can then be traversed and processed according to the needs of your application.</span></span> <span data-ttu-id="992b8-109">Por ejemplo, puede usar el árbol para generar código de F # o generar código en algún otro lenguaje.</span><span class="sxs-lookup"><span data-stu-id="992b8-109">For example, you can use the tree to generate F# code or generate code in some other language.</span></span>

## <a name="quoted-expressions"></a><span data-ttu-id="992b8-110">Expresiones delimitadas</span><span class="sxs-lookup"><span data-stu-id="992b8-110">Quoted Expressions</span></span>

<span data-ttu-id="992b8-111">Un *expresión delimitada* es una expresión de F # en el código que está delimitada de tal manera que no se compilan como parte del programa, pero en su lugar se compila en un objeto que representa una expresión de F #.</span><span class="sxs-lookup"><span data-stu-id="992b8-111">A *quoted expression* is an F# expression in your code that is delimited in such a way that it is not compiled as part of your program, but instead is compiled into an object that represents an F# expression.</span></span> <span data-ttu-id="992b8-112">Puede marcar una expresión entre comillas en una de dos maneras: con la información de tipo o sin información de tipo.</span><span class="sxs-lookup"><span data-stu-id="992b8-112">You can mark a quoted expression in one of two ways: either with type information or without type information.</span></span> <span data-ttu-id="992b8-113">Si desea incluir información de tipo, use los símbolos `<@` y `@>` para delimitar la expresión entre comillas.</span><span class="sxs-lookup"><span data-stu-id="992b8-113">If you want to include type information, you use the symbols `<@` and `@>` to delimit the quoted expression.</span></span> <span data-ttu-id="992b8-114">Si no necesita información de tipo, use los símbolos `<@@` y `@@>`.</span><span class="sxs-lookup"><span data-stu-id="992b8-114">If you do not need type information, you use the symbols `<@@` and `@@>`.</span></span> <span data-ttu-id="992b8-115">El código siguiente muestra los presupuestos con y sin tipo.</span><span class="sxs-lookup"><span data-stu-id="992b8-115">The following code shows typed and untyped quotations.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-3/snippet501.fs)]

<span data-ttu-id="992b8-116">Recorrer un árbol de expresión grande es más rápido si no se incluye información de tipo.</span><span class="sxs-lookup"><span data-stu-id="992b8-116">Traversing a large expression tree is faster if you do not include type information.</span></span> <span data-ttu-id="992b8-117">El tipo resultante de una expresión delimitada con los símbolos de tipo es `Expr<'T>`, donde el parámetro de tipo tiene el tipo de la expresión, según lo determinado por el algoritmo de deducción de tipo de F # del compilador.</span><span class="sxs-lookup"><span data-stu-id="992b8-117">The resulting type of an expression quoted with the typed symbols is `Expr<'T>`, where the type parameter has the type of the expression as determined by the F# compiler's type inference algorithm.</span></span> <span data-ttu-id="992b8-118">Al usar expresiones de código delimitadas sin información de tipo, el tipo de la expresión entre comillas es el tipo no genérico [Expr](https://msdn.microsoft.com/library/ed6a2caf-69d4-45c2-ab97-e9b3be9bce65).</span><span class="sxs-lookup"><span data-stu-id="992b8-118">When you use code quotations without type information, the type of the quoted expression is the non-generic type [Expr](https://msdn.microsoft.com/library/ed6a2caf-69d4-45c2-ab97-e9b3be9bce65).</span></span> <span data-ttu-id="992b8-119">Puede llamar a la [Raw](https://msdn.microsoft.com/library/47fb94f1-e77f-4c68-aabc-2b0ba40d59c2) propiedad en el objeto `Expr` clase para obtener el sin tipo `Expr` objeto.</span><span class="sxs-lookup"><span data-stu-id="992b8-119">You can call the [Raw](https://msdn.microsoft.com/library/47fb94f1-e77f-4c68-aabc-2b0ba40d59c2) property on the typed `Expr` class to obtain the untyped `Expr` object.</span></span>

<span data-ttu-id="992b8-120">Hay una gran variedad de métodos estáticos que permiten generar expresión objetos de F # mediante programación en el `Expr` clase sin utilizar expresiones delimitadas.</span><span class="sxs-lookup"><span data-stu-id="992b8-120">There are a variety of static methods that allow you to generate F# expression objects programmatically in the `Expr` class without using quoted expressions.</span></span>

<span data-ttu-id="992b8-121">Tenga en cuenta que una expresión de código debe incluir una expresión completa.</span><span class="sxs-lookup"><span data-stu-id="992b8-121">Note that a code quotation must include a complete expression.</span></span> <span data-ttu-id="992b8-122">Para un `let` de enlace, por ejemplo, se necesita la definición del nombre enlazado y una expresión adicional que usa el enlace.</span><span class="sxs-lookup"><span data-stu-id="992b8-122">For a `let` binding, for example, you need both the definition of the bound name and an additional expression that uses the binding.</span></span> <span data-ttu-id="992b8-123">En la sintaxis detallada, esto es una expresión que sigue el `in` palabra clave.</span><span class="sxs-lookup"><span data-stu-id="992b8-123">In verbose syntax, this is an expression that follows the `in` keyword.</span></span> <span data-ttu-id="992b8-124">En el nivel superior en un módulo, esto es simplemente la siguiente expresión en el módulo, pero en una expresión, se requiere de forma explícita.</span><span class="sxs-lookup"><span data-stu-id="992b8-124">At the top-level in a module, this is just the next expression in the module, but in a quotation, it is explicitly required.</span></span>

<span data-ttu-id="992b8-125">Por lo tanto, la siguiente expresión no es válida.</span><span class="sxs-lookup"><span data-stu-id="992b8-125">Therefore, the following expression is not valid.</span></span>

```fsharp
// Not valid:
// <@ let f x = x + 1 @>
```

<span data-ttu-id="992b8-126">Pero las expresiones siguientes son válidas.</span><span class="sxs-lookup"><span data-stu-id="992b8-126">But the following expressions are valid.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-3/snippet502.fs)]

<span data-ttu-id="992b8-127">Para usar expresiones de código delimitadas, debe agregar una declaración de importación (mediante el uso de la `open` palabra clave) que se abre el [Microsoft.FSharp.Quotations](https://msdn.microsoft.com/library/e9ce8a3a-e00c-4190-bad5-cce52ee089b2) espacio de nombres.</span><span class="sxs-lookup"><span data-stu-id="992b8-127">To use code quotations, you must add an import declaration (by using the `open` keyword) that opens the [Microsoft.FSharp.Quotations](https://msdn.microsoft.com/library/e9ce8a3a-e00c-4190-bad5-cce52ee089b2) namespace.</span></span>

<span data-ttu-id="992b8-128">F # PowerPack proporciona soporte técnico para evaluar y ejecutar objetos de expresión de F #.</span><span class="sxs-lookup"><span data-stu-id="992b8-128">The F# PowerPack provides support for evaluating and executing F# expression objects.</span></span>

## <a name="expr-type"></a><span data-ttu-id="992b8-129">Tipo expr</span><span class="sxs-lookup"><span data-stu-id="992b8-129">Expr Type</span></span>

<span data-ttu-id="992b8-130">Una instancia de la `Expr` tipo representa una expresión de F #.</span><span class="sxs-lookup"><span data-stu-id="992b8-130">An instance of the `Expr` type represents an F# expression.</span></span> <span data-ttu-id="992b8-131">El tipo genérico y no genérica `Expr` tipos se documentan en la documentación de biblioteca de F #.</span><span class="sxs-lookup"><span data-stu-id="992b8-131">Both the generic and the non-generic `Expr` types are documented in the F# library documentation.</span></span> <span data-ttu-id="992b8-132">Para obtener más información, consulte [Microsoft.FSharp.Quotations Namespace](https://msdn.microsoft.com/visualfsharpdocs/conceptual/microsoft.fsharp.quotations-namespace-%5bfsharp%5d) y [Quotations.Expr clase](https://msdn.microsoft.com/visualfsharpdocs/conceptual/quotations.expr-class-%5bfsharp%5d).</span><span class="sxs-lookup"><span data-stu-id="992b8-132">For more information, see [Microsoft.FSharp.Quotations Namespace](https://msdn.microsoft.com/visualfsharpdocs/conceptual/microsoft.fsharp.quotations-namespace-%5bfsharp%5d) and [Quotations.Expr Class](https://msdn.microsoft.com/visualfsharpdocs/conceptual/quotations.expr-class-%5bfsharp%5d).</span></span>

## <a name="splicing-operators"></a><span data-ttu-id="992b8-133">Operadores de conjuntos</span><span class="sxs-lookup"><span data-stu-id="992b8-133">Splicing Operators</span></span>

<span data-ttu-id="992b8-134">Insertar permite combinar los presupuestos de código literal con expresiones que ha creado mediante programación o desde otra expresión de código.</span><span class="sxs-lookup"><span data-stu-id="992b8-134">Splicing enables you to combine literal code quotations with expressions that you have created programmatically or from another code quotation.</span></span> <span data-ttu-id="992b8-135">El `%` y `%%` operadores permiten agregar un objeto de expresión de F # en una expresión de código.</span><span class="sxs-lookup"><span data-stu-id="992b8-135">The `%` and `%%` operators enable you to add an F# expression object into a code quotation.</span></span> <span data-ttu-id="992b8-136">Usa el `%` operador para insertar un objeto de expresión con tipo en una expresión con tipo; use el `%%` operador para insertar un objeto de expresión sin tipo en una expresión de código delimitada sin tipo.</span><span class="sxs-lookup"><span data-stu-id="992b8-136">You use the `%` operator to insert a typed expression object into a typed quotation; you use the `%%` operator to insert an untyped expression object into an untyped quotation.</span></span> <span data-ttu-id="992b8-137">Ambos operadores son operadores de prefijo unario.</span><span class="sxs-lookup"><span data-stu-id="992b8-137">Both operators are unary prefix operators.</span></span> <span data-ttu-id="992b8-138">Por lo tanto si `expr` es una expresión de tipo sin tipo `Expr`, el código siguiente es válido.</span><span class="sxs-lookup"><span data-stu-id="992b8-138">Thus if `expr` is an untyped expression of type `Expr`, the following code is valid.</span></span>

```fsharp
<@@ 1 + %%expr @@>
```

<span data-ttu-id="992b8-139">Y si `expr` es una expresión de tipo con tipo `Expr<int>`, el código siguiente es válido.</span><span class="sxs-lookup"><span data-stu-id="992b8-139">And if `expr` is a typed quotation of type `Expr<int>`, the following code is valid.</span></span>

```fsharp
<@ 1 + %expr @>
```

## <a name="example"></a><span data-ttu-id="992b8-140">Ejemplo</span><span class="sxs-lookup"><span data-stu-id="992b8-140">Example</span></span>

### <a name="description"></a><span data-ttu-id="992b8-141">Descripción</span><span class="sxs-lookup"><span data-stu-id="992b8-141">Description</span></span>

<span data-ttu-id="992b8-142">El ejemplo siguiente muestra el uso de expresiones de código delimitadas a poner el código de F # en un objeto de expresión y, a continuación, imprimir el código de F # que representa la expresión.</span><span class="sxs-lookup"><span data-stu-id="992b8-142">The following example illustrates the use of code quotations to put F# code into an expression object and then print the F# code that represents the expression.</span></span> <span data-ttu-id="992b8-143">Una función `println` está definido que contiene una función recursiva `print` que muestra un objeto de expresión de F # (de tipo `Expr`) en un formato descriptivo.</span><span class="sxs-lookup"><span data-stu-id="992b8-143">A function `println` is defined that contains a recursive function `print` that displays an F# expression object (of type `Expr`) in a friendly format.</span></span> <span data-ttu-id="992b8-144">Hay varios modelos activos en el [Microsoft.FSharp.Quotations.Patterns](https://msdn.microsoft.com/library/093944a9-c752-403a-8983-5fcd5dbf92a4) y [Microsoft.FSharp.Quotations.DerivedPatterns](https://msdn.microsoft.com/library/d2434a6e-ae7b-4f3d-b567-c162938bc9cd) módulos que pueden usarse para analizar objetos de expresión.</span><span class="sxs-lookup"><span data-stu-id="992b8-144">There are several active patterns in the [Microsoft.FSharp.Quotations.Patterns](https://msdn.microsoft.com/library/093944a9-c752-403a-8983-5fcd5dbf92a4) and [Microsoft.FSharp.Quotations.DerivedPatterns](https://msdn.microsoft.com/library/d2434a6e-ae7b-4f3d-b567-c162938bc9cd) modules that can be used to analyze expression objects.</span></span> <span data-ttu-id="992b8-145">En este ejemplo no incluye todos los posibles modelos que pueden aparecer en una expresión de F #.</span><span class="sxs-lookup"><span data-stu-id="992b8-145">This example does not include all the possible patterns that might appear in an F# expression.</span></span> <span data-ttu-id="992b8-146">Ninguno no se reconoce el patrón desencadena una coincidencia con el carácter comodín (`_`) y se representa mediante el uso de la `ToString` método, que, en el `Expr` escriba permite saber el modelo activo para agregar a la expresión de coincidencia.</span><span class="sxs-lookup"><span data-stu-id="992b8-146">Any unrecognized pattern triggers a match to the wildcard pattern (`_`) and is rendered by using the `ToString` method, which, on the `Expr` type, lets you know the active pattern to add to your match expression.</span></span>

### <a name="code"></a><span data-ttu-id="992b8-147">Código</span><span class="sxs-lookup"><span data-stu-id="992b8-147">Code</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-3/snippet601.fs)]

### <a name="output"></a><span data-ttu-id="992b8-148">Salida</span><span class="sxs-lookup"><span data-stu-id="992b8-148">Output</span></span>

```fsharp
fun (x:System.Int32) -> x + 1
a + 1
let f = fun (x:System.Int32) -> x + 10 in f 10
```

## <a name="example"></a><span data-ttu-id="992b8-149">Ejemplo</span><span class="sxs-lookup"><span data-stu-id="992b8-149">Example</span></span>

### <a name="description"></a><span data-ttu-id="992b8-150">Descripción</span><span class="sxs-lookup"><span data-stu-id="992b8-150">Description</span></span>

<span data-ttu-id="992b8-151">También puede usar los tres modelos activos en el [ExprShape (módulo)](https://msdn.microsoft.com/library/7685150e-2432-4d39-9338-57292eff18de) para recorrer los árboles de expresión con menos modelos activos.</span><span class="sxs-lookup"><span data-stu-id="992b8-151">You can also use the three active patterns in the [ExprShape module](https://msdn.microsoft.com/library/7685150e-2432-4d39-9338-57292eff18de) to traverse expression trees with fewer active patterns.</span></span> <span data-ttu-id="992b8-152">Estos modelos activos pueden ser útiles cuando desea recorrer un árbol, pero no es necesario toda la información en la mayoría de los nodos.</span><span class="sxs-lookup"><span data-stu-id="992b8-152">These active patterns can be useful when you want to traverse a tree but you do not need all the information in most of the nodes.</span></span> <span data-ttu-id="992b8-153">Al usar estos patrones, cualquier expresión de F # coincide con uno de los siguientes tres modelos: `ShapeVar` si la expresión es una variable, `ShapeLambda` si la expresión es una expresión lambda, o `ShapeCombination` si la expresión no es nada más.</span><span class="sxs-lookup"><span data-stu-id="992b8-153">When you use these patterns, any F# expression matches one of the following three patterns: `ShapeVar` if the expression is a variable, `ShapeLambda` if the expression is a lambda expression, or `ShapeCombination` if the expression is anything else.</span></span> <span data-ttu-id="992b8-154">Si se recorre un árbol de expresión mediante el uso de los patrones activos como en el ejemplo de código anterior, tiene que usar muchos más modelos para controlar todos los tipos de expresión de F # posibles y su código será más compleja.</span><span class="sxs-lookup"><span data-stu-id="992b8-154">If you traverse an expression tree by using the active patterns as in the previous code example, you have to use many more patterns to handle all possible F# expression types, and your code will be more complex.</span></span> <span data-ttu-id="992b8-155">Para obtener más información, consulte [ExprShape.ShapeVar&#124;ShapeLambda&#124;ShapeCombination (modelo activo)](https://msdn.microsoft.com/visualfsharpdocs/conceptual/exprshape.shapevarhshapelambdahshapecombination-active-pattern-%5bfsharp%5d).</span><span class="sxs-lookup"><span data-stu-id="992b8-155">For more information, see [ExprShape.ShapeVar&#124;ShapeLambda&#124;ShapeCombination Active Pattern](https://msdn.microsoft.com/visualfsharpdocs/conceptual/exprshape.shapevarhshapelambdahshapecombination-active-pattern-%5bfsharp%5d).</span></span>

<span data-ttu-id="992b8-156">El siguiente ejemplo de código se puede usar como punto de partida para recorridos más complejos.</span><span class="sxs-lookup"><span data-stu-id="992b8-156">The following code example can be used as a basis for more complex traversals.</span></span> <span data-ttu-id="992b8-157">En este código, se crea un árbol de expresión para una expresión que implica una llamada de función, `add`.</span><span class="sxs-lookup"><span data-stu-id="992b8-157">In this code, an expression tree is created for an expression that involves a function call, `add`.</span></span> <span data-ttu-id="992b8-158">El [SpecificCall](https://msdn.microsoft.com/library/05a77b21-20fe-4b9a-8e07-aa999538198d) (modelo activo) se usa para detectar cualquier llamada a `add` en el árbol de expresión.</span><span class="sxs-lookup"><span data-stu-id="992b8-158">The [SpecificCall](https://msdn.microsoft.com/library/05a77b21-20fe-4b9a-8e07-aa999538198d) active pattern is used to detect any call to `add` in the expression tree.</span></span> <span data-ttu-id="992b8-159">Este modelo activo asigna los argumentos de la llamada a la `exprList` valor.</span><span class="sxs-lookup"><span data-stu-id="992b8-159">This active pattern assigns the arguments of the call to the `exprList` value.</span></span> <span data-ttu-id="992b8-160">En este caso, hay solo dos, por lo que se extraen estos y la función se llama de forma recursiva en los argumentos.</span><span class="sxs-lookup"><span data-stu-id="992b8-160">In this case, there are only two, so these are pulled out and the function is called recursively on the arguments.</span></span> <span data-ttu-id="992b8-161">Los resultados se insertan en una expresión de código que representa una llamada a `mul` mediante el operador de inserción (`%%`).</span><span class="sxs-lookup"><span data-stu-id="992b8-161">The results are inserted into a code quotation that represents a call to `mul` by using the splice operator (`%%`).</span></span> <span data-ttu-id="992b8-162">El `println` función del ejemplo anterior se usa para mostrar los resultados.</span><span class="sxs-lookup"><span data-stu-id="992b8-162">The `println` function from the previous example is used to display the results.</span></span>

<span data-ttu-id="992b8-163">El código de las demás ramas del modelo activo simplemente regenera el mismo árbol de expresión, por lo que el único cambio en la expresión resultante es el cambio de `add` a `mul`.</span><span class="sxs-lookup"><span data-stu-id="992b8-163">The code in the other active pattern branches just regenerates the same expression tree, so the only change in the resulting expression is the change from `add` to `mul`.</span></span>

### <a name="code"></a><span data-ttu-id="992b8-164">Código</span><span class="sxs-lookup"><span data-stu-id="992b8-164">Code</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-3/snippet701.fs)]

### <a name="output"></a><span data-ttu-id="992b8-165">Salida</span><span class="sxs-lookup"><span data-stu-id="992b8-165">Output</span></span>

```fsharp
1 + Module1.add(2,Module1.add(3,4))
1 + Module1.mul(2,Module1.mul(3,4))
```

## <a name="see-also"></a><span data-ttu-id="992b8-166">Vea también</span><span class="sxs-lookup"><span data-stu-id="992b8-166">See also</span></span>

- [<span data-ttu-id="992b8-167">Referencia del lenguaje F#</span><span class="sxs-lookup"><span data-stu-id="992b8-167">F# Language Reference</span></span>](index.md)
