---
title: Clases
description: 'Obtenga información sobre cómo las clases de F # son tipos que representan objetos que pueden tener propiedades, métodos y eventos.'
ms.date: 05/16/2016
ms.openlocfilehash: fd6638e0f1c08cf667a73582e19b2bb5bba46e20
ms.sourcegitcommit: 7ef96827b161ef3fcde75f79d839885632e26ef1
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 01/07/2021
ms.locfileid: "97970172"
---
# <a name="classes"></a><span data-ttu-id="3b12e-103">Clases</span><span class="sxs-lookup"><span data-stu-id="3b12e-103">Classes</span></span>

<span data-ttu-id="3b12e-104">*Las clases* son tipos que representan objetos que pueden tener propiedades, métodos y eventos.</span><span class="sxs-lookup"><span data-stu-id="3b12e-104">*Classes* are types that represent objects that can have properties, methods, and events.</span></span>

## <a name="syntax"></a><span data-ttu-id="3b12e-105">Sintaxis</span><span class="sxs-lookup"><span data-stu-id="3b12e-105">Syntax</span></span>

```fsharp
// Class definition:
type [access-modifier] type-name [type-params] [access-modifier] ( parameter-list ) [ as identifier ] =
[ class ]
[ inherit base-type-name(base-constructor-args) ]
[ let-bindings ]
[ do-bindings ]
member-list
...
[ end ]
// Mutually recursive class definitions:
type [access-modifier] type-name1 ...
and [access-modifier] type-name2 ...
...
```

## <a name="remarks"></a><span data-ttu-id="3b12e-106">Comentarios</span><span class="sxs-lookup"><span data-stu-id="3b12e-106">Remarks</span></span>

<span data-ttu-id="3b12e-107">Las clases representan la descripción fundamental de los tipos de objeto .NET; la clase es el concepto de tipo principal que admite la programación orientada a objetos en F #.</span><span class="sxs-lookup"><span data-stu-id="3b12e-107">Classes represent the fundamental description of .NET object types; the class is the primary type concept that supports object-oriented programming in F#.</span></span>

<span data-ttu-id="3b12e-108">En la sintaxis anterior, `type-name` es cualquier identificador válido.</span><span class="sxs-lookup"><span data-stu-id="3b12e-108">In the preceding syntax, the `type-name` is any valid identifier.</span></span> <span data-ttu-id="3b12e-109">El `type-params` describe los parámetros de tipo genérico opcionales.</span><span class="sxs-lookup"><span data-stu-id="3b12e-109">The `type-params` describes optional generic type parameters.</span></span> <span data-ttu-id="3b12e-110">Consta de los nombres de parámetro de tipo y las restricciones entre corchetes angulares ( `<` y `>` ).</span><span class="sxs-lookup"><span data-stu-id="3b12e-110">It consists of type parameter names and constraints enclosed in angle brackets (`<` and `>`).</span></span> <span data-ttu-id="3b12e-111">Para obtener más información, vea [genéricos](./generics/index.md) y [restricciones](./generics/constraints.md).</span><span class="sxs-lookup"><span data-stu-id="3b12e-111">For more information, see [Generics](./generics/index.md) and [Constraints](./generics/constraints.md).</span></span> <span data-ttu-id="3b12e-112">`parameter-list`Describe los parámetros de constructor.</span><span class="sxs-lookup"><span data-stu-id="3b12e-112">The `parameter-list` describes constructor parameters.</span></span> <span data-ttu-id="3b12e-113">El primer modificador de acceso pertenece al tipo; el segundo pertenece al constructor principal.</span><span class="sxs-lookup"><span data-stu-id="3b12e-113">The first access modifier pertains to the type; the second pertains to the primary constructor.</span></span> <span data-ttu-id="3b12e-114">En ambos casos, el valor predeterminado es `public` .</span><span class="sxs-lookup"><span data-stu-id="3b12e-114">In both cases, the default is `public`.</span></span>

<span data-ttu-id="3b12e-115">La clase base de una clase se especifica mediante la `inherit` palabra clave.</span><span class="sxs-lookup"><span data-stu-id="3b12e-115">You specify the base class for a class by using the `inherit` keyword.</span></span> <span data-ttu-id="3b12e-116">Debe proporcionar argumentos, entre paréntesis, para el constructor de clase base.</span><span class="sxs-lookup"><span data-stu-id="3b12e-116">You must supply arguments, in parentheses, for the base class constructor.</span></span>

<span data-ttu-id="3b12e-117">Declare los campos o valores de función que son locales de la clase mediante `let` enlaces y debe seguir las reglas generales para los `let` enlaces.</span><span class="sxs-lookup"><span data-stu-id="3b12e-117">You declare fields or function values that are local to the class by using `let` bindings, and you must follow the general rules for `let` bindings.</span></span> <span data-ttu-id="3b12e-118">`do-bindings`En la sección se incluye el código que se va a ejecutar durante la construcción del objeto.</span><span class="sxs-lookup"><span data-stu-id="3b12e-118">The `do-bindings` section includes code to be executed upon object construction.</span></span>

<span data-ttu-id="3b12e-119">`member-list`Está formado por constructores adicionales, declaraciones de instancias y métodos estáticos, declaraciones de interfaz, enlaces abstractos y declaraciones de propiedades y eventos.</span><span class="sxs-lookup"><span data-stu-id="3b12e-119">The `member-list` consists of additional constructors, instance and static method declarations, interface declarations, abstract bindings, and property and event declarations.</span></span> <span data-ttu-id="3b12e-120">Se describen en [miembros](./members/index.md).</span><span class="sxs-lookup"><span data-stu-id="3b12e-120">These are described in [Members](./members/index.md).</span></span>

<span data-ttu-id="3b12e-121">El `identifier` que se usa con la `as` palabra clave opcional proporciona un nombre a la variable de instancia, o Self Identifier, que se puede usar en la definición de tipo para hacer referencia a la instancia del tipo.</span><span class="sxs-lookup"><span data-stu-id="3b12e-121">The `identifier` that is used with the optional `as` keyword gives a name to the instance variable, or self identifier, which can be used in the type definition to refer to the instance of the type.</span></span> <span data-ttu-id="3b12e-122">Para obtener más información, vea la sección identificadores propios más adelante en este tema.</span><span class="sxs-lookup"><span data-stu-id="3b12e-122">For more information, see the section Self Identifiers later in this topic.</span></span>

<span data-ttu-id="3b12e-123">Las palabras clave `class` y `end` que marcan el inicio y el final de la definición son opcionales.</span><span class="sxs-lookup"><span data-stu-id="3b12e-123">The keywords `class` and `end` that mark the start and end of the definition are optional.</span></span>

<span data-ttu-id="3b12e-124">Los tipos mutuamente recursivos, que son tipos que hacen referencia entre sí, se unen junto con la palabra clave, al igual `and` que las funciones recursivas.</span><span class="sxs-lookup"><span data-stu-id="3b12e-124">Mutually recursive types, which are types that reference each other, are joined together with the `and` keyword just as mutually recursive functions are.</span></span> <span data-ttu-id="3b12e-125">Para obtener un ejemplo, vea la sección tipos mutuamente recursivos.</span><span class="sxs-lookup"><span data-stu-id="3b12e-125">For an example, see the section Mutually Recursive Types.</span></span>

## <a name="constructors"></a><span data-ttu-id="3b12e-126">Constructores</span><span class="sxs-lookup"><span data-stu-id="3b12e-126">Constructors</span></span>

<span data-ttu-id="3b12e-127">El constructor es código que crea una instancia del tipo de clase.</span><span class="sxs-lookup"><span data-stu-id="3b12e-127">The constructor is code that creates an instance of the class type.</span></span> <span data-ttu-id="3b12e-128">Los constructores de las clases funcionan de forma ligeramente diferente en F # que en otros lenguajes .NET.</span><span class="sxs-lookup"><span data-stu-id="3b12e-128">Constructors for classes work somewhat differently in F# than they do in other .NET languages.</span></span> <span data-ttu-id="3b12e-129">En una clase de F #, siempre hay un constructor principal cuyos argumentos se describen en el `parameter-list` que sigue al nombre de tipo y cuyo cuerpo está compuesto de los `let` enlaces (y `let rec` ) al principio de la declaración de clase y los `do` enlaces siguientes.</span><span class="sxs-lookup"><span data-stu-id="3b12e-129">In an F# class, there is always a primary constructor whose arguments are described in the `parameter-list` that follows the type name, and whose body consists of the `let` (and `let rec`) bindings at the start of the class declaration and the `do` bindings that follow.</span></span> <span data-ttu-id="3b12e-130">Los argumentos del constructor principal están en el ámbito de la declaración de clase.</span><span class="sxs-lookup"><span data-stu-id="3b12e-130">The arguments of the primary constructor are in scope throughout the class declaration.</span></span>

<span data-ttu-id="3b12e-131">Puede Agregar constructores adicionales mediante la `new` palabra clave para agregar un miembro, como se indica a continuación:</span><span class="sxs-lookup"><span data-stu-id="3b12e-131">You can add additional constructors by using the `new` keyword to add a member, as follows:</span></span>

<span data-ttu-id="3b12e-132">`new`(`argument-list`) = `constructor-body`</span><span class="sxs-lookup"><span data-stu-id="3b12e-132">`new`(`argument-list`) = `constructor-body`</span></span>

<span data-ttu-id="3b12e-133">El cuerpo del nuevo constructor debe invocar el constructor principal que se especifica en la parte superior de la declaración de clase.</span><span class="sxs-lookup"><span data-stu-id="3b12e-133">The body of the new constructor must invoke the primary constructor that is specified at the top of the class declaration.</span></span>

<span data-ttu-id="3b12e-134">En el ejemplo siguiente se muestra este concepto.</span><span class="sxs-lookup"><span data-stu-id="3b12e-134">The following example illustrates this concept.</span></span> <span data-ttu-id="3b12e-135">En el código siguiente, `MyClass` tiene dos constructores, un constructor principal que toma dos argumentos y otro que no toma ningún argumento.</span><span class="sxs-lookup"><span data-stu-id="3b12e-135">In the following code, `MyClass` has two constructors, a primary constructor that takes two arguments and another constructor that takes no arguments.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet2401.fs)]

## <a name="let-and-do-bindings"></a><span data-ttu-id="3b12e-136">permitir y realizar enlaces</span><span class="sxs-lookup"><span data-stu-id="3b12e-136">let and do Bindings</span></span>

<span data-ttu-id="3b12e-137">Los `let` `do` enlaces y de una definición de clase forman el cuerpo del constructor de clase principal y, por lo tanto, se ejecutan cada vez que se crea una instancia de clase.</span><span class="sxs-lookup"><span data-stu-id="3b12e-137">The `let` and `do` bindings in a class definition form the body of the primary class constructor, and therefore they run whenever a class instance is created.</span></span> <span data-ttu-id="3b12e-138">Si un `let` enlace es una función, se compila en un miembro.</span><span class="sxs-lookup"><span data-stu-id="3b12e-138">If a `let` binding is a function, then it is compiled into a member.</span></span> <span data-ttu-id="3b12e-139">Si el `let` enlace es un valor que no se usa en ninguna función o miembro, se compila en una variable local para el constructor.</span><span class="sxs-lookup"><span data-stu-id="3b12e-139">If the `let` binding is a value that is not used in any function or member, then it is compiled into a variable that is local to the constructor.</span></span> <span data-ttu-id="3b12e-140">De lo contrario, se compila en un campo de la clase.</span><span class="sxs-lookup"><span data-stu-id="3b12e-140">Otherwise, it is compiled into a field of the class.</span></span> <span data-ttu-id="3b12e-141">Las `do` expresiones siguientes se compilan en el constructor principal y ejecutan el código de inicialización para cada instancia.</span><span class="sxs-lookup"><span data-stu-id="3b12e-141">The `do` expressions that follow are compiled into the primary constructor and execute initialization code for every instance.</span></span> <span data-ttu-id="3b12e-142">Dado que los constructores adicionales siempre llaman al constructor principal, los `let` enlaces y `do` enlaces siempre se ejecutan independientemente del constructor al que se llame.</span><span class="sxs-lookup"><span data-stu-id="3b12e-142">Because any additional constructors always call the primary constructor, the `let` bindings and `do` bindings always execute regardless of which constructor is called.</span></span>

<span data-ttu-id="3b12e-143">Se puede tener acceso a los campos que se crean mediante `let` enlaces a través de los métodos y propiedades de la clase; sin embargo, no se puede tener acceso a ellos desde métodos estáticos, incluso si los métodos estáticos toman una variable de instancia como parámetro.</span><span class="sxs-lookup"><span data-stu-id="3b12e-143">Fields that are created by `let` bindings can be accessed throughout the methods and properties of the class; however, they cannot be accessed from static methods, even if the static methods take an instance variable as a parameter.</span></span> <span data-ttu-id="3b12e-144">No se puede tener acceso a ellos mediante el identificador propio, si existe alguno.</span><span class="sxs-lookup"><span data-stu-id="3b12e-144">They cannot be accessed by using the self identifier, if one exists.</span></span>

## <a name="self-identifiers"></a><span data-ttu-id="3b12e-145">Identificadores propios</span><span class="sxs-lookup"><span data-stu-id="3b12e-145">Self Identifiers</span></span>

<span data-ttu-id="3b12e-146">Un *identificador propio* es un nombre que representa la instancia actual.</span><span class="sxs-lookup"><span data-stu-id="3b12e-146">A *self identifier* is a name that represents the current instance.</span></span> <span data-ttu-id="3b12e-147">Los identificadores propios se asemejan a la `this` palabra clave en C# o C++ o `Me` en Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="3b12e-147">Self identifiers resemble the `this` keyword in C# or C++ or `Me` in Visual Basic.</span></span> <span data-ttu-id="3b12e-148">Puede definir un identificador propio de dos maneras diferentes, en función de si desea que el identificador propio esté en el ámbito de la definición de clase completa o solo para un método individual.</span><span class="sxs-lookup"><span data-stu-id="3b12e-148">You can define a self identifier in two different ways, depending on whether you want the self identifier to be in scope for the whole class definition or just for an individual method.</span></span>

<span data-ttu-id="3b12e-149">Para definir un identificador propio para toda la clase, utilice la `as` palabra clave después del paréntesis de cierre de la lista de parámetros del constructor y especifique el nombre del identificador.</span><span class="sxs-lookup"><span data-stu-id="3b12e-149">To define a self identifier for the whole class, use the `as` keyword after the closing parentheses of the constructor parameter list, and specify the identifier name.</span></span>

<span data-ttu-id="3b12e-150">Para definir un identificador propio solo para un método, proporcione el identificador propio en la declaración de miembro, justo antes del nombre del método y un punto (.) como separador.</span><span class="sxs-lookup"><span data-stu-id="3b12e-150">To define a self identifier for just one method, provide the self identifier in the member declaration, just before the method name and a period (.) as a separator.</span></span>

<span data-ttu-id="3b12e-151">En el ejemplo de código siguiente se muestran las dos maneras de crear un identificador propio.</span><span class="sxs-lookup"><span data-stu-id="3b12e-151">The following code example illustrates the two ways to create a self identifier.</span></span> <span data-ttu-id="3b12e-152">En la primera línea, la `as` palabra clave se usa para definir el identificador propio.</span><span class="sxs-lookup"><span data-stu-id="3b12e-152">In the first line, the `as` keyword is used to define the self identifier.</span></span> <span data-ttu-id="3b12e-153">En la quinta línea, el identificador `this` se usa para definir un identificador propio cuyo ámbito está restringido al método `PrintMessage` .</span><span class="sxs-lookup"><span data-stu-id="3b12e-153">In the fifth line, the identifier `this` is used to define a self identifier whose scope is restricted to the method `PrintMessage`.</span></span>

```fsharp
type MyClass2(dataIn) as self =
    let data = dataIn
    do
        self.PrintMessage()
    member this.PrintMessage() =
        printf "Creating MyClass2 with Data %d" data
```

<span data-ttu-id="3b12e-154">A diferencia de otros lenguajes de .NET, puede asignar un nombre al propio identificador si lo desea; no está restringido a nombres como `self` , `Me` o `this` .</span><span class="sxs-lookup"><span data-stu-id="3b12e-154">Unlike in other .NET languages, you can name the self identifier however you want; you are not restricted to names such as `self`, `Me`, or `this`.</span></span>

<span data-ttu-id="3b12e-155">El identificador propio que se declara con la `as` palabra clave no se inicializa hasta después del constructor base.</span><span class="sxs-lookup"><span data-stu-id="3b12e-155">The self identifier that is declared with the `as` keyword is not initialized until after the base constructor.</span></span> <span data-ttu-id="3b12e-156">Por consiguiente, cuando se utiliza antes o dentro del constructor base, se `System.InvalidOperationException: The initialization of an object or value resulted in an object or value being accessed recursively before it was fully initialized.` generará durante el tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="3b12e-156">Therefore, when used before or inside the base constructor, `System.InvalidOperationException: The initialization of an object or value resulted in an object or value being accessed recursively before it was fully initialized.` will be raised during runtime.</span></span> <span data-ttu-id="3b12e-157">Puede usar el identificador propio libremente después del constructor base, como en `let` enlaces o enlaces `do` .</span><span class="sxs-lookup"><span data-stu-id="3b12e-157">You can use the self identifier freely after the base constructor, such as in `let` bindings or `do` bindings.</span></span>

## <a name="generic-type-parameters"></a><span data-ttu-id="3b12e-158">Parámetros de tipos genéricos</span><span class="sxs-lookup"><span data-stu-id="3b12e-158">Generic Type Parameters</span></span>

<span data-ttu-id="3b12e-159">Los parámetros de tipo genérico se especifican entre corchetes angulares ( `<` y `>` ), en forma de comillas simples seguidos de un identificador.</span><span class="sxs-lookup"><span data-stu-id="3b12e-159">Generic type parameters are specified in angle brackets (`<` and `>`), in the form of a single quotation mark followed by an identifier.</span></span> <span data-ttu-id="3b12e-160">Varios parámetros de tipo genérico se separan mediante comas.</span><span class="sxs-lookup"><span data-stu-id="3b12e-160">Multiple generic type parameters are separated by commas.</span></span> <span data-ttu-id="3b12e-161">El parámetro de tipo genérico está en el ámbito de la declaración.</span><span class="sxs-lookup"><span data-stu-id="3b12e-161">The generic type parameter is in scope throughout the declaration.</span></span> <span data-ttu-id="3b12e-162">En el ejemplo de código siguiente se muestra cómo especificar parámetros de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="3b12e-162">The following code example shows how to specify generic type parameters.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet2403.fs)]

<span data-ttu-id="3b12e-163">Los argumentos de tipo se deducen cuando se usa el tipo.</span><span class="sxs-lookup"><span data-stu-id="3b12e-163">Type arguments are inferred when the type is used.</span></span> <span data-ttu-id="3b12e-164">En el código siguiente, el tipo deducido es una secuencia de tuplas.</span><span class="sxs-lookup"><span data-stu-id="3b12e-164">In the following code, the inferred type is a sequence of tuples.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet24031.fs)]

## <a name="specifying-inheritance"></a><span data-ttu-id="3b12e-165">Especificar herencia</span><span class="sxs-lookup"><span data-stu-id="3b12e-165">Specifying Inheritance</span></span>

<span data-ttu-id="3b12e-166">La `inherit` cláusula identifica la clase base directa, si hay alguna.</span><span class="sxs-lookup"><span data-stu-id="3b12e-166">The `inherit` clause identifies the direct base class, if there is one.</span></span> <span data-ttu-id="3b12e-167">En F #, solo se permite una clase base directa.</span><span class="sxs-lookup"><span data-stu-id="3b12e-167">In F#, only one direct base class is allowed.</span></span> <span data-ttu-id="3b12e-168">Las interfaces que implementa una clase no se consideran clases base.</span><span class="sxs-lookup"><span data-stu-id="3b12e-168">Interfaces that a class implements are not considered base classes.</span></span> <span data-ttu-id="3b12e-169">Las interfaces se describen en el tema [interfaces](Interfaces.md) .</span><span class="sxs-lookup"><span data-stu-id="3b12e-169">Interfaces are discussed in the [Interfaces](Interfaces.md) topic.</span></span>

<span data-ttu-id="3b12e-170">Puede tener acceso a los métodos y propiedades de la clase base desde la clase derivada mediante el uso de la palabra clave Language `base` como identificador, seguido de un punto (.) y el nombre del miembro.</span><span class="sxs-lookup"><span data-stu-id="3b12e-170">You can access the methods and properties of the base class from the derived class by using the language keyword `base` as an identifier, followed by a period (.) and the name of the member.</span></span>

<span data-ttu-id="3b12e-171">Para obtener más información, vea [Herencia](inheritance.md).</span><span class="sxs-lookup"><span data-stu-id="3b12e-171">For more information, see [Inheritance](inheritance.md).</span></span>

## <a name="members-section"></a><span data-ttu-id="3b12e-172">Sección de miembros</span><span class="sxs-lookup"><span data-stu-id="3b12e-172">Members Section</span></span>

<span data-ttu-id="3b12e-173">Puede definir métodos estáticos o de instancia, propiedades, implementaciones de interfaz, miembros abstractos, declaraciones de eventos y constructores adicionales en esta sección.</span><span class="sxs-lookup"><span data-stu-id="3b12e-173">You can define static or instance methods, properties, interface implementations, abstract members, event declarations, and additional constructors in this section.</span></span> <span data-ttu-id="3b12e-174">Los enlaces Let y do no pueden aparecer en esta sección.</span><span class="sxs-lookup"><span data-stu-id="3b12e-174">Let and do bindings cannot appear in this section.</span></span> <span data-ttu-id="3b12e-175">Dado que los miembros se pueden agregar a una variedad de tipos de F # además de a las clases, se tratan en un tema independiente, [miembros](./members/index.md).</span><span class="sxs-lookup"><span data-stu-id="3b12e-175">Because members can be added to a variety of F# types in addition to classes, they are discussed in a separate topic, [Members](./members/index.md).</span></span>

## <a name="mutually-recursive-types"></a><span data-ttu-id="3b12e-176">Tipos recursivos mutuamente</span><span class="sxs-lookup"><span data-stu-id="3b12e-176">Mutually Recursive Types</span></span>

<span data-ttu-id="3b12e-177">Al definir tipos que se hacen referencia entre sí de forma circular, se concatenan las definiciones de tipos mediante la `and` palabra clave.</span><span class="sxs-lookup"><span data-stu-id="3b12e-177">When you define types that reference each other in a circular way, you string together the type definitions by using the `and` keyword.</span></span> <span data-ttu-id="3b12e-178">La `and` palabra clave reemplaza la `type` palabra clave en todas las definiciones excepto la primera, como se indica a continuación.</span><span class="sxs-lookup"><span data-stu-id="3b12e-178">The `and` keyword replaces the `type` keyword on all except the first definition, as follows.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet2404.fs)]

<span data-ttu-id="3b12e-179">La salida es una lista de todos los archivos del directorio actual.</span><span class="sxs-lookup"><span data-stu-id="3b12e-179">The output is a list of all the files in the current directory.</span></span>

## <a name="when-to-use-classes-unions-records-and-structures"></a><span data-ttu-id="3b12e-180">Cuándo usar clases, uniones, registros y estructuras</span><span class="sxs-lookup"><span data-stu-id="3b12e-180">When to Use Classes, Unions, Records, and Structures</span></span>

<span data-ttu-id="3b12e-181">Dada la variedad de tipos entre los que elegir, debe tener una buena comprensión de para qué se ha diseñado cada tipo para seleccionar el tipo adecuado para una situación determinada.</span><span class="sxs-lookup"><span data-stu-id="3b12e-181">Given the variety of types to choose from, you need to have a good understanding of what each type is designed for to select the appropriate type for a particular situation.</span></span> <span data-ttu-id="3b12e-182">Las clases están diseñadas para su uso en contextos de programación orientados a objetos.</span><span class="sxs-lookup"><span data-stu-id="3b12e-182">Classes are designed for use in object-oriented programming contexts.</span></span> <span data-ttu-id="3b12e-183">La programación orientada a objetos es el paradigma dominante utilizado en las aplicaciones escritas para el .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="3b12e-183">Object-oriented programming is the dominant paradigm used in applications that are written for the .NET Framework.</span></span> <span data-ttu-id="3b12e-184">Si el código de F # tiene que trabajar estrechamente con el .NET Framework u otra biblioteca orientada a objetos, y especialmente si tiene que extender desde un sistema de tipos orientado a objetos como una biblioteca de interfaz de usuario, las clases probablemente sean adecuadas.</span><span class="sxs-lookup"><span data-stu-id="3b12e-184">If your F# code has to work closely with the .NET Framework or another object-oriented library, and especially if you have to extend from an object-oriented type system such as a UI library, classes are probably appropriate.</span></span>

<span data-ttu-id="3b12e-185">Si no está interoperando estrechamente con código orientado a objetos, o si está escribiendo código que es independiente y, por tanto, está protegido contra la interacción frecuente con código orientado a objetos, considere la posibilidad de utilizar registros y uniones discriminadas.</span><span class="sxs-lookup"><span data-stu-id="3b12e-185">If you are not interoperating closely with object-oriented code, or if you are writing code that is self-contained and therefore protected from frequent interaction with object-oriented code, you should consider using records and discriminated unions.</span></span> <span data-ttu-id="3b12e-186">A menudo, se puede usar una Unión discriminada única y bien pensada, junto con el código de coincidencia de patrones adecuado, como alternativa más sencilla a una jerarquía de objetos.</span><span class="sxs-lookup"><span data-stu-id="3b12e-186">A single, well thought–out discriminated union, together with appropriate pattern matching code, can often be used as a simpler alternative to an object hierarchy.</span></span> <span data-ttu-id="3b12e-187">Para obtener más información sobre las uniones discriminadas, consulte [uniones discriminadas](discriminated-unions.md).</span><span class="sxs-lookup"><span data-stu-id="3b12e-187">For more information about discriminated unions, see [Discriminated Unions](discriminated-unions.md).</span></span>

<span data-ttu-id="3b12e-188">Los registros tienen la ventaja de ser más sencillos que las clases, pero los registros no son adecuados cuando las demandas de un tipo superan lo que se puede lograr con su simplicidad.</span><span class="sxs-lookup"><span data-stu-id="3b12e-188">Records have the advantage of being simpler than classes, but records are not appropriate when the demands of a type exceed what can be accomplished with their simplicity.</span></span> <span data-ttu-id="3b12e-189">Los registros son básicamente agregados de valores sencillos, sin constructores independientes que pueden realizar acciones personalizadas, sin campos ocultos y sin las implementaciones de herencia o de interfaz.</span><span class="sxs-lookup"><span data-stu-id="3b12e-189">Records are basically simple aggregates of values, without separate constructors that can perform custom actions, without hidden fields, and without inheritance or interface implementations.</span></span> <span data-ttu-id="3b12e-190">Aunque se pueden agregar miembros como propiedades y métodos a los registros para que su comportamiento sea más complejo, los campos almacenados en un registro siguen siendo un agregado simple de valores.</span><span class="sxs-lookup"><span data-stu-id="3b12e-190">Although members such as properties and methods can be added to records to make their behavior more complex, the fields stored in a record are still a simple aggregate of values.</span></span> <span data-ttu-id="3b12e-191">Para obtener más información sobre los registros, consulte [registros](records.md).</span><span class="sxs-lookup"><span data-stu-id="3b12e-191">For more information about records, see [Records](records.md).</span></span>

<span data-ttu-id="3b12e-192">Las estructuras también son útiles para los pequeños agregados de datos, pero difieren de las clases y los registros en que son tipos de valor de .NET.</span><span class="sxs-lookup"><span data-stu-id="3b12e-192">Structures are also useful for small aggregates of data, but they differ from classes and records in that they are .NET value types.</span></span> <span data-ttu-id="3b12e-193">Las clases y los registros son tipos de referencia de .NET.</span><span class="sxs-lookup"><span data-stu-id="3b12e-193">Classes and records are .NET reference types.</span></span> <span data-ttu-id="3b12e-194">La semántica de los tipos de valor y los tipos de referencia es diferente en que los tipos de valor se pasan por valor.</span><span class="sxs-lookup"><span data-stu-id="3b12e-194">The semantics of value types and reference types are different in that value types are passed by value.</span></span> <span data-ttu-id="3b12e-195">Esto significa que se copian bit de bit cuando se pasan como un parámetro o se devuelven desde una función.</span><span class="sxs-lookup"><span data-stu-id="3b12e-195">This means that they are copied bit for bit when they are passed as a parameter or returned from a function.</span></span> <span data-ttu-id="3b12e-196">También se almacenan en la pila o, si se usan como un campo, se insertan dentro del objeto primario en lugar de almacenarse en su propia ubicación independiente en el montón.</span><span class="sxs-lookup"><span data-stu-id="3b12e-196">They are also stored on the stack or, if they are used as a field, embedded inside the parent object instead of stored in their own separate location on the heap.</span></span> <span data-ttu-id="3b12e-197">Por lo tanto, las estructuras son adecuadas para los datos a los que se accede con frecuencia cuando la sobrecarga de tener acceso al montón es un problema.</span><span class="sxs-lookup"><span data-stu-id="3b12e-197">Therefore, structures are appropriate for frequently accessed data when the overhead of accessing the heap is a problem.</span></span> <span data-ttu-id="3b12e-198">Para obtener más información sobre las estructuras, vea [estructuras](structures.md).</span><span class="sxs-lookup"><span data-stu-id="3b12e-198">For more information about structures, see [Structures](structures.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="3b12e-199">Vea también</span><span class="sxs-lookup"><span data-stu-id="3b12e-199">See also</span></span>

- [<span data-ttu-id="3b12e-200">Referencia del lenguaje F#</span><span class="sxs-lookup"><span data-stu-id="3b12e-200">F# Language Reference</span></span>](index.md)
- [<span data-ttu-id="3b12e-201">Miembros</span><span class="sxs-lookup"><span data-stu-id="3b12e-201">Members</span></span>](./members/index.md)
- [<span data-ttu-id="3b12e-202">Herencia</span><span class="sxs-lookup"><span data-stu-id="3b12e-202">Inheritance</span></span>](inheritance.md)
- [<span data-ttu-id="3b12e-203">Interfaces</span><span class="sxs-lookup"><span data-stu-id="3b12e-203">Interfaces</span></span>](interfaces.md)
